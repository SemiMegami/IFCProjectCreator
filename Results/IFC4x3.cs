	/// <summary>
	/// TYPE IfcAbsorbedDoseMeasure = REAL;
	/// <para>TYPE IfcAbsorbedDoseMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAbsorbedDoseMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcAbsorbedDoseMeasure() { }
		IfcAbsorbedDoseMeasure(double value) { Value = value; }
		public static implicit operator IfcAbsorbedDoseMeasure(double value) { return new IfcAbsorbedDoseMeasure(double);}
		public static implicit operator double(IfcAbsorbedDoseMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAccelerationMeasure = REAL;
	/// <para>TYPE IfcAccelerationMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAccelerationMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcAccelerationMeasure() { }
		IfcAccelerationMeasure(double value) { Value = value; }
		public static implicit operator IfcAccelerationMeasure(double value) { return new IfcAccelerationMeasure(double);}
		public static implicit operator double(IfcAccelerationMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAmountOfSubstanceMeasure = REAL;
	/// <para>TYPE IfcAmountOfSubstanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAmountOfSubstanceMeasure : REAL, IfcMeasureValue
	{
		IfcAmountOfSubstanceMeasure() { }
		IfcAmountOfSubstanceMeasure(double value) { Value = value; }
		public static implicit operator IfcAmountOfSubstanceMeasure(double value) { return new IfcAmountOfSubstanceMeasure(double);}
		public static implicit operator double(IfcAmountOfSubstanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAngularVelocityMeasure = REAL;
	/// <para>TYPE IfcAngularVelocityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAngularVelocityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcAngularVelocityMeasure() { }
		IfcAngularVelocityMeasure(double value) { Value = value; }
		public static implicit operator IfcAngularVelocityMeasure(double value) { return new IfcAngularVelocityMeasure(double);}
		public static implicit operator double(IfcAngularVelocityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAreaDensityMeasure = REAL;
	/// <para>TYPE IfcAreaDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAreaDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcAreaDensityMeasure() { }
		IfcAreaDensityMeasure(double value) { Value = value; }
		public static implicit operator IfcAreaDensityMeasure(double value) { return new IfcAreaDensityMeasure(double);}
		public static implicit operator double(IfcAreaDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAreaMeasure = REAL;
	/// <para>TYPE IfcAreaMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAreaMeasure : REAL, IfcMeasureValue
	{
		IfcAreaMeasure() { }
		IfcAreaMeasure(double value) { Value = value; }
		public static implicit operator IfcAreaMeasure(double value) { return new IfcAreaMeasure(double);}
		public static implicit operator double(IfcAreaMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBinary = BINARY;
	/// <para>TYPE IfcBinary = BINARY;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBinary : BINARY, IfcSimpleValue
	{
		IfcBinary() { }
		IfcBinary(int value) { Value = value; }
		public static implicit operator IfcBinary(int value) { return new IfcBinary(int);}
		public static implicit operator int(IfcBinary value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBoolean = BOOLEAN;
	/// <para>TYPE IfcBoolean = BOOLEAN;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBoolean : BOOLEAN, IfcModulusOfRotationalSubgradeReactionSelect, IfcModulusOfSubgradeReactionSelect, IfcModulusOfTranslationalSubgradeReactionSelect, IfcRotationalStiffnessSelect, IfcSimpleValue, IfcTranslationalStiffnessSelect, IfcWarpingStiffnessSelect
	{
		IfcBoolean() { }
		IfcBoolean(bool value) { Value = value; }
		public static implicit operator IfcBoolean(bool value) { return new IfcBoolean(bool);}
		public static implicit operator bool(IfcBoolean value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBoxAlignment = IfcLabel;
	/// <para>TYPE IfcBoxAlignment = IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF IN ['top-left', 'top-middle', 'top-right', 'middle-left', 'center', 'middle-right', 'bottom-left', 'bottom-middle', 'bottom-right'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBoxAlignment : IfcLabel
	{
		IfcBoxAlignment() { }
		IfcBoxAlignment(string value) { Value = value; }
		public static implicit operator IfcBoxAlignment(string value) { return new IfcBoxAlignment(string);}
		public static implicit operator string(IfcBoxAlignment value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCardinalPointReference = INTEGER;
	/// <para>TYPE IfcCardinalPointReference = INTEGER;</para>
	/// <para> WHERE</para>
	/// <para>	 GreaterThanZero : SELF > 0;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCardinalPointReference : INTEGER
	{
		IfcCardinalPointReference() { }
		IfcCardinalPointReference(int value) { Value = value; }
		public static implicit operator IfcCardinalPointReference(int value) { return new IfcCardinalPointReference(int);}
		public static implicit operator int(IfcCardinalPointReference value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcContextDependentMeasure = REAL;
	/// <para>TYPE IfcContextDependentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcContextDependentMeasure : REAL, IfcMeasureValue
	{
		IfcContextDependentMeasure() { }
		IfcContextDependentMeasure(double value) { Value = value; }
		public static implicit operator IfcContextDependentMeasure(double value) { return new IfcContextDependentMeasure(double);}
		public static implicit operator double(IfcContextDependentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCountMeasure = INTEGER;
	/// <para>TYPE IfcCountMeasure = INTEGER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCountMeasure : INTEGER, IfcMeasureValue
	{
		IfcCountMeasure() { }
		IfcCountMeasure(int value) { Value = value; }
		public static implicit operator IfcCountMeasure(int value) { return new IfcCountMeasure(int);}
		public static implicit operator int(IfcCountMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCurvatureMeasure = REAL;
	/// <para>TYPE IfcCurvatureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCurvatureMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcCurvatureMeasure() { }
		IfcCurvatureMeasure(double value) { Value = value; }
		public static implicit operator IfcCurvatureMeasure(double value) { return new IfcCurvatureMeasure(double);}
		public static implicit operator double(IfcCurvatureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDate = STRING;
	/// <para>TYPE IfcDate = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDate : STRING, IfcSimpleValue
	{
		IfcDate() { }
		IfcDate(string value) { Value = value; }
		public static implicit operator IfcDate(string value) { return new IfcDate(string);}
		public static implicit operator string(IfcDate value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDateTime = STRING;
	/// <para>TYPE IfcDateTime = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDateTime : STRING, IfcSimpleValue
	{
		IfcDateTime() { }
		IfcDateTime(string value) { Value = value; }
		public static implicit operator IfcDateTime(string value) { return new IfcDateTime(string);}
		public static implicit operator string(IfcDateTime value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDayInMonthNumber = INTEGER;
	/// <para>TYPE IfcDayInMonthNumber = INTEGER;</para>
	/// <para> WHERE</para>
	/// <para>	 ValidRange : {1 <= SELF <= 31};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDayInMonthNumber : INTEGER
	{
		IfcDayInMonthNumber() { }
		IfcDayInMonthNumber(int value) { Value = value; }
		public static implicit operator IfcDayInMonthNumber(int value) { return new IfcDayInMonthNumber(int);}
		public static implicit operator int(IfcDayInMonthNumber value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDayInWeekNumber = INTEGER;
	/// <para>TYPE IfcDayInWeekNumber = INTEGER;</para>
	/// <para> WHERE</para>
	/// <para>	 ValidRange : {1 <= SELF <= 7};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDayInWeekNumber : INTEGER
	{
		IfcDayInWeekNumber() { }
		IfcDayInWeekNumber(int value) { Value = value; }
		public static implicit operator IfcDayInWeekNumber(int value) { return new IfcDayInWeekNumber(int);}
		public static implicit operator int(IfcDayInWeekNumber value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDescriptiveMeasure = STRING;
	/// <para>TYPE IfcDescriptiveMeasure = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDescriptiveMeasure : STRING, IfcMeasureValue, IfcSizeSelect
	{
		IfcDescriptiveMeasure() { }
		IfcDescriptiveMeasure(string value) { Value = value; }
		public static implicit operator IfcDescriptiveMeasure(string value) { return new IfcDescriptiveMeasure(string);}
		public static implicit operator string(IfcDescriptiveMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDimensionCount = INTEGER;
	/// <para>TYPE IfcDimensionCount = INTEGER;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : { 0 < SELF <= 3 };</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDimensionCount : INTEGER
	{
		IfcDimensionCount() { }
		IfcDimensionCount(int value) { Value = value; }
		public static implicit operator IfcDimensionCount(int value) { return new IfcDimensionCount(int);}
		public static implicit operator int(IfcDimensionCount value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoseEquivalentMeasure = REAL;
	/// <para>TYPE IfcDoseEquivalentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoseEquivalentMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcDoseEquivalentMeasure() { }
		IfcDoseEquivalentMeasure(double value) { Value = value; }
		public static implicit operator IfcDoseEquivalentMeasure(double value) { return new IfcDoseEquivalentMeasure(double);}
		public static implicit operator double(IfcDoseEquivalentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDuration = STRING;
	/// <para>TYPE IfcDuration = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDuration : STRING, IfcSimpleValue, IfcTimeOrRatioSelect
	{
		IfcDuration() { }
		IfcDuration(string value) { Value = value; }
		public static implicit operator IfcDuration(string value) { return new IfcDuration(string);}
		public static implicit operator string(IfcDuration value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDynamicViscosityMeasure = REAL;
	/// <para>TYPE IfcDynamicViscosityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDynamicViscosityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcDynamicViscosityMeasure() { }
		IfcDynamicViscosityMeasure(double value) { Value = value; }
		public static implicit operator IfcDynamicViscosityMeasure(double value) { return new IfcDynamicViscosityMeasure(double);}
		public static implicit operator double(IfcDynamicViscosityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricCapacitanceMeasure = REAL;
	/// <para>TYPE IfcElectricCapacitanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricCapacitanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcElectricCapacitanceMeasure() { }
		IfcElectricCapacitanceMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricCapacitanceMeasure(double value) { return new IfcElectricCapacitanceMeasure(double);}
		public static implicit operator double(IfcElectricCapacitanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricChargeMeasure = REAL;
	/// <para>TYPE IfcElectricChargeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricChargeMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcElectricChargeMeasure() { }
		IfcElectricChargeMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricChargeMeasure(double value) { return new IfcElectricChargeMeasure(double);}
		public static implicit operator double(IfcElectricChargeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricConductanceMeasure = REAL;
	/// <para>TYPE IfcElectricConductanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricConductanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcElectricConductanceMeasure() { }
		IfcElectricConductanceMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricConductanceMeasure(double value) { return new IfcElectricConductanceMeasure(double);}
		public static implicit operator double(IfcElectricConductanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricCurrentMeasure = REAL;
	/// <para>TYPE IfcElectricCurrentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricCurrentMeasure : REAL, IfcMeasureValue
	{
		IfcElectricCurrentMeasure() { }
		IfcElectricCurrentMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricCurrentMeasure(double value) { return new IfcElectricCurrentMeasure(double);}
		public static implicit operator double(IfcElectricCurrentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricResistanceMeasure = REAL;
	/// <para>TYPE IfcElectricResistanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricResistanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcElectricResistanceMeasure() { }
		IfcElectricResistanceMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricResistanceMeasure(double value) { return new IfcElectricResistanceMeasure(double);}
		public static implicit operator double(IfcElectricResistanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricVoltageMeasure = REAL;
	/// <para>TYPE IfcElectricVoltageMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricVoltageMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcElectricVoltageMeasure() { }
		IfcElectricVoltageMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricVoltageMeasure(double value) { return new IfcElectricVoltageMeasure(double);}
		public static implicit operator double(IfcElectricVoltageMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEnergyMeasure = REAL;
	/// <para>TYPE IfcEnergyMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEnergyMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcEnergyMeasure() { }
		IfcEnergyMeasure(double value) { Value = value; }
		public static implicit operator IfcEnergyMeasure(double value) { return new IfcEnergyMeasure(double);}
		public static implicit operator double(IfcEnergyMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFontStyle = STRING;
	/// <para>TYPE IfcFontStyle = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF IN ['normal','italic','oblique'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFontStyle : STRING
	{
		IfcFontStyle() { }
		IfcFontStyle(string value) { Value = value; }
		public static implicit operator IfcFontStyle(string value) { return new IfcFontStyle(string);}
		public static implicit operator string(IfcFontStyle value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFontVariant = STRING;
	/// <para>TYPE IfcFontVariant = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF IN ['normal','small-caps'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFontVariant : STRING
	{
		IfcFontVariant() { }
		IfcFontVariant(string value) { Value = value; }
		public static implicit operator IfcFontVariant(string value) { return new IfcFontVariant(string);}
		public static implicit operator string(IfcFontVariant value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFontWeight = STRING;
	/// <para>TYPE IfcFontWeight = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF IN ['normal','small-caps','100','200','300','400','500','600','700','800','900'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFontWeight : STRING
	{
		IfcFontWeight() { }
		IfcFontWeight(string value) { Value = value; }
		public static implicit operator IfcFontWeight(string value) { return new IfcFontWeight(string);}
		public static implicit operator string(IfcFontWeight value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcForceMeasure = REAL;
	/// <para>TYPE IfcForceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcForceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcForceMeasure() { }
		IfcForceMeasure(double value) { Value = value; }
		public static implicit operator IfcForceMeasure(double value) { return new IfcForceMeasure(double);}
		public static implicit operator double(IfcForceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFrequencyMeasure = REAL;
	/// <para>TYPE IfcFrequencyMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFrequencyMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcFrequencyMeasure() { }
		IfcFrequencyMeasure(double value) { Value = value; }
		public static implicit operator IfcFrequencyMeasure(double value) { return new IfcFrequencyMeasure(double);}
		public static implicit operator double(IfcFrequencyMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGloballyUniqueId = STRING(22) FIXED;
	/// <para>TYPE IfcGloballyUniqueId = STRING(22) FIXED;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGloballyUniqueId : STRING
	{
		IfcGloballyUniqueId() { }
		IfcGloballyUniqueId(string value) { Value = value; }
		public static implicit operator IfcGloballyUniqueId(string value) { return new IfcGloballyUniqueId(string);}
		public static implicit operator string(IfcGloballyUniqueId value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcHeatFluxDensityMeasure = REAL;
	/// <para>TYPE IfcHeatFluxDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcHeatFluxDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcHeatFluxDensityMeasure() { }
		IfcHeatFluxDensityMeasure(double value) { Value = value; }
		public static implicit operator IfcHeatFluxDensityMeasure(double value) { return new IfcHeatFluxDensityMeasure(double);}
		public static implicit operator double(IfcHeatFluxDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcHeatingValueMeasure = REAL;
	/// <para>TYPE IfcHeatingValueMeasure = REAL;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcHeatingValueMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcHeatingValueMeasure() { }
		IfcHeatingValueMeasure(double value) { Value = value; }
		public static implicit operator IfcHeatingValueMeasure(double value) { return new IfcHeatingValueMeasure(double);}
		public static implicit operator double(IfcHeatingValueMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIdentifier = STRING(255);
	/// <para>TYPE IfcIdentifier = STRING(255);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIdentifier : STRING, IfcSimpleValue
	{
		IfcIdentifier() { }
		IfcIdentifier(string value) { Value = value; }
		public static implicit operator IfcIdentifier(string value) { return new IfcIdentifier(string);}
		public static implicit operator string(IfcIdentifier value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIlluminanceMeasure = REAL;
	/// <para>TYPE IfcIlluminanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIlluminanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcIlluminanceMeasure() { }
		IfcIlluminanceMeasure(double value) { Value = value; }
		public static implicit operator IfcIlluminanceMeasure(double value) { return new IfcIlluminanceMeasure(double);}
		public static implicit operator double(IfcIlluminanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInductanceMeasure = REAL;
	/// <para>TYPE IfcInductanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInductanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcInductanceMeasure() { }
		IfcInductanceMeasure(double value) { Value = value; }
		public static implicit operator IfcInductanceMeasure(double value) { return new IfcInductanceMeasure(double);}
		public static implicit operator double(IfcInductanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInteger = INTEGER;
	/// <para>TYPE IfcInteger = INTEGER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInteger : INTEGER, IfcSimpleValue
	{
		IfcInteger() { }
		IfcInteger(int value) { Value = value; }
		public static implicit operator IfcInteger(int value) { return new IfcInteger(int);}
		public static implicit operator int(IfcInteger value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIntegerCountRateMeasure = INTEGER;
	/// <para>TYPE IfcIntegerCountRateMeasure = INTEGER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIntegerCountRateMeasure : INTEGER, IfcDerivedMeasureValue
	{
		IfcIntegerCountRateMeasure() { }
		IfcIntegerCountRateMeasure(int value) { Value = value; }
		public static implicit operator IfcIntegerCountRateMeasure(int value) { return new IfcIntegerCountRateMeasure(int);}
		public static implicit operator int(IfcIntegerCountRateMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIonConcentrationMeasure = REAL;
	/// <para>TYPE IfcIonConcentrationMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIonConcentrationMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcIonConcentrationMeasure() { }
		IfcIonConcentrationMeasure(double value) { Value = value; }
		public static implicit operator IfcIonConcentrationMeasure(double value) { return new IfcIonConcentrationMeasure(double);}
		public static implicit operator double(IfcIonConcentrationMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIsothermalMoistureCapacityMeasure = REAL;
	/// <para>TYPE IfcIsothermalMoistureCapacityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIsothermalMoistureCapacityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcIsothermalMoistureCapacityMeasure() { }
		IfcIsothermalMoistureCapacityMeasure(double value) { Value = value; }
		public static implicit operator IfcIsothermalMoistureCapacityMeasure(double value) { return new IfcIsothermalMoistureCapacityMeasure(double);}
		public static implicit operator double(IfcIsothermalMoistureCapacityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcKinematicViscosityMeasure = REAL;
	/// <para>TYPE IfcKinematicViscosityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcKinematicViscosityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcKinematicViscosityMeasure() { }
		IfcKinematicViscosityMeasure(double value) { Value = value; }
		public static implicit operator IfcKinematicViscosityMeasure(double value) { return new IfcKinematicViscosityMeasure(double);}
		public static implicit operator double(IfcKinematicViscosityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLabel = STRING(255);
	/// <para>TYPE IfcLabel = STRING(255);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLabel : STRING, IfcSimpleValue
	{
		IfcLabel() { }
		IfcLabel(string value) { Value = value; }
		public static implicit operator IfcLabel(string value) { return new IfcLabel(string);}
		public static implicit operator string(IfcLabel value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLanguageId = IfcIdentifier;
	/// <para>TYPE IfcLanguageId = IfcIdentifier;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLanguageId : IfcIdentifier
	{
		IfcLanguageId() { }
		IfcLanguageId(string value) { Value = value; }
		public static implicit operator IfcLanguageId(string value) { return new IfcLanguageId(string);}
		public static implicit operator string(IfcLanguageId value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLengthMeasure = REAL;
	/// <para>TYPE IfcLengthMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLengthMeasure : REAL, IfcBendingParameterSelect, IfcCurveMeasureSelect, IfcMeasureValue, IfcSizeSelect
	{
		IfcLengthMeasure() { }
		IfcLengthMeasure(double value) { Value = value; }
		public static implicit operator IfcLengthMeasure(double value) { return new IfcLengthMeasure(double);}
		public static implicit operator double(IfcLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearForceMeasure = REAL;
	/// <para>TYPE IfcLinearForceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearForceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcLinearForceMeasure() { }
		IfcLinearForceMeasure(double value) { Value = value; }
		public static implicit operator IfcLinearForceMeasure(double value) { return new IfcLinearForceMeasure(double);}
		public static implicit operator double(IfcLinearForceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearMomentMeasure = REAL;
	/// <para>TYPE IfcLinearMomentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearMomentMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcLinearMomentMeasure() { }
		IfcLinearMomentMeasure(double value) { Value = value; }
		public static implicit operator IfcLinearMomentMeasure(double value) { return new IfcLinearMomentMeasure(double);}
		public static implicit operator double(IfcLinearMomentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearStiffnessMeasure = REAL;
	/// <para>TYPE IfcLinearStiffnessMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearStiffnessMeasure : REAL, IfcDerivedMeasureValue, IfcTranslationalStiffnessSelect
	{
		IfcLinearStiffnessMeasure() { }
		IfcLinearStiffnessMeasure(double value) { Value = value; }
		public static implicit operator IfcLinearStiffnessMeasure(double value) { return new IfcLinearStiffnessMeasure(double);}
		public static implicit operator double(IfcLinearStiffnessMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearVelocityMeasure = REAL;
	/// <para>TYPE IfcLinearVelocityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearVelocityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcLinearVelocityMeasure() { }
		IfcLinearVelocityMeasure(double value) { Value = value; }
		public static implicit operator IfcLinearVelocityMeasure(double value) { return new IfcLinearVelocityMeasure(double);}
		public static implicit operator double(IfcLinearVelocityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLogical = LOGICAL;
	/// <para>TYPE IfcLogical = LOGICAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLogical : LOGICAL, IfcSimpleValue
	{
		IfcLogical() { }
		IfcLogical(bool value) { Value = value; }
		public static implicit operator IfcLogical(bool value) { return new IfcLogical(bool);}
		public static implicit operator bool(IfcLogical value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLuminousFluxMeasure = REAL;
	/// <para>TYPE IfcLuminousFluxMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLuminousFluxMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcLuminousFluxMeasure() { }
		IfcLuminousFluxMeasure(double value) { Value = value; }
		public static implicit operator IfcLuminousFluxMeasure(double value) { return new IfcLuminousFluxMeasure(double);}
		public static implicit operator double(IfcLuminousFluxMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLuminousIntensityDistributionMeasure = REAL;
	/// <para>TYPE IfcLuminousIntensityDistributionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLuminousIntensityDistributionMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcLuminousIntensityDistributionMeasure() { }
		IfcLuminousIntensityDistributionMeasure(double value) { Value = value; }
		public static implicit operator IfcLuminousIntensityDistributionMeasure(double value) { return new IfcLuminousIntensityDistributionMeasure(double);}
		public static implicit operator double(IfcLuminousIntensityDistributionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLuminousIntensityMeasure = REAL;
	/// <para>TYPE IfcLuminousIntensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLuminousIntensityMeasure : REAL, IfcMeasureValue
	{
		IfcLuminousIntensityMeasure() { }
		IfcLuminousIntensityMeasure(double value) { Value = value; }
		public static implicit operator IfcLuminousIntensityMeasure(double value) { return new IfcLuminousIntensityMeasure(double);}
		public static implicit operator double(IfcLuminousIntensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMagneticFluxDensityMeasure = REAL;
	/// <para>TYPE IfcMagneticFluxDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMagneticFluxDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMagneticFluxDensityMeasure() { }
		IfcMagneticFluxDensityMeasure(double value) { Value = value; }
		public static implicit operator IfcMagneticFluxDensityMeasure(double value) { return new IfcMagneticFluxDensityMeasure(double);}
		public static implicit operator double(IfcMagneticFluxDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMagneticFluxMeasure = REAL;
	/// <para>TYPE IfcMagneticFluxMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMagneticFluxMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMagneticFluxMeasure() { }
		IfcMagneticFluxMeasure(double value) { Value = value; }
		public static implicit operator IfcMagneticFluxMeasure(double value) { return new IfcMagneticFluxMeasure(double);}
		public static implicit operator double(IfcMagneticFluxMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassDensityMeasure = REAL;
	/// <para>TYPE IfcMassDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMassDensityMeasure() { }
		IfcMassDensityMeasure(double value) { Value = value; }
		public static implicit operator IfcMassDensityMeasure(double value) { return new IfcMassDensityMeasure(double);}
		public static implicit operator double(IfcMassDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassFlowRateMeasure = REAL;
	/// <para>TYPE IfcMassFlowRateMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassFlowRateMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMassFlowRateMeasure() { }
		IfcMassFlowRateMeasure(double value) { Value = value; }
		public static implicit operator IfcMassFlowRateMeasure(double value) { return new IfcMassFlowRateMeasure(double);}
		public static implicit operator double(IfcMassFlowRateMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassMeasure = REAL;
	/// <para>TYPE IfcMassMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassMeasure : REAL, IfcMeasureValue
	{
		IfcMassMeasure() { }
		IfcMassMeasure(double value) { Value = value; }
		public static implicit operator IfcMassMeasure(double value) { return new IfcMassMeasure(double);}
		public static implicit operator double(IfcMassMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassPerLengthMeasure = REAL;
	/// <para>TYPE IfcMassPerLengthMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassPerLengthMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMassPerLengthMeasure() { }
		IfcMassPerLengthMeasure(double value) { Value = value; }
		public static implicit operator IfcMassPerLengthMeasure(double value) { return new IfcMassPerLengthMeasure(double);}
		public static implicit operator double(IfcMassPerLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfElasticityMeasure = REAL;
	/// <para>TYPE IfcModulusOfElasticityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfElasticityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcModulusOfElasticityMeasure() { }
		IfcModulusOfElasticityMeasure(double value) { Value = value; }
		public static implicit operator IfcModulusOfElasticityMeasure(double value) { return new IfcModulusOfElasticityMeasure(double);}
		public static implicit operator double(IfcModulusOfElasticityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfLinearSubgradeReactionMeasure = REAL;
	/// <para>TYPE IfcModulusOfLinearSubgradeReactionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfLinearSubgradeReactionMeasure : REAL, IfcDerivedMeasureValue, IfcModulusOfTranslationalSubgradeReactionSelect
	{
		IfcModulusOfLinearSubgradeReactionMeasure() { }
		IfcModulusOfLinearSubgradeReactionMeasure(double value) { Value = value; }
		public static implicit operator IfcModulusOfLinearSubgradeReactionMeasure(double value) { return new IfcModulusOfLinearSubgradeReactionMeasure(double);}
		public static implicit operator double(IfcModulusOfLinearSubgradeReactionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfRotationalSubgradeReactionMeasure = REAL;
	/// <para>TYPE IfcModulusOfRotationalSubgradeReactionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfRotationalSubgradeReactionMeasure : REAL, IfcDerivedMeasureValue, IfcModulusOfRotationalSubgradeReactionSelect
	{
		IfcModulusOfRotationalSubgradeReactionMeasure() { }
		IfcModulusOfRotationalSubgradeReactionMeasure(double value) { Value = value; }
		public static implicit operator IfcModulusOfRotationalSubgradeReactionMeasure(double value) { return new IfcModulusOfRotationalSubgradeReactionMeasure(double);}
		public static implicit operator double(IfcModulusOfRotationalSubgradeReactionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfSubgradeReactionMeasure = REAL;
	/// <para>TYPE IfcModulusOfSubgradeReactionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfSubgradeReactionMeasure : REAL, IfcDerivedMeasureValue, IfcModulusOfSubgradeReactionSelect
	{
		IfcModulusOfSubgradeReactionMeasure() { }
		IfcModulusOfSubgradeReactionMeasure(double value) { Value = value; }
		public static implicit operator IfcModulusOfSubgradeReactionMeasure(double value) { return new IfcModulusOfSubgradeReactionMeasure(double);}
		public static implicit operator double(IfcModulusOfSubgradeReactionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMoistureDiffusivityMeasure = REAL;
	/// <para>TYPE IfcMoistureDiffusivityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMoistureDiffusivityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMoistureDiffusivityMeasure() { }
		IfcMoistureDiffusivityMeasure(double value) { Value = value; }
		public static implicit operator IfcMoistureDiffusivityMeasure(double value) { return new IfcMoistureDiffusivityMeasure(double);}
		public static implicit operator double(IfcMoistureDiffusivityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMolecularWeightMeasure = REAL;
	/// <para>TYPE IfcMolecularWeightMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMolecularWeightMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMolecularWeightMeasure() { }
		IfcMolecularWeightMeasure(double value) { Value = value; }
		public static implicit operator IfcMolecularWeightMeasure(double value) { return new IfcMolecularWeightMeasure(double);}
		public static implicit operator double(IfcMolecularWeightMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMomentOfInertiaMeasure = REAL;
	/// <para>TYPE IfcMomentOfInertiaMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMomentOfInertiaMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMomentOfInertiaMeasure() { }
		IfcMomentOfInertiaMeasure(double value) { Value = value; }
		public static implicit operator IfcMomentOfInertiaMeasure(double value) { return new IfcMomentOfInertiaMeasure(double);}
		public static implicit operator double(IfcMomentOfInertiaMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMonetaryMeasure = REAL;
	/// <para>TYPE IfcMonetaryMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMonetaryMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMonetaryMeasure() { }
		IfcMonetaryMeasure(double value) { Value = value; }
		public static implicit operator IfcMonetaryMeasure(double value) { return new IfcMonetaryMeasure(double);}
		public static implicit operator double(IfcMonetaryMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMonthInYearNumber = INTEGER;
	/// <para>TYPE IfcMonthInYearNumber = INTEGER;</para>
	/// <para> WHERE</para>
	/// <para>	 ValidRange : {1 <= SELF <= 12};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMonthInYearNumber : INTEGER
	{
		IfcMonthInYearNumber() { }
		IfcMonthInYearNumber(int value) { Value = value; }
		public static implicit operator IfcMonthInYearNumber(int value) { return new IfcMonthInYearNumber(int);}
		public static implicit operator int(IfcMonthInYearNumber value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNonNegativeLengthMeasure = IfcLengthMeasure;
	/// <para>TYPE IfcNonNegativeLengthMeasure = IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	 NotNegative : SELF >= 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNonNegativeLengthMeasure : IfcLengthMeasure, IfcMeasureValue
	{
		IfcNonNegativeLengthMeasure() { }
		IfcNonNegativeLengthMeasure(double value) { Value = value; }
		public static implicit operator IfcNonNegativeLengthMeasure(double value) { return new IfcNonNegativeLengthMeasure(double);}
		public static implicit operator double(IfcNonNegativeLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNormalisedRatioMeasure = IfcRatioMeasure;
	/// <para>TYPE IfcNormalisedRatioMeasure = IfcRatioMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : {0.0 <= SELF <= 1.0};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNormalisedRatioMeasure : IfcRatioMeasure, IfcColourOrFactor, IfcMeasureValue, IfcSizeSelect
	{
		IfcNormalisedRatioMeasure() { }
		IfcNormalisedRatioMeasure(double value) { Value = value; }
		public static implicit operator IfcNormalisedRatioMeasure(double value) { return new IfcNormalisedRatioMeasure(double);}
		public static implicit operator double(IfcNormalisedRatioMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNumericMeasure = NUMBER;
	/// <para>TYPE IfcNumericMeasure = NUMBER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNumericMeasure : NUMBER, IfcMeasureValue
	{
		IfcNumericMeasure() { }
		IfcNumericMeasure(double value) { Value = value; }
		public static implicit operator IfcNumericMeasure(double value) { return new IfcNumericMeasure(double);}
		public static implicit operator double(IfcNumericMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPHMeasure = REAL;
	/// <para>TYPE IfcPHMeasure = REAL;</para>
	/// <para> WHERE</para>
	/// <para>	 WR21 : {0.0 <= SELF <= 14.0};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPHMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcPHMeasure() { }
		IfcPHMeasure(double value) { Value = value; }
		public static implicit operator IfcPHMeasure(double value) { return new IfcPHMeasure(double);}
		public static implicit operator double(IfcPHMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcParameterValue = REAL;
	/// <para>TYPE IfcParameterValue = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcParameterValue : REAL, IfcCurveMeasureSelect, IfcMeasureValue, IfcTrimmingSelect
	{
		IfcParameterValue() { }
		IfcParameterValue(double value) { Value = value; }
		public static implicit operator IfcParameterValue(double value) { return new IfcParameterValue(double);}
		public static implicit operator double(IfcParameterValue value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPlanarForceMeasure = REAL;
	/// <para>TYPE IfcPlanarForceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPlanarForceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcPlanarForceMeasure() { }
		IfcPlanarForceMeasure(double value) { Value = value; }
		public static implicit operator IfcPlanarForceMeasure(double value) { return new IfcPlanarForceMeasure(double);}
		public static implicit operator double(IfcPlanarForceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPlaneAngleMeasure = REAL;
	/// <para>TYPE IfcPlaneAngleMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPlaneAngleMeasure : REAL, IfcBendingParameterSelect, IfcMeasureValue
	{
		IfcPlaneAngleMeasure() { }
		IfcPlaneAngleMeasure(double value) { Value = value; }
		public static implicit operator IfcPlaneAngleMeasure(double value) { return new IfcPlaneAngleMeasure(double);}
		public static implicit operator double(IfcPlaneAngleMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositiveInteger = IfcInteger;
	/// <para>TYPE IfcPositiveInteger = IfcInteger;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF > 0;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositiveInteger : IfcInteger, IfcSimpleValue
	{
		IfcPositiveInteger() { }
		IfcPositiveInteger(int value) { Value = value; }
		public static implicit operator IfcPositiveInteger(int value) { return new IfcPositiveInteger(int);}
		public static implicit operator int(IfcPositiveInteger value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositiveLengthMeasure = IfcLengthMeasure;
	/// <para>TYPE IfcPositiveLengthMeasure = IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositiveLengthMeasure : IfcLengthMeasure, IfcHatchLineDistanceSelect, IfcMeasureValue, IfcSizeSelect
	{
		IfcPositiveLengthMeasure() { }
		IfcPositiveLengthMeasure(double value) { Value = value; }
		public static implicit operator IfcPositiveLengthMeasure(double value) { return new IfcPositiveLengthMeasure(double);}
		public static implicit operator double(IfcPositiveLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositivePlaneAngleMeasure = IfcPlaneAngleMeasure;
	/// <para>TYPE IfcPositivePlaneAngleMeasure = IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositivePlaneAngleMeasure : IfcPlaneAngleMeasure, IfcMeasureValue
	{
		IfcPositivePlaneAngleMeasure() { }
		IfcPositivePlaneAngleMeasure(double value) { Value = value; }
		public static implicit operator IfcPositivePlaneAngleMeasure(double value) { return new IfcPositivePlaneAngleMeasure(double);}
		public static implicit operator double(IfcPositivePlaneAngleMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositiveRatioMeasure = IfcRatioMeasure;
	/// <para>TYPE IfcPositiveRatioMeasure = IfcRatioMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositiveRatioMeasure : IfcRatioMeasure, IfcMeasureValue, IfcSizeSelect
	{
		IfcPositiveRatioMeasure() { }
		IfcPositiveRatioMeasure(double value) { Value = value; }
		public static implicit operator IfcPositiveRatioMeasure(double value) { return new IfcPositiveRatioMeasure(double);}
		public static implicit operator double(IfcPositiveRatioMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPowerMeasure = REAL;
	/// <para>TYPE IfcPowerMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPowerMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcPowerMeasure() { }
		IfcPowerMeasure(double value) { Value = value; }
		public static implicit operator IfcPowerMeasure(double value) { return new IfcPowerMeasure(double);}
		public static implicit operator double(IfcPowerMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPresentableText = STRING;
	/// <para>TYPE IfcPresentableText = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPresentableText : STRING
	{
		IfcPresentableText() { }
		IfcPresentableText(string value) { Value = value; }
		public static implicit operator IfcPresentableText(string value) { return new IfcPresentableText(string);}
		public static implicit operator string(IfcPresentableText value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPressureMeasure = REAL;
	/// <para>TYPE IfcPressureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPressureMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcPressureMeasure() { }
		IfcPressureMeasure(double value) { Value = value; }
		public static implicit operator IfcPressureMeasure(double value) { return new IfcPressureMeasure(double);}
		public static implicit operator double(IfcPressureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRadioActivityMeasure = REAL;
	/// <para>TYPE IfcRadioActivityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRadioActivityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcRadioActivityMeasure() { }
		IfcRadioActivityMeasure(double value) { Value = value; }
		public static implicit operator IfcRadioActivityMeasure(double value) { return new IfcRadioActivityMeasure(double);}
		public static implicit operator double(IfcRadioActivityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRatioMeasure = REAL;
	/// <para>TYPE IfcRatioMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRatioMeasure : REAL, IfcMeasureValue, IfcSizeSelect, IfcTimeOrRatioSelect
	{
		IfcRatioMeasure() { }
		IfcRatioMeasure(double value) { Value = value; }
		public static implicit operator IfcRatioMeasure(double value) { return new IfcRatioMeasure(double);}
		public static implicit operator double(IfcRatioMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReal = REAL;
	/// <para>TYPE IfcReal = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReal : REAL, IfcSimpleValue
	{
		IfcReal() { }
		IfcReal(double value) { Value = value; }
		public static implicit operator IfcReal(double value) { return new IfcReal(double);}
		public static implicit operator double(IfcReal value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRotationalFrequencyMeasure = REAL;
	/// <para>TYPE IfcRotationalFrequencyMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRotationalFrequencyMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcRotationalFrequencyMeasure() { }
		IfcRotationalFrequencyMeasure(double value) { Value = value; }
		public static implicit operator IfcRotationalFrequencyMeasure(double value) { return new IfcRotationalFrequencyMeasure(double);}
		public static implicit operator double(IfcRotationalFrequencyMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRotationalMassMeasure = REAL;
	/// <para>TYPE IfcRotationalMassMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRotationalMassMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcRotationalMassMeasure() { }
		IfcRotationalMassMeasure(double value) { Value = value; }
		public static implicit operator IfcRotationalMassMeasure(double value) { return new IfcRotationalMassMeasure(double);}
		public static implicit operator double(IfcRotationalMassMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRotationalStiffnessMeasure = REAL;
	/// <para>TYPE IfcRotationalStiffnessMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRotationalStiffnessMeasure : REAL, IfcDerivedMeasureValue, IfcRotationalStiffnessSelect
	{
		IfcRotationalStiffnessMeasure() { }
		IfcRotationalStiffnessMeasure(double value) { Value = value; }
		public static implicit operator IfcRotationalStiffnessMeasure(double value) { return new IfcRotationalStiffnessMeasure(double);}
		public static implicit operator double(IfcRotationalStiffnessMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSectionModulusMeasure = REAL;
	/// <para>TYPE IfcSectionModulusMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSectionModulusMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSectionModulusMeasure() { }
		IfcSectionModulusMeasure(double value) { Value = value; }
		public static implicit operator IfcSectionModulusMeasure(double value) { return new IfcSectionModulusMeasure(double);}
		public static implicit operator double(IfcSectionModulusMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSectionalAreaIntegralMeasure = REAL;
	/// <para>TYPE IfcSectionalAreaIntegralMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSectionalAreaIntegralMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSectionalAreaIntegralMeasure() { }
		IfcSectionalAreaIntegralMeasure(double value) { Value = value; }
		public static implicit operator IfcSectionalAreaIntegralMeasure(double value) { return new IfcSectionalAreaIntegralMeasure(double);}
		public static implicit operator double(IfcSectionalAreaIntegralMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcShearModulusMeasure = REAL;
	/// <para>TYPE IfcShearModulusMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcShearModulusMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcShearModulusMeasure() { }
		IfcShearModulusMeasure(double value) { Value = value; }
		public static implicit operator IfcShearModulusMeasure(double value) { return new IfcShearModulusMeasure(double);}
		public static implicit operator double(IfcShearModulusMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSolidAngleMeasure = REAL;
	/// <para>TYPE IfcSolidAngleMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSolidAngleMeasure : REAL, IfcMeasureValue
	{
		IfcSolidAngleMeasure() { }
		IfcSolidAngleMeasure(double value) { Value = value; }
		public static implicit operator IfcSolidAngleMeasure(double value) { return new IfcSolidAngleMeasure(double);}
		public static implicit operator double(IfcSolidAngleMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPowerLevelMeasure = REAL;
	/// <para>TYPE IfcSoundPowerLevelMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPowerLevelMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSoundPowerLevelMeasure() { }
		IfcSoundPowerLevelMeasure(double value) { Value = value; }
		public static implicit operator IfcSoundPowerLevelMeasure(double value) { return new IfcSoundPowerLevelMeasure(double);}
		public static implicit operator double(IfcSoundPowerLevelMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPowerMeasure = REAL;
	/// <para>TYPE IfcSoundPowerMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPowerMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSoundPowerMeasure() { }
		IfcSoundPowerMeasure(double value) { Value = value; }
		public static implicit operator IfcSoundPowerMeasure(double value) { return new IfcSoundPowerMeasure(double);}
		public static implicit operator double(IfcSoundPowerMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPressureLevelMeasure = REAL;
	/// <para>TYPE IfcSoundPressureLevelMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPressureLevelMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSoundPressureLevelMeasure() { }
		IfcSoundPressureLevelMeasure(double value) { Value = value; }
		public static implicit operator IfcSoundPressureLevelMeasure(double value) { return new IfcSoundPressureLevelMeasure(double);}
		public static implicit operator double(IfcSoundPressureLevelMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPressureMeasure = REAL;
	/// <para>TYPE IfcSoundPressureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPressureMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSoundPressureMeasure() { }
		IfcSoundPressureMeasure(double value) { Value = value; }
		public static implicit operator IfcSoundPressureMeasure(double value) { return new IfcSoundPressureMeasure(double);}
		public static implicit operator double(IfcSoundPressureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpecificHeatCapacityMeasure = REAL;
	/// <para>TYPE IfcSpecificHeatCapacityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpecificHeatCapacityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSpecificHeatCapacityMeasure() { }
		IfcSpecificHeatCapacityMeasure(double value) { Value = value; }
		public static implicit operator IfcSpecificHeatCapacityMeasure(double value) { return new IfcSpecificHeatCapacityMeasure(double);}
		public static implicit operator double(IfcSpecificHeatCapacityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpecularExponent = REAL;
	/// <para>TYPE IfcSpecularExponent = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpecularExponent : REAL, IfcSpecularHighlightSelect
	{
		IfcSpecularExponent() { }
		IfcSpecularExponent(double value) { Value = value; }
		public static implicit operator IfcSpecularExponent(double value) { return new IfcSpecularExponent(double);}
		public static implicit operator double(IfcSpecularExponent value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpecularRoughness = REAL;
	/// <para>TYPE IfcSpecularRoughness = REAL;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : {0.0 <= SELF <= 1.0};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpecularRoughness : REAL, IfcSpecularHighlightSelect
	{
		IfcSpecularRoughness() { }
		IfcSpecularRoughness(double value) { Value = value; }
		public static implicit operator IfcSpecularRoughness(double value) { return new IfcSpecularRoughness(double);}
		public static implicit operator double(IfcSpecularRoughness value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStrippedOptional = BOOLEAN;
	/// <para>TYPE IfcStrippedOptional = BOOLEAN;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStrippedOptional : BOOLEAN
	{
		IfcStrippedOptional() { }
		IfcStrippedOptional(bool value) { Value = value; }
		public static implicit operator IfcStrippedOptional(bool value) { return new IfcStrippedOptional(bool);}
		public static implicit operator bool(IfcStrippedOptional value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTemperatureGradientMeasure = REAL;
	/// <para>TYPE IfcTemperatureGradientMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTemperatureGradientMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcTemperatureGradientMeasure() { }
		IfcTemperatureGradientMeasure(double value) { Value = value; }
		public static implicit operator IfcTemperatureGradientMeasure(double value) { return new IfcTemperatureGradientMeasure(double);}
		public static implicit operator double(IfcTemperatureGradientMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTemperatureRateOfChangeMeasure = REAL;
	/// <para>TYPE IfcTemperatureRateOfChangeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTemperatureRateOfChangeMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcTemperatureRateOfChangeMeasure() { }
		IfcTemperatureRateOfChangeMeasure(double value) { Value = value; }
		public static implicit operator IfcTemperatureRateOfChangeMeasure(double value) { return new IfcTemperatureRateOfChangeMeasure(double);}
		public static implicit operator double(IfcTemperatureRateOfChangeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcText = STRING;
	/// <para>TYPE IfcText = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcText : STRING, IfcSimpleValue
	{
		IfcText() { }
		IfcText(string value) { Value = value; }
		public static implicit operator IfcText(string value) { return new IfcText(string);}
		public static implicit operator string(IfcText value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextAlignment = STRING;
	/// <para>TYPE IfcTextAlignment = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF IN ['left', 'right', 'center', 'justify'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextAlignment : STRING
	{
		IfcTextAlignment() { }
		IfcTextAlignment(string value) { Value = value; }
		public static implicit operator IfcTextAlignment(string value) { return new IfcTextAlignment(string);}
		public static implicit operator string(IfcTextAlignment value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextDecoration = STRING;
	/// <para>TYPE IfcTextDecoration = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF IN ['none', 'underline', 'overline', 'line-through', 'blink'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextDecoration : STRING
	{
		IfcTextDecoration() { }
		IfcTextDecoration(string value) { Value = value; }
		public static implicit operator IfcTextDecoration(string value) { return new IfcTextDecoration(string);}
		public static implicit operator string(IfcTextDecoration value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextFontName = STRING;
	/// <para>TYPE IfcTextFontName = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextFontName : STRING
	{
		IfcTextFontName() { }
		IfcTextFontName(string value) { Value = value; }
		public static implicit operator IfcTextFontName(string value) { return new IfcTextFontName(string);}
		public static implicit operator string(IfcTextFontName value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextTransformation = STRING;
	/// <para>TYPE IfcTextTransformation = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	 WR1 : SELF IN ['capitalize', 'uppercase', 'lowercase', 'none'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextTransformation : STRING
	{
		IfcTextTransformation() { }
		IfcTextTransformation(string value) { Value = value; }
		public static implicit operator IfcTextTransformation(string value) { return new IfcTextTransformation(string);}
		public static implicit operator string(IfcTextTransformation value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalAdmittanceMeasure = REAL;
	/// <para>TYPE IfcThermalAdmittanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalAdmittanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcThermalAdmittanceMeasure() { }
		IfcThermalAdmittanceMeasure(double value) { Value = value; }
		public static implicit operator IfcThermalAdmittanceMeasure(double value) { return new IfcThermalAdmittanceMeasure(double);}
		public static implicit operator double(IfcThermalAdmittanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalConductivityMeasure = REAL;
	/// <para>TYPE IfcThermalConductivityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalConductivityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcThermalConductivityMeasure() { }
		IfcThermalConductivityMeasure(double value) { Value = value; }
		public static implicit operator IfcThermalConductivityMeasure(double value) { return new IfcThermalConductivityMeasure(double);}
		public static implicit operator double(IfcThermalConductivityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalExpansionCoefficientMeasure = REAL;
	/// <para>TYPE IfcThermalExpansionCoefficientMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalExpansionCoefficientMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcThermalExpansionCoefficientMeasure() { }
		IfcThermalExpansionCoefficientMeasure(double value) { Value = value; }
		public static implicit operator IfcThermalExpansionCoefficientMeasure(double value) { return new IfcThermalExpansionCoefficientMeasure(double);}
		public static implicit operator double(IfcThermalExpansionCoefficientMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalResistanceMeasure = REAL;
	/// <para>TYPE IfcThermalResistanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalResistanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcThermalResistanceMeasure() { }
		IfcThermalResistanceMeasure(double value) { Value = value; }
		public static implicit operator IfcThermalResistanceMeasure(double value) { return new IfcThermalResistanceMeasure(double);}
		public static implicit operator double(IfcThermalResistanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalTransmittanceMeasure = REAL;
	/// <para>TYPE IfcThermalTransmittanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalTransmittanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcThermalTransmittanceMeasure() { }
		IfcThermalTransmittanceMeasure(double value) { Value = value; }
		public static implicit operator IfcThermalTransmittanceMeasure(double value) { return new IfcThermalTransmittanceMeasure(double);}
		public static implicit operator double(IfcThermalTransmittanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermodynamicTemperatureMeasure = REAL;
	/// <para>TYPE IfcThermodynamicTemperatureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermodynamicTemperatureMeasure : REAL, IfcMeasureValue
	{
		IfcThermodynamicTemperatureMeasure() { }
		IfcThermodynamicTemperatureMeasure(double value) { Value = value; }
		public static implicit operator IfcThermodynamicTemperatureMeasure(double value) { return new IfcThermodynamicTemperatureMeasure(double);}
		public static implicit operator double(IfcThermodynamicTemperatureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTime = STRING;
	/// <para>TYPE IfcTime = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTime : STRING, IfcSimpleValue
	{
		IfcTime() { }
		IfcTime(string value) { Value = value; }
		public static implicit operator IfcTime(string value) { return new IfcTime(string);}
		public static implicit operator string(IfcTime value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTimeMeasure = REAL;
	/// <para>TYPE IfcTimeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTimeMeasure : REAL, IfcMeasureValue
	{
		IfcTimeMeasure() { }
		IfcTimeMeasure(double value) { Value = value; }
		public static implicit operator IfcTimeMeasure(double value) { return new IfcTimeMeasure(double);}
		public static implicit operator double(IfcTimeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTimeStamp = INTEGER;
	/// <para>TYPE IfcTimeStamp = INTEGER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTimeStamp : INTEGER, IfcSimpleValue
	{
		IfcTimeStamp() { }
		IfcTimeStamp(int value) { Value = value; }
		public static implicit operator IfcTimeStamp(int value) { return new IfcTimeStamp(int);}
		public static implicit operator int(IfcTimeStamp value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTorqueMeasure = REAL;
	/// <para>TYPE IfcTorqueMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTorqueMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcTorqueMeasure() { }
		IfcTorqueMeasure(double value) { Value = value; }
		public static implicit operator IfcTorqueMeasure(double value) { return new IfcTorqueMeasure(double);}
		public static implicit operator double(IfcTorqueMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcURIReference = STRING;
	/// <para>TYPE IfcURIReference = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcURIReference : STRING, IfcSimpleValue
	{
		IfcURIReference() { }
		IfcURIReference(string value) { Value = value; }
		public static implicit operator IfcURIReference(string value) { return new IfcURIReference(string);}
		public static implicit operator string(IfcURIReference value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVaporPermeabilityMeasure = REAL;
	/// <para>TYPE IfcVaporPermeabilityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVaporPermeabilityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcVaporPermeabilityMeasure() { }
		IfcVaporPermeabilityMeasure(double value) { Value = value; }
		public static implicit operator IfcVaporPermeabilityMeasure(double value) { return new IfcVaporPermeabilityMeasure(double);}
		public static implicit operator double(IfcVaporPermeabilityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVolumeMeasure = REAL;
	/// <para>TYPE IfcVolumeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVolumeMeasure : REAL, IfcMeasureValue
	{
		IfcVolumeMeasure() { }
		IfcVolumeMeasure(double value) { Value = value; }
		public static implicit operator IfcVolumeMeasure(double value) { return new IfcVolumeMeasure(double);}
		public static implicit operator double(IfcVolumeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVolumetricFlowRateMeasure = REAL;
	/// <para>TYPE IfcVolumetricFlowRateMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVolumetricFlowRateMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcVolumetricFlowRateMeasure() { }
		IfcVolumetricFlowRateMeasure(double value) { Value = value; }
		public static implicit operator IfcVolumetricFlowRateMeasure(double value) { return new IfcVolumetricFlowRateMeasure(double);}
		public static implicit operator double(IfcVolumetricFlowRateMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWarpingConstantMeasure = REAL;
	/// <para>TYPE IfcWarpingConstantMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWarpingConstantMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcWarpingConstantMeasure() { }
		IfcWarpingConstantMeasure(double value) { Value = value; }
		public static implicit operator IfcWarpingConstantMeasure(double value) { return new IfcWarpingConstantMeasure(double);}
		public static implicit operator double(IfcWarpingConstantMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWarpingMomentMeasure = REAL;
	/// <para>TYPE IfcWarpingMomentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWarpingMomentMeasure : REAL, IfcDerivedMeasureValue, IfcWarpingStiffnessSelect
	{
		IfcWarpingMomentMeasure() { }
		IfcWarpingMomentMeasure(double value) { Value = value; }
		public static implicit operator IfcWarpingMomentMeasure(double value) { return new IfcWarpingMomentMeasure(double);}
		public static implicit operator double(IfcWarpingMomentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWellKnownTextLiteral = STRING;
	/// <para>TYPE IfcWellKnownTextLiteral = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWellKnownTextLiteral : STRING
	{
		IfcWellKnownTextLiteral() { }
		IfcWellKnownTextLiteral(string value) { Value = value; }
		public static implicit operator IfcWellKnownTextLiteral(string value) { return new IfcWellKnownTextLiteral(string);}
		public static implicit operator string(IfcWellKnownTextLiteral value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcActorSelect = SELECT
	/// <para>TYPE IfcActorSelect = SELECT</para>
	/// <para>	(IfcOrganization</para>
	/// <para>	,IfcPerson</para>
	/// <para>	,IfcPersonAndOrganization);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcActorSelect
	{
	}
	/// <summary>
	/// TYPE IfcAppliedValueSelect = SELECT
	/// <para>TYPE IfcAppliedValueSelect = SELECT</para>
	/// <para>	(IfcMeasureWithUnit</para>
	/// <para>	,IfcReference</para>
	/// <para>	,IfcValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcAppliedValueSelect
	{
	}
	/// <summary>
	/// TYPE IfcAxis2Placement = SELECT
	/// <para>TYPE IfcAxis2Placement = SELECT</para>
	/// <para>	(IfcAxis2Placement2D</para>
	/// <para>	,IfcAxis2Placement3D);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcAxis2Placement
	{
	}
	/// <summary>
	/// TYPE IfcBendingParameterSelect = SELECT
	/// <para>TYPE IfcBendingParameterSelect = SELECT</para>
	/// <para>	(IfcLengthMeasure</para>
	/// <para>	,IfcPlaneAngleMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcBendingParameterSelect
	{
	}
	/// <summary>
	/// TYPE IfcBooleanOperand = SELECT
	/// <para>TYPE IfcBooleanOperand = SELECT</para>
	/// <para>	(IfcBooleanResult</para>
	/// <para>	,IfcCsgPrimitive3D</para>
	/// <para>	,IfcHalfSpaceSolid</para>
	/// <para>	,IfcSolidModel</para>
	/// <para>	,IfcTessellatedFaceSet);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcBooleanOperand
	{
	}
	/// <summary>
	/// TYPE IfcClassificationReferenceSelect = SELECT
	/// <para>TYPE IfcClassificationReferenceSelect = SELECT</para>
	/// <para>	(IfcClassification</para>
	/// <para>	,IfcClassificationReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcClassificationReferenceSelect
	{
	}
	/// <summary>
	/// TYPE IfcClassificationSelect = SELECT
	/// <para>TYPE IfcClassificationSelect = SELECT</para>
	/// <para>	(IfcClassification</para>
	/// <para>	,IfcClassificationReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcClassificationSelect
	{
	}
	/// <summary>
	/// TYPE IfcColour = SELECT
	/// <para>TYPE IfcColour = SELECT</para>
	/// <para>	(IfcColourSpecification</para>
	/// <para>	,IfcPreDefinedColour);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcColour, IfcFillStyleSelect
	{
	}
	/// <summary>
	/// TYPE IfcColourOrFactor = SELECT
	/// <para>TYPE IfcColourOrFactor = SELECT</para>
	/// <para>	(IfcColourRgb</para>
	/// <para>	,IfcNormalisedRatioMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcColourOrFactor
	{
	}
	/// <summary>
	/// TYPE IfcCoordinateReferenceSystemSelect = SELECT
	/// <para>TYPE IfcCoordinateReferenceSystemSelect = SELECT</para>
	/// <para>	(IfcCoordinateReferenceSystem</para>
	/// <para>	,IfcGeometricRepresentationContext);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCoordinateReferenceSystemSelect
	{
	}
	/// <summary>
	/// TYPE IfcCsgSelect = SELECT
	/// <para>TYPE IfcCsgSelect = SELECT</para>
	/// <para>	(IfcBooleanResult</para>
	/// <para>	,IfcCsgPrimitive3D);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCsgSelect
	{
	}
	/// <summary>
	/// TYPE IfcCurveFontOrScaledCurveFontSelect = SELECT
	/// <para>TYPE IfcCurveFontOrScaledCurveFontSelect = SELECT</para>
	/// <para>	(IfcCurveStyleFontAndScaling</para>
	/// <para>	,IfcCurveStyleFontSelect);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveFontOrScaledCurveFontSelect
	{
	}
	/// <summary>
	/// TYPE IfcCurveMeasureSelect = SELECT
	/// <para>TYPE IfcCurveMeasureSelect = SELECT</para>
	/// <para>	(IfcLengthMeasure</para>
	/// <para>	,IfcParameterValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveMeasureSelect
	{
	}
	/// <summary>
	/// TYPE IfcCurveOnSurface = SELECT
	/// <para>TYPE IfcCurveOnSurface = SELECT</para>
	/// <para>	(IfcCompositeCurveOnSurface</para>
	/// <para>	,IfcPcurve</para>
	/// <para>	,IfcSurfaceCurve);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveOnSurface
	{
	}
	/// <summary>
	/// TYPE IfcCurveOrEdgeCurve = SELECT
	/// <para>TYPE IfcCurveOrEdgeCurve = SELECT</para>
	/// <para>	(IfcBoundedCurve</para>
	/// <para>	,IfcEdgeCurve);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveOrEdgeCurve
	{
	}
	/// <summary>
	/// TYPE IfcCurveStyleFontSelect = SELECT
	/// <para>TYPE IfcCurveStyleFontSelect = SELECT</para>
	/// <para>	(IfcCurveStyleFont</para>
	/// <para>	,IfcPreDefinedCurveFont);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveStyleFontSelect, IfcCurveFontOrScaledCurveFontSelect
	{
	}
	/// <summary>
	/// TYPE IfcDefinitionSelect = SELECT
	/// <para>TYPE IfcDefinitionSelect = SELECT</para>
	/// <para>	(IfcObjectDefinition</para>
	/// <para>	,IfcPropertyDefinition);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcDefinitionSelect
	{
	}
	/// <summary>
	/// TYPE IfcDerivedMeasureValue = SELECT
	/// <para>TYPE IfcDerivedMeasureValue = SELECT</para>
	/// <para>	(IfcAbsorbedDoseMeasure</para>
	/// <para>	,IfcAccelerationMeasure</para>
	/// <para>	,IfcAngularVelocityMeasure</para>
	/// <para>	,IfcAreaDensityMeasure</para>
	/// <para>	,IfcCompoundPlaneAngleMeasure</para>
	/// <para>	,IfcCurvatureMeasure</para>
	/// <para>	,IfcDoseEquivalentMeasure</para>
	/// <para>	,IfcDynamicViscosityMeasure</para>
	/// <para>	,IfcElectricCapacitanceMeasure</para>
	/// <para>	,IfcElectricChargeMeasure</para>
	/// <para>	,IfcElectricConductanceMeasure</para>
	/// <para>	,IfcElectricResistanceMeasure</para>
	/// <para>	,IfcElectricVoltageMeasure</para>
	/// <para>	,IfcEnergyMeasure</para>
	/// <para>	,IfcForceMeasure</para>
	/// <para>	,IfcFrequencyMeasure</para>
	/// <para>	,IfcHeatFluxDensityMeasure</para>
	/// <para>	,IfcHeatingValueMeasure</para>
	/// <para>	,IfcIlluminanceMeasure</para>
	/// <para>	,IfcInductanceMeasure</para>
	/// <para>	,IfcIntegerCountRateMeasure</para>
	/// <para>	,IfcIonConcentrationMeasure</para>
	/// <para>	,IfcIsothermalMoistureCapacityMeasure</para>
	/// <para>	,IfcKinematicViscosityMeasure</para>
	/// <para>	,IfcLinearForceMeasure</para>
	/// <para>	,IfcLinearMomentMeasure</para>
	/// <para>	,IfcLinearStiffnessMeasure</para>
	/// <para>	,IfcLinearVelocityMeasure</para>
	/// <para>	,IfcLuminousFluxMeasure</para>
	/// <para>	,IfcLuminousIntensityDistributionMeasure</para>
	/// <para>	,IfcMagneticFluxDensityMeasure</para>
	/// <para>	,IfcMagneticFluxMeasure</para>
	/// <para>	,IfcMassDensityMeasure</para>
	/// <para>	,IfcMassFlowRateMeasure</para>
	/// <para>	,IfcMassPerLengthMeasure</para>
	/// <para>	,IfcModulusOfElasticityMeasure</para>
	/// <para>	,IfcModulusOfLinearSubgradeReactionMeasure</para>
	/// <para>	,IfcModulusOfRotationalSubgradeReactionMeasure</para>
	/// <para>	,IfcModulusOfSubgradeReactionMeasure</para>
	/// <para>	,IfcMoistureDiffusivityMeasure</para>
	/// <para>	,IfcMolecularWeightMeasure</para>
	/// <para>	,IfcMomentOfInertiaMeasure</para>
	/// <para>	,IfcMonetaryMeasure</para>
	/// <para>	,IfcPHMeasure</para>
	/// <para>	,IfcPlanarForceMeasure</para>
	/// <para>	,IfcPowerMeasure</para>
	/// <para>	,IfcPressureMeasure</para>
	/// <para>	,IfcRadioActivityMeasure</para>
	/// <para>	,IfcRotationalFrequencyMeasure</para>
	/// <para>	,IfcRotationalMassMeasure</para>
	/// <para>	,IfcRotationalStiffnessMeasure</para>
	/// <para>	,IfcSectionModulusMeasure</para>
	/// <para>	,IfcSectionalAreaIntegralMeasure</para>
	/// <para>	,IfcShearModulusMeasure</para>
	/// <para>	,IfcSoundPowerLevelMeasure</para>
	/// <para>	,IfcSoundPowerMeasure</para>
	/// <para>	,IfcSoundPressureLevelMeasure</para>
	/// <para>	,IfcSoundPressureMeasure</para>
	/// <para>	,IfcSpecificHeatCapacityMeasure</para>
	/// <para>	,IfcTemperatureGradientMeasure</para>
	/// <para>	,IfcTemperatureRateOfChangeMeasure</para>
	/// <para>	,IfcThermalAdmittanceMeasure</para>
	/// <para>	,IfcThermalConductivityMeasure</para>
	/// <para>	,IfcThermalExpansionCoefficientMeasure</para>
	/// <para>	,IfcThermalResistanceMeasure</para>
	/// <para>	,IfcThermalTransmittanceMeasure</para>
	/// <para>	,IfcTorqueMeasure</para>
	/// <para>	,IfcVaporPermeabilityMeasure</para>
	/// <para>	,IfcVolumetricFlowRateMeasure</para>
	/// <para>	,IfcWarpingConstantMeasure</para>
	/// <para>	,IfcWarpingMomentMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcDerivedMeasureValue, IfcValue
	{
	}
	/// <summary>
	/// TYPE IfcDocumentSelect = SELECT
	/// <para>TYPE IfcDocumentSelect = SELECT</para>
	/// <para>	(IfcDocumentInformation</para>
	/// <para>	,IfcDocumentReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcDocumentSelect
	{
	}
	/// <summary>
	/// TYPE IfcFillStyleSelect = SELECT
	/// <para>TYPE IfcFillStyleSelect = SELECT</para>
	/// <para>	(IfcColour</para>
	/// <para>	,IfcExternallyDefinedHatchStyle</para>
	/// <para>	,IfcFillAreaStyleHatching</para>
	/// <para>	,IfcFillAreaStyleTiles);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcFillStyleSelect
	{
	}
	/// <summary>
	/// TYPE IfcGeometricSetSelect = SELECT
	/// <para>TYPE IfcGeometricSetSelect = SELECT</para>
	/// <para>	(IfcCurve</para>
	/// <para>	,IfcPoint</para>
	/// <para>	,IfcSurface);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcGeometricSetSelect
	{
	}
	/// <summary>
	/// TYPE IfcGridPlacementDirectionSelect = SELECT
	/// <para>TYPE IfcGridPlacementDirectionSelect = SELECT</para>
	/// <para>	(IfcDirection</para>
	/// <para>	,IfcVirtualGridIntersection);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcGridPlacementDirectionSelect
	{
	}
	/// <summary>
	/// TYPE IfcHatchLineDistanceSelect = SELECT
	/// <para>TYPE IfcHatchLineDistanceSelect = SELECT</para>
	/// <para>	(IfcPositiveLengthMeasure</para>
	/// <para>	,IfcVector);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcHatchLineDistanceSelect
	{
	}
	/// <summary>
	/// TYPE IfcInterferenceSelect = SELECT
	/// <para>TYPE IfcInterferenceSelect = SELECT</para>
	/// <para>	(IfcElement</para>
	/// <para>	,IfcSpatialElement);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcInterferenceSelect
	{
	}
	/// <summary>
	/// TYPE IfcLayeredItem = SELECT
	/// <para>TYPE IfcLayeredItem = SELECT</para>
	/// <para>	(IfcRepresentation</para>
	/// <para>	,IfcRepresentationItem);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcLayeredItem
	{
	}
	/// <summary>
	/// TYPE IfcLibrarySelect = SELECT
	/// <para>TYPE IfcLibrarySelect = SELECT</para>
	/// <para>	(IfcLibraryInformation</para>
	/// <para>	,IfcLibraryReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcLibrarySelect
	{
	}
	/// <summary>
	/// TYPE IfcLightDistributionDataSourceSelect = SELECT
	/// <para>TYPE IfcLightDistributionDataSourceSelect = SELECT</para>
	/// <para>	(IfcExternalReference</para>
	/// <para>	,IfcLightIntensityDistribution);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcLightDistributionDataSourceSelect
	{
	}
	/// <summary>
	/// TYPE IfcMaterialSelect = SELECT
	/// <para>TYPE IfcMaterialSelect = SELECT</para>
	/// <para>	(IfcMaterialDefinition</para>
	/// <para>	,IfcMaterialList</para>
	/// <para>	,IfcMaterialUsageDefinition);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcMaterialSelect
	{
	}
	/// <summary>
	/// TYPE IfcMeasureValue = SELECT
	/// <para>TYPE IfcMeasureValue = SELECT</para>
	/// <para>	(IfcAmountOfSubstanceMeasure</para>
	/// <para>	,IfcAreaMeasure</para>
	/// <para>	,IfcComplexNumber</para>
	/// <para>	,IfcContextDependentMeasure</para>
	/// <para>	,IfcCountMeasure</para>
	/// <para>	,IfcDescriptiveMeasure</para>
	/// <para>	,IfcElectricCurrentMeasure</para>
	/// <para>	,IfcLengthMeasure</para>
	/// <para>	,IfcLuminousIntensityMeasure</para>
	/// <para>	,IfcMassMeasure</para>
	/// <para>	,IfcNonNegativeLengthMeasure</para>
	/// <para>	,IfcNormalisedRatioMeasure</para>
	/// <para>	,IfcNumericMeasure</para>
	/// <para>	,IfcParameterValue</para>
	/// <para>	,IfcPlaneAngleMeasure</para>
	/// <para>	,IfcPositiveLengthMeasure</para>
	/// <para>	,IfcPositivePlaneAngleMeasure</para>
	/// <para>	,IfcPositiveRatioMeasure</para>
	/// <para>	,IfcRatioMeasure</para>
	/// <para>	,IfcSolidAngleMeasure</para>
	/// <para>	,IfcThermodynamicTemperatureMeasure</para>
	/// <para>	,IfcTimeMeasure</para>
	/// <para>	,IfcVolumeMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcMeasureValue, IfcValue
	{
	}
	/// <summary>
	/// TYPE IfcMetricValueSelect = SELECT
	/// <para>TYPE IfcMetricValueSelect = SELECT</para>
	/// <para>	(IfcAppliedValue</para>
	/// <para>	,IfcMeasureWithUnit</para>
	/// <para>	,IfcReference</para>
	/// <para>	,IfcTable</para>
	/// <para>	,IfcTimeSeries</para>
	/// <para>	,IfcValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcMetricValueSelect
	{
	}
	/// <summary>
	/// TYPE IfcModulusOfRotationalSubgradeReactionSelect = SELECT
	/// <para>TYPE IfcModulusOfRotationalSubgradeReactionSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcModulusOfRotationalSubgradeReactionMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcModulusOfRotationalSubgradeReactionSelect
	{
	}
	/// <summary>
	/// TYPE IfcModulusOfSubgradeReactionSelect = SELECT
	/// <para>TYPE IfcModulusOfSubgradeReactionSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcModulusOfSubgradeReactionMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcModulusOfSubgradeReactionSelect
	{
	}
	/// <summary>
	/// TYPE IfcModulusOfTranslationalSubgradeReactionSelect = SELECT
	/// <para>TYPE IfcModulusOfTranslationalSubgradeReactionSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcModulusOfLinearSubgradeReactionMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcModulusOfTranslationalSubgradeReactionSelect
	{
	}
	/// <summary>
	/// TYPE IfcObjectReferenceSelect = SELECT
	/// <para>TYPE IfcObjectReferenceSelect = SELECT</para>
	/// <para>	(IfcAddress</para>
	/// <para>	,IfcAppliedValue</para>
	/// <para>	,IfcExternalReference</para>
	/// <para>	,IfcMaterialDefinition</para>
	/// <para>	,IfcOrganization</para>
	/// <para>	,IfcPerson</para>
	/// <para>	,IfcPersonAndOrganization</para>
	/// <para>	,IfcTable</para>
	/// <para>	,IfcTimeSeries);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcObjectReferenceSelect
	{
	}
	/// <summary>
	/// TYPE IfcPointOrVertexPoint = SELECT
	/// <para>TYPE IfcPointOrVertexPoint = SELECT</para>
	/// <para>	(IfcPoint</para>
	/// <para>	,IfcVertexPoint);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcPointOrVertexPoint
	{
	}
	/// <summary>
	/// TYPE IfcProcessSelect = SELECT
	/// <para>TYPE IfcProcessSelect = SELECT</para>
	/// <para>	(IfcProcess</para>
	/// <para>	,IfcTypeProcess);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcProcessSelect
	{
	}
	/// <summary>
	/// TYPE IfcProductRepresentationSelect = SELECT
	/// <para>TYPE IfcProductRepresentationSelect = SELECT</para>
	/// <para>	(IfcProductDefinitionShape</para>
	/// <para>	,IfcRepresentationMap);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcProductRepresentationSelect
	{
	}
	/// <summary>
	/// TYPE IfcProductSelect = SELECT
	/// <para>TYPE IfcProductSelect = SELECT</para>
	/// <para>	(IfcProduct</para>
	/// <para>	,IfcTypeProduct);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcProductSelect
	{
	}
	/// <summary>
	/// TYPE IfcPropertySetDefinitionSelect = SELECT
	/// <para>TYPE IfcPropertySetDefinitionSelect = SELECT</para>
	/// <para>	(IfcPropertySetDefinition</para>
	/// <para>	,IfcPropertySetDefinitionSet);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcPropertySetDefinitionSelect
	{
	}
	/// <summary>
	/// TYPE IfcResourceObjectSelect = SELECT
	/// <para>TYPE IfcResourceObjectSelect = SELECT</para>
	/// <para>	(IfcActorRole</para>
	/// <para>	,IfcAppliedValue</para>
	/// <para>	,IfcApproval</para>
	/// <para>	,IfcConstraint</para>
	/// <para>	,IfcContextDependentUnit</para>
	/// <para>	,IfcConversionBasedUnit</para>
	/// <para>	,IfcExternalInformation</para>
	/// <para>	,IfcExternalReference</para>
	/// <para>	,IfcMaterialDefinition</para>
	/// <para>	,IfcOrganization</para>
	/// <para>	,IfcPerson</para>
	/// <para>	,IfcPersonAndOrganization</para>
	/// <para>	,IfcPhysicalQuantity</para>
	/// <para>	,IfcProfileDef</para>
	/// <para>	,IfcPropertyAbstraction</para>
	/// <para>	,IfcShapeAspect</para>
	/// <para>	,IfcTimeSeries);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcResourceObjectSelect
	{
	}
	/// <summary>
	/// TYPE IfcResourceSelect = SELECT
	/// <para>TYPE IfcResourceSelect = SELECT</para>
	/// <para>	(IfcResource</para>
	/// <para>	,IfcTypeResource);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcResourceSelect
	{
	}
	/// <summary>
	/// TYPE IfcRotationalStiffnessSelect = SELECT
	/// <para>TYPE IfcRotationalStiffnessSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcRotationalStiffnessMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcRotationalStiffnessSelect
	{
	}
	/// <summary>
	/// TYPE IfcSegmentIndexSelect = SELECT
	/// <para>TYPE IfcSegmentIndexSelect = SELECT</para>
	/// <para>	(IfcArcIndex</para>
	/// <para>	,IfcLineIndex);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSegmentIndexSelect
	{
	}
	/// <summary>
	/// TYPE IfcShell = SELECT
	/// <para>TYPE IfcShell = SELECT</para>
	/// <para>	(IfcClosedShell</para>
	/// <para>	,IfcOpenShell);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcShell
	{
	}
	/// <summary>
	/// TYPE IfcSimpleValue = SELECT
	/// <para>TYPE IfcSimpleValue = SELECT</para>
	/// <para>	(IfcBinary</para>
	/// <para>	,IfcBoolean</para>
	/// <para>	,IfcDate</para>
	/// <para>	,IfcDateTime</para>
	/// <para>	,IfcDuration</para>
	/// <para>	,IfcIdentifier</para>
	/// <para>	,IfcInteger</para>
	/// <para>	,IfcLabel</para>
	/// <para>	,IfcLogical</para>
	/// <para>	,IfcPositiveInteger</para>
	/// <para>	,IfcReal</para>
	/// <para>	,IfcText</para>
	/// <para>	,IfcTime</para>
	/// <para>	,IfcTimeStamp</para>
	/// <para>	,IfcURIReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSimpleValue, IfcValue
	{
	}
	/// <summary>
	/// TYPE IfcSizeSelect = SELECT
	/// <para>TYPE IfcSizeSelect = SELECT</para>
	/// <para>	(IfcDescriptiveMeasure</para>
	/// <para>	,IfcLengthMeasure</para>
	/// <para>	,IfcNormalisedRatioMeasure</para>
	/// <para>	,IfcPositiveLengthMeasure</para>
	/// <para>	,IfcPositiveRatioMeasure</para>
	/// <para>	,IfcRatioMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSizeSelect
	{
	}
	/// <summary>
	/// TYPE IfcSolidOrShell = SELECT
	/// <para>TYPE IfcSolidOrShell = SELECT</para>
	/// <para>	(IfcClosedShell</para>
	/// <para>	,IfcSolidModel);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSolidOrShell
	{
	}
	/// <summary>
	/// TYPE IfcSpaceBoundarySelect = SELECT
	/// <para>TYPE IfcSpaceBoundarySelect = SELECT</para>
	/// <para>	(IfcExternalSpatialElement</para>
	/// <para>	,IfcSpace);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSpaceBoundarySelect
	{
	}
	/// <summary>
	/// TYPE IfcSpatialReferenceSelect = SELECT
	/// <para>TYPE IfcSpatialReferenceSelect = SELECT</para>
	/// <para>	(IfcGroup</para>
	/// <para>	,IfcProduct);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSpatialReferenceSelect
	{
	}
	/// <summary>
	/// TYPE IfcSpecularHighlightSelect = SELECT
	/// <para>TYPE IfcSpecularHighlightSelect = SELECT</para>
	/// <para>	(IfcSpecularExponent</para>
	/// <para>	,IfcSpecularRoughness);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSpecularHighlightSelect
	{
	}
	/// <summary>
	/// TYPE IfcStructuralActivityAssignmentSelect = SELECT
	/// <para>TYPE IfcStructuralActivityAssignmentSelect = SELECT</para>
	/// <para>	(IfcElement</para>
	/// <para>	,IfcStructuralItem);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcStructuralActivityAssignmentSelect
	{
	}
	/// <summary>
	/// TYPE IfcSurfaceOrFaceSurface = SELECT
	/// <para>TYPE IfcSurfaceOrFaceSurface = SELECT</para>
	/// <para>	(IfcFaceBasedSurfaceModel</para>
	/// <para>	,IfcFaceSurface</para>
	/// <para>	,IfcSurface);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSurfaceOrFaceSurface
	{
	}
	/// <summary>
	/// TYPE IfcSurfaceStyleElementSelect = SELECT
	/// <para>TYPE IfcSurfaceStyleElementSelect = SELECT</para>
	/// <para>	(IfcExternallyDefinedSurfaceStyle</para>
	/// <para>	,IfcSurfaceStyleLighting</para>
	/// <para>	,IfcSurfaceStyleRefraction</para>
	/// <para>	,IfcSurfaceStyleShading</para>
	/// <para>	,IfcSurfaceStyleWithTextures);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSurfaceStyleElementSelect
	{
	}
	/// <summary>
	/// TYPE IfcTextFontSelect = SELECT
	/// <para>TYPE IfcTextFontSelect = SELECT</para>
	/// <para>	(IfcExternallyDefinedTextFont</para>
	/// <para>	,IfcPreDefinedTextFont);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTextFontSelect
	{
	}
	/// <summary>
	/// TYPE IfcTimeOrRatioSelect = SELECT
	/// <para>TYPE IfcTimeOrRatioSelect = SELECT</para>
	/// <para>	(IfcDuration</para>
	/// <para>	,IfcRatioMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTimeOrRatioSelect
	{
	}
	/// <summary>
	/// TYPE IfcTranslationalStiffnessSelect = SELECT
	/// <para>TYPE IfcTranslationalStiffnessSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcLinearStiffnessMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTranslationalStiffnessSelect
	{
	}
	/// <summary>
	/// TYPE IfcTrimmingSelect = SELECT
	/// <para>TYPE IfcTrimmingSelect = SELECT</para>
	/// <para>	(IfcCartesianPoint</para>
	/// <para>	,IfcParameterValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTrimmingSelect
	{
	}
	/// <summary>
	/// TYPE IfcUnit = SELECT
	/// <para>TYPE IfcUnit = SELECT</para>
	/// <para>	(IfcDerivedUnit</para>
	/// <para>	,IfcMonetaryUnit</para>
	/// <para>	,IfcNamedUnit);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcUnit
	{
	}
	/// <summary>
	/// TYPE IfcValue = SELECT
	/// <para>TYPE IfcValue = SELECT</para>
	/// <para>	(IfcDerivedMeasureValue</para>
	/// <para>	,IfcMeasureValue</para>
	/// <para>	,IfcSimpleValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcValue, IfcAppliedValueSelect, IfcMetricValueSelect
	{
	}
	/// <summary>
	/// TYPE IfcVectorOrDirection = SELECT
	/// <para>TYPE IfcVectorOrDirection = SELECT</para>
	/// <para>	(IfcDirection</para>
	/// <para>	,IfcVector);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcVectorOrDirection
	{
	}
	/// <summary>
	/// TYPE IfcWarpingStiffnessSelect = SELECT
	/// <para>TYPE IfcWarpingStiffnessSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcWarpingMomentMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcWarpingStiffnessSelect
	{
	}
	/// <summary>
	/// ENTITY IfcActionRequest
	/// <para>ENTITY IfcActionRequest</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcActionRequestTypeEnum;</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActionRequest : IfcControl
	{
		public IfcActionRequestTypeEnum? PredefinedType { get; set; }
		public IfcLabel? Status { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcActionRequest() : base()
		{
		}
		public IfcActionRequest(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcActionRequestTypeEnum PredefinedType, IfcLabel Status, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcActor
	/// <para>ENTITY IfcActor</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcOccupant))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para>	TheActor : IfcActorSelect;</para>
	/// <para> INVERSE</para>
	/// <para>	IsActingUpon : SET [0:?] OF IfcRelAssignsToActor FOR RelatingActor;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActor : IfcObject
	{
		public IfcActorSelect TheActor { get; set; }
		public IfcActor() : base()
		{
			TheActor = new IfcActorSelect();
		}
		public IfcActor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcActorSelect TheActor) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.TheActor = TheActor;
		}
	}
	/// <summary>
	/// ENTITY IfcActorRole;
	/// <para>ENTITY IfcActorRole;</para>
	/// <para>	Role : IfcRoleEnum;</para>
	/// <para>	UserDefinedRole : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : (Role <> IfcRoleEnum.USERDEFINED) OR</para>
	/// <para>((Role = IfcRoleEnum.USERDEFINED) AND</para>
	/// <para>  EXISTS(SELF.UserDefinedRole));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActorRoleENTITY, IfcResourceObjectSelect
	{
		public IfcRoleEnum Role { get; set; }
		public IfcLabel? UserDefinedRole { get; set; }
		public IfcText? Description { get; set; }
		public IfcActorRole() : base()
		{
			Role = new IfcRoleEnum();
		}
		public IfcActorRole(IfcRoleEnum Role, IfcLabel UserDefinedRole, IfcText Description) : base ()
		{
			this.Role = Role;
			this.UserDefinedRole = UserDefinedRole;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcActuator
	/// <para>ENTITY IfcActuator</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcActuatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcActuatorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcActuatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCACTUATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActuator : IfcDistributionControlElement
	{
		public IfcActuatorTypeEnum? PredefinedType { get; set; }
		public IfcActuator() : base()
		{
		}
		public IfcActuator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcActuatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcActuatorType
	/// <para>ENTITY IfcActuatorType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcActuatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcActuatorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcActuatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActuatorType : IfcDistributionControlElementType
	{
		public IfcActuatorTypeEnum PredefinedType { get; set; }
		public IfcActuatorType() : base()
		{
			PredefinedType = new IfcActuatorTypeEnum();
		}
		public IfcActuatorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcActuatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAddress
	/// <para>ENTITY IfcAddress</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcPostalAddress</para>
	/// <para>	,IfcTelecomAddress));</para>
	/// <para>	Purpose : OPTIONAL IfcAddressTypeEnum;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	UserDefinedPurpose : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	OfPerson : SET [0:?] OF IfcPerson FOR Addresses;</para>
	/// <para>	OfOrganization : SET [0:?] OF IfcOrganization FOR Addresses;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : (NOT(EXISTS(Purpose))) OR</para>
	/// <para>((Purpose <> IfcAddressTypeEnum.USERDEFINED) OR</para>
	/// <para>((Purpose = IfcAddressTypeEnum.USERDEFINED) AND</para>
	/// <para>  EXISTS(SELF.UserDefinedPurpose)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcAddressENTITY, IfcObjectReferenceSelect
	{
		public IfcAddressTypeEnum? Purpose { get; set; }
		public IfcText? Description { get; set; }
		public IfcLabel? UserDefinedPurpose { get; set; }
		public IfcAddress() : base()
		{
		}
		public IfcAddress(IfcAddressTypeEnum Purpose, IfcText Description, IfcLabel UserDefinedPurpose) : base ()
		{
			this.Purpose = Purpose;
			this.Description = Description;
			this.UserDefinedPurpose = UserDefinedPurpose;
		}
	}
	/// <summary>
	/// ENTITY IfcAdvancedBrep
	/// <para>ENTITY IfcAdvancedBrep</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAdvancedBrepWithVoids))</para>
	/// <para> SUBTYPE OF (IfcManifoldSolidBrep);</para>
	/// <para> WHERE</para>
	/// <para>	HasAdvancedFaces : SIZEOF(QUERY(Afs <* SELF\IfcManifoldSolidBrep.Outer.CfsFaces |</para>
	/// <para>  (NOT ('IFC4X3_ADD2.IFCADVANCEDFACE' IN TYPEOF(Afs)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAdvancedBrep : IfcManifoldSolidBrep
	{
		public IfcAdvancedBrep() : base()
		{
		}
		public IfcAdvancedBrep(IfcClosedShell Outer) : base (Outer)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAdvancedBrepWithVoids
	/// <para>ENTITY IfcAdvancedBrepWithVoids</para>
	/// <para> SUBTYPE OF (IfcAdvancedBrep);</para>
	/// <para>	Voids : SET [1:?] OF IfcClosedShell;</para>
	/// <para> WHERE</para>
	/// <para>	VoidsHaveAdvancedFaces : SIZEOF (QUERY (Vsh <* Voids |</para>
	/// <para>  SIZEOF (QUERY (Afs <* Vsh.CfsFaces |</para>
	/// <para>  (NOT ('IFC4X3_ADD2.IFCADVANCEDFACE' IN TYPEOF(Afs)))</para>
	/// <para>  )) = 0</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAdvancedBrepWithVoids : IfcAdvancedBrep
	{
		public List<IfcClosedShell> Voids { get; set; }
		public IfcAdvancedBrepWithVoids() : base()
		{
			Voids = new List<IfcClosedShell>();
		}
		public IfcAdvancedBrepWithVoids(IfcClosedShell Outer, List<IfcClosedShell> Voids) : base (Outer)
		{
			this.Voids = Voids;
		}
	}
	/// <summary>
	/// ENTITY IfcAdvancedFace
	/// <para>ENTITY IfcAdvancedFace</para>
	/// <para> SUBTYPE OF (IfcFaceSurface);</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableEdgeCurves : SIZEOF(QUERY (ElpFbnds <* </para>
	/// <para>  QUERY (Bnds <* SELF\IfcFace.Bounds |</para>
	/// <para>    'IFC4X3_ADD2.IFCEDGELOOP' IN TYPEOF(Bnds.Bound)) |</para>
	/// <para>     NOT (SIZEOF (QUERY (Oe <* ElpFbnds.Bound\IfcEdgeLoop.EdgeList |</para>
	/// <para>       NOT (SIZEOF (['IFC4X3_ADD2.IFCLINE',</para>
	/// <para>                     'IFC4X3_ADD2.IFCCONIC',</para>
	/// <para>                     'IFC4X3_ADD2.IFCPOLYLINE',</para>
	/// <para>                     'IFC4X3_ADD2.IFCBSPLINECURVE'] *</para>
	/// <para>         TYPEOF(Oe\IfcOrientedEdge.EdgeElement\IfcEdgeCurve.EdgeGeometry)) = 1 )</para>
	/// <para>  )) = 0</para>
	/// <para>))) = 0;</para>
	/// <para>	ApplicableSurface : SIZEOF (</para>
	/// <para>['IFC4X3_ADD2.IFCELEMENTARYSURFACE',</para>
	/// <para> 'IFC4X3_ADD2.IFCSWEPTSURFACE',</para>
	/// <para> 'IFC4X3_ADD2.IFCBSPLINESURFACE'] *</para>
	/// <para>TYPEOF(SELF\IfcFaceSurface.FaceSurface)) = 1;</para>
	/// <para>	RequiresEdgeCurve : SIZEOF(QUERY (ElpFbnds <* </para>
	/// <para>  QUERY (Bnds <* SELF\IfcFace.Bounds |</para>
	/// <para>    'IFC4X3_ADD2.IFCEDGELOOP' IN TYPEOF(Bnds.Bound)) |</para>
	/// <para>     NOT (SIZEOF (QUERY (Oe <* ElpFbnds.Bound\IfcEdgeLoop.EdgeList |</para>
	/// <para>       NOT('IFC4X3_ADD2.IFCEDGECURVE' IN </para>
	/// <para>       TYPEOF(Oe\IfcOrientedEdge.EdgeElement)</para>
	/// <para>  ))) = 0</para>
	/// <para>))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAdvancedFace : IfcFaceSurface
	{
		public IfcAdvancedFace() : base()
		{
		}
		public IfcAdvancedFace(List<IfcFaceBound> Bounds, IfcSurface FaceSurface, IfcBoolean SameSense) : base (Bounds, FaceSurface, SameSense)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminal
	/// <para>ENTITY IfcAirTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAirTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcAirTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAirTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCAIRTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminal : IfcFlowTerminal
	{
		public IfcAirTerminalTypeEnum? PredefinedType { get; set; }
		public IfcAirTerminal() : base()
		{
		}
		public IfcAirTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAirTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminalBox
	/// <para>ENTITY IfcAirTerminalBox</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAirTerminalBoxTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcAirTerminalBoxTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAirTerminalBoxTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCAIRTERMINALBOXTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminalBox : IfcFlowController
	{
		public IfcAirTerminalBoxTypeEnum? PredefinedType { get; set; }
		public IfcAirTerminalBox() : base()
		{
		}
		public IfcAirTerminalBox(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAirTerminalBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminalBoxType
	/// <para>ENTITY IfcAirTerminalBoxType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcAirTerminalBoxTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAirTerminalBoxTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAirTerminalBoxTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminalBoxType : IfcFlowControllerType
	{
		public IfcAirTerminalBoxTypeEnum PredefinedType { get; set; }
		public IfcAirTerminalBoxType() : base()
		{
			PredefinedType = new IfcAirTerminalBoxTypeEnum();
		}
		public IfcAirTerminalBoxType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAirTerminalBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminalType
	/// <para>ENTITY IfcAirTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcAirTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAirTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAirTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminalType : IfcFlowTerminalType
	{
		public IfcAirTerminalTypeEnum PredefinedType { get; set; }
		public IfcAirTerminalType() : base()
		{
			PredefinedType = new IfcAirTerminalTypeEnum();
		}
		public IfcAirTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAirTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirToAirHeatRecovery
	/// <para>ENTITY IfcAirToAirHeatRecovery</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAirToAirHeatRecoveryTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCAIRTOAIRHEATRECOVERYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirToAirHeatRecovery : IfcEnergyConversionDevice
	{
		public IfcAirToAirHeatRecoveryTypeEnum? PredefinedType { get; set; }
		public IfcAirToAirHeatRecovery() : base()
		{
		}
		public IfcAirToAirHeatRecovery(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAirToAirHeatRecoveryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirToAirHeatRecoveryType
	/// <para>ENTITY IfcAirToAirHeatRecoveryType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcAirToAirHeatRecoveryTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirToAirHeatRecoveryType : IfcEnergyConversionDeviceType
	{
		public IfcAirToAirHeatRecoveryTypeEnum PredefinedType { get; set; }
		public IfcAirToAirHeatRecoveryType() : base()
		{
			PredefinedType = new IfcAirToAirHeatRecoveryTypeEnum();
		}
		public IfcAirToAirHeatRecoveryType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAirToAirHeatRecoveryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlarm
	/// <para>ENTITY IfcAlarm</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAlarmTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcAlarmTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAlarmTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCALARMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlarm : IfcDistributionControlElement
	{
		public IfcAlarmTypeEnum? PredefinedType { get; set; }
		public IfcAlarm() : base()
		{
		}
		public IfcAlarm(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAlarmTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlarmType
	/// <para>ENTITY IfcAlarmType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcAlarmTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAlarmTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAlarmTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlarmType : IfcDistributionControlElementType
	{
		public IfcAlarmTypeEnum PredefinedType { get; set; }
		public IfcAlarmType() : base()
		{
			PredefinedType = new IfcAlarmTypeEnum();
		}
		public IfcAlarmType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAlarmTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignment
	/// <para>ENTITY IfcAlignment</para>
	/// <para> SUBTYPE OF (IfcLinearPositioningElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAlignmentTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignment : IfcLinearPositioningElement
	{
		public IfcAlignmentTypeEnum? PredefinedType { get; set; }
		public IfcAlignment() : base()
		{
		}
		public IfcAlignment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcAlignmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignmentCant
	/// <para>ENTITY IfcAlignmentCant</para>
	/// <para> SUBTYPE OF (IfcLinearElement);</para>
	/// <para>	RailHeadDistance : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignmentCant : IfcLinearElement
	{
		public IfcPositiveLengthMeasure RailHeadDistance { get; set; }
		public IfcAlignmentCant() : base()
		{
			RailHeadDistance = new IfcPositiveLengthMeasure();
		}
		public IfcAlignmentCant(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcPositiveLengthMeasure RailHeadDistance) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.RailHeadDistance = RailHeadDistance;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignmentCantSegment
	/// <para>ENTITY IfcAlignmentCantSegment</para>
	/// <para> SUBTYPE OF (IfcAlignmentParameterSegment);</para>
	/// <para>	StartDistAlong : IfcLengthMeasure;</para>
	/// <para>	HorizontalLength : IfcNonNegativeLengthMeasure;</para>
	/// <para>	StartCantLeft : IfcLengthMeasure;</para>
	/// <para>	EndCantLeft : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	StartCantRight : IfcLengthMeasure;</para>
	/// <para>	EndCantRight : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	PredefinedType : IfcAlignmentCantSegmentTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignmentCantSegment : IfcAlignmentParameterSegment
	{
		public IfcLengthMeasure StartDistAlong { get; set; }
		public IfcNonNegativeLengthMeasure HorizontalLength { get; set; }
		public IfcLengthMeasure StartCantLeft { get; set; }
		public IfcLengthMeasure? EndCantLeft { get; set; }
		public IfcLengthMeasure StartCantRight { get; set; }
		public IfcLengthMeasure? EndCantRight { get; set; }
		public IfcAlignmentCantSegmentTypeEnum PredefinedType { get; set; }
		public IfcAlignmentCantSegment() : base()
		{
			StartDistAlong = new IfcLengthMeasure();
			HorizontalLength = new IfcNonNegativeLengthMeasure();
			StartCantLeft = new IfcLengthMeasure();
			StartCantRight = new IfcLengthMeasure();
			PredefinedType = new IfcAlignmentCantSegmentTypeEnum();
		}
		public IfcAlignmentCantSegment(IfcLabel StartTag, IfcLabel EndTag, IfcLengthMeasure StartDistAlong, IfcNonNegativeLengthMeasure HorizontalLength, IfcLengthMeasure StartCantLeft, IfcLengthMeasure EndCantLeft, IfcLengthMeasure StartCantRight, IfcLengthMeasure EndCantRight, IfcAlignmentCantSegmentTypeEnum PredefinedType) : base (StartTag, EndTag)
		{
			this.StartDistAlong = StartDistAlong;
			this.HorizontalLength = HorizontalLength;
			this.StartCantLeft = StartCantLeft;
			this.EndCantLeft = EndCantLeft;
			this.StartCantRight = StartCantRight;
			this.EndCantRight = EndCantRight;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignmentHorizontal
	/// <para>ENTITY IfcAlignmentHorizontal</para>
	/// <para> SUBTYPE OF (IfcLinearElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignmentHorizontal : IfcLinearElement
	{
		public IfcAlignmentHorizontal() : base()
		{
		}
		public IfcAlignmentHorizontal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAlignmentHorizontalSegment
	/// <para>ENTITY IfcAlignmentHorizontalSegment</para>
	/// <para> SUBTYPE OF (IfcAlignmentParameterSegment);</para>
	/// <para>	StartPoint : IfcCartesianPoint;</para>
	/// <para>	StartDirection : IfcPlaneAngleMeasure;</para>
	/// <para>	StartRadiusOfCurvature : IfcLengthMeasure;</para>
	/// <para>	EndRadiusOfCurvature : IfcLengthMeasure;</para>
	/// <para>	SegmentLength : IfcNonNegativeLengthMeasure;</para>
	/// <para>	GravityCenterLineHeight : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : IfcAlignmentHorizontalSegmentTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignmentHorizontalSegment : IfcAlignmentParameterSegment
	{
		public IfcCartesianPoint StartPoint { get; set; }
		public IfcPlaneAngleMeasure StartDirection { get; set; }
		public IfcLengthMeasure StartRadiusOfCurvature { get; set; }
		public IfcLengthMeasure EndRadiusOfCurvature { get; set; }
		public IfcNonNegativeLengthMeasure SegmentLength { get; set; }
		public IfcPositiveLengthMeasure? GravityCenterLineHeight { get; set; }
		public IfcAlignmentHorizontalSegmentTypeEnum PredefinedType { get; set; }
		public IfcAlignmentHorizontalSegment() : base()
		{
			StartPoint = new IfcCartesianPoint();
			StartDirection = new IfcPlaneAngleMeasure();
			StartRadiusOfCurvature = new IfcLengthMeasure();
			EndRadiusOfCurvature = new IfcLengthMeasure();
			SegmentLength = new IfcNonNegativeLengthMeasure();
			PredefinedType = new IfcAlignmentHorizontalSegmentTypeEnum();
		}
		public IfcAlignmentHorizontalSegment(IfcLabel StartTag, IfcLabel EndTag, IfcCartesianPoint StartPoint, IfcPlaneAngleMeasure StartDirection, IfcLengthMeasure StartRadiusOfCurvature, IfcLengthMeasure EndRadiusOfCurvature, IfcNonNegativeLengthMeasure SegmentLength, IfcPositiveLengthMeasure GravityCenterLineHeight, IfcAlignmentHorizontalSegmentTypeEnum PredefinedType) : base (StartTag, EndTag)
		{
			this.StartPoint = StartPoint;
			this.StartDirection = StartDirection;
			this.StartRadiusOfCurvature = StartRadiusOfCurvature;
			this.EndRadiusOfCurvature = EndRadiusOfCurvature;
			this.SegmentLength = SegmentLength;
			this.GravityCenterLineHeight = GravityCenterLineHeight;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignmentParameterSegment
	/// <para>ENTITY IfcAlignmentParameterSegment</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAlignmentCantSegment</para>
	/// <para>	,IfcAlignmentHorizontalSegment</para>
	/// <para>	,IfcAlignmentVerticalSegment));</para>
	/// <para>	StartTag : OPTIONAL IfcLabel;</para>
	/// <para>	EndTag : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcAlignmentParameterSegmentENTITY
	{
		public IfcLabel? StartTag { get; set; }
		public IfcLabel? EndTag { get; set; }
		public IfcAlignmentParameterSegment() : base()
		{
		}
		public IfcAlignmentParameterSegment(IfcLabel StartTag, IfcLabel EndTag) : base ()
		{
			this.StartTag = StartTag;
			this.EndTag = EndTag;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignmentSegment
	/// <para>ENTITY IfcAlignmentSegment</para>
	/// <para> SUBTYPE OF (IfcLinearElement);</para>
	/// <para>	DesignParameters : IfcAlignmentParameterSegment;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignmentSegment : IfcLinearElement
	{
		public IfcAlignmentParameterSegment DesignParameters { get; set; }
		public IfcAlignmentSegment() : base()
		{
			DesignParameters = new IfcAlignmentParameterSegment();
		}
		public IfcAlignmentSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcAlignmentParameterSegment DesignParameters) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.DesignParameters = DesignParameters;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignmentVertical
	/// <para>ENTITY IfcAlignmentVertical</para>
	/// <para> SUBTYPE OF (IfcLinearElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignmentVertical : IfcLinearElement
	{
		public IfcAlignmentVertical() : base()
		{
		}
		public IfcAlignmentVertical(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAlignmentVerticalSegment
	/// <para>ENTITY IfcAlignmentVerticalSegment</para>
	/// <para> SUBTYPE OF (IfcAlignmentParameterSegment);</para>
	/// <para>	StartDistAlong : IfcLengthMeasure;</para>
	/// <para>	HorizontalLength : IfcNonNegativeLengthMeasure;</para>
	/// <para>	StartHeight : IfcLengthMeasure;</para>
	/// <para>	StartGradient : IfcRatioMeasure;</para>
	/// <para>	EndGradient : IfcRatioMeasure;</para>
	/// <para>	RadiusOfCurvature : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	PredefinedType : IfcAlignmentVerticalSegmentTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignmentVerticalSegment : IfcAlignmentParameterSegment
	{
		public IfcLengthMeasure StartDistAlong { get; set; }
		public IfcNonNegativeLengthMeasure HorizontalLength { get; set; }
		public IfcLengthMeasure StartHeight { get; set; }
		public IfcRatioMeasure StartGradient { get; set; }
		public IfcRatioMeasure EndGradient { get; set; }
		public IfcLengthMeasure? RadiusOfCurvature { get; set; }
		public IfcAlignmentVerticalSegmentTypeEnum PredefinedType { get; set; }
		public IfcAlignmentVerticalSegment() : base()
		{
			StartDistAlong = new IfcLengthMeasure();
			HorizontalLength = new IfcNonNegativeLengthMeasure();
			StartHeight = new IfcLengthMeasure();
			StartGradient = new IfcRatioMeasure();
			EndGradient = new IfcRatioMeasure();
			PredefinedType = new IfcAlignmentVerticalSegmentTypeEnum();
		}
		public IfcAlignmentVerticalSegment(IfcLabel StartTag, IfcLabel EndTag, IfcLengthMeasure StartDistAlong, IfcNonNegativeLengthMeasure HorizontalLength, IfcLengthMeasure StartHeight, IfcRatioMeasure StartGradient, IfcRatioMeasure EndGradient, IfcLengthMeasure RadiusOfCurvature, IfcAlignmentVerticalSegmentTypeEnum PredefinedType) : base (StartTag, EndTag)
		{
			this.StartDistAlong = StartDistAlong;
			this.HorizontalLength = HorizontalLength;
			this.StartHeight = StartHeight;
			this.StartGradient = StartGradient;
			this.EndGradient = EndGradient;
			this.RadiusOfCurvature = RadiusOfCurvature;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAnnotation
	/// <para>ENTITY IfcAnnotation</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAnnotationTypeEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	ContainedInStructure : SET [0:1] OF IfcRelContainedInSpatialStructure FOR RelatedElements;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAnnotation : IfcProduct
	{
		public IfcAnnotationTypeEnum? PredefinedType { get; set; }
		public IfcAnnotation() : base()
		{
		}
		public IfcAnnotation(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcAnnotationTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAnnotationFillArea
	/// <para>ENTITY IfcAnnotationFillArea</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	OuterBoundary : IfcCurve;</para>
	/// <para>	InnerBoundaries : OPTIONAL SET [1:?] OF IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAnnotationFillArea : IfcGeometricRepresentationItem
	{
		public IfcCurve OuterBoundary { get; set; }
		public List<IfcCurve>? InnerBoundaries { get; set; }
		public IfcAnnotationFillArea() : base()
		{
			OuterBoundary = new IfcCurve();
		}
		public IfcAnnotationFillArea(IfcCurve OuterBoundary, List<IfcCurve> InnerBoundaries) : base ()
		{
			this.OuterBoundary = OuterBoundary;
			this.InnerBoundaries = InnerBoundaries;
		}
	}
	/// <summary>
	/// ENTITY IfcApplication;
	/// <para>ENTITY IfcApplication;</para>
	/// <para>	ApplicationDeveloper : IfcOrganization;</para>
	/// <para>	Version : IfcLabel;</para>
	/// <para>	ApplicationFullName : IfcLabel;</para>
	/// <para>	ApplicationIdentifier : IfcIdentifier;</para>
	/// <para> UNIQUE</para>
	/// <para>	UR1 : ApplicationIdentifier;</para>
	/// <para>	UR2 : ApplicationFullName, Version;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcApplicationENTITY
	{
		public IfcOrganization ApplicationDeveloper { get; set; }
		public IfcLabel Version { get; set; }
		public IfcLabel ApplicationFullName { get; set; }
		public IfcIdentifier ApplicationIdentifier { get; set; }
		public IfcApplication() : base()
		{
			ApplicationDeveloper = new IfcOrganization();
			Version = new IfcLabel();
			ApplicationFullName = new IfcLabel();
			ApplicationIdentifier = new IfcIdentifier();
		}
		public IfcApplication(IfcOrganization ApplicationDeveloper, IfcLabel Version, IfcLabel ApplicationFullName, IfcIdentifier ApplicationIdentifier) : base ()
		{
			this.ApplicationDeveloper = ApplicationDeveloper;
			this.Version = Version;
			this.ApplicationFullName = ApplicationFullName;
			this.ApplicationIdentifier = ApplicationIdentifier;
		}
	}
	/// <summary>
	/// ENTITY IfcAppliedValue
	/// <para>ENTITY IfcAppliedValue</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCostValue));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	AppliedValue : OPTIONAL IfcAppliedValueSelect;</para>
	/// <para>	UnitBasis : OPTIONAL IfcMeasureWithUnit;</para>
	/// <para>	ApplicableDate : OPTIONAL IfcDate;</para>
	/// <para>	FixedUntilDate : OPTIONAL IfcDate;</para>
	/// <para>	Category : OPTIONAL IfcLabel;</para>
	/// <para>	Condition : OPTIONAL IfcLabel;</para>
	/// <para>	ArithmeticOperator : OPTIONAL IfcArithmeticOperatorEnum;</para>
	/// <para>	Components : OPTIONAL LIST [1:?] OF IfcAppliedValue;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAppliedValueENTITY, IfcMetricValueSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcAppliedValueSelect? AppliedValue { get; set; }
		public IfcMeasureWithUnit? UnitBasis { get; set; }
		public IfcDate? ApplicableDate { get; set; }
		public IfcDate? FixedUntilDate { get; set; }
		public IfcLabel? Category { get; set; }
		public IfcLabel? Condition { get; set; }
		public IfcArithmeticOperatorEnum? ArithmeticOperator { get; set; }
		public List<IfcAppliedValue>? Components { get; set; }
		public IfcAppliedValue() : base()
		{
		}
		public IfcAppliedValue(IfcLabel Name, IfcText Description, IfcAppliedValueSelect AppliedValue, IfcMeasureWithUnit UnitBasis, IfcDate ApplicableDate, IfcDate FixedUntilDate, IfcLabel Category, IfcLabel Condition, IfcArithmeticOperatorEnum ArithmeticOperator, List<IfcAppliedValue> Components) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.AppliedValue = AppliedValue;
			this.UnitBasis = UnitBasis;
			this.ApplicableDate = ApplicableDate;
			this.FixedUntilDate = FixedUntilDate;
			this.Category = Category;
			this.Condition = Condition;
			this.ArithmeticOperator = ArithmeticOperator;
			this.Components = Components;
		}
	}
	/// <summary>
	/// ENTITY IfcApproval;
	/// <para>ENTITY IfcApproval;</para>
	/// <para>	Identifier : OPTIONAL IfcIdentifier;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	TimeOfApproval : OPTIONAL IfcDateTime;</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	Level : OPTIONAL IfcLabel;</para>
	/// <para>	Qualifier : OPTIONAL IfcText;</para>
	/// <para>	RequestingApproval : OPTIONAL IfcActorSelect;</para>
	/// <para>	GivingApproval : OPTIONAL IfcActorSelect;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>	ApprovedObjects : SET [0:?] OF IfcRelAssociatesApproval FOR RelatingApproval;</para>
	/// <para>	ApprovedResources : SET [0:?] OF IfcResourceApprovalRelationship FOR RelatingApproval;</para>
	/// <para>	IsRelatedWith : SET [0:?] OF IfcApprovalRelationship FOR RelatedApprovals;</para>
	/// <para>	Relates : SET [0:?] OF IfcApprovalRelationship FOR RelatingApproval;</para>
	/// <para> WHERE</para>
	/// <para>	HasIdentifierOrName : EXISTS (Identifier) OR EXISTS (Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcApprovalENTITY, IfcResourceObjectSelect
	{
		public IfcIdentifier? Identifier { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcDateTime? TimeOfApproval { get; set; }
		public IfcLabel? Status { get; set; }
		public IfcLabel? Level { get; set; }
		public IfcText? Qualifier { get; set; }
		public IfcActorSelect? RequestingApproval { get; set; }
		public IfcActorSelect? GivingApproval { get; set; }
		public IfcApproval() : base()
		{
		}
		public IfcApproval(IfcIdentifier Identifier, IfcLabel Name, IfcText Description, IfcDateTime TimeOfApproval, IfcLabel Status, IfcLabel Level, IfcText Qualifier, IfcActorSelect RequestingApproval, IfcActorSelect GivingApproval) : base ()
		{
			this.Identifier = Identifier;
			this.Name = Name;
			this.Description = Description;
			this.TimeOfApproval = TimeOfApproval;
			this.Status = Status;
			this.Level = Level;
			this.Qualifier = Qualifier;
			this.RequestingApproval = RequestingApproval;
			this.GivingApproval = GivingApproval;
		}
	}
	/// <summary>
	/// ENTITY IfcApprovalRelationship
	/// <para>ENTITY IfcApprovalRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingApproval : IfcApproval;</para>
	/// <para>	RelatedApprovals : SET [1:?] OF IfcApproval;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcApprovalRelationship : IfcResourceLevelRelationship
	{
		public IfcApproval RelatingApproval { get; set; }
		public List<IfcApproval> RelatedApprovals { get; set; }
		public IfcApprovalRelationship() : base()
		{
			RelatingApproval = new IfcApproval();
			RelatedApprovals = new List<IfcApproval>();
		}
		public IfcApprovalRelationship(IfcLabel Name, IfcText Description, IfcApproval RelatingApproval, List<IfcApproval> RelatedApprovals) : base (Name, Description)
		{
			this.RelatingApproval = RelatingApproval;
			this.RelatedApprovals = RelatedApprovals;
		}
	}
	/// <summary>
	/// ENTITY IfcArbitraryClosedProfileDef
	/// <para>ENTITY IfcArbitraryClosedProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcArbitraryProfileDefWithVoids))</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	OuterCurve : IfcCurve;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : OuterCurve.Dim = 2;</para>
	/// <para>	WR2 : NOT('IFC4X3_ADD2.IFCLINE' IN TYPEOF(OuterCurve));</para>
	/// <para>	WR3 : NOT('IFC4X3_ADD2.IFCOFFSETCURVE2D' IN TYPEOF(OuterCurve));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcArbitraryClosedProfileDef : IfcProfileDef
	{
		public IfcCurve OuterCurve { get; set; }
		public IfcArbitraryClosedProfileDef() : base()
		{
			OuterCurve = new IfcCurve();
		}
		public IfcArbitraryClosedProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcCurve OuterCurve) : base (ProfileType, ProfileName)
		{
			this.OuterCurve = OuterCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcArbitraryOpenProfileDef
	/// <para>ENTITY IfcArbitraryOpenProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCenterLineProfileDef))</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	Curve : IfcBoundedCurve;</para>
	/// <para> WHERE</para>
	/// <para>	WR11 : ('IFC4X3_ADD2.IFCCENTERLINEPROFILEDEF' IN TYPEOF(SELF)) OR </para>
	/// <para> (SELF\IfcProfileDef.ProfileType = IfcProfileTypeEnum.CURVE);</para>
	/// <para>	WR12 : Curve.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcArbitraryOpenProfileDef : IfcProfileDef
	{
		public IfcBoundedCurve Curve { get; set; }
		public IfcArbitraryOpenProfileDef() : base()
		{
			Curve = new IfcBoundedCurve();
		}
		public IfcArbitraryOpenProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcBoundedCurve Curve) : base (ProfileType, ProfileName)
		{
			this.Curve = Curve;
		}
	}
	/// <summary>
	/// ENTITY IfcArbitraryProfileDefWithVoids
	/// <para>ENTITY IfcArbitraryProfileDefWithVoids</para>
	/// <para> SUBTYPE OF (IfcArbitraryClosedProfileDef);</para>
	/// <para>	InnerCurves : SET [1:?] OF IfcCurve;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF\IfcProfileDef.ProfileType = AREA;</para>
	/// <para>	WR2 : SIZEOF(QUERY(temp <* InnerCurves | temp.Dim <> 2)) = 0;</para>
	/// <para>	WR3 : SIZEOF(QUERY(temp <* InnerCurves | 'IFC4X3_ADD2.IFCLINE' IN TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcArbitraryProfileDefWithVoids : IfcArbitraryClosedProfileDef
	{
		public List<IfcCurve> InnerCurves { get; set; }
		public IfcArbitraryProfileDefWithVoids() : base()
		{
			InnerCurves = new List<IfcCurve>();
		}
		public IfcArbitraryProfileDefWithVoids(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcCurve OuterCurve, List<IfcCurve> InnerCurves) : base (ProfileType, ProfileName, OuterCurve)
		{
			this.InnerCurves = InnerCurves;
		}
	}
	/// <summary>
	/// ENTITY IfcAsset
	/// <para>ENTITY IfcAsset</para>
	/// <para> SUBTYPE OF (IfcGroup);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	OriginalValue : OPTIONAL IfcCostValue;</para>
	/// <para>	CurrentValue : OPTIONAL IfcCostValue;</para>
	/// <para>	TotalReplacementCost : OPTIONAL IfcCostValue;</para>
	/// <para>	Owner : OPTIONAL IfcActorSelect;</para>
	/// <para>	User : OPTIONAL IfcActorSelect;</para>
	/// <para>	ResponsiblePerson : OPTIONAL IfcPerson;</para>
	/// <para>	IncorporationDate : OPTIONAL IfcDate;</para>
	/// <para>	DepreciatedValue : OPTIONAL IfcCostValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAsset : IfcGroup
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcCostValue? OriginalValue { get; set; }
		public IfcCostValue? CurrentValue { get; set; }
		public IfcCostValue? TotalReplacementCost { get; set; }
		public IfcActorSelect? Owner { get; set; }
		public IfcActorSelect? User { get; set; }
		public IfcPerson? ResponsiblePerson { get; set; }
		public IfcDate? IncorporationDate { get; set; }
		public IfcCostValue? DepreciatedValue { get; set; }
		public IfcAsset() : base()
		{
		}
		public IfcAsset(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcCostValue OriginalValue, IfcCostValue CurrentValue, IfcCostValue TotalReplacementCost, IfcActorSelect Owner, IfcActorSelect User, IfcPerson ResponsiblePerson, IfcDate IncorporationDate, IfcCostValue DepreciatedValue) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
			this.OriginalValue = OriginalValue;
			this.CurrentValue = CurrentValue;
			this.TotalReplacementCost = TotalReplacementCost;
			this.Owner = Owner;
			this.User = User;
			this.ResponsiblePerson = ResponsiblePerson;
			this.IncorporationDate = IncorporationDate;
			this.DepreciatedValue = DepreciatedValue;
		}
	}
	/// <summary>
	/// ENTITY IfcAsymmetricIShapeProfileDef
	/// <para>ENTITY IfcAsymmetricIShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	BottomFlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	OverallDepth : IfcPositiveLengthMeasure;</para>
	/// <para>	WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	BottomFlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	BottomFlangeFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	TopFlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	TopFlangeThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TopFlangeFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	BottomFlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	BottomFlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>	TopFlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	TopFlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidBottomFilletRadius : (NOT(EXISTS(BottomFlangeFilletRadius))) OR </para>
	/// <para>(BottomFlangeFilletRadius <= (BottomFlangeWidth - WebThickness)/2.);</para>
	/// <para>	ValidFlangeThickness : NOT(EXISTS(TopFlangeThickness)) OR ((BottomFlangeThickness + TopFlangeThickness) < OverallDepth);</para>
	/// <para>	ValidTopFilletRadius : (NOT(EXISTS(TopFlangeFilletRadius))) OR </para>
	/// <para>(TopFlangeFilletRadius <= (TopFlangeWidth - WebThickness)/2.);</para>
	/// <para>	ValidWebThickness : (WebThickness < BottomFlangeWidth) AND (WebThickness < TopFlangeWidth);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAsymmetricIShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure BottomFlangeWidth { get; set; }
		public IfcPositiveLengthMeasure OverallDepth { get; set; }
		public IfcPositiveLengthMeasure WebThickness { get; set; }
		public IfcPositiveLengthMeasure BottomFlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? BottomFlangeFilletRadius { get; set; }
		public IfcPositiveLengthMeasure TopFlangeWidth { get; set; }
		public IfcPositiveLengthMeasure? TopFlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? TopFlangeFilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? BottomFlangeEdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? BottomFlangeSlope { get; set; }
		public IfcNonNegativeLengthMeasure? TopFlangeEdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? TopFlangeSlope { get; set; }
		public IfcAsymmetricIShapeProfileDef() : base()
		{
			BottomFlangeWidth = new IfcPositiveLengthMeasure();
			OverallDepth = new IfcPositiveLengthMeasure();
			WebThickness = new IfcPositiveLengthMeasure();
			BottomFlangeThickness = new IfcPositiveLengthMeasure();
			TopFlangeWidth = new IfcPositiveLengthMeasure();
		}
		public IfcAsymmetricIShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure BottomFlangeWidth, IfcPositiveLengthMeasure OverallDepth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure BottomFlangeThickness, IfcNonNegativeLengthMeasure BottomFlangeFilletRadius, IfcPositiveLengthMeasure TopFlangeWidth, IfcPositiveLengthMeasure TopFlangeThickness, IfcNonNegativeLengthMeasure TopFlangeFilletRadius, IfcNonNegativeLengthMeasure BottomFlangeEdgeRadius, IfcPlaneAngleMeasure BottomFlangeSlope, IfcNonNegativeLengthMeasure TopFlangeEdgeRadius, IfcPlaneAngleMeasure TopFlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.BottomFlangeWidth = BottomFlangeWidth;
			this.OverallDepth = OverallDepth;
			this.WebThickness = WebThickness;
			this.BottomFlangeThickness = BottomFlangeThickness;
			this.BottomFlangeFilletRadius = BottomFlangeFilletRadius;
			this.TopFlangeWidth = TopFlangeWidth;
			this.TopFlangeThickness = TopFlangeThickness;
			this.TopFlangeFilletRadius = TopFlangeFilletRadius;
			this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius;
			this.BottomFlangeSlope = BottomFlangeSlope;
			this.TopFlangeEdgeRadius = TopFlangeEdgeRadius;
			this.TopFlangeSlope = TopFlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcAudioVisualAppliance
	/// <para>ENTITY IfcAudioVisualAppliance</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAudioVisualApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcAudioVisualApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAudioVisualApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCAUDIOVISUALAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAudioVisualAppliance : IfcFlowTerminal
	{
		public IfcAudioVisualApplianceTypeEnum? PredefinedType { get; set; }
		public IfcAudioVisualAppliance() : base()
		{
		}
		public IfcAudioVisualAppliance(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAudioVisualApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAudioVisualApplianceType
	/// <para>ENTITY IfcAudioVisualApplianceType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcAudioVisualApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAudioVisualApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAudioVisualApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAudioVisualApplianceType : IfcFlowTerminalType
	{
		public IfcAudioVisualApplianceTypeEnum PredefinedType { get; set; }
		public IfcAudioVisualApplianceType() : base()
		{
			PredefinedType = new IfcAudioVisualApplianceTypeEnum();
		}
		public IfcAudioVisualApplianceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAudioVisualApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAxis1Placement
	/// <para>ENTITY IfcAxis1Placement</para>
	/// <para> SUBTYPE OF (IfcPlacement);</para>
	/// <para>	Axis : OPTIONAL IfcDirection;</para>
	/// <para> DERIVE</para>
	/// <para>	 Z : IfcDirection := NVL (IfcNormalise(Axis), IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([0.0,0.0,1.0]));</para>
	/// <para> WHERE</para>
	/// <para>	AxisIs3D : (NOT (EXISTS (Axis))) OR (Axis.Dim = 3);</para>
	/// <para>	LocationIs3D : SELF\IfcPlacement.Location.Dim = 3;</para>
	/// <para>	LocationIsCP : 'IFC4X3_ADD2.IFCCARTESIANPOINT' IN TYPEOF(SELF\IfcPlacement.Location);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAxis1Placement : IfcPlacement
	{
		public IfcDirection? Axis { get; set; }
		public IfcAxis1Placement() : base()
		{
		}
		public IfcAxis1Placement(IfcPoint Location, IfcDirection Axis) : base (Location)
		{
			this.Axis = Axis;
		}
	}
	/// <summary>
	/// ENTITY IfcAxis2Placement2D
	/// <para>ENTITY IfcAxis2Placement2D</para>
	/// <para> SUBTYPE OF (IfcPlacement);</para>
	/// <para>	RefDirection : OPTIONAL IfcDirection;</para>
	/// <para> DERIVE</para>
	/// <para>	 P : LIST [2:2] OF IfcDirection := IfcBuild2Axes(RefDirection);</para>
	/// <para> WHERE</para>
	/// <para>	LocationIs2D : SELF\IfcPlacement.Location.Dim = 2;</para>
	/// <para>	LocationIsCP : 'IFC4X3_ADD2.IFCCARTESIANPOINT' IN TYPEOF(SELF\IfcPlacement.Location);</para>
	/// <para>	RefDirIs2D : (NOT (EXISTS (RefDirection))) OR (RefDirection.Dim = 2);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAxis2Placement2D : IfcPlacement, IfcAxis2Placement
	{
		public IfcDirection? RefDirection { get; set; }
		public IfcAxis2Placement2D() : base()
		{
		}
		public IfcAxis2Placement2D(IfcPoint Location, IfcDirection RefDirection) : base (Location)
		{
			this.RefDirection = RefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcAxis2Placement3D
	/// <para>ENTITY IfcAxis2Placement3D</para>
	/// <para> SUBTYPE OF (IfcPlacement);</para>
	/// <para>	Axis : OPTIONAL IfcDirection;</para>
	/// <para>	RefDirection : OPTIONAL IfcDirection;</para>
	/// <para> DERIVE</para>
	/// <para>	 P : LIST [3:3] OF IfcDirection := IfcBuildAxes(Axis, RefDirection);</para>
	/// <para> WHERE</para>
	/// <para>	AxisAndRefDirProvision : NOT ((EXISTS (Axis)) XOR (EXISTS (RefDirection)));</para>
	/// <para>	AxisIs3D : (NOT (EXISTS (Axis))) OR (Axis.Dim = 3);</para>
	/// <para>	AxisToRefDirPosition : (NOT (EXISTS (Axis))) OR (NOT (EXISTS (RefDirection))) OR (IfcCrossProduct(Axis,RefDirection).Magnitude > 0.0);</para>
	/// <para>	LocationIs3D : SELF\IfcPlacement.Location.Dim = 3;</para>
	/// <para>	LocationIsCP : 'IFC4X3_ADD2.IFCCARTESIANPOINT' IN TYPEOF(SELF\IfcPlacement.Location);</para>
	/// <para>	RefDirIs3D : (NOT (EXISTS (RefDirection))) OR (RefDirection.Dim = 3);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAxis2Placement3D : IfcPlacement, IfcAxis2Placement
	{
		public IfcDirection? Axis { get; set; }
		public IfcDirection? RefDirection { get; set; }
		public IfcAxis2Placement3D() : base()
		{
		}
		public IfcAxis2Placement3D(IfcPoint Location, IfcDirection Axis, IfcDirection RefDirection) : base (Location)
		{
			this.Axis = Axis;
			this.RefDirection = RefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcAxis2PlacementLinear
	/// <para>ENTITY IfcAxis2PlacementLinear</para>
	/// <para> SUBTYPE OF (IfcPlacement);</para>
	/// <para>	Axis : OPTIONAL IfcDirection;</para>
	/// <para>	RefDirection : OPTIONAL IfcDirection;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : 'IFC4X3_ADD2.IFCPOINTBYDISTANCEEXPRESSION' IN TYPEOF(SELF\IfcPlacement.Location);</para>
	/// <para>	WR2 : (NOT (EXISTS (Axis))) OR (NOT (EXISTS (RefDirection))) OR (IfcCrossProduct(Axis,RefDirection).Magnitude > 0.0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAxis2PlacementLinear : IfcPlacement
	{
		public IfcDirection? Axis { get; set; }
		public IfcDirection? RefDirection { get; set; }
		public IfcAxis2PlacementLinear() : base()
		{
		}
		public IfcAxis2PlacementLinear(IfcPoint Location, IfcDirection Axis, IfcDirection RefDirection) : base (Location)
		{
			this.Axis = Axis;
			this.RefDirection = RefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineCurve
	/// <para>ENTITY IfcBSplineCurve</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBSplineCurveWithKnots))</para>
	/// <para> SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>	Degree : IfcInteger;</para>
	/// <para>	ControlPointsList : LIST [2:?] OF IfcCartesianPoint;</para>
	/// <para>	CurveForm : IfcBSplineCurveForm;</para>
	/// <para>	ClosedCurve : IfcLogical;</para>
	/// <para>	SelfIntersect : IfcLogical;</para>
	/// <para> DERIVE</para>
	/// <para>	 UpperIndexOnControlPoints : IfcInteger := (SIZEOF(ControlPointsList) - 1);</para>
	/// <para>	 ControlPoints : ARRAY [0:UpperIndexOnControlPoints] OF IfcCartesianPoint := IfcListToArray(ControlPointsList,0,UpperIndexOnControlPoints);</para>
	/// <para> WHERE</para>
	/// <para>	SameDim : SIZEOF(QUERY(Temp <* ControlPointsList |</para>
	/// <para>  Temp.Dim <> ControlPointsList[1].Dim))</para>
	/// <para>= 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBSplineCurve : IfcBoundedCurve
	{
		public IfcInteger Degree { get; set; }
		public List<IfcCartesianPoint> ControlPointsList { get; set; }
		public IfcBSplineCurveForm CurveForm { get; set; }
		public IfcLogical ClosedCurve { get; set; }
		public IfcLogical SelfIntersect { get; set; }
		public IfcBSplineCurve() : base()
		{
			Degree = new IfcInteger();
			ControlPointsList = new List<IfcCartesianPoint>();
			CurveForm = new IfcBSplineCurveForm();
			ClosedCurve = new IfcLogical();
			SelfIntersect = new IfcLogical();
		}
		public IfcBSplineCurve(IfcInteger Degree, List<IfcCartesianPoint> ControlPointsList, IfcBSplineCurveForm CurveForm, IfcLogical ClosedCurve, IfcLogical SelfIntersect) : base ()
		{
			this.Degree = Degree;
			this.ControlPointsList = ControlPointsList;
			this.CurveForm = CurveForm;
			this.ClosedCurve = ClosedCurve;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineCurveWithKnots
	/// <para>ENTITY IfcBSplineCurveWithKnots</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRationalBSplineCurveWithKnots))</para>
	/// <para> SUBTYPE OF (IfcBSplineCurve);</para>
	/// <para>	KnotMultiplicities : LIST [2:?] OF IfcInteger;</para>
	/// <para>	Knots : LIST [2:?] OF IfcParameterValue;</para>
	/// <para>	KnotSpec : IfcKnotType;</para>
	/// <para> DERIVE</para>
	/// <para>	 UpperIndexOnKnots : IfcInteger := SIZEOF(Knots);</para>
	/// <para> WHERE</para>
	/// <para>	ConsistentBSpline : IfcConstraintsParamBSpline(Degree, UpperIndexOnKnots,</para>
	/// <para>UpperIndexOnControlPoints, KnotMultiplicities, Knots);</para>
	/// <para>	CorrespondingKnotLists : SIZEOF(KnotMultiplicities) = UpperIndexOnKnots;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBSplineCurveWithKnots : IfcBSplineCurve
	{
		public List<IfcInteger> KnotMultiplicities { get; set; }
		public List<IfcParameterValue> Knots { get; set; }
		public IfcKnotType KnotSpec { get; set; }
		public IfcBSplineCurveWithKnots() : base()
		{
			KnotMultiplicities = new List<IfcInteger>();
			Knots = new List<IfcParameterValue>();
			KnotSpec = new IfcKnotType();
		}
		public IfcBSplineCurveWithKnots(IfcInteger Degree, List<IfcCartesianPoint> ControlPointsList, IfcBSplineCurveForm CurveForm, IfcLogical ClosedCurve, IfcLogical SelfIntersect, List<IfcInteger> KnotMultiplicities, List<IfcParameterValue> Knots, IfcKnotType KnotSpec) : base (Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect)
		{
			this.KnotMultiplicities = KnotMultiplicities;
			this.Knots = Knots;
			this.KnotSpec = KnotSpec;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineSurface
	/// <para>ENTITY IfcBSplineSurface</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBSplineSurfaceWithKnots))</para>
	/// <para> SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>	UDegree : IfcInteger;</para>
	/// <para>	VDegree : IfcInteger;</para>
	/// <para>	ControlPointsList : LIST [2:?] OF LIST [2:?] OF IfcCartesianPoint;</para>
	/// <para>	SurfaceForm : IfcBSplineSurfaceForm;</para>
	/// <para>	UClosed : IfcLogical;</para>
	/// <para>	VClosed : IfcLogical;</para>
	/// <para>	SelfIntersect : IfcLogical;</para>
	/// <para> DERIVE</para>
	/// <para>	 UUpper : IfcInteger := SIZEOF(ControlPointsList) - 1;</para>
	/// <para>	 VUpper : IfcInteger := SIZEOF(ControlPointsList[1]) - 1;</para>
	/// <para>	 ControlPoints : ARRAY [0:UUpper] OF ARRAY [0:VUpper] OF IfcCartesianPoint := IfcMakeArrayOfArray(ControlPointsList,</para>
	/// <para>0,UUpper,0,VUpper);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBSplineSurface : IfcBoundedSurface
	{
		public IfcInteger UDegree { get; set; }
		public IfcInteger VDegree { get; set; }
		public List<List<IfcCartesianPoint >> ControlPointsList { get; set; }
		public IfcBSplineSurfaceForm SurfaceForm { get; set; }
		public IfcLogical UClosed { get; set; }
		public IfcLogical VClosed { get; set; }
		public IfcLogical SelfIntersect { get; set; }
		public IfcBSplineSurface() : base()
		{
			UDegree = new IfcInteger();
			VDegree = new IfcInteger();
			ControlPointsList = new List<List<IfcCartesianPoint >>();
			SurfaceForm = new IfcBSplineSurfaceForm();
			UClosed = new IfcLogical();
			VClosed = new IfcLogical();
			SelfIntersect = new IfcLogical();
		}
		public IfcBSplineSurface(IfcInteger UDegree, IfcInteger VDegree, List<List<IfcCartesianPoint >> ControlPointsList, IfcBSplineSurfaceForm SurfaceForm, IfcLogical UClosed, IfcLogical VClosed, IfcLogical SelfIntersect) : base ()
		{
			this.UDegree = UDegree;
			this.VDegree = VDegree;
			this.ControlPointsList = ControlPointsList;
			this.SurfaceForm = SurfaceForm;
			this.UClosed = UClosed;
			this.VClosed = VClosed;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineSurfaceWithKnots
	/// <para>ENTITY IfcBSplineSurfaceWithKnots</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRationalBSplineSurfaceWithKnots))</para>
	/// <para> SUBTYPE OF (IfcBSplineSurface);</para>
	/// <para>	UMultiplicities : LIST [2:?] OF IfcInteger;</para>
	/// <para>	VMultiplicities : LIST [2:?] OF IfcInteger;</para>
	/// <para>	UKnots : LIST [2:?] OF IfcParameterValue;</para>
	/// <para>	VKnots : LIST [2:?] OF IfcParameterValue;</para>
	/// <para>	KnotSpec : IfcKnotType;</para>
	/// <para> DERIVE</para>
	/// <para>	 KnotVUpper : IfcInteger := SIZEOF(VKnots);</para>
	/// <para>	 KnotUUpper : IfcInteger := SIZEOF(UKnots);</para>
	/// <para> WHERE</para>
	/// <para>	CorrespondingULists : SIZEOF(UMultiplicities) = KnotUUpper;</para>
	/// <para>	CorrespondingVLists : SIZEOF(VMultiplicities) = KnotVUpper;</para>
	/// <para>	UDirectionConstraints : IfcConstraintsParamBSpline (</para>
	/// <para>  SELF\IfcBSplineSurface.UDegree, KnotUUpper, </para>
	/// <para>  SELF\IfcBSplineSurface.UUpper, UMultiplicities, UKnots);</para>
	/// <para>	VDirectionConstraints : IfcConstraintsParamBSpline (</para>
	/// <para>  SELF\IfcBSplineSurface.VDegree, KnotVUpper, </para>
	/// <para>  SELF\IfcBSplineSurface.VUpper, VMultiplicities, VKnots);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBSplineSurfaceWithKnots : IfcBSplineSurface
	{
		public List<IfcInteger> UMultiplicities { get; set; }
		public List<IfcInteger> VMultiplicities { get; set; }
		public List<IfcParameterValue> UKnots { get; set; }
		public List<IfcParameterValue> VKnots { get; set; }
		public IfcKnotType KnotSpec { get; set; }
		public IfcBSplineSurfaceWithKnots() : base()
		{
			UMultiplicities = new List<IfcInteger>();
			VMultiplicities = new List<IfcInteger>();
			UKnots = new List<IfcParameterValue>();
			VKnots = new List<IfcParameterValue>();
			KnotSpec = new IfcKnotType();
		}
		public IfcBSplineSurfaceWithKnots(IfcInteger UDegree, IfcInteger VDegree, List<List<IfcCartesianPoint >> ControlPointsList, IfcBSplineSurfaceForm SurfaceForm, IfcLogical UClosed, IfcLogical VClosed, IfcLogical SelfIntersect, List<IfcInteger> UMultiplicities, List<IfcInteger> VMultiplicities, List<IfcParameterValue> UKnots, List<IfcParameterValue> VKnots, IfcKnotType KnotSpec) : base (UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect)
		{
			this.UMultiplicities = UMultiplicities;
			this.VMultiplicities = VMultiplicities;
			this.UKnots = UKnots;
			this.VKnots = VKnots;
			this.KnotSpec = KnotSpec;
		}
	}
	/// <summary>
	/// ENTITY IfcBeam
	/// <para>ENTITY IfcBeam</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBeamTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBeamTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBeamTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCBEAMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBeam : IfcBuiltElement
	{
		public IfcBeamTypeEnum? PredefinedType { get; set; }
		public IfcBeam() : base()
		{
		}
		public IfcBeam(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBeamType
	/// <para>ENTITY IfcBeamType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcBeamTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBeamTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBeamTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBeamType : IfcBuiltElementType
	{
		public IfcBeamTypeEnum PredefinedType { get; set; }
		public IfcBeamType() : base()
		{
			PredefinedType = new IfcBeamTypeEnum();
		}
		public IfcBeamType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBearing
	/// <para>ENTITY IfcBearing</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBearingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBearingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBearingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCBEARINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBearing : IfcBuiltElement
	{
		public IfcBearingTypeEnum? PredefinedType { get; set; }
		public IfcBearing() : base()
		{
		}
		public IfcBearing(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBearingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBearingType
	/// <para>ENTITY IfcBearingType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcBearingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBearingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBearingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBearingType : IfcBuiltElementType
	{
		public IfcBearingTypeEnum PredefinedType { get; set; }
		public IfcBearingType() : base()
		{
			PredefinedType = new IfcBearingTypeEnum();
		}
		public IfcBearingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBearingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBlobTexture
	/// <para>ENTITY IfcBlobTexture</para>
	/// <para> SUBTYPE OF (IfcSurfaceTexture);</para>
	/// <para>	RasterFormat : IfcIdentifier;</para>
	/// <para>	RasterCode : IfcBinary;</para>
	/// <para> WHERE</para>
	/// <para>	RasterCodeByteStream : BLENGTH(RasterCode) MOD 8 = 0;</para>
	/// <para>	SupportedRasterFormat : SELF.RasterFormat IN ['BMP', 'JPG', 'GIF', 'PNG'];</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBlobTexture : IfcSurfaceTexture
	{
		public IfcIdentifier RasterFormat { get; set; }
		public IfcBinary RasterCode { get; set; }
		public IfcBlobTexture() : base()
		{
			RasterFormat = new IfcIdentifier();
			RasterCode = new IfcBinary();
		}
		public IfcBlobTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter, IfcIdentifier RasterFormat, IfcBinary RasterCode) : base (RepeatS, RepeatT, Mode, TextureTransform, Parameter)
		{
			this.RasterFormat = RasterFormat;
			this.RasterCode = RasterCode;
		}
	}
	/// <summary>
	/// ENTITY IfcBlock
	/// <para>ENTITY IfcBlock</para>
	/// <para> SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>	XLength : IfcPositiveLengthMeasure;</para>
	/// <para>	YLength : IfcPositiveLengthMeasure;</para>
	/// <para>	ZLength : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBlock : IfcCsgPrimitive3D
	{
		public IfcPositiveLengthMeasure XLength { get; set; }
		public IfcPositiveLengthMeasure YLength { get; set; }
		public IfcPositiveLengthMeasure ZLength { get; set; }
		public IfcBlock() : base()
		{
			XLength = new IfcPositiveLengthMeasure();
			YLength = new IfcPositiveLengthMeasure();
			ZLength = new IfcPositiveLengthMeasure();
		}
		public IfcBlock(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure XLength, IfcPositiveLengthMeasure YLength, IfcPositiveLengthMeasure ZLength) : base (Position)
		{
			this.XLength = XLength;
			this.YLength = YLength;
			this.ZLength = ZLength;
		}
	}
	/// <summary>
	/// ENTITY IfcBoiler
	/// <para>ENTITY IfcBoiler</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBoilerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBoilerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBoilerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCBOILERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoiler : IfcEnergyConversionDevice
	{
		public IfcBoilerTypeEnum? PredefinedType { get; set; }
		public IfcBoiler() : base()
		{
		}
		public IfcBoiler(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBoilerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBoilerType
	/// <para>ENTITY IfcBoilerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcBoilerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBoilerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBoilerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoilerType : IfcEnergyConversionDeviceType
	{
		public IfcBoilerTypeEnum PredefinedType { get; set; }
		public IfcBoilerType() : base()
		{
			PredefinedType = new IfcBoilerTypeEnum();
		}
		public IfcBoilerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBoilerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBooleanClippingResult
	/// <para>ENTITY IfcBooleanClippingResult</para>
	/// <para> SUBTYPE OF (IfcBooleanResult);</para>
	/// <para> WHERE</para>
	/// <para>	FirstOperandType : ('IFC4X3_ADD2.IFCSWEPTAREASOLID' IN TYPEOF(FirstOperand)) OR </para>
	/// <para>('IFC4X3_ADD2.IFCSWEPTDISCSOLID' IN TYPEOF(FirstOperand)) OR </para>
	/// <para>('IFC4X3_ADD2.IFCBOOLEANCLIPPINGRESULT' IN TYPEOF(FirstOperand));</para>
	/// <para>	OperatorType : Operator = DIFFERENCE;</para>
	/// <para>	SecondOperandType : ('IFC4X3_ADD2.IFCHALFSPACESOLID' IN TYPEOF(SecondOperand));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBooleanClippingResult : IfcBooleanResult
	{
		public IfcBooleanClippingResult() : base()
		{
		}
		public IfcBooleanClippingResult(IfcBooleanOperator Operator, IfcBooleanOperand FirstOperand, IfcBooleanOperand SecondOperand) : base (Operator, FirstOperand, SecondOperand)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBooleanResult
	/// <para>ENTITY IfcBooleanResult</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBooleanClippingResult))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Operator : IfcBooleanOperator;</para>
	/// <para>	FirstOperand : IfcBooleanOperand;</para>
	/// <para>	SecondOperand : IfcBooleanOperand;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := FirstOperand.Dim;</para>
	/// <para> WHERE</para>
	/// <para>	FirstOperandClosed : NOT('IFC4X3_ADD2.IFCTESSELLATEDFACESET' IN TYPEOF(FirstOperand)) OR (EXISTS(FirstOperand.Closed) AND FirstOperand.Closed);</para>
	/// <para>	SameDim : FirstOperand.Dim = SecondOperand.Dim;</para>
	/// <para>	SecondOperandClosed : NOT('IFC4X3_ADD2.IFCTESSELLATEDFACESET' IN TYPEOF(SecondOperand)) OR (EXISTS(SecondOperand.Closed) AND SecondOperand.Closed);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBooleanResult : IfcGeometricRepresentationItem, IfcBooleanOperand, IfcCsgSelect
	{
		public IfcBooleanOperator Operator { get; set; }
		public IfcBooleanOperand FirstOperand { get; set; }
		public IfcBooleanOperand SecondOperand { get; set; }
		public IfcBooleanResult() : base()
		{
			Operator = new IfcBooleanOperator();
			FirstOperand = new IfcBooleanOperand();
			SecondOperand = new IfcBooleanOperand();
		}
		public IfcBooleanResult(IfcBooleanOperator Operator, IfcBooleanOperand FirstOperand, IfcBooleanOperand SecondOperand) : base ()
		{
			this.Operator = Operator;
			this.FirstOperand = FirstOperand;
			this.SecondOperand = SecondOperand;
		}
	}
	/// <summary>
	/// ENTITY IfcBorehole
	/// <para>ENTITY IfcBorehole</para>
	/// <para> SUBTYPE OF (IfcGeotechnicalAssembly);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBorehole : IfcGeotechnicalAssembly
	{
		public IfcBorehole() : base()
		{
		}
		public IfcBorehole(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryCondition
	/// <para>ENTITY IfcBoundaryCondition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBoundaryEdgeCondition</para>
	/// <para>	,IfcBoundaryFaceCondition</para>
	/// <para>	,IfcBoundaryNodeCondition));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBoundaryConditionENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcBoundaryCondition() : base()
		{
		}
		public IfcBoundaryCondition(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryCurve
	/// <para>ENTITY IfcBoundaryCurve</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcOuterBoundaryCurve))</para>
	/// <para> SUBTYPE OF (IfcCompositeCurveOnSurface);</para>
	/// <para> WHERE</para>
	/// <para>	IsClosed : SELF\IfcCompositeCurve.ClosedCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryCurve : IfcCompositeCurveOnSurface
	{
		public IfcBoundaryCurve() : base()
		{
		}
		public IfcBoundaryCurve(List<IfcSegment> Segments, IfcLogical SelfIntersect) : base (Segments, SelfIntersect)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryEdgeCondition
	/// <para>ENTITY IfcBoundaryEdgeCondition</para>
	/// <para> SUBTYPE OF (IfcBoundaryCondition);</para>
	/// <para>	TranslationalStiffnessByLengthX : OPTIONAL IfcModulusOfTranslationalSubgradeReactionSelect;</para>
	/// <para>	TranslationalStiffnessByLengthY : OPTIONAL IfcModulusOfTranslationalSubgradeReactionSelect;</para>
	/// <para>	TranslationalStiffnessByLengthZ : OPTIONAL IfcModulusOfTranslationalSubgradeReactionSelect;</para>
	/// <para>	RotationalStiffnessByLengthX : OPTIONAL IfcModulusOfRotationalSubgradeReactionSelect;</para>
	/// <para>	RotationalStiffnessByLengthY : OPTIONAL IfcModulusOfRotationalSubgradeReactionSelect;</para>
	/// <para>	RotationalStiffnessByLengthZ : OPTIONAL IfcModulusOfRotationalSubgradeReactionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryEdgeCondition : IfcBoundaryCondition
	{
		public IfcModulusOfTranslationalSubgradeReactionSelect? TranslationalStiffnessByLengthX { get; set; }
		public IfcModulusOfTranslationalSubgradeReactionSelect? TranslationalStiffnessByLengthY { get; set; }
		public IfcModulusOfTranslationalSubgradeReactionSelect? TranslationalStiffnessByLengthZ { get; set; }
		public IfcModulusOfRotationalSubgradeReactionSelect? RotationalStiffnessByLengthX { get; set; }
		public IfcModulusOfRotationalSubgradeReactionSelect? RotationalStiffnessByLengthY { get; set; }
		public IfcModulusOfRotationalSubgradeReactionSelect? RotationalStiffnessByLengthZ { get; set; }
		public IfcBoundaryEdgeCondition() : base()
		{
		}
		public IfcBoundaryEdgeCondition(IfcLabel Name, IfcModulusOfTranslationalSubgradeReactionSelect TranslationalStiffnessByLengthX, IfcModulusOfTranslationalSubgradeReactionSelect TranslationalStiffnessByLengthY, IfcModulusOfTranslationalSubgradeReactionSelect TranslationalStiffnessByLengthZ, IfcModulusOfRotationalSubgradeReactionSelect RotationalStiffnessByLengthX, IfcModulusOfRotationalSubgradeReactionSelect RotationalStiffnessByLengthY, IfcModulusOfRotationalSubgradeReactionSelect RotationalStiffnessByLengthZ) : base (Name)
		{
			this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX;
			this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY;
			this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ;
			this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX;
			this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY;
			this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryFaceCondition
	/// <para>ENTITY IfcBoundaryFaceCondition</para>
	/// <para> SUBTYPE OF (IfcBoundaryCondition);</para>
	/// <para>	TranslationalStiffnessByAreaX : OPTIONAL IfcModulusOfSubgradeReactionSelect;</para>
	/// <para>	TranslationalStiffnessByAreaY : OPTIONAL IfcModulusOfSubgradeReactionSelect;</para>
	/// <para>	TranslationalStiffnessByAreaZ : OPTIONAL IfcModulusOfSubgradeReactionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryFaceCondition : IfcBoundaryCondition
	{
		public IfcModulusOfSubgradeReactionSelect? TranslationalStiffnessByAreaX { get; set; }
		public IfcModulusOfSubgradeReactionSelect? TranslationalStiffnessByAreaY { get; set; }
		public IfcModulusOfSubgradeReactionSelect? TranslationalStiffnessByAreaZ { get; set; }
		public IfcBoundaryFaceCondition() : base()
		{
		}
		public IfcBoundaryFaceCondition(IfcLabel Name, IfcModulusOfSubgradeReactionSelect TranslationalStiffnessByAreaX, IfcModulusOfSubgradeReactionSelect TranslationalStiffnessByAreaY, IfcModulusOfSubgradeReactionSelect TranslationalStiffnessByAreaZ) : base (Name)
		{
			this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX;
			this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY;
			this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryNodeCondition
	/// <para>ENTITY IfcBoundaryNodeCondition</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBoundaryNodeConditionWarping))</para>
	/// <para> SUBTYPE OF (IfcBoundaryCondition);</para>
	/// <para>	TranslationalStiffnessX : OPTIONAL IfcTranslationalStiffnessSelect;</para>
	/// <para>	TranslationalStiffnessY : OPTIONAL IfcTranslationalStiffnessSelect;</para>
	/// <para>	TranslationalStiffnessZ : OPTIONAL IfcTranslationalStiffnessSelect;</para>
	/// <para>	RotationalStiffnessX : OPTIONAL IfcRotationalStiffnessSelect;</para>
	/// <para>	RotationalStiffnessY : OPTIONAL IfcRotationalStiffnessSelect;</para>
	/// <para>	RotationalStiffnessZ : OPTIONAL IfcRotationalStiffnessSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryNodeCondition : IfcBoundaryCondition
	{
		public IfcTranslationalStiffnessSelect? TranslationalStiffnessX { get; set; }
		public IfcTranslationalStiffnessSelect? TranslationalStiffnessY { get; set; }
		public IfcTranslationalStiffnessSelect? TranslationalStiffnessZ { get; set; }
		public IfcRotationalStiffnessSelect? RotationalStiffnessX { get; set; }
		public IfcRotationalStiffnessSelect? RotationalStiffnessY { get; set; }
		public IfcRotationalStiffnessSelect? RotationalStiffnessZ { get; set; }
		public IfcBoundaryNodeCondition() : base()
		{
		}
		public IfcBoundaryNodeCondition(IfcLabel Name, IfcTranslationalStiffnessSelect TranslationalStiffnessX, IfcTranslationalStiffnessSelect TranslationalStiffnessY, IfcTranslationalStiffnessSelect TranslationalStiffnessZ, IfcRotationalStiffnessSelect RotationalStiffnessX, IfcRotationalStiffnessSelect RotationalStiffnessY, IfcRotationalStiffnessSelect RotationalStiffnessZ) : base (Name)
		{
			this.TranslationalStiffnessX = TranslationalStiffnessX;
			this.TranslationalStiffnessY = TranslationalStiffnessY;
			this.TranslationalStiffnessZ = TranslationalStiffnessZ;
			this.RotationalStiffnessX = RotationalStiffnessX;
			this.RotationalStiffnessY = RotationalStiffnessY;
			this.RotationalStiffnessZ = RotationalStiffnessZ;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryNodeConditionWarping
	/// <para>ENTITY IfcBoundaryNodeConditionWarping</para>
	/// <para> SUBTYPE OF (IfcBoundaryNodeCondition);</para>
	/// <para>	WarpingStiffness : OPTIONAL IfcWarpingStiffnessSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryNodeConditionWarping : IfcBoundaryNodeCondition
	{
		public IfcWarpingStiffnessSelect? WarpingStiffness { get; set; }
		public IfcBoundaryNodeConditionWarping() : base()
		{
		}
		public IfcBoundaryNodeConditionWarping(IfcLabel Name, IfcTranslationalStiffnessSelect TranslationalStiffnessX, IfcTranslationalStiffnessSelect TranslationalStiffnessY, IfcTranslationalStiffnessSelect TranslationalStiffnessZ, IfcRotationalStiffnessSelect RotationalStiffnessX, IfcRotationalStiffnessSelect RotationalStiffnessY, IfcRotationalStiffnessSelect RotationalStiffnessZ, IfcWarpingStiffnessSelect WarpingStiffness) : base (Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ)
		{
			this.WarpingStiffness = WarpingStiffness;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundedCurve
	/// <para>ENTITY IfcBoundedCurve</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBSplineCurve</para>
	/// <para>	,IfcCompositeCurve</para>
	/// <para>	,IfcIndexedPolyCurve</para>
	/// <para>	,IfcPolyline</para>
	/// <para>	,IfcTrimmedCurve))</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBoundedCurve : IfcCurve, IfcCurveOrEdgeCurve
	{
		public IfcBoundedCurve() : base()
		{
		}
		public IfcBoundedCurve() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBoundedSurface
	/// <para>ENTITY IfcBoundedSurface</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBSplineSurface</para>
	/// <para>	,IfcCurveBoundedPlane</para>
	/// <para>	,IfcCurveBoundedSurface</para>
	/// <para>	,IfcRectangularTrimmedSurface))</para>
	/// <para> SUBTYPE OF (IfcSurface);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBoundedSurface : IfcSurface
	{
		public IfcBoundedSurface() : base()
		{
		}
		public IfcBoundedSurface() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBoundingBox
	/// <para>ENTITY IfcBoundingBox</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Corner : IfcCartesianPoint;</para>
	/// <para>	XDim : IfcPositiveLengthMeasure;</para>
	/// <para>	YDim : IfcPositiveLengthMeasure;</para>
	/// <para>	ZDim : IfcPositiveLengthMeasure;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundingBox : IfcGeometricRepresentationItem
	{
		public IfcCartesianPoint Corner { get; set; }
		public IfcPositiveLengthMeasure XDim { get; set; }
		public IfcPositiveLengthMeasure YDim { get; set; }
		public IfcPositiveLengthMeasure ZDim { get; set; }
		public IfcBoundingBox() : base()
		{
			Corner = new IfcCartesianPoint();
			XDim = new IfcPositiveLengthMeasure();
			YDim = new IfcPositiveLengthMeasure();
			ZDim = new IfcPositiveLengthMeasure();
		}
		public IfcBoundingBox(IfcCartesianPoint Corner, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim, IfcPositiveLengthMeasure ZDim) : base ()
		{
			this.Corner = Corner;
			this.XDim = XDim;
			this.YDim = YDim;
			this.ZDim = ZDim;
		}
	}
	/// <summary>
	/// ENTITY IfcBoxedHalfSpace
	/// <para>ENTITY IfcBoxedHalfSpace</para>
	/// <para> SUBTYPE OF (IfcHalfSpaceSolid);</para>
	/// <para>	Enclosure : IfcBoundingBox;</para>
	/// <para> WHERE</para>
	/// <para>	UnboundedSurface : NOT ('IFC4X3_ADD2.IFCCURVEBOUNDEDPLANE' IN TYPEOF(SELF\IfcHalfSpaceSolid.BaseSurface));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoxedHalfSpace : IfcHalfSpaceSolid
	{
		public IfcBoundingBox Enclosure { get; set; }
		public IfcBoxedHalfSpace() : base()
		{
			Enclosure = new IfcBoundingBox();
		}
		public IfcBoxedHalfSpace(IfcSurface BaseSurface, IfcBoolean AgreementFlag, IfcBoundingBox Enclosure) : base (BaseSurface, AgreementFlag)
		{
			this.Enclosure = Enclosure;
		}
	}
	/// <summary>
	/// ENTITY IfcBridge
	/// <para>ENTITY IfcBridge</para>
	/// <para> SUBTYPE OF (IfcFacility);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBridgeTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBridgeTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBridgeTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBridge : IfcFacility
	{
		public IfcBridgeTypeEnum? PredefinedType { get; set; }
		public IfcBridge() : base()
		{
		}
		public IfcBridge(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcBridgeTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBridgePart
	/// <para>ENTITY IfcBridgePart</para>
	/// <para> SUBTYPE OF (IfcFacilityPart);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBridgePartTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBridgePartTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBridgePartTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBridgePart : IfcFacilityPart
	{
		public IfcBridgePartTypeEnum? PredefinedType { get; set; }
		public IfcBridgePart() : base()
		{
		}
		public IfcBridgePart(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcFacilityUsageEnum UsageType, IfcBridgePartTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, UsageType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuilding
	/// <para>ENTITY IfcBuilding</para>
	/// <para> SUBTYPE OF (IfcFacility);</para>
	/// <para>	ElevationOfRefHeight : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ElevationOfTerrain : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	BuildingAddress : OPTIONAL IfcPostalAddress;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuilding : IfcFacility
	{
		public IfcLengthMeasure? ElevationOfRefHeight { get; set; }
		public IfcLengthMeasure? ElevationOfTerrain { get; set; }
		public IfcPostalAddress? BuildingAddress { get; set; }
		public IfcBuilding() : base()
		{
		}
		public IfcBuilding(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcLengthMeasure ElevationOfRefHeight, IfcLengthMeasure ElevationOfTerrain, IfcPostalAddress BuildingAddress) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.ElevationOfRefHeight = ElevationOfRefHeight;
			this.ElevationOfTerrain = ElevationOfTerrain;
			this.BuildingAddress = BuildingAddress;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementPart
	/// <para>ENTITY IfcBuildingElementPart</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBuildingElementPartTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBuildingElementPartTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBuildingElementPartTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCBUILDINGELEMENTPARTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementPart : IfcElementComponent
	{
		public IfcBuildingElementPartTypeEnum? PredefinedType { get; set; }
		public IfcBuildingElementPart() : base()
		{
		}
		public IfcBuildingElementPart(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBuildingElementPartTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementPartType
	/// <para>ENTITY IfcBuildingElementPartType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcBuildingElementPartTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBuildingElementPartTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBuildingElementPartTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementPartType : IfcElementComponentType
	{
		public IfcBuildingElementPartTypeEnum PredefinedType { get; set; }
		public IfcBuildingElementPartType() : base()
		{
			PredefinedType = new IfcBuildingElementPartTypeEnum();
		}
		public IfcBuildingElementPartType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBuildingElementPartTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementProxy
	/// <para>ENTITY IfcBuildingElementProxy</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBuildingElementProxyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBuildingElementProxyTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBuildingElementProxyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCBUILDINGELEMENTPROXYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>	HasObjectName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementProxy : IfcBuiltElement
	{
		public IfcBuildingElementProxyTypeEnum? PredefinedType { get; set; }
		public IfcBuildingElementProxy() : base()
		{
		}
		public IfcBuildingElementProxy(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBuildingElementProxyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementProxyType
	/// <para>ENTITY IfcBuildingElementProxyType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcBuildingElementProxyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBuildingElementProxyTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBuildingElementProxyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementProxyType : IfcBuiltElementType
	{
		public IfcBuildingElementProxyTypeEnum PredefinedType { get; set; }
		public IfcBuildingElementProxyType() : base()
		{
			PredefinedType = new IfcBuildingElementProxyTypeEnum();
		}
		public IfcBuildingElementProxyType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBuildingElementProxyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingStorey
	/// <para>ENTITY IfcBuildingStorey</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>	Elevation : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingStorey : IfcSpatialStructureElement
	{
		public IfcLengthMeasure? Elevation { get; set; }
		public IfcBuildingStorey() : base()
		{
		}
		public IfcBuildingStorey(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcLengthMeasure Elevation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.Elevation = Elevation;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingSystem
	/// <para>ENTITY IfcBuildingSystem</para>
	/// <para> SUBTYPE OF (IfcSystem);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBuildingSystemTypeEnum;</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBuildingSystemTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBuildingSystemTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingSystem : IfcSystem
	{
		public IfcBuildingSystemTypeEnum? PredefinedType { get; set; }
		public IfcLabel? LongName { get; set; }
		public IfcBuildingSystem() : base()
		{
		}
		public IfcBuildingSystem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcBuildingSystemTypeEnum PredefinedType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcBuiltElement
	/// <para>ENTITY IfcBuiltElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBeam</para>
	/// <para>	,IfcBearing</para>
	/// <para>	,IfcBuildingElementProxy</para>
	/// <para>	,IfcChimney</para>
	/// <para>	,IfcColumn</para>
	/// <para>	,IfcCourse</para>
	/// <para>	,IfcCovering</para>
	/// <para>	,IfcCurtainWall</para>
	/// <para>	,IfcDeepFoundation</para>
	/// <para>	,IfcDoor</para>
	/// <para>	,IfcEarthworksElement</para>
	/// <para>	,IfcFooting</para>
	/// <para>	,IfcKerb</para>
	/// <para>	,IfcMember</para>
	/// <para>	,IfcMooringDevice</para>
	/// <para>	,IfcNavigationElement</para>
	/// <para>	,IfcPavement</para>
	/// <para>	,IfcPlate</para>
	/// <para>	,IfcRail</para>
	/// <para>	,IfcRailing</para>
	/// <para>	,IfcRamp</para>
	/// <para>	,IfcRampFlight</para>
	/// <para>	,IfcRoof</para>
	/// <para>	,IfcShadingDevice</para>
	/// <para>	,IfcSlab</para>
	/// <para>	,IfcStair</para>
	/// <para>	,IfcStairFlight</para>
	/// <para>	,IfcTrackElement</para>
	/// <para>	,IfcWall</para>
	/// <para>	,IfcWindow))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para> WHERE</para>
	/// <para>	MaxOneMaterialAssociation : SIZEOF (QUERY(temp <* SELF\IfcObjectDefinition.HasAssociations |</para>
	/// <para>  'IFC4X3_ADD2.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)</para>
	/// <para>  )) <= 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuiltElement : IfcElement
	{
		public IfcBuiltElement() : base()
		{
		}
		public IfcBuiltElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBuiltElementType
	/// <para>ENTITY IfcBuiltElementType</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBeamType</para>
	/// <para>	,IfcBearingType</para>
	/// <para>	,IfcBuildingElementProxyType</para>
	/// <para>	,IfcChimneyType</para>
	/// <para>	,IfcColumnType</para>
	/// <para>	,IfcCourseType</para>
	/// <para>	,IfcCoveringType</para>
	/// <para>	,IfcCurtainWallType</para>
	/// <para>	,IfcDeepFoundationType</para>
	/// <para>	,IfcDoorType</para>
	/// <para>	,IfcFootingType</para>
	/// <para>	,IfcKerbType</para>
	/// <para>	,IfcMemberType</para>
	/// <para>	,IfcMooringDeviceType</para>
	/// <para>	,IfcNavigationElementType</para>
	/// <para>	,IfcPavementType</para>
	/// <para>	,IfcPlateType</para>
	/// <para>	,IfcRailType</para>
	/// <para>	,IfcRailingType</para>
	/// <para>	,IfcRampFlightType</para>
	/// <para>	,IfcRampType</para>
	/// <para>	,IfcRoofType</para>
	/// <para>	,IfcShadingDeviceType</para>
	/// <para>	,IfcSlabType</para>
	/// <para>	,IfcStairFlightType</para>
	/// <para>	,IfcStairType</para>
	/// <para>	,IfcTrackElementType</para>
	/// <para>	,IfcWallType</para>
	/// <para>	,IfcWindowType))</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuiltElementType : IfcElementType
	{
		public IfcBuiltElementType() : base()
		{
		}
		public IfcBuiltElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBuiltSystem
	/// <para>ENTITY IfcBuiltSystem</para>
	/// <para> SUBTYPE OF (IfcSystem);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBuiltSystemTypeEnum;</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBuiltSystemTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBuiltSystemTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuiltSystem : IfcSystem
	{
		public IfcBuiltSystemTypeEnum? PredefinedType { get; set; }
		public IfcLabel? LongName { get; set; }
		public IfcBuiltSystem() : base()
		{
		}
		public IfcBuiltSystem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcBuiltSystemTypeEnum PredefinedType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcBurner
	/// <para>ENTITY IfcBurner</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBurnerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBurnerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBurnerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCBURNERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBurner : IfcEnergyConversionDevice
	{
		public IfcBurnerTypeEnum? PredefinedType { get; set; }
		public IfcBurner() : base()
		{
		}
		public IfcBurner(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBurnerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBurnerType
	/// <para>ENTITY IfcBurnerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcBurnerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBurnerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBurnerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBurnerType : IfcEnergyConversionDeviceType
	{
		public IfcBurnerTypeEnum PredefinedType { get; set; }
		public IfcBurnerType() : base()
		{
			PredefinedType = new IfcBurnerTypeEnum();
		}
		public IfcBurnerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBurnerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCShapeProfileDef
	/// <para>ENTITY IfcCShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para>	Width : IfcPositiveLengthMeasure;</para>
	/// <para>	WallThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	Girth : IfcPositiveLengthMeasure;</para>
	/// <para>	InternalFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidGirth : Girth < (Depth / 2.);</para>
	/// <para>	ValidInternalFilletRadius : NOT(EXISTS(InternalFilletRadius)) OR</para>
	/// <para>((InternalFilletRadius <= Width/2. - WallThickness) AND (InternalFilletRadius <= Depth/2. - WallThickness));</para>
	/// <para>	ValidWallThickness : (WallThickness < Width/2.) AND (WallThickness < Depth/2.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcPositiveLengthMeasure Width { get; set; }
		public IfcPositiveLengthMeasure WallThickness { get; set; }
		public IfcPositiveLengthMeasure Girth { get; set; }
		public IfcNonNegativeLengthMeasure? InternalFilletRadius { get; set; }
		public IfcCShapeProfileDef() : base()
		{
			Depth = new IfcPositiveLengthMeasure();
			Width = new IfcPositiveLengthMeasure();
			WallThickness = new IfcPositiveLengthMeasure();
			Girth = new IfcPositiveLengthMeasure();
		}
		public IfcCShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure Width, IfcPositiveLengthMeasure WallThickness, IfcPositiveLengthMeasure Girth, IfcNonNegativeLengthMeasure InternalFilletRadius) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.Width = Width;
			this.WallThickness = WallThickness;
			this.Girth = Girth;
			this.InternalFilletRadius = InternalFilletRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierFitting
	/// <para>ENTITY IfcCableCarrierFitting</para>
	/// <para> SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCableCarrierFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCableCarrierFittingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCableCarrierFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCABLECARRIERFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierFitting : IfcFlowFitting
	{
		public IfcCableCarrierFittingTypeEnum? PredefinedType { get; set; }
		public IfcCableCarrierFitting() : base()
		{
		}
		public IfcCableCarrierFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableCarrierFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierFittingType
	/// <para>ENTITY IfcCableCarrierFittingType</para>
	/// <para> SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>	PredefinedType : IfcCableCarrierFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCableCarrierFittingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCableCarrierFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierFittingType : IfcFlowFittingType
	{
		public IfcCableCarrierFittingTypeEnum PredefinedType { get; set; }
		public IfcCableCarrierFittingType() : base()
		{
			PredefinedType = new IfcCableCarrierFittingTypeEnum();
		}
		public IfcCableCarrierFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableCarrierFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierSegment
	/// <para>ENTITY IfcCableCarrierSegment</para>
	/// <para> SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCableCarrierSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCableCarrierSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCableCarrierSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCABLECARRIERSEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierSegment : IfcFlowSegment
	{
		public IfcCableCarrierSegmentTypeEnum? PredefinedType { get; set; }
		public IfcCableCarrierSegment() : base()
		{
		}
		public IfcCableCarrierSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableCarrierSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierSegmentType
	/// <para>ENTITY IfcCableCarrierSegmentType</para>
	/// <para> SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>	PredefinedType : IfcCableCarrierSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCableCarrierSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCableCarrierSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierSegmentType : IfcFlowSegmentType
	{
		public IfcCableCarrierSegmentTypeEnum PredefinedType { get; set; }
		public IfcCableCarrierSegmentType() : base()
		{
			PredefinedType = new IfcCableCarrierSegmentTypeEnum();
		}
		public IfcCableCarrierSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableCarrierSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableFitting
	/// <para>ENTITY IfcCableFitting</para>
	/// <para> SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCableFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCableFittingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCableFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCABLEFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableFitting : IfcFlowFitting
	{
		public IfcCableFittingTypeEnum? PredefinedType { get; set; }
		public IfcCableFitting() : base()
		{
		}
		public IfcCableFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableFittingType
	/// <para>ENTITY IfcCableFittingType</para>
	/// <para> SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>	PredefinedType : IfcCableFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCableFittingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCableFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableFittingType : IfcFlowFittingType
	{
		public IfcCableFittingTypeEnum PredefinedType { get; set; }
		public IfcCableFittingType() : base()
		{
			PredefinedType = new IfcCableFittingTypeEnum();
		}
		public IfcCableFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableSegment
	/// <para>ENTITY IfcCableSegment</para>
	/// <para> SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCableSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCableSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCableSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCABLESEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableSegment : IfcFlowSegment
	{
		public IfcCableSegmentTypeEnum? PredefinedType { get; set; }
		public IfcCableSegment() : base()
		{
		}
		public IfcCableSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableSegmentType
	/// <para>ENTITY IfcCableSegmentType</para>
	/// <para> SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>	PredefinedType : IfcCableSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCableSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCableSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableSegmentType : IfcFlowSegmentType
	{
		public IfcCableSegmentTypeEnum PredefinedType { get; set; }
		public IfcCableSegmentType() : base()
		{
			PredefinedType = new IfcCableSegmentTypeEnum();
		}
		public IfcCableSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCaissonFoundation
	/// <para>ENTITY IfcCaissonFoundation</para>
	/// <para> SUBTYPE OF (IfcDeepFoundation);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCaissonFoundationTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCaissonFoundationTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCaissonFoundationTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCAISSONFOUNDATIONTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCaissonFoundation : IfcDeepFoundation
	{
		public IfcCaissonFoundationTypeEnum? PredefinedType { get; set; }
		public IfcCaissonFoundation() : base()
		{
		}
		public IfcCaissonFoundation(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCaissonFoundationTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCaissonFoundationType
	/// <para>ENTITY IfcCaissonFoundationType</para>
	/// <para> SUBTYPE OF (IfcDeepFoundationType);</para>
	/// <para>	PredefinedType : IfcCaissonFoundationTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCaissonFoundationTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCaissonFoundationTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCaissonFoundationType : IfcDeepFoundationType
	{
		public IfcCaissonFoundationTypeEnum PredefinedType { get; set; }
		public IfcCaissonFoundationType() : base()
		{
			PredefinedType = new IfcCaissonFoundationTypeEnum();
		}
		public IfcCaissonFoundationType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCaissonFoundationTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPoint
	/// <para>ENTITY IfcCartesianPoint</para>
	/// <para> SUBTYPE OF (IfcPoint);</para>
	/// <para>	Coordinates : LIST [1:3] OF IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	CP2Dor3D : HIINDEX(Coordinates) >= 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianPoint : IfcPoint, IfcTrimmingSelect
	{
		public List<IfcLengthMeasure> Coordinates { get; set; }
		public IfcCartesianPoint() : base()
		{
			Coordinates = new List<IfcLengthMeasure>();
		}
		public IfcCartesianPoint(List<IfcLengthMeasure> Coordinates) : base ()
		{
			this.Coordinates = Coordinates;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPointList
	/// <para>ENTITY IfcCartesianPointList</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCartesianPointList2D</para>
	/// <para>	,IfcCartesianPointList3D))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := IfcPointListDim(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCartesianPointList : IfcGeometricRepresentationItem
	{
		public IfcCartesianPointList() : base()
		{
		}
		public IfcCartesianPointList() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPointList2D
	/// <para>ENTITY IfcCartesianPointList2D</para>
	/// <para> SUBTYPE OF (IfcCartesianPointList);</para>
	/// <para>	CoordList : LIST [1:?] OF LIST [2:2] OF IfcLengthMeasure;</para>
	/// <para>	TagList : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianPointList2D : IfcCartesianPointList
	{
		public List<List<IfcLengthMeasure >> CoordList { get; set; }
		public List<IfcLabel>? TagList { get; set; }
		public IfcCartesianPointList2D() : base()
		{
			CoordList = new List<List<IfcLengthMeasure >>();
		}
		public IfcCartesianPointList2D(List<List<IfcLengthMeasure >> CoordList, List<IfcLabel> TagList) : base ()
		{
			this.CoordList = CoordList;
			this.TagList = TagList;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPointList3D
	/// <para>ENTITY IfcCartesianPointList3D</para>
	/// <para> SUBTYPE OF (IfcCartesianPointList);</para>
	/// <para>	CoordList : LIST [1:?] OF LIST [3:3] OF IfcLengthMeasure;</para>
	/// <para>	TagList : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianPointList3D : IfcCartesianPointList
	{
		public List<List<IfcLengthMeasure >> CoordList { get; set; }
		public List<IfcLabel>? TagList { get; set; }
		public IfcCartesianPointList3D() : base()
		{
			CoordList = new List<List<IfcLengthMeasure >>();
		}
		public IfcCartesianPointList3D(List<List<IfcLengthMeasure >> CoordList, List<IfcLabel> TagList) : base ()
		{
			this.CoordList = CoordList;
			this.TagList = TagList;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator
	/// <para>ENTITY IfcCartesianTransformationOperator</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCartesianTransformationOperator2D</para>
	/// <para>	,IfcCartesianTransformationOperator3D))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Axis1 : OPTIONAL IfcDirection;</para>
	/// <para>	Axis2 : OPTIONAL IfcDirection;</para>
	/// <para>	LocalOrigin : IfcCartesianPoint;</para>
	/// <para>	Scale : OPTIONAL IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	 Scl : IfcReal := NVL(Scale, 1.0);</para>
	/// <para>	 Dim : IfcDimensionCount := LocalOrigin.Dim;</para>
	/// <para> WHERE</para>
	/// <para>	ScaleGreaterZero : Scl > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCartesianTransformationOperator : IfcGeometricRepresentationItem
	{
		public IfcDirection? Axis1 { get; set; }
		public IfcDirection? Axis2 { get; set; }
		public IfcCartesianPoint LocalOrigin { get; set; }
		public IfcReal? Scale { get; set; }
		public IfcCartesianTransformationOperator() : base()
		{
			LocalOrigin = new IfcCartesianPoint();
		}
		public IfcCartesianTransformationOperator(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale) : base ()
		{
			this.Axis1 = Axis1;
			this.Axis2 = Axis2;
			this.LocalOrigin = LocalOrigin;
			this.Scale = Scale;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator2D
	/// <para>ENTITY IfcCartesianTransformationOperator2D</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCartesianTransformationOperator2DnonUniform))</para>
	/// <para> SUBTYPE OF (IfcCartesianTransformationOperator);</para>
	/// <para> DERIVE</para>
	/// <para>	 U : LIST [2:2] OF IfcDirection := IfcBaseAxis(2,SELF\IfcCartesianTransformationOperator.Axis1,</para>
	/// <para>SELF\IfcCartesianTransformationOperator.Axis2,?);</para>
	/// <para> WHERE</para>
	/// <para>	Axis1Is2D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis1)) OR </para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis1.Dim = 2);</para>
	/// <para>	Axis2Is2D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis2)) OR </para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis2.Dim = 2);</para>
	/// <para>	DimEqual2 : SELF\IfcCartesianTransformationOperator.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator2D : IfcCartesianTransformationOperator
	{
		public IfcCartesianTransformationOperator2D() : base()
		{
		}
		public IfcCartesianTransformationOperator2D(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale) : base (Axis1, Axis2, LocalOrigin, Scale)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator2DnonUniform
	/// <para>ENTITY IfcCartesianTransformationOperator2DnonUniform</para>
	/// <para> SUBTYPE OF (IfcCartesianTransformationOperator2D);</para>
	/// <para>	Scale2 : OPTIONAL IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	 Scl2 : IfcReal := NVL(Scale2, SELF\IfcCartesianTransformationOperator.Scl);</para>
	/// <para> WHERE</para>
	/// <para>	Scale2GreaterZero : Scl2 > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator2DnonUniform : IfcCartesianTransformationOperator2D
	{
		public IfcReal? Scale2 { get; set; }
		public IfcCartesianTransformationOperator2DnonUniform() : base()
		{
		}
		public IfcCartesianTransformationOperator2DnonUniform(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale, IfcReal Scale2) : base (Axis1, Axis2, LocalOrigin, Scale)
		{
			this.Scale2 = Scale2;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator3D
	/// <para>ENTITY IfcCartesianTransformationOperator3D</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCartesianTransformationOperator3DnonUniform))</para>
	/// <para> SUBTYPE OF (IfcCartesianTransformationOperator);</para>
	/// <para>	Axis3 : OPTIONAL IfcDirection;</para>
	/// <para> DERIVE</para>
	/// <para>	 U : LIST [3:3] OF IfcDirection := IfcBaseAxis(3,SELF\IfcCartesianTransformationOperator.Axis1,</para>
	/// <para>SELF\IfcCartesianTransformationOperator.Axis2,Axis3);</para>
	/// <para> WHERE</para>
	/// <para>	Axis1Is3D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis1)) OR </para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis1.Dim = 3);</para>
	/// <para>	Axis2Is3D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis2)) OR </para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis2.Dim = 3);</para>
	/// <para>	Axis3Is3D : NOT(EXISTS(Axis3)) OR (Axis3.Dim = 3);</para>
	/// <para>	DimIs3D : SELF\IfcCartesianTransformationOperator.Dim = 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator3D : IfcCartesianTransformationOperator
	{
		public IfcDirection? Axis3 { get; set; }
		public IfcCartesianTransformationOperator3D() : base()
		{
		}
		public IfcCartesianTransformationOperator3D(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale, IfcDirection Axis3) : base (Axis1, Axis2, LocalOrigin, Scale)
		{
			this.Axis3 = Axis3;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator3DnonUniform
	/// <para>ENTITY IfcCartesianTransformationOperator3DnonUniform</para>
	/// <para> SUBTYPE OF (IfcCartesianTransformationOperator3D);</para>
	/// <para>	Scale2 : OPTIONAL IfcReal;</para>
	/// <para>	Scale3 : OPTIONAL IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	 Scl2 : IfcReal := NVL(Scale2, SELF\IfcCartesianTransformationOperator.Scl);</para>
	/// <para>	 Scl3 : IfcReal := NVL(Scale3, SELF\IfcCartesianTransformationOperator.Scl);</para>
	/// <para> WHERE</para>
	/// <para>	Scale2GreaterZero : Scl2 > 0.0;</para>
	/// <para>	Scale3GreaterZero : Scl3 > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator3DnonUniform : IfcCartesianTransformationOperator3D
	{
		public IfcReal? Scale2 { get; set; }
		public IfcReal? Scale3 { get; set; }
		public IfcCartesianTransformationOperator3DnonUniform() : base()
		{
		}
		public IfcCartesianTransformationOperator3DnonUniform(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale, IfcDirection Axis3, IfcReal Scale2, IfcReal Scale3) : base (Axis1, Axis2, LocalOrigin, Scale, Axis3)
		{
			this.Scale2 = Scale2;
			this.Scale3 = Scale3;
		}
	}
	/// <summary>
	/// ENTITY IfcCenterLineProfileDef
	/// <para>ENTITY IfcCenterLineProfileDef</para>
	/// <para> SUBTYPE OF (IfcArbitraryOpenProfileDef);</para>
	/// <para>	Thickness : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCenterLineProfileDef : IfcArbitraryOpenProfileDef
	{
		public IfcPositiveLengthMeasure Thickness { get; set; }
		public IfcCenterLineProfileDef() : base()
		{
			Thickness = new IfcPositiveLengthMeasure();
		}
		public IfcCenterLineProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcBoundedCurve Curve, IfcPositiveLengthMeasure Thickness) : base (ProfileType, ProfileName, Curve)
		{
			this.Thickness = Thickness;
		}
	}
	/// <summary>
	/// ENTITY IfcChiller
	/// <para>ENTITY IfcChiller</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcChillerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcChillerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcChillerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCHILLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChiller : IfcEnergyConversionDevice
	{
		public IfcChillerTypeEnum? PredefinedType { get; set; }
		public IfcChiller() : base()
		{
		}
		public IfcChiller(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcChillerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcChillerType
	/// <para>ENTITY IfcChillerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcChillerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcChillerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcChillerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChillerType : IfcEnergyConversionDeviceType
	{
		public IfcChillerTypeEnum PredefinedType { get; set; }
		public IfcChillerType() : base()
		{
			PredefinedType = new IfcChillerTypeEnum();
		}
		public IfcChillerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcChillerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcChimney
	/// <para>ENTITY IfcChimney</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcChimneyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcChimneyTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcChimneyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCHIMNEYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChimney : IfcBuiltElement
	{
		public IfcChimneyTypeEnum? PredefinedType { get; set; }
		public IfcChimney() : base()
		{
		}
		public IfcChimney(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcChimneyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcChimneyType
	/// <para>ENTITY IfcChimneyType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcChimneyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcChimneyTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcChimneyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChimneyType : IfcBuiltElementType
	{
		public IfcChimneyTypeEnum PredefinedType { get; set; }
		public IfcChimneyType() : base()
		{
			PredefinedType = new IfcChimneyTypeEnum();
		}
		public IfcChimneyType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcChimneyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCircle
	/// <para>ENTITY IfcCircle</para>
	/// <para> SUBTYPE OF (IfcConic);</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCircle : IfcConic
	{
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcCircle() : base()
		{
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcCircle(IfcAxis2Placement Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcCircleHollowProfileDef
	/// <para>ENTITY IfcCircleHollowProfileDef</para>
	/// <para> SUBTYPE OF (IfcCircleProfileDef);</para>
	/// <para>	WallThickness : IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : WallThickness < SELF\IfcCircleProfileDef.Radius;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCircleHollowProfileDef : IfcCircleProfileDef
	{
		public IfcPositiveLengthMeasure WallThickness { get; set; }
		public IfcCircleHollowProfileDef() : base()
		{
			WallThickness = new IfcPositiveLengthMeasure();
		}
		public IfcCircleHollowProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Radius, IfcPositiveLengthMeasure WallThickness) : base (ProfileType, ProfileName, Position, Radius)
		{
			this.WallThickness = WallThickness;
		}
	}
	/// <summary>
	/// ENTITY IfcCircleProfileDef
	/// <para>ENTITY IfcCircleProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCircleHollowProfileDef))</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCircleProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcCircleProfileDef() : base()
		{
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcCircleProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Radius) : base (ProfileType, ProfileName, Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcCivilElement
	/// <para>ENTITY IfcCivilElement</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCivilElement : IfcElement
	{
		public IfcCivilElement() : base()
		{
		}
		public IfcCivilElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCivilElementType
	/// <para>ENTITY IfcCivilElementType</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCivilElementType : IfcElementType
	{
		public IfcCivilElementType() : base()
		{
		}
		public IfcCivilElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcClassification
	/// <para>ENTITY IfcClassification</para>
	/// <para> SUBTYPE OF (IfcExternalInformation);</para>
	/// <para>	Source : OPTIONAL IfcLabel;</para>
	/// <para>	Edition : OPTIONAL IfcLabel;</para>
	/// <para>	EditionDate : OPTIONAL IfcDate;</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Specification : OPTIONAL IfcURIReference;</para>
	/// <para>	ReferenceTokens : OPTIONAL LIST [1:?] OF IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	ClassificationForObjects : SET [0:?] OF IfcRelAssociatesClassification FOR RelatingClassification;</para>
	/// <para>	HasReferences : SET [0:?] OF IfcClassificationReference FOR ReferencedSource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcClassification : IfcExternalInformation, IfcClassificationReferenceSelect, IfcClassificationSelect
	{
		public IfcLabel? Source { get; set; }
		public IfcLabel? Edition { get; set; }
		public IfcDate? EditionDate { get; set; }
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcURIReference? Specification { get; set; }
		public List<IfcIdentifier>? ReferenceTokens { get; set; }
		public IfcClassification() : base()
		{
			Name = new IfcLabel();
		}
		public IfcClassification(IfcLabel Source, IfcLabel Edition, IfcDate EditionDate, IfcLabel Name, IfcText Description, IfcURIReference Specification, List<IfcIdentifier> ReferenceTokens) : base ()
		{
			this.Source = Source;
			this.Edition = Edition;
			this.EditionDate = EditionDate;
			this.Name = Name;
			this.Description = Description;
			this.Specification = Specification;
			this.ReferenceTokens = ReferenceTokens;
		}
	}
	/// <summary>
	/// ENTITY IfcClassificationReference
	/// <para>ENTITY IfcClassificationReference</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>	ReferencedSource : OPTIONAL IfcClassificationReferenceSelect;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Sort : OPTIONAL IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	ClassificationRefForObjects : SET [0:?] OF IfcRelAssociatesClassification FOR RelatingClassification;</para>
	/// <para>	HasReferences : SET [0:?] OF IfcClassificationReference FOR ReferencedSource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcClassificationReference : IfcExternalReference, IfcClassificationReferenceSelect, IfcClassificationSelect
	{
		public IfcClassificationReferenceSelect? ReferencedSource { get; set; }
		public IfcText? Description { get; set; }
		public IfcIdentifier? Sort { get; set; }
		public IfcClassificationReference() : base()
		{
		}
		public IfcClassificationReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name, IfcClassificationReferenceSelect ReferencedSource, IfcText Description, IfcIdentifier Sort) : base (Location, Identification, Name)
		{
			this.ReferencedSource = ReferencedSource;
			this.Description = Description;
			this.Sort = Sort;
		}
	}
	/// <summary>
	/// ENTITY IfcClosedShell
	/// <para>ENTITY IfcClosedShell</para>
	/// <para> SUBTYPE OF (IfcConnectedFaceSet);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcClosedShell : IfcConnectedFaceSet, IfcShell, IfcSolidOrShell
	{
		public IfcClosedShell() : base()
		{
		}
		public IfcClosedShell(List<IfcFace> CfsFaces) : base (CfsFaces)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcClothoid
	/// <para>ENTITY IfcClothoid</para>
	/// <para> SUBTYPE OF (IfcSpiral);</para>
	/// <para>	ClothoidConstant : IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcClothoid : IfcSpiral
	{
		public IfcLengthMeasure ClothoidConstant { get; set; }
		public IfcClothoid() : base()
		{
			ClothoidConstant = new IfcLengthMeasure();
		}
		public IfcClothoid(IfcAxis2Placement Position, IfcLengthMeasure ClothoidConstant) : base (Position)
		{
			this.ClothoidConstant = ClothoidConstant;
		}
	}
	/// <summary>
	/// ENTITY IfcCoil
	/// <para>ENTITY IfcCoil</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCoilTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCoilTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCoilTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCOILTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoil : IfcEnergyConversionDevice
	{
		public IfcCoilTypeEnum? PredefinedType { get; set; }
		public IfcCoil() : base()
		{
		}
		public IfcCoil(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCoilTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoilType
	/// <para>ENTITY IfcCoilType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcCoilTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCoilTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCoilTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoilType : IfcEnergyConversionDeviceType
	{
		public IfcCoilTypeEnum PredefinedType { get; set; }
		public IfcCoilType() : base()
		{
			PredefinedType = new IfcCoilTypeEnum();
		}
		public IfcCoilType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCoilTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcColourRgb
	/// <para>ENTITY IfcColourRgb</para>
	/// <para> SUBTYPE OF (IfcColourSpecification);</para>
	/// <para>	Red : IfcNormalisedRatioMeasure;</para>
	/// <para>	Green : IfcNormalisedRatioMeasure;</para>
	/// <para>	Blue : IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColourRgb : IfcColourSpecification, IfcColourOrFactor
	{
		public IfcNormalisedRatioMeasure Red { get; set; }
		public IfcNormalisedRatioMeasure Green { get; set; }
		public IfcNormalisedRatioMeasure Blue { get; set; }
		public IfcColourRgb() : base()
		{
			Red = new IfcNormalisedRatioMeasure();
			Green = new IfcNormalisedRatioMeasure();
			Blue = new IfcNormalisedRatioMeasure();
		}
		public IfcColourRgb(IfcLabel Name, IfcNormalisedRatioMeasure Red, IfcNormalisedRatioMeasure Green, IfcNormalisedRatioMeasure Blue) : base (Name)
		{
			this.Red = Red;
			this.Green = Green;
			this.Blue = Blue;
		}
	}
	/// <summary>
	/// ENTITY IfcColourRgbList
	/// <para>ENTITY IfcColourRgbList</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	ColourList : LIST [1:?] OF LIST [3:3] OF IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColourRgbList : IfcPresentationItem
	{
		public List<List<IfcNormalisedRatioMeasure >> ColourList { get; set; }
		public IfcColourRgbList() : base()
		{
			ColourList = new List<List<IfcNormalisedRatioMeasure >>();
		}
		public IfcColourRgbList(List<List<IfcNormalisedRatioMeasure >> ColourList) : base ()
		{
			this.ColourList = ColourList;
		}
	}
	/// <summary>
	/// ENTITY IfcColourSpecification
	/// <para>ENTITY IfcColourSpecification</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcColourRgb))</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcColourSpecification : IfcPresentationItem, IfcColour
	{
		public IfcLabel? Name { get; set; }
		public IfcColourSpecification() : base()
		{
		}
		public IfcColourSpecification(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcColumn
	/// <para>ENTITY IfcColumn</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcColumnTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcColumnTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcColumnTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCOLUMNTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColumn : IfcBuiltElement
	{
		public IfcColumnTypeEnum? PredefinedType { get; set; }
		public IfcColumn() : base()
		{
		}
		public IfcColumn(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcColumnTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcColumnType
	/// <para>ENTITY IfcColumnType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcColumnTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcColumnTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcColumnTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColumnType : IfcBuiltElementType
	{
		public IfcColumnTypeEnum PredefinedType { get; set; }
		public IfcColumnType() : base()
		{
			PredefinedType = new IfcColumnTypeEnum();
		}
		public IfcColumnType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcColumnTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCommunicationsAppliance
	/// <para>ENTITY IfcCommunicationsAppliance</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCommunicationsApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCommunicationsApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCommunicationsApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCOMMUNICATIONSAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCommunicationsAppliance : IfcFlowTerminal
	{
		public IfcCommunicationsApplianceTypeEnum? PredefinedType { get; set; }
		public IfcCommunicationsAppliance() : base()
		{
		}
		public IfcCommunicationsAppliance(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCommunicationsApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCommunicationsApplianceType
	/// <para>ENTITY IfcCommunicationsApplianceType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcCommunicationsApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCommunicationsApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCommunicationsApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCommunicationsApplianceType : IfcFlowTerminalType
	{
		public IfcCommunicationsApplianceTypeEnum PredefinedType { get; set; }
		public IfcCommunicationsApplianceType() : base()
		{
			PredefinedType = new IfcCommunicationsApplianceTypeEnum();
		}
		public IfcCommunicationsApplianceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCommunicationsApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcComplexProperty
	/// <para>ENTITY IfcComplexProperty</para>
	/// <para> SUBTYPE OF (IfcProperty);</para>
	/// <para>	UsageName : IfcIdentifier;</para>
	/// <para>	HasProperties : SET [1:?] OF IfcProperty;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : SIZEOF(QUERY(temp <* HasProperties | SELF :=: temp)) = 0;</para>
	/// <para>	WR22 : IfcUniquePropertyName(HasProperties);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcComplexProperty : IfcProperty
	{
		public IfcIdentifier UsageName { get; set; }
		public List<IfcProperty> HasProperties { get; set; }
		public IfcComplexProperty() : base()
		{
			UsageName = new IfcIdentifier();
			HasProperties = new List<IfcProperty>();
		}
		public IfcComplexProperty(IfcIdentifier Name, IfcText Specification, IfcIdentifier UsageName, List<IfcProperty> HasProperties) : base (Name, Specification)
		{
			this.UsageName = UsageName;
			this.HasProperties = HasProperties;
		}
	}
	/// <summary>
	/// ENTITY IfcComplexPropertyTemplate
	/// <para>ENTITY IfcComplexPropertyTemplate</para>
	/// <para> SUBTYPE OF (IfcPropertyTemplate);</para>
	/// <para>	UsageName : OPTIONAL IfcLabel;</para>
	/// <para>	TemplateType : OPTIONAL IfcComplexPropertyTemplateTypeEnum;</para>
	/// <para>	HasPropertyTemplates : OPTIONAL SET [1:?] OF IfcPropertyTemplate;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(temp <* HasPropertyTemplates | SELF :=: temp)) = 0;</para>
	/// <para>	UniquePropertyNames : IfcUniquePropertyTemplateNames(HasPropertyTemplates);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcComplexPropertyTemplate : IfcPropertyTemplate
	{
		public IfcLabel? UsageName { get; set; }
		public IfcComplexPropertyTemplateTypeEnum? TemplateType { get; set; }
		public List<IfcPropertyTemplate>? HasPropertyTemplates { get; set; }
		public IfcComplexPropertyTemplate() : base()
		{
		}
		public IfcComplexPropertyTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel UsageName, IfcComplexPropertyTemplateTypeEnum TemplateType, List<IfcPropertyTemplate> HasPropertyTemplates) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.UsageName = UsageName;
			this.TemplateType = TemplateType;
			this.HasPropertyTemplates = HasPropertyTemplates;
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeCurve
	/// <para>ENTITY IfcCompositeCurve</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCompositeCurveOnSurface</para>
	/// <para>	,IfcGradientCurve</para>
	/// <para>	,IfcSegmentedReferenceCurve))</para>
	/// <para> SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>	Segments : LIST [1:?] OF IfcSegment;</para>
	/// <para>	SelfIntersect : IfcLogical;</para>
	/// <para> DERIVE</para>
	/// <para>	 NSegments : IfcInteger := SIZEOF(Segments);</para>
	/// <para>	 ClosedCurve : IfcLogical := Segments[NSegments].Transition <> Discontinuous;</para>
	/// <para> WHERE</para>
	/// <para>	CurveContinuous : ((NOT ClosedCurve) AND (SIZEOF(QUERY(Temp <* Segments | Temp.Transition = Discontinuous)) = 1)) OR ((ClosedCurve) AND (SIZEOF(QUERY(Temp <* Segments | Temp.Transition = Discontinuous)) = 0));</para>
	/// <para>	SameDim : SIZEOF( QUERY( Temp <* Segments | Temp.Dim <> Segments[1].Dim)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeCurve : IfcBoundedCurve
	{
		public List<IfcSegment> Segments { get; set; }
		public IfcLogical SelfIntersect { get; set; }
		public IfcCompositeCurve() : base()
		{
			Segments = new List<IfcSegment>();
			SelfIntersect = new IfcLogical();
		}
		public IfcCompositeCurve(List<IfcSegment> Segments, IfcLogical SelfIntersect) : base ()
		{
			this.Segments = Segments;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeCurveOnSurface
	/// <para>ENTITY IfcCompositeCurveOnSurface</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBoundaryCurve))</para>
	/// <para> SUBTYPE OF (IfcCompositeCurve);</para>
	/// <para> DERIVE</para>
	/// <para>	 BasisSurface : SET [0:1] OF IfcSurface := IfcGetBasisSurface(SELF);</para>
	/// <para> WHERE</para>
	/// <para>	SameSurface : SIZEOF(BasisSurface) > 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeCurveOnSurface : IfcCompositeCurve, IfcCurveOnSurface
	{
		public IfcCompositeCurveOnSurface() : base()
		{
		}
		public IfcCompositeCurveOnSurface(List<IfcSegment> Segments, IfcLogical SelfIntersect) : base (Segments, SelfIntersect)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeCurveSegment
	/// <para>ENTITY IfcCompositeCurveSegment</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcReparametrisedCompositeCurveSegment))</para>
	/// <para> SUBTYPE OF (IfcSegment);</para>
	/// <para>	SameSense : IfcBoolean;</para>
	/// <para>	ParentCurve : IfcCurve;</para>
	/// <para> WHERE</para>
	/// <para>	ParentIsBoundedCurve : ('IFC4X3_ADD2.IFCBOUNDEDCURVE' IN TYPEOF(ParentCurve));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeCurveSegment : IfcSegment
	{
		public IfcBoolean SameSense { get; set; }
		public IfcCurve ParentCurve { get; set; }
		public IfcCompositeCurveSegment() : base()
		{
			SameSense = new IfcBoolean();
			ParentCurve = new IfcCurve();
		}
		public IfcCompositeCurveSegment(IfcTransitionCode Transition, IfcBoolean SameSense, IfcCurve ParentCurve) : base (Transition)
		{
			this.SameSense = SameSense;
			this.ParentCurve = ParentCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeProfileDef
	/// <para>ENTITY IfcCompositeProfileDef</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	Profiles : SET [2:?] OF IfcProfileDef;</para>
	/// <para>	Label : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	InvariantProfileType : SIZEOF(QUERY(temp <* Profiles | temp.ProfileType <> Profiles[1].ProfileType)) = 0;</para>
	/// <para>	NoRecursion : SIZEOF(QUERY(temp <* Profiles | 'IFC4X3_ADD2.IFCCOMPOSITEPROFILEDEF' IN TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeProfileDef : IfcProfileDef
	{
		public List<IfcProfileDef> Profiles { get; set; }
		public IfcLabel? Label { get; set; }
		public IfcCompositeProfileDef() : base()
		{
			Profiles = new List<IfcProfileDef>();
		}
		public IfcCompositeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, List<IfcProfileDef> Profiles, IfcLabel Label) : base (ProfileType, ProfileName)
		{
			this.Profiles = Profiles;
			this.Label = Label;
		}
	}
	/// <summary>
	/// ENTITY IfcCompressor
	/// <para>ENTITY IfcCompressor</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCompressorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCompressorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCompressorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCOMPRESSORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompressor : IfcFlowMovingDevice
	{
		public IfcCompressorTypeEnum? PredefinedType { get; set; }
		public IfcCompressor() : base()
		{
		}
		public IfcCompressor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCompressorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCompressorType
	/// <para>ENTITY IfcCompressorType</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDeviceType);</para>
	/// <para>	PredefinedType : IfcCompressorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCompressorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCompressorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompressorType : IfcFlowMovingDeviceType
	{
		public IfcCompressorTypeEnum PredefinedType { get; set; }
		public IfcCompressorType() : base()
		{
			PredefinedType = new IfcCompressorTypeEnum();
		}
		public IfcCompressorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCompressorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCondenser
	/// <para>ENTITY IfcCondenser</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCondenserTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCondenserTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCondenserTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCONDENSERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCondenser : IfcEnergyConversionDevice
	{
		public IfcCondenserTypeEnum? PredefinedType { get; set; }
		public IfcCondenser() : base()
		{
		}
		public IfcCondenser(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCondenserTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCondenserType
	/// <para>ENTITY IfcCondenserType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcCondenserTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCondenserTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCondenserTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCondenserType : IfcEnergyConversionDeviceType
	{
		public IfcCondenserTypeEnum PredefinedType { get; set; }
		public IfcCondenserType() : base()
		{
			PredefinedType = new IfcCondenserTypeEnum();
		}
		public IfcCondenserType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCondenserTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConic
	/// <para>ENTITY IfcConic</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCircle</para>
	/// <para>	,IfcEllipse))</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	Position : IfcAxis2Placement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConic : IfcCurve
	{
		public IfcAxis2Placement Position { get; set; }
		public IfcConic() : base()
		{
			Position = new IfcAxis2Placement();
		}
		public IfcConic(IfcAxis2Placement Position) : base ()
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectedFaceSet
	/// <para>ENTITY IfcConnectedFaceSet</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcClosedShell</para>
	/// <para>	,IfcOpenShell))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>	CfsFaces : SET [1:?] OF IfcFace;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectedFaceSet : IfcTopologicalRepresentationItem
	{
		public List<IfcFace> CfsFaces { get; set; }
		public IfcConnectedFaceSet() : base()
		{
			CfsFaces = new List<IfcFace>();
		}
		public IfcConnectedFaceSet(List<IfcFace> CfsFaces) : base ()
		{
			this.CfsFaces = CfsFaces;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionCurveGeometry
	/// <para>ENTITY IfcConnectionCurveGeometry</para>
	/// <para> SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>	CurveOnRelatingElement : IfcCurveOrEdgeCurve;</para>
	/// <para>	CurveOnRelatedElement : OPTIONAL IfcCurveOrEdgeCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionCurveGeometry : IfcConnectionGeometry
	{
		public IfcCurveOrEdgeCurve CurveOnRelatingElement { get; set; }
		public IfcCurveOrEdgeCurve? CurveOnRelatedElement { get; set; }
		public IfcConnectionCurveGeometry() : base()
		{
			CurveOnRelatingElement = new IfcCurveOrEdgeCurve();
		}
		public IfcConnectionCurveGeometry(IfcCurveOrEdgeCurve CurveOnRelatingElement, IfcCurveOrEdgeCurve CurveOnRelatedElement) : base ()
		{
			this.CurveOnRelatingElement = CurveOnRelatingElement;
			this.CurveOnRelatedElement = CurveOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionGeometry
	/// <para>ENTITY IfcConnectionGeometry</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcConnectionCurveGeometry</para>
	/// <para>	,IfcConnectionPointGeometry</para>
	/// <para>	,IfcConnectionSurfaceGeometry</para>
	/// <para>	,IfcConnectionVolumeGeometry));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConnectionGeometryENTITY
	{
		public IfcConnectionGeometry() : base()
		{
		}
		public IfcConnectionGeometry() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionPointEccentricity
	/// <para>ENTITY IfcConnectionPointEccentricity</para>
	/// <para> SUBTYPE OF (IfcConnectionPointGeometry);</para>
	/// <para>	EccentricityInX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	EccentricityInY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	EccentricityInZ : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionPointEccentricity : IfcConnectionPointGeometry
	{
		public IfcLengthMeasure? EccentricityInX { get; set; }
		public IfcLengthMeasure? EccentricityInY { get; set; }
		public IfcLengthMeasure? EccentricityInZ { get; set; }
		public IfcConnectionPointEccentricity() : base()
		{
		}
		public IfcConnectionPointEccentricity(IfcPointOrVertexPoint PointOnRelatingElement, IfcPointOrVertexPoint PointOnRelatedElement, IfcLengthMeasure EccentricityInX, IfcLengthMeasure EccentricityInY, IfcLengthMeasure EccentricityInZ) : base (PointOnRelatingElement, PointOnRelatedElement)
		{
			this.EccentricityInX = EccentricityInX;
			this.EccentricityInY = EccentricityInY;
			this.EccentricityInZ = EccentricityInZ;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionPointGeometry
	/// <para>ENTITY IfcConnectionPointGeometry</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcConnectionPointEccentricity))</para>
	/// <para> SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>	PointOnRelatingElement : IfcPointOrVertexPoint;</para>
	/// <para>	PointOnRelatedElement : OPTIONAL IfcPointOrVertexPoint;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionPointGeometry : IfcConnectionGeometry
	{
		public IfcPointOrVertexPoint PointOnRelatingElement { get; set; }
		public IfcPointOrVertexPoint? PointOnRelatedElement { get; set; }
		public IfcConnectionPointGeometry() : base()
		{
			PointOnRelatingElement = new IfcPointOrVertexPoint();
		}
		public IfcConnectionPointGeometry(IfcPointOrVertexPoint PointOnRelatingElement, IfcPointOrVertexPoint PointOnRelatedElement) : base ()
		{
			this.PointOnRelatingElement = PointOnRelatingElement;
			this.PointOnRelatedElement = PointOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionSurfaceGeometry
	/// <para>ENTITY IfcConnectionSurfaceGeometry</para>
	/// <para> SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>	SurfaceOnRelatingElement : IfcSurfaceOrFaceSurface;</para>
	/// <para>	SurfaceOnRelatedElement : OPTIONAL IfcSurfaceOrFaceSurface;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionSurfaceGeometry : IfcConnectionGeometry
	{
		public IfcSurfaceOrFaceSurface SurfaceOnRelatingElement { get; set; }
		public IfcSurfaceOrFaceSurface? SurfaceOnRelatedElement { get; set; }
		public IfcConnectionSurfaceGeometry() : base()
		{
			SurfaceOnRelatingElement = new IfcSurfaceOrFaceSurface();
		}
		public IfcConnectionSurfaceGeometry(IfcSurfaceOrFaceSurface SurfaceOnRelatingElement, IfcSurfaceOrFaceSurface SurfaceOnRelatedElement) : base ()
		{
			this.SurfaceOnRelatingElement = SurfaceOnRelatingElement;
			this.SurfaceOnRelatedElement = SurfaceOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionVolumeGeometry
	/// <para>ENTITY IfcConnectionVolumeGeometry</para>
	/// <para> SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>	VolumeOnRelatingElement : IfcSolidOrShell;</para>
	/// <para>	VolumeOnRelatedElement : OPTIONAL IfcSolidOrShell;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionVolumeGeometry : IfcConnectionGeometry
	{
		public IfcSolidOrShell VolumeOnRelatingElement { get; set; }
		public IfcSolidOrShell? VolumeOnRelatedElement { get; set; }
		public IfcConnectionVolumeGeometry() : base()
		{
			VolumeOnRelatingElement = new IfcSolidOrShell();
		}
		public IfcConnectionVolumeGeometry(IfcSolidOrShell VolumeOnRelatingElement, IfcSolidOrShell VolumeOnRelatedElement) : base ()
		{
			this.VolumeOnRelatingElement = VolumeOnRelatingElement;
			this.VolumeOnRelatedElement = VolumeOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConstraint
	/// <para>ENTITY IfcConstraint</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMetric</para>
	/// <para>	,IfcObjective));</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	ConstraintGrade : IfcConstraintEnum;</para>
	/// <para>	ConstraintSource : OPTIONAL IfcLabel;</para>
	/// <para>	CreatingActor : OPTIONAL IfcActorSelect;</para>
	/// <para>	CreationTime : OPTIONAL IfcDateTime;</para>
	/// <para>	UserDefinedGrade : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>	PropertiesForConstraint : SET [0:?] OF IfcResourceConstraintRelationship FOR RelatingConstraint;</para>
	/// <para> WHERE</para>
	/// <para>	WR11 : (ConstraintGrade <> IfcConstraintEnum.USERDEFINED) OR</para>
	/// <para>((ConstraintGrade = IfcConstraintEnum.USERDEFINED) AND EXISTS(SELF\IfcConstraint.UserDefinedGrade));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConstraintENTITY, IfcResourceObjectSelect
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcConstraintEnum ConstraintGrade { get; set; }
		public IfcLabel? ConstraintSource { get; set; }
		public IfcActorSelect? CreatingActor { get; set; }
		public IfcDateTime? CreationTime { get; set; }
		public IfcLabel? UserDefinedGrade { get; set; }
		public IfcConstraint() : base()
		{
			Name = new IfcLabel();
			ConstraintGrade = new IfcConstraintEnum();
		}
		public IfcConstraint(IfcLabel Name, IfcText Description, IfcConstraintEnum ConstraintGrade, IfcLabel ConstraintSource, IfcActorSelect CreatingActor, IfcDateTime CreationTime, IfcLabel UserDefinedGrade) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.ConstraintGrade = ConstraintGrade;
			this.ConstraintSource = ConstraintSource;
			this.CreatingActor = CreatingActor;
			this.CreationTime = CreationTime;
			this.UserDefinedGrade = UserDefinedGrade;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionEquipmentResource
	/// <para>ENTITY IfcConstructionEquipmentResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcConstructionEquipmentResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para>(PredefinedType <> IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) OR </para>
	/// <para>((PredefinedType = IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionEquipmentResource : IfcConstructionResource
	{
		public IfcConstructionEquipmentResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionEquipmentResource() : base()
		{
		}
		public IfcConstructionEquipmentResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionEquipmentResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionEquipmentResourceType
	/// <para>ENTITY IfcConstructionEquipmentResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcConstructionEquipmentResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionEquipmentResourceType : IfcConstructionResourceType
	{
		public IfcConstructionEquipmentResourceTypeEnum PredefinedType { get; set; }
		public IfcConstructionEquipmentResourceType() : base()
		{
			PredefinedType = new IfcConstructionEquipmentResourceTypeEnum();
		}
		public IfcConstructionEquipmentResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionEquipmentResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionMaterialResource
	/// <para>ENTITY IfcConstructionMaterialResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcConstructionMaterialResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcConstructionMaterialResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcConstructionMaterialResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionMaterialResource : IfcConstructionResource
	{
		public IfcConstructionMaterialResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionMaterialResource() : base()
		{
		}
		public IfcConstructionMaterialResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionMaterialResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionMaterialResourceType
	/// <para>ENTITY IfcConstructionMaterialResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcConstructionMaterialResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcConstructionMaterialResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionMaterialResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionMaterialResourceType : IfcConstructionResourceType
	{
		public IfcConstructionMaterialResourceTypeEnum PredefinedType { get; set; }
		public IfcConstructionMaterialResourceType() : base()
		{
			PredefinedType = new IfcConstructionMaterialResourceTypeEnum();
		}
		public IfcConstructionMaterialResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionMaterialResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionProductResource
	/// <para>ENTITY IfcConstructionProductResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcConstructionProductResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcConstructionProductResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcConstructionProductResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionProductResource : IfcConstructionResource
	{
		public IfcConstructionProductResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionProductResource() : base()
		{
		}
		public IfcConstructionProductResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionProductResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionProductResourceType
	/// <para>ENTITY IfcConstructionProductResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcConstructionProductResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcConstructionProductResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionProductResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionProductResourceType : IfcConstructionResourceType
	{
		public IfcConstructionProductResourceTypeEnum PredefinedType { get; set; }
		public IfcConstructionProductResourceType() : base()
		{
			PredefinedType = new IfcConstructionProductResourceTypeEnum();
		}
		public IfcConstructionProductResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionProductResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionResource
	/// <para>ENTITY IfcConstructionResource</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcConstructionEquipmentResource</para>
	/// <para>	,IfcConstructionMaterialResource</para>
	/// <para>	,IfcConstructionProductResource</para>
	/// <para>	,IfcCrewResource</para>
	/// <para>	,IfcLaborResource</para>
	/// <para>	,IfcSubContractResource))</para>
	/// <para> SUBTYPE OF (IfcResource);</para>
	/// <para>	Usage : OPTIONAL IfcResourceTime;</para>
	/// <para>	BaseCosts : OPTIONAL LIST [1:?] OF IfcAppliedValue;</para>
	/// <para>	BaseQuantity : OPTIONAL IfcPhysicalQuantity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConstructionResource : IfcResource
	{
		public IfcResourceTime? Usage { get; set; }
		public List<IfcAppliedValue>? BaseCosts { get; set; }
		public IfcPhysicalQuantity? BaseQuantity { get; set; }
		public IfcConstructionResource() : base()
		{
		}
		public IfcConstructionResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.Usage = Usage;
			this.BaseCosts = BaseCosts;
			this.BaseQuantity = BaseQuantity;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionResourceType
	/// <para>ENTITY IfcConstructionResourceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcConstructionEquipmentResourceType</para>
	/// <para>	,IfcConstructionMaterialResourceType</para>
	/// <para>	,IfcConstructionProductResourceType</para>
	/// <para>	,IfcCrewResourceType</para>
	/// <para>	,IfcLaborResourceType</para>
	/// <para>	,IfcSubContractResourceType))</para>
	/// <para> SUBTYPE OF (IfcTypeResource);</para>
	/// <para>	BaseCosts : OPTIONAL LIST [1:?] OF IfcAppliedValue;</para>
	/// <para>	BaseQuantity : OPTIONAL IfcPhysicalQuantity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConstructionResourceType : IfcTypeResource
	{
		public List<IfcAppliedValue>? BaseCosts { get; set; }
		public IfcPhysicalQuantity? BaseQuantity { get; set; }
		public IfcConstructionResourceType() : base()
		{
		}
		public IfcConstructionResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType)
		{
			this.BaseCosts = BaseCosts;
			this.BaseQuantity = BaseQuantity;
		}
	}
	/// <summary>
	/// ENTITY IfcContext
	/// <para>ENTITY IfcContext</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcProject</para>
	/// <para>	,IfcProjectLibrary))</para>
	/// <para> SUBTYPE OF (IfcObjectDefinition);</para>
	/// <para>	ObjectType : OPTIONAL IfcLabel;</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para>	Phase : OPTIONAL IfcLabel;</para>
	/// <para>	RepresentationContexts : OPTIONAL SET [1:?] OF IfcRepresentationContext;</para>
	/// <para>	UnitsInContext : OPTIONAL IfcUnitAssignment;</para>
	/// <para> INVERSE</para>
	/// <para>	IsDefinedBy : SET [0:?] OF IfcRelDefinesByProperties FOR RelatedObjects;</para>
	/// <para>	Declares : SET [0:?] OF IfcRelDeclares FOR RelatingContext;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcContext : IfcObjectDefinition
	{
		public IfcLabel? ObjectType { get; set; }
		public IfcLabel? LongName { get; set; }
		public IfcLabel? Phase { get; set; }
		public List<IfcRepresentationContext>? RepresentationContexts { get; set; }
		public IfcUnitAssignment? UnitsInContext { get; set; }
		public IfcContext() : base()
		{
		}
		public IfcContext(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcLabel Phase, List<IfcRepresentationContext> RepresentationContexts, IfcUnitAssignment UnitsInContext) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ObjectType = ObjectType;
			this.LongName = LongName;
			this.Phase = Phase;
			this.RepresentationContexts = RepresentationContexts;
			this.UnitsInContext = UnitsInContext;
		}
	}
	/// <summary>
	/// ENTITY IfcContextDependentUnit
	/// <para>ENTITY IfcContextDependentUnit</para>
	/// <para> SUBTYPE OF (IfcNamedUnit);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcContextDependentUnit : IfcNamedUnit, IfcResourceObjectSelect
	{
		public IfcLabel Name { get; set; }
		public IfcContextDependentUnit() : base()
		{
			Name = new IfcLabel();
		}
		public IfcContextDependentUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcLabel Name) : base (Dimensions, UnitType)
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcControl
	/// <para>ENTITY IfcControl</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcActionRequest</para>
	/// <para>	,IfcCostItem</para>
	/// <para>	,IfcCostSchedule</para>
	/// <para>	,IfcPerformanceHistory</para>
	/// <para>	,IfcPermit</para>
	/// <para>	,IfcProjectOrder</para>
	/// <para>	,IfcWorkCalendar</para>
	/// <para>	,IfcWorkControl))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	Controls : SET [0:?] OF IfcRelAssignsToControl FOR RelatingControl;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcControl : IfcObject
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcControl() : base()
		{
		}
		public IfcControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
		}
	}
	/// <summary>
	/// ENTITY IfcController
	/// <para>ENTITY IfcController</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcControllerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcControllerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcControllerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCONTROLLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcController : IfcDistributionControlElement
	{
		public IfcControllerTypeEnum? PredefinedType { get; set; }
		public IfcController() : base()
		{
		}
		public IfcController(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcControllerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcControllerType
	/// <para>ENTITY IfcControllerType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcControllerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcControllerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcControllerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcControllerType : IfcDistributionControlElementType
	{
		public IfcControllerTypeEnum PredefinedType { get; set; }
		public IfcControllerType() : base()
		{
			PredefinedType = new IfcControllerTypeEnum();
		}
		public IfcControllerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcControllerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConversionBasedUnit
	/// <para>ENTITY IfcConversionBasedUnit</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcConversionBasedUnitWithOffset))</para>
	/// <para> SUBTYPE OF (IfcNamedUnit);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	ConversionFactor : IfcMeasureWithUnit;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConversionBasedUnit : IfcNamedUnit, IfcResourceObjectSelect
	{
		public IfcLabel Name { get; set; }
		public IfcMeasureWithUnit ConversionFactor { get; set; }
		public IfcConversionBasedUnit() : base()
		{
			Name = new IfcLabel();
			ConversionFactor = new IfcMeasureWithUnit();
		}
		public IfcConversionBasedUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcLabel Name, IfcMeasureWithUnit ConversionFactor) : base (Dimensions, UnitType)
		{
			this.Name = Name;
			this.ConversionFactor = ConversionFactor;
		}
	}
	/// <summary>
	/// ENTITY IfcConversionBasedUnitWithOffset
	/// <para>ENTITY IfcConversionBasedUnitWithOffset</para>
	/// <para> SUBTYPE OF (IfcConversionBasedUnit);</para>
	/// <para>	ConversionOffset : IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConversionBasedUnitWithOffset : IfcConversionBasedUnit
	{
		public IfcReal ConversionOffset { get; set; }
		public IfcConversionBasedUnitWithOffset() : base()
		{
			ConversionOffset = new IfcReal();
		}
		public IfcConversionBasedUnitWithOffset(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcLabel Name, IfcMeasureWithUnit ConversionFactor, IfcReal ConversionOffset) : base (Dimensions, UnitType, Name, ConversionFactor)
		{
			this.ConversionOffset = ConversionOffset;
		}
	}
	/// <summary>
	/// ENTITY IfcConveyorSegment
	/// <para>ENTITY IfcConveyorSegment</para>
	/// <para> SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>	PredefinedType : OPTIONAL IfcConveyorSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcConveyorSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcConveyorSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCONVEYORSEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConveyorSegment : IfcFlowSegment
	{
		public IfcConveyorSegmentTypeEnum? PredefinedType { get; set; }
		public IfcConveyorSegment() : base()
		{
		}
		public IfcConveyorSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcConveyorSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConveyorSegmentType
	/// <para>ENTITY IfcConveyorSegmentType</para>
	/// <para> SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>	PredefinedType : IfcConveyorSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcConveyorSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcConveyorSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConveyorSegmentType : IfcFlowSegmentType
	{
		public IfcConveyorSegmentTypeEnum PredefinedType { get; set; }
		public IfcConveyorSegmentType() : base()
		{
			PredefinedType = new IfcConveyorSegmentTypeEnum();
		}
		public IfcConveyorSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcConveyorSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCooledBeam
	/// <para>ENTITY IfcCooledBeam</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCooledBeamTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCooledBeamTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCooledBeamTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCOOLEDBEAMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCooledBeam : IfcEnergyConversionDevice
	{
		public IfcCooledBeamTypeEnum? PredefinedType { get; set; }
		public IfcCooledBeam() : base()
		{
		}
		public IfcCooledBeam(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCooledBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCooledBeamType
	/// <para>ENTITY IfcCooledBeamType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcCooledBeamTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCooledBeamTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCooledBeamTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCooledBeamType : IfcEnergyConversionDeviceType
	{
		public IfcCooledBeamTypeEnum PredefinedType { get; set; }
		public IfcCooledBeamType() : base()
		{
			PredefinedType = new IfcCooledBeamTypeEnum();
		}
		public IfcCooledBeamType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCooledBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoolingTower
	/// <para>ENTITY IfcCoolingTower</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCoolingTowerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCoolingTowerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCoolingTowerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCOOLINGTOWERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoolingTower : IfcEnergyConversionDevice
	{
		public IfcCoolingTowerTypeEnum? PredefinedType { get; set; }
		public IfcCoolingTower() : base()
		{
		}
		public IfcCoolingTower(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCoolingTowerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoolingTowerType
	/// <para>ENTITY IfcCoolingTowerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcCoolingTowerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCoolingTowerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCoolingTowerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoolingTowerType : IfcEnergyConversionDeviceType
	{
		public IfcCoolingTowerTypeEnum PredefinedType { get; set; }
		public IfcCoolingTowerType() : base()
		{
			PredefinedType = new IfcCoolingTowerTypeEnum();
		}
		public IfcCoolingTowerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCoolingTowerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoordinateOperation
	/// <para>ENTITY IfcCoordinateOperation</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMapConversion</para>
	/// <para>	,IfcRigidOperation));</para>
	/// <para>	SourceCRS : IfcCoordinateReferenceSystemSelect;</para>
	/// <para>	TargetCRS : IfcCoordinateReferenceSystem;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCoordinateOperationENTITY
	{
		public IfcCoordinateReferenceSystemSelect SourceCRS { get; set; }
		public IfcCoordinateReferenceSystem TargetCRS { get; set; }
		public IfcCoordinateOperation() : base()
		{
			SourceCRS = new IfcCoordinateReferenceSystemSelect();
			TargetCRS = new IfcCoordinateReferenceSystem();
		}
		public IfcCoordinateOperation(IfcCoordinateReferenceSystemSelect SourceCRS, IfcCoordinateReferenceSystem TargetCRS) : base ()
		{
			this.SourceCRS = SourceCRS;
			this.TargetCRS = TargetCRS;
		}
	}
	/// <summary>
	/// ENTITY IfcCoordinateReferenceSystem
	/// <para>ENTITY IfcCoordinateReferenceSystem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcGeographicCRS</para>
	/// <para>	,IfcProjectedCRS));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	GeodeticDatum : OPTIONAL IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	HasCoordinateOperation : SET [0:1] OF IfcCoordinateOperation FOR SourceCRS;</para>
	/// <para>	WellKnownText : SET [0:1] OF IfcWellKnownText FOR CoordinateReferenceSystem;</para>
	/// <para> WHERE</para>
	/// <para>	NameOrWKT : (HIINDEX(WellKnownText) = 1) OR EXISTS(Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCoordinateReferenceSystemENTITY, IfcCoordinateReferenceSystemSelect
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcIdentifier? GeodeticDatum { get; set; }
		public IfcCoordinateReferenceSystem() : base()
		{
		}
		public IfcCoordinateReferenceSystem(IfcLabel Name, IfcText Description, IfcIdentifier GeodeticDatum) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.GeodeticDatum = GeodeticDatum;
		}
	}
	/// <summary>
	/// ENTITY IfcCosineSpiral
	/// <para>ENTITY IfcCosineSpiral</para>
	/// <para> SUBTYPE OF (IfcSpiral);</para>
	/// <para>	CosineTerm : IfcLengthMeasure;</para>
	/// <para>	ConstantTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCosineSpiral : IfcSpiral
	{
		public IfcLengthMeasure CosineTerm { get; set; }
		public IfcLengthMeasure? ConstantTerm { get; set; }
		public IfcCosineSpiral() : base()
		{
			CosineTerm = new IfcLengthMeasure();
		}
		public IfcCosineSpiral(IfcAxis2Placement Position, IfcLengthMeasure CosineTerm, IfcLengthMeasure ConstantTerm) : base (Position)
		{
			this.CosineTerm = CosineTerm;
			this.ConstantTerm = ConstantTerm;
		}
	}
	/// <summary>
	/// ENTITY IfcCostItem
	/// <para>ENTITY IfcCostItem</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCostItemTypeEnum;</para>
	/// <para>	CostValues : OPTIONAL LIST [1:?] OF IfcCostValue;</para>
	/// <para>	CostQuantities : OPTIONAL LIST [1:?] OF IfcPhysicalQuantity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCostItem : IfcControl
	{
		public IfcCostItemTypeEnum? PredefinedType { get; set; }
		public List<IfcCostValue>? CostValues { get; set; }
		public List<IfcPhysicalQuantity>? CostQuantities { get; set; }
		public IfcCostItem() : base()
		{
		}
		public IfcCostItem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcCostItemTypeEnum PredefinedType, List<IfcCostValue> CostValues, List<IfcPhysicalQuantity> CostQuantities) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.CostValues = CostValues;
			this.CostQuantities = CostQuantities;
		}
	}
	/// <summary>
	/// ENTITY IfcCostSchedule
	/// <para>ENTITY IfcCostSchedule</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCostScheduleTypeEnum;</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	SubmittedOn : OPTIONAL IfcDateTime;</para>
	/// <para>	UpdateDate : OPTIONAL IfcDateTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCostSchedule : IfcControl
	{
		public IfcCostScheduleTypeEnum? PredefinedType { get; set; }
		public IfcLabel? Status { get; set; }
		public IfcDateTime? SubmittedOn { get; set; }
		public IfcDateTime? UpdateDate { get; set; }
		public IfcCostSchedule() : base()
		{
		}
		public IfcCostSchedule(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcCostScheduleTypeEnum PredefinedType, IfcLabel Status, IfcDateTime SubmittedOn, IfcDateTime UpdateDate) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.SubmittedOn = SubmittedOn;
			this.UpdateDate = UpdateDate;
		}
	}
	/// <summary>
	/// ENTITY IfcCostValue
	/// <para>ENTITY IfcCostValue</para>
	/// <para> SUBTYPE OF (IfcAppliedValue);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCostValue : IfcAppliedValue
	{
		public IfcCostValue() : base()
		{
		}
		public IfcCostValue(IfcLabel Name, IfcText Description, IfcAppliedValueSelect AppliedValue, IfcMeasureWithUnit UnitBasis, IfcDate ApplicableDate, IfcDate FixedUntilDate, IfcLabel Category, IfcLabel Condition, IfcArithmeticOperatorEnum ArithmeticOperator, List<IfcAppliedValue> Components) : base (Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCourse
	/// <para>ENTITY IfcCourse</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCourseTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCourseTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCourseTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCOURSETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCourse : IfcBuiltElement
	{
		public IfcCourseTypeEnum? PredefinedType { get; set; }
		public IfcCourse() : base()
		{
		}
		public IfcCourse(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCourseTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCourseType
	/// <para>ENTITY IfcCourseType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcCourseTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCourseTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCourseTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCourseType : IfcBuiltElementType
	{
		public IfcCourseTypeEnum PredefinedType { get; set; }
		public IfcCourseType() : base()
		{
			PredefinedType = new IfcCourseTypeEnum();
		}
		public IfcCourseType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCourseTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCovering
	/// <para>ENTITY IfcCovering</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCoveringTypeEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	CoversSpaces : SET [0:1] OF IfcRelCoversSpaces FOR RelatedCoverings;</para>
	/// <para>	CoversElements : SET [0:1] OF IfcRelCoversBldgElements FOR RelatedCoverings;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCoveringTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCoveringTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCOVERINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCovering : IfcBuiltElement
	{
		public IfcCoveringTypeEnum? PredefinedType { get; set; }
		public IfcCovering() : base()
		{
		}
		public IfcCovering(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCoveringTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoveringType
	/// <para>ENTITY IfcCoveringType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcCoveringTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCoveringTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCoveringTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoveringType : IfcBuiltElementType
	{
		public IfcCoveringTypeEnum PredefinedType { get; set; }
		public IfcCoveringType() : base()
		{
			PredefinedType = new IfcCoveringTypeEnum();
		}
		public IfcCoveringType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCoveringTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCrewResource
	/// <para>ENTITY IfcCrewResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCrewResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCrewResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCrewResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCrewResource : IfcConstructionResource
	{
		public IfcCrewResourceTypeEnum? PredefinedType { get; set; }
		public IfcCrewResource() : base()
		{
		}
		public IfcCrewResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcCrewResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCrewResourceType
	/// <para>ENTITY IfcCrewResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcCrewResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCrewResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCrewResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCrewResourceType : IfcConstructionResourceType
	{
		public IfcCrewResourceTypeEnum PredefinedType { get; set; }
		public IfcCrewResourceType() : base()
		{
			PredefinedType = new IfcCrewResourceTypeEnum();
		}
		public IfcCrewResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcCrewResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCsgPrimitive3D
	/// <para>ENTITY IfcCsgPrimitive3D</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBlock</para>
	/// <para>	,IfcRectangularPyramid</para>
	/// <para>	,IfcRightCircularCone</para>
	/// <para>	,IfcRightCircularCylinder</para>
	/// <para>	,IfcSphere))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Position : IfcAxis2Placement3D;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCsgPrimitive3D : IfcGeometricRepresentationItem, IfcBooleanOperand, IfcCsgSelect
	{
		public IfcAxis2Placement3D Position { get; set; }
		public IfcCsgPrimitive3D() : base()
		{
			Position = new IfcAxis2Placement3D();
		}
		public IfcCsgPrimitive3D(IfcAxis2Placement3D Position) : base ()
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcCsgSolid
	/// <para>ENTITY IfcCsgSolid</para>
	/// <para> SUBTYPE OF (IfcSolidModel);</para>
	/// <para>	TreeRootExpression : IfcCsgSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCsgSolid : IfcSolidModel
	{
		public IfcCsgSelect TreeRootExpression { get; set; }
		public IfcCsgSolid() : base()
		{
			TreeRootExpression = new IfcCsgSelect();
		}
		public IfcCsgSolid(IfcCsgSelect TreeRootExpression) : base ()
		{
			this.TreeRootExpression = TreeRootExpression;
		}
	}
	/// <summary>
	/// ENTITY IfcCurrencyRelationship
	/// <para>ENTITY IfcCurrencyRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingMonetaryUnit : IfcMonetaryUnit;</para>
	/// <para>	RelatedMonetaryUnit : IfcMonetaryUnit;</para>
	/// <para>	ExchangeRate : IfcPositiveRatioMeasure;</para>
	/// <para>	RateDateTime : OPTIONAL IfcDateTime;</para>
	/// <para>	RateSource : OPTIONAL IfcLibraryInformation;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurrencyRelationship : IfcResourceLevelRelationship
	{
		public IfcMonetaryUnit RelatingMonetaryUnit { get; set; }
		public IfcMonetaryUnit RelatedMonetaryUnit { get; set; }
		public IfcPositiveRatioMeasure ExchangeRate { get; set; }
		public IfcDateTime? RateDateTime { get; set; }
		public IfcLibraryInformation? RateSource { get; set; }
		public IfcCurrencyRelationship() : base()
		{
			RelatingMonetaryUnit = new IfcMonetaryUnit();
			RelatedMonetaryUnit = new IfcMonetaryUnit();
			ExchangeRate = new IfcPositiveRatioMeasure();
		}
		public IfcCurrencyRelationship(IfcLabel Name, IfcText Description, IfcMonetaryUnit RelatingMonetaryUnit, IfcMonetaryUnit RelatedMonetaryUnit, IfcPositiveRatioMeasure ExchangeRate, IfcDateTime RateDateTime, IfcLibraryInformation RateSource) : base (Name, Description)
		{
			this.RelatingMonetaryUnit = RelatingMonetaryUnit;
			this.RelatedMonetaryUnit = RelatedMonetaryUnit;
			this.ExchangeRate = ExchangeRate;
			this.RateDateTime = RateDateTime;
			this.RateSource = RateSource;
		}
	}
	/// <summary>
	/// ENTITY IfcCurtainWall
	/// <para>ENTITY IfcCurtainWall</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCurtainWallTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCurtainWallTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCurtainWallTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCCURTAINWALLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurtainWall : IfcBuiltElement
	{
		public IfcCurtainWallTypeEnum? PredefinedType { get; set; }
		public IfcCurtainWall() : base()
		{
		}
		public IfcCurtainWall(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCurtainWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCurtainWallType
	/// <para>ENTITY IfcCurtainWallType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcCurtainWallTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCurtainWallTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCurtainWallTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurtainWallType : IfcBuiltElementType
	{
		public IfcCurtainWallTypeEnum PredefinedType { get; set; }
		public IfcCurtainWallType() : base()
		{
			PredefinedType = new IfcCurtainWallTypeEnum();
		}
		public IfcCurtainWallType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCurtainWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCurve
	/// <para>ENTITY IfcCurve</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBoundedCurve</para>
	/// <para>	,IfcConic</para>
	/// <para>	,IfcLine</para>
	/// <para>	,IfcOffsetCurve</para>
	/// <para>	,IfcPcurve</para>
	/// <para>	,IfcPolynomialCurve</para>
	/// <para>	,IfcSpiral</para>
	/// <para>	,IfcSurfaceCurve))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := IfcCurveDim(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCurve : IfcGeometricRepresentationItem, IfcGeometricSetSelect
	{
		public IfcCurve() : base()
		{
		}
		public IfcCurve() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCurveBoundedPlane
	/// <para>ENTITY IfcCurveBoundedPlane</para>
	/// <para> SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>	BasisSurface : IfcPlane;</para>
	/// <para>	OuterBoundary : IfcCurve;</para>
	/// <para>	InnerBoundaries : SET [0:?] OF IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveBoundedPlane : IfcBoundedSurface
	{
		public IfcPlane BasisSurface { get; set; }
		public IfcCurve OuterBoundary { get; set; }
		public List<IfcCurve> InnerBoundaries { get; set; }
		public IfcCurveBoundedPlane() : base()
		{
			BasisSurface = new IfcPlane();
			OuterBoundary = new IfcCurve();
			InnerBoundaries = new List<IfcCurve>();
		}
		public IfcCurveBoundedPlane(IfcPlane BasisSurface, IfcCurve OuterBoundary, List<IfcCurve> InnerBoundaries) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.OuterBoundary = OuterBoundary;
			this.InnerBoundaries = InnerBoundaries;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveBoundedSurface
	/// <para>ENTITY IfcCurveBoundedSurface</para>
	/// <para> SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>	BasisSurface : IfcSurface;</para>
	/// <para>	Boundaries : SET [1:?] OF IfcBoundaryCurve;</para>
	/// <para>	ImplicitOuter : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveBoundedSurface : IfcBoundedSurface
	{
		public IfcSurface BasisSurface { get; set; }
		public List<IfcBoundaryCurve> Boundaries { get; set; }
		public IfcBoolean ImplicitOuter { get; set; }
		public IfcCurveBoundedSurface() : base()
		{
			BasisSurface = new IfcSurface();
			Boundaries = new List<IfcBoundaryCurve>();
			ImplicitOuter = new IfcBoolean();
		}
		public IfcCurveBoundedSurface(IfcSurface BasisSurface, List<IfcBoundaryCurve> Boundaries, IfcBoolean ImplicitOuter) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.Boundaries = Boundaries;
			this.ImplicitOuter = ImplicitOuter;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveSegment
	/// <para>ENTITY IfcCurveSegment</para>
	/// <para> SUBTYPE OF (IfcSegment);</para>
	/// <para>	Placement : IfcPlacement;</para>
	/// <para>	SegmentStart : IfcCurveMeasureSelect;</para>
	/// <para>	SegmentLength : IfcCurveMeasureSelect;</para>
	/// <para>	ParentCurve : IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveSegment : IfcSegment
	{
		public IfcPlacement Placement { get; set; }
		public IfcCurveMeasureSelect SegmentStart { get; set; }
		public IfcCurveMeasureSelect SegmentLength { get; set; }
		public IfcCurve ParentCurve { get; set; }
		public IfcCurveSegment() : base()
		{
			Placement = new IfcPlacement();
			SegmentStart = new IfcCurveMeasureSelect();
			SegmentLength = new IfcCurveMeasureSelect();
			ParentCurve = new IfcCurve();
		}
		public IfcCurveSegment(IfcTransitionCode Transition, IfcPlacement Placement, IfcCurveMeasureSelect SegmentStart, IfcCurveMeasureSelect SegmentLength, IfcCurve ParentCurve) : base (Transition)
		{
			this.Placement = Placement;
			this.SegmentStart = SegmentStart;
			this.SegmentLength = SegmentLength;
			this.ParentCurve = ParentCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyle
	/// <para>ENTITY IfcCurveStyle</para>
	/// <para> SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>	CurveFont : OPTIONAL IfcCurveFontOrScaledCurveFontSelect;</para>
	/// <para>	CurveWidth : OPTIONAL IfcSizeSelect;</para>
	/// <para>	CurveColour : OPTIONAL IfcColour;</para>
	/// <para>	ModelOrDraughting : OPTIONAL IfcBoolean;</para>
	/// <para> WHERE</para>
	/// <para>	IdentifiableCurveStyle : EXISTS(CurveFont) OR EXISTS(CurveWidth) OR EXISTS(CurveColour);</para>
	/// <para>	MeasureOfWidth : (NOT(EXISTS(CurveWidth))) OR</para>
	/// <para>('IFC4X3_ADD2.IFCPOSITIVELENGTHMEASURE' IN TYPEOF(CurveWidth)) OR </para>
	/// <para> (('IFC4X3_ADD2.IFCDESCRIPTIVEMEASURE' IN TYPEOF(CurveWidth)) AND</para>
	/// <para> (CurveWidth = 'by layer'));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyle : IfcPresentationStyle
	{
		public IfcCurveFontOrScaledCurveFontSelect? CurveFont { get; set; }
		public IfcSizeSelect? CurveWidth { get; set; }
		public IfcColour? CurveColour { get; set; }
		public IfcBoolean? ModelOrDraughting { get; set; }
		public IfcCurveStyle() : base()
		{
		}
		public IfcCurveStyle(IfcLabel Name, IfcCurveFontOrScaledCurveFontSelect CurveFont, IfcSizeSelect CurveWidth, IfcColour CurveColour, IfcBoolean ModelOrDraughting) : base (Name)
		{
			this.CurveFont = CurveFont;
			this.CurveWidth = CurveWidth;
			this.CurveColour = CurveColour;
			this.ModelOrDraughting = ModelOrDraughting;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyleFont
	/// <para>ENTITY IfcCurveStyleFont</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	PatternList : LIST [1:?] OF IfcCurveStyleFontPattern;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyleFont : IfcPresentationItem, IfcCurveStyleFontSelect
	{
		public IfcLabel? Name { get; set; }
		public List<IfcCurveStyleFontPattern> PatternList { get; set; }
		public IfcCurveStyleFont() : base()
		{
			PatternList = new List<IfcCurveStyleFontPattern>();
		}
		public IfcCurveStyleFont(IfcLabel Name, List<IfcCurveStyleFontPattern> PatternList) : base ()
		{
			this.Name = Name;
			this.PatternList = PatternList;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyleFontAndScaling
	/// <para>ENTITY IfcCurveStyleFontAndScaling</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	CurveStyleFont : IfcCurveStyleFontSelect;</para>
	/// <para>	CurveFontScaling : IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyleFontAndScaling : IfcPresentationItem, IfcCurveFontOrScaledCurveFontSelect
	{
		public IfcLabel? Name { get; set; }
		public IfcCurveStyleFontSelect CurveStyleFont { get; set; }
		public IfcPositiveRatioMeasure CurveFontScaling { get; set; }
		public IfcCurveStyleFontAndScaling() : base()
		{
			CurveStyleFont = new IfcCurveStyleFontSelect();
			CurveFontScaling = new IfcPositiveRatioMeasure();
		}
		public IfcCurveStyleFontAndScaling(IfcLabel Name, IfcCurveStyleFontSelect CurveStyleFont, IfcPositiveRatioMeasure CurveFontScaling) : base ()
		{
			this.Name = Name;
			this.CurveStyleFont = CurveStyleFont;
			this.CurveFontScaling = CurveFontScaling;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyleFontPattern
	/// <para>ENTITY IfcCurveStyleFontPattern</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	VisibleSegmentLength : IfcLengthMeasure;</para>
	/// <para>	InvisibleSegmentLength : IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	VisibleLengthGreaterEqualZero : VisibleSegmentLength >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyleFontPattern : IfcPresentationItem
	{
		public IfcLengthMeasure VisibleSegmentLength { get; set; }
		public IfcPositiveLengthMeasure InvisibleSegmentLength { get; set; }
		public IfcCurveStyleFontPattern() : base()
		{
			VisibleSegmentLength = new IfcLengthMeasure();
			InvisibleSegmentLength = new IfcPositiveLengthMeasure();
		}
		public IfcCurveStyleFontPattern(IfcLengthMeasure VisibleSegmentLength, IfcPositiveLengthMeasure InvisibleSegmentLength) : base ()
		{
			this.VisibleSegmentLength = VisibleSegmentLength;
			this.InvisibleSegmentLength = InvisibleSegmentLength;
		}
	}
	/// <summary>
	/// ENTITY IfcCylindricalSurface
	/// <para>ENTITY IfcCylindricalSurface</para>
	/// <para> SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCylindricalSurface : IfcElementarySurface
	{
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcCylindricalSurface() : base()
		{
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcCylindricalSurface(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcDamper
	/// <para>ENTITY IfcDamper</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDamperTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcDamperTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDamperTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCDAMPERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDamper : IfcFlowController
	{
		public IfcDamperTypeEnum? PredefinedType { get; set; }
		public IfcDamper() : base()
		{
		}
		public IfcDamper(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDamperTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDamperType
	/// <para>ENTITY IfcDamperType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcDamperTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDamperTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDamperTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDamperType : IfcFlowControllerType
	{
		public IfcDamperTypeEnum PredefinedType { get; set; }
		public IfcDamperType() : base()
		{
			PredefinedType = new IfcDamperTypeEnum();
		}
		public IfcDamperType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDamperTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDeepFoundation
	/// <para>ENTITY IfcDeepFoundation</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCaissonFoundation</para>
	/// <para>	,IfcPile))</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para> WHERE</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCDEEPFOUNDATIONTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDeepFoundation : IfcBuiltElement
	{
		public IfcDeepFoundation() : base()
		{
		}
		public IfcDeepFoundation(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDeepFoundationType
	/// <para>ENTITY IfcDeepFoundationType</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCaissonFoundationType</para>
	/// <para>	,IfcPileType))</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDeepFoundationType : IfcBuiltElementType
	{
		public IfcDeepFoundationType() : base()
		{
		}
		public IfcDeepFoundationType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDerivedProfileDef
	/// <para>ENTITY IfcDerivedProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMirroredProfileDef))</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	ParentProfile : IfcProfileDef;</para>
	/// <para>	Operator : IfcCartesianTransformationOperator2D;</para>
	/// <para>	Label : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	InvariantProfileType : SELF\IfcProfileDef.ProfileType = ParentProfile.ProfileType;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDerivedProfileDef : IfcProfileDef
	{
		public IfcProfileDef ParentProfile { get; set; }
		public IfcCartesianTransformationOperator2D Operator { get; set; }
		public IfcLabel? Label { get; set; }
		public IfcDerivedProfileDef() : base()
		{
			ParentProfile = new IfcProfileDef();
			Operator = new IfcCartesianTransformationOperator2D();
		}
		public IfcDerivedProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcProfileDef ParentProfile, IfcCartesianTransformationOperator2D Operator, IfcLabel Label) : base (ProfileType, ProfileName)
		{
			this.ParentProfile = ParentProfile;
			this.Operator = Operator;
			this.Label = Label;
		}
	}
	/// <summary>
	/// ENTITY IfcDerivedUnit;
	/// <para>ENTITY IfcDerivedUnit;</para>
	/// <para>	Elements : SET [1:?] OF IfcDerivedUnitElement;</para>
	/// <para>	UnitType : IfcDerivedUnitEnum;</para>
	/// <para>	UserDefinedType : OPTIONAL IfcLabel;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dimensions : IfcDimensionalExponents := IfcDeriveDimensionalExponents(Elements);</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : (SIZEOF (Elements) > 1) OR ((SIZEOF (Elements) = 1) AND (Elements[1].Exponent <> 1 ));</para>
	/// <para>	WR2 : (UnitType <> IfcDerivedUnitEnum.USERDEFINED) OR</para>
	/// <para>((UnitType = IfcDerivedUnitEnum.USERDEFINED) AND </para>
	/// <para> (EXISTS(SELF.UserDefinedType)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDerivedUnitENTITY, IfcUnit
	{
		public List<IfcDerivedUnitElement> Elements { get; set; }
		public IfcDerivedUnitEnum UnitType { get; set; }
		public IfcLabel? UserDefinedType { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcDerivedUnit() : base()
		{
			Elements = new List<IfcDerivedUnitElement>();
			UnitType = new IfcDerivedUnitEnum();
		}
		public IfcDerivedUnit(List<IfcDerivedUnitElement> Elements, IfcDerivedUnitEnum UnitType, IfcLabel UserDefinedType, IfcLabel Name) : base ()
		{
			this.Elements = Elements;
			this.UnitType = UnitType;
			this.UserDefinedType = UserDefinedType;
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcDerivedUnitElement;
	/// <para>ENTITY IfcDerivedUnitElement;</para>
	/// <para>	Unit : IfcNamedUnit;</para>
	/// <para>	Exponent : INTEGER;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDerivedUnitElementENTITY
	{
		public IfcNamedUnit Unit { get; set; }
		public INTEGER Exponent { get; set; }
		public IfcDerivedUnitElement() : base()
		{
			Unit = new IfcNamedUnit();
			Exponent = new INTEGER();
		}
		public IfcDerivedUnitElement(IfcNamedUnit Unit, INTEGER Exponent) : base ()
		{
			this.Unit = Unit;
			this.Exponent = Exponent;
		}
	}
	/// <summary>
	/// ENTITY IfcDimensionalExponents;
	/// <para>ENTITY IfcDimensionalExponents;</para>
	/// <para>	LengthExponent : INTEGER;</para>
	/// <para>	MassExponent : INTEGER;</para>
	/// <para>	TimeExponent : INTEGER;</para>
	/// <para>	ElectricCurrentExponent : INTEGER;</para>
	/// <para>	ThermodynamicTemperatureExponent : INTEGER;</para>
	/// <para>	AmountOfSubstanceExponent : INTEGER;</para>
	/// <para>	LuminousIntensityExponent : INTEGER;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDimensionalExponentsENTITY
	{
		public INTEGER LengthExponent { get; set; }
		public INTEGER MassExponent { get; set; }
		public INTEGER TimeExponent { get; set; }
		public INTEGER ElectricCurrentExponent { get; set; }
		public INTEGER ThermodynamicTemperatureExponent { get; set; }
		public INTEGER AmountOfSubstanceExponent { get; set; }
		public INTEGER LuminousIntensityExponent { get; set; }
		public IfcDimensionalExponents() : base()
		{
			LengthExponent = new INTEGER();
			MassExponent = new INTEGER();
			TimeExponent = new INTEGER();
			ElectricCurrentExponent = new INTEGER();
			ThermodynamicTemperatureExponent = new INTEGER();
			AmountOfSubstanceExponent = new INTEGER();
			LuminousIntensityExponent = new INTEGER();
		}
		public IfcDimensionalExponents(INTEGER LengthExponent, INTEGER MassExponent, INTEGER TimeExponent, INTEGER ElectricCurrentExponent, INTEGER ThermodynamicTemperatureExponent, INTEGER AmountOfSubstanceExponent, INTEGER LuminousIntensityExponent) : base ()
		{
			this.LengthExponent = LengthExponent;
			this.MassExponent = MassExponent;
			this.TimeExponent = TimeExponent;
			this.ElectricCurrentExponent = ElectricCurrentExponent;
			this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent;
			this.AmountOfSubstanceExponent = AmountOfSubstanceExponent;
			this.LuminousIntensityExponent = LuminousIntensityExponent;
		}
	}
	/// <summary>
	/// ENTITY IfcDirection
	/// <para>ENTITY IfcDirection</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	DirectionRatios : LIST [2:3] OF IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := HIINDEX(DirectionRatios);</para>
	/// <para> WHERE</para>
	/// <para>	MagnitudeGreaterZero : SIZEOF(QUERY(Tmp <* DirectionRatios | Tmp <> 0.0)) > 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDirection : IfcGeometricRepresentationItem, IfcGridPlacementDirectionSelect, IfcVectorOrDirection
	{
		public List<IfcReal> DirectionRatios { get; set; }
		public IfcDirection() : base()
		{
			DirectionRatios = new List<IfcReal>();
		}
		public IfcDirection(List<IfcReal> DirectionRatios) : base ()
		{
			this.DirectionRatios = DirectionRatios;
		}
	}
	/// <summary>
	/// ENTITY IfcDirectrixCurveSweptAreaSolid
	/// <para>ENTITY IfcDirectrixCurveSweptAreaSolid</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcFixedReferenceSweptAreaSolid</para>
	/// <para>	,IfcSurfaceCurveSweptAreaSolid))</para>
	/// <para> SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>	Directrix : IfcCurve;</para>
	/// <para>	StartParam : OPTIONAL IfcCurveMeasureSelect;</para>
	/// <para>	EndParam : OPTIONAL IfcCurveMeasureSelect;</para>
	/// <para> WHERE</para>
	/// <para>	DirectrixBounded : (EXISTS(StartParam) AND EXISTS(EndParam)) OR </para>
	/// <para>(SIZEOF(['IFC4X3_ADD2.IFCCONIC', 'IFC4X3_ADD2.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcDirectrixCurveSweptAreaSolid : IfcSweptAreaSolid
	{
		public IfcCurve Directrix { get; set; }
		public IfcCurveMeasureSelect? StartParam { get; set; }
		public IfcCurveMeasureSelect? EndParam { get; set; }
		public IfcDirectrixCurveSweptAreaSolid() : base()
		{
			Directrix = new IfcCurve();
		}
		public IfcDirectrixCurveSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcCurve Directrix, IfcCurveMeasureSelect StartParam, IfcCurveMeasureSelect EndParam) : base (SweptArea, Position)
		{
			this.Directrix = Directrix;
			this.StartParam = StartParam;
			this.EndParam = EndParam;
		}
	}
	/// <summary>
	/// ENTITY IfcDirectrixDerivedReferenceSweptAreaSolid
	/// <para>ENTITY IfcDirectrixDerivedReferenceSweptAreaSolid</para>
	/// <para> SUBTYPE OF (IfcFixedReferenceSweptAreaSolid);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDirectrixDerivedReferenceSweptAreaSolid : IfcFixedReferenceSweptAreaSolid
	{
		public IfcDirectrixDerivedReferenceSweptAreaSolid() : base()
		{
		}
		public IfcDirectrixDerivedReferenceSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcCurve Directrix, IfcCurveMeasureSelect StartParam, IfcCurveMeasureSelect EndParam, IfcDirection FixedReference) : base (SweptArea, Position, Directrix, StartParam, EndParam, FixedReference)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDiscreteAccessory
	/// <para>ENTITY IfcDiscreteAccessory</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDiscreteAccessoryTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcDiscreteAccessoryTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDiscreteAccessoryTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCDISCRETEACCESSORYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDiscreteAccessory : IfcElementComponent
	{
		public IfcDiscreteAccessoryTypeEnum? PredefinedType { get; set; }
		public IfcDiscreteAccessory() : base()
		{
		}
		public IfcDiscreteAccessory(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDiscreteAccessoryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDiscreteAccessoryType
	/// <para>ENTITY IfcDiscreteAccessoryType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcDiscreteAccessoryTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDiscreteAccessoryTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDiscreteAccessoryTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDiscreteAccessoryType : IfcElementComponentType
	{
		public IfcDiscreteAccessoryTypeEnum PredefinedType { get; set; }
		public IfcDiscreteAccessoryType() : base()
		{
			PredefinedType = new IfcDiscreteAccessoryTypeEnum();
		}
		public IfcDiscreteAccessoryType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDiscreteAccessoryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionBoard
	/// <para>ENTITY IfcDistributionBoard</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDistributionBoardTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcDistributionBoardTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDistributionBoardTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCDISTRIBUTIONBOARDTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionBoard : IfcFlowController
	{
		public IfcDistributionBoardTypeEnum? PredefinedType { get; set; }
		public IfcDistributionBoard() : base()
		{
		}
		public IfcDistributionBoard(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDistributionBoardTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionBoardType
	/// <para>ENTITY IfcDistributionBoardType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcDistributionBoardTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDistributionBoardTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDistributionBoardTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionBoardType : IfcFlowControllerType
	{
		public IfcDistributionBoardTypeEnum PredefinedType { get; set; }
		public IfcDistributionBoardType() : base()
		{
			PredefinedType = new IfcDistributionBoardTypeEnum();
		}
		public IfcDistributionBoardType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDistributionBoardTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionChamberElement
	/// <para>ENTITY IfcDistributionChamberElement</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDistributionChamberElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcDistributionChamberElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDistributionChamberElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCDISTRIBUTIONCHAMBERELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionChamberElement : IfcDistributionFlowElement
	{
		public IfcDistributionChamberElementTypeEnum? PredefinedType { get; set; }
		public IfcDistributionChamberElement() : base()
		{
		}
		public IfcDistributionChamberElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDistributionChamberElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionChamberElementType
	/// <para>ENTITY IfcDistributionChamberElementType</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>	PredefinedType : IfcDistributionChamberElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDistributionChamberElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDistributionChamberElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionChamberElementType : IfcDistributionFlowElementType
	{
		public IfcDistributionChamberElementTypeEnum PredefinedType { get; set; }
		public IfcDistributionChamberElementType() : base()
		{
			PredefinedType = new IfcDistributionChamberElementTypeEnum();
		}
		public IfcDistributionChamberElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDistributionChamberElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionCircuit
	/// <para>ENTITY IfcDistributionCircuit</para>
	/// <para> SUBTYPE OF (IfcDistributionSystem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionCircuit : IfcDistributionSystem
	{
		public IfcDistributionCircuit() : base()
		{
		}
		public IfcDistributionCircuit(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcDistributionSystemEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionControlElement
	/// <para>ENTITY IfcDistributionControlElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcActuator</para>
	/// <para>	,IfcAlarm</para>
	/// <para>	,IfcController</para>
	/// <para>	,IfcFlowInstrument</para>
	/// <para>	,IfcProtectiveDeviceTrippingUnit</para>
	/// <para>	,IfcSensor</para>
	/// <para>	,IfcUnitaryControlElement))</para>
	/// <para> SUBTYPE OF (IfcDistributionElement);</para>
	/// <para> INVERSE</para>
	/// <para>	AssignedToFlowElement : SET [0:1] OF IfcRelFlowControlElements FOR RelatedControlElements;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionControlElement : IfcDistributionElement
	{
		public IfcDistributionControlElement() : base()
		{
		}
		public IfcDistributionControlElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionControlElementType
	/// <para>ENTITY IfcDistributionControlElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcActuatorType</para>
	/// <para>	,IfcAlarmType</para>
	/// <para>	,IfcControllerType</para>
	/// <para>	,IfcFlowInstrumentType</para>
	/// <para>	,IfcProtectiveDeviceTrippingUnitType</para>
	/// <para>	,IfcSensorType</para>
	/// <para>	,IfcUnitaryControlElementType))</para>
	/// <para> SUBTYPE OF (IfcDistributionElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcDistributionControlElementType : IfcDistributionElementType
	{
		public IfcDistributionControlElementType() : base()
		{
		}
		public IfcDistributionControlElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionElement
	/// <para>ENTITY IfcDistributionElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDistributionControlElement</para>
	/// <para>	,IfcDistributionFlowElement))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para> INVERSE</para>
	/// <para>	HasPorts : SET [0:?] OF IfcRelConnectsPortToElement FOR RelatedElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionElement : IfcElement
	{
		public IfcDistributionElement() : base()
		{
		}
		public IfcDistributionElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionElementType
	/// <para>ENTITY IfcDistributionElementType</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDistributionControlElementType</para>
	/// <para>	,IfcDistributionFlowElementType))</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionElementType : IfcElementType
	{
		public IfcDistributionElementType() : base()
		{
		}
		public IfcDistributionElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionFlowElement
	/// <para>ENTITY IfcDistributionFlowElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDistributionChamberElement</para>
	/// <para>	,IfcEnergyConversionDevice</para>
	/// <para>	,IfcFlowController</para>
	/// <para>	,IfcFlowFitting</para>
	/// <para>	,IfcFlowMovingDevice</para>
	/// <para>	,IfcFlowSegment</para>
	/// <para>	,IfcFlowStorageDevice</para>
	/// <para>	,IfcFlowTerminal</para>
	/// <para>	,IfcFlowTreatmentDevice))</para>
	/// <para> SUBTYPE OF (IfcDistributionElement);</para>
	/// <para> INVERSE</para>
	/// <para>	HasControlElements : SET [0:1] OF IfcRelFlowControlElements FOR RelatingFlowElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionFlowElement : IfcDistributionElement
	{
		public IfcDistributionFlowElement() : base()
		{
		}
		public IfcDistributionFlowElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionFlowElementType
	/// <para>ENTITY IfcDistributionFlowElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDistributionChamberElementType</para>
	/// <para>	,IfcEnergyConversionDeviceType</para>
	/// <para>	,IfcFlowControllerType</para>
	/// <para>	,IfcFlowFittingType</para>
	/// <para>	,IfcFlowMovingDeviceType</para>
	/// <para>	,IfcFlowSegmentType</para>
	/// <para>	,IfcFlowStorageDeviceType</para>
	/// <para>	,IfcFlowTerminalType</para>
	/// <para>	,IfcFlowTreatmentDeviceType))</para>
	/// <para> SUBTYPE OF (IfcDistributionElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcDistributionFlowElementType : IfcDistributionElementType
	{
		public IfcDistributionFlowElementType() : base()
		{
		}
		public IfcDistributionFlowElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionPort
	/// <para>ENTITY IfcDistributionPort</para>
	/// <para> SUBTYPE OF (IfcPort);</para>
	/// <para>	FlowDirection : OPTIONAL IfcFlowDirectionEnum;</para>
	/// <para>	PredefinedType : OPTIONAL IfcDistributionPortTypeEnum;</para>
	/// <para>	SystemType : OPTIONAL IfcDistributionSystemEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionPort : IfcPort
	{
		public IfcFlowDirectionEnum? FlowDirection { get; set; }
		public IfcDistributionPortTypeEnum? PredefinedType { get; set; }
		public IfcDistributionSystemEnum? SystemType { get; set; }
		public IfcDistributionPort() : base()
		{
		}
		public IfcDistributionPort(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcFlowDirectionEnum FlowDirection, IfcDistributionPortTypeEnum PredefinedType, IfcDistributionSystemEnum SystemType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.FlowDirection = FlowDirection;
			this.PredefinedType = PredefinedType;
			this.SystemType = SystemType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionSystem
	/// <para>ENTITY IfcDistributionSystem</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDistributionCircuit))</para>
	/// <para> SUBTYPE OF (IfcSystem);</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para>	PredefinedType : OPTIONAL IfcDistributionSystemEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcDistributionSystemEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDistributionSystemEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionSystem : IfcSystem
	{
		public IfcLabel? LongName { get; set; }
		public IfcDistributionSystemEnum? PredefinedType { get; set; }
		public IfcDistributionSystem() : base()
		{
		}
		public IfcDistributionSystem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcDistributionSystemEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.LongName = LongName;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDocumentInformation
	/// <para>ENTITY IfcDocumentInformation</para>
	/// <para> SUBTYPE OF (IfcExternalInformation);</para>
	/// <para>	Identification : IfcIdentifier;</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Location : OPTIONAL IfcURIReference;</para>
	/// <para>	Purpose : OPTIONAL IfcText;</para>
	/// <para>	IntendedUse : OPTIONAL IfcText;</para>
	/// <para>	Scope : OPTIONAL IfcText;</para>
	/// <para>	Revision : OPTIONAL IfcLabel;</para>
	/// <para>	DocumentOwner : OPTIONAL IfcActorSelect;</para>
	/// <para>	Editors : OPTIONAL SET [1:?] OF IfcActorSelect;</para>
	/// <para>	CreationTime : OPTIONAL IfcDateTime;</para>
	/// <para>	LastRevisionTime : OPTIONAL IfcDateTime;</para>
	/// <para>	ElectronicFormat : OPTIONAL IfcIdentifier;</para>
	/// <para>	ValidFrom : OPTIONAL IfcDate;</para>
	/// <para>	ValidUntil : OPTIONAL IfcDate;</para>
	/// <para>	Confidentiality : OPTIONAL IfcDocumentConfidentialityEnum;</para>
	/// <para>	Status : OPTIONAL IfcDocumentStatusEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	DocumentInfoForObjects : SET [0:?] OF IfcRelAssociatesDocument FOR RelatingDocument;</para>
	/// <para>	HasDocumentReferences : SET [0:?] OF IfcDocumentReference FOR ReferencedDocument;</para>
	/// <para>	IsPointedTo : SET [0:?] OF IfcDocumentInformationRelationship FOR RelatedDocuments;</para>
	/// <para>	IsPointer : SET [0:1] OF IfcDocumentInformationRelationship FOR RelatingDocument;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDocumentInformation : IfcExternalInformation, IfcDocumentSelect
	{
		public IfcIdentifier Identification { get; set; }
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcURIReference? Location { get; set; }
		public IfcText? Purpose { get; set; }
		public IfcText? IntendedUse { get; set; }
		public IfcText? Scope { get; set; }
		public IfcLabel? Revision { get; set; }
		public IfcActorSelect? DocumentOwner { get; set; }
		public List<IfcActorSelect>? Editors { get; set; }
		public IfcDateTime? CreationTime { get; set; }
		public IfcDateTime? LastRevisionTime { get; set; }
		public IfcIdentifier? ElectronicFormat { get; set; }
		public IfcDate? ValidFrom { get; set; }
		public IfcDate? ValidUntil { get; set; }
		public IfcDocumentConfidentialityEnum? Confidentiality { get; set; }
		public IfcDocumentStatusEnum? Status { get; set; }
		public IfcDocumentInformation() : base()
		{
			Identification = new IfcIdentifier();
			Name = new IfcLabel();
		}
		public IfcDocumentInformation(IfcIdentifier Identification, IfcLabel Name, IfcText Description, IfcURIReference Location, IfcText Purpose, IfcText IntendedUse, IfcText Scope, IfcLabel Revision, IfcActorSelect DocumentOwner, List<IfcActorSelect> Editors, IfcDateTime CreationTime, IfcDateTime LastRevisionTime, IfcIdentifier ElectronicFormat, IfcDate ValidFrom, IfcDate ValidUntil, IfcDocumentConfidentialityEnum Confidentiality, IfcDocumentStatusEnum Status) : base ()
		{
			this.Identification = Identification;
			this.Name = Name;
			this.Description = Description;
			this.Location = Location;
			this.Purpose = Purpose;
			this.IntendedUse = IntendedUse;
			this.Scope = Scope;
			this.Revision = Revision;
			this.DocumentOwner = DocumentOwner;
			this.Editors = Editors;
			this.CreationTime = CreationTime;
			this.LastRevisionTime = LastRevisionTime;
			this.ElectronicFormat = ElectronicFormat;
			this.ValidFrom = ValidFrom;
			this.ValidUntil = ValidUntil;
			this.Confidentiality = Confidentiality;
			this.Status = Status;
		}
	}
	/// <summary>
	/// ENTITY IfcDocumentInformationRelationship
	/// <para>ENTITY IfcDocumentInformationRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingDocument : IfcDocumentInformation;</para>
	/// <para>	RelatedDocuments : SET [1:?] OF IfcDocumentInformation;</para>
	/// <para>	RelationshipType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDocumentInformationRelationship : IfcResourceLevelRelationship
	{
		public IfcDocumentInformation RelatingDocument { get; set; }
		public List<IfcDocumentInformation> RelatedDocuments { get; set; }
		public IfcLabel? RelationshipType { get; set; }
		public IfcDocumentInformationRelationship() : base()
		{
			RelatingDocument = new IfcDocumentInformation();
			RelatedDocuments = new List<IfcDocumentInformation>();
		}
		public IfcDocumentInformationRelationship(IfcLabel Name, IfcText Description, IfcDocumentInformation RelatingDocument, List<IfcDocumentInformation> RelatedDocuments, IfcLabel RelationshipType) : base (Name, Description)
		{
			this.RelatingDocument = RelatingDocument;
			this.RelatedDocuments = RelatedDocuments;
			this.RelationshipType = RelationshipType;
		}
	}
	/// <summary>
	/// ENTITY IfcDocumentReference
	/// <para>ENTITY IfcDocumentReference</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	ReferencedDocument : OPTIONAL IfcDocumentInformation;</para>
	/// <para> INVERSE</para>
	/// <para>	DocumentRefForObjects : SET [0:?] OF IfcRelAssociatesDocument FOR RelatingDocument;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : EXISTS(Name) XOR EXISTS(ReferencedDocument);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDocumentReference : IfcExternalReference, IfcDocumentSelect
	{
		public IfcText? Description { get; set; }
		public IfcDocumentInformation? ReferencedDocument { get; set; }
		public IfcDocumentReference() : base()
		{
		}
		public IfcDocumentReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name, IfcText Description, IfcDocumentInformation ReferencedDocument) : base (Location, Identification, Name)
		{
			this.Description = Description;
			this.ReferencedDocument = ReferencedDocument;
		}
	}
	/// <summary>
	/// ENTITY IfcDoor
	/// <para>ENTITY IfcDoor</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	OverallHeight : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	OverallWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcDoorTypeEnum;</para>
	/// <para>	OperationType : OPTIONAL IfcDoorTypeOperationEnum;</para>
	/// <para>	UserDefinedOperationType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcDoorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDoorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCDOORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoor : IfcBuiltElement
	{
		public IfcPositiveLengthMeasure? OverallHeight { get; set; }
		public IfcPositiveLengthMeasure? OverallWidth { get; set; }
		public IfcDoorTypeEnum? PredefinedType { get; set; }
		public IfcDoorTypeOperationEnum? OperationType { get; set; }
		public IfcLabel? UserDefinedOperationType { get; set; }
		public IfcDoor() : base()
		{
		}
		public IfcDoor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure OverallHeight, IfcPositiveLengthMeasure OverallWidth, IfcDoorTypeEnum PredefinedType, IfcDoorTypeOperationEnum OperationType, IfcLabel UserDefinedOperationType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.OverallHeight = OverallHeight;
			this.OverallWidth = OverallWidth;
			this.PredefinedType = PredefinedType;
			this.OperationType = OperationType;
			this.UserDefinedOperationType = UserDefinedOperationType;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorLiningProperties
	/// <para>ENTITY IfcDoorLiningProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	LiningDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LiningThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	ThresholdDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	ThresholdThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	TransomThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	TransomOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LiningOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ThresholdOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	CasingThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	CasingDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>	LiningToPanelOffsetX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LiningToPanelOffsetY : OPTIONAL IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : NOT(EXISTS(LiningDepth) AND NOT(EXISTS(LiningThickness)));</para>
	/// <para>	WR32 : NOT(EXISTS(ThresholdDepth) AND NOT(EXISTS(ThresholdThickness)));</para>
	/// <para>	WR33 : (EXISTS(TransomOffset) AND EXISTS(TransomThickness)) XOR</para>
	/// <para>(NOT(EXISTS(TransomOffset)) AND NOT(EXISTS(TransomThickness)));</para>
	/// <para>	WR34 : (EXISTS(CasingDepth) AND EXISTS(CasingThickness)) XOR</para>
	/// <para>(NOT(EXISTS(CasingDepth)) AND NOT(EXISTS(CasingThickness)));</para>
	/// <para>	WR35 : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) </para>
	/// <para>AND </para>
	/// <para>('IFC4X3_ADD2.IFCDOORTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorLiningProperties : IfcPreDefinedPropertySet
	{
		public IfcPositiveLengthMeasure? LiningDepth { get; set; }
		public IfcNonNegativeLengthMeasure? LiningThickness { get; set; }
		public IfcPositiveLengthMeasure? ThresholdDepth { get; set; }
		public IfcNonNegativeLengthMeasure? ThresholdThickness { get; set; }
		public IfcNonNegativeLengthMeasure? TransomThickness { get; set; }
		public IfcLengthMeasure? TransomOffset { get; set; }
		public IfcLengthMeasure? LiningOffset { get; set; }
		public IfcLengthMeasure? ThresholdOffset { get; set; }
		public IfcPositiveLengthMeasure? CasingThickness { get; set; }
		public IfcPositiveLengthMeasure? CasingDepth { get; set; }
		public IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcLengthMeasure? LiningToPanelOffsetX { get; set; }
		public IfcLengthMeasure? LiningToPanelOffsetY { get; set; }
		public IfcDoorLiningProperties() : base()
		{
		}
		public IfcDoorLiningProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPositiveLengthMeasure LiningDepth, IfcNonNegativeLengthMeasure LiningThickness, IfcPositiveLengthMeasure ThresholdDepth, IfcNonNegativeLengthMeasure ThresholdThickness, IfcNonNegativeLengthMeasure TransomThickness, IfcLengthMeasure TransomOffset, IfcLengthMeasure LiningOffset, IfcLengthMeasure ThresholdOffset, IfcPositiveLengthMeasure CasingThickness, IfcPositiveLengthMeasure CasingDepth, IfcShapeAspect ShapeAspectStyle, IfcLengthMeasure LiningToPanelOffsetX, IfcLengthMeasure LiningToPanelOffsetY) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.LiningDepth = LiningDepth;
			this.LiningThickness = LiningThickness;
			this.ThresholdDepth = ThresholdDepth;
			this.ThresholdThickness = ThresholdThickness;
			this.TransomThickness = TransomThickness;
			this.TransomOffset = TransomOffset;
			this.LiningOffset = LiningOffset;
			this.ThresholdOffset = ThresholdOffset;
			this.CasingThickness = CasingThickness;
			this.CasingDepth = CasingDepth;
			this.ShapeAspectStyle = ShapeAspectStyle;
			this.LiningToPanelOffsetX = LiningToPanelOffsetX;
			this.LiningToPanelOffsetY = LiningToPanelOffsetY;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorPanelProperties
	/// <para>ENTITY IfcDoorPanelProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	PanelDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PanelOperation : IfcDoorPanelOperationEnum;</para>
	/// <para>	PanelWidth : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	PanelPosition : IfcDoorPanelPositionEnum;</para>
	/// <para>	ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableToType : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) </para>
	/// <para>AND </para>
	/// <para>('IFC4X3_ADD2.IFCDOORTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorPanelProperties : IfcPreDefinedPropertySet
	{
		public IfcPositiveLengthMeasure? PanelDepth { get; set; }
		public IfcDoorPanelOperationEnum PanelOperation { get; set; }
		public IfcNormalisedRatioMeasure? PanelWidth { get; set; }
		public IfcDoorPanelPositionEnum PanelPosition { get; set; }
		public IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcDoorPanelProperties() : base()
		{
			PanelOperation = new IfcDoorPanelOperationEnum();
			PanelPosition = new IfcDoorPanelPositionEnum();
		}
		public IfcDoorPanelProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPositiveLengthMeasure PanelDepth, IfcDoorPanelOperationEnum PanelOperation, IfcNormalisedRatioMeasure PanelWidth, IfcDoorPanelPositionEnum PanelPosition, IfcShapeAspect ShapeAspectStyle) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.PanelDepth = PanelDepth;
			this.PanelOperation = PanelOperation;
			this.PanelWidth = PanelWidth;
			this.PanelPosition = PanelPosition;
			this.ShapeAspectStyle = ShapeAspectStyle;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorType
	/// <para>ENTITY IfcDoorType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcDoorTypeEnum;</para>
	/// <para>	OperationType : IfcDoorTypeOperationEnum;</para>
	/// <para>	ParameterTakesPrecedence : OPTIONAL IfcBoolean;</para>
	/// <para>	UserDefinedOperationType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDoorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDoorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorType : IfcBuiltElementType
	{
		public IfcDoorTypeEnum PredefinedType { get; set; }
		public IfcDoorTypeOperationEnum OperationType { get; set; }
		public IfcBoolean? ParameterTakesPrecedence { get; set; }
		public IfcLabel? UserDefinedOperationType { get; set; }
		public IfcDoorType() : base()
		{
			PredefinedType = new IfcDoorTypeEnum();
			OperationType = new IfcDoorTypeOperationEnum();
		}
		public IfcDoorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDoorTypeEnum PredefinedType, IfcDoorTypeOperationEnum OperationType, IfcBoolean ParameterTakesPrecedence, IfcLabel UserDefinedOperationType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.OperationType = OperationType;
			this.ParameterTakesPrecedence = ParameterTakesPrecedence;
			this.UserDefinedOperationType = UserDefinedOperationType;
		}
	}
	/// <summary>
	/// ENTITY IfcDraughtingPreDefinedColour
	/// <para>ENTITY IfcDraughtingPreDefinedColour</para>
	/// <para> SUBTYPE OF (IfcPreDefinedColour);</para>
	/// <para> WHERE</para>
	/// <para>	PreDefinedColourNames : SELF\IfcPreDefinedItem.Name IN ['black','red','green','blue','yellow',</para>
	/// <para>     'magenta','cyan','white','by layer'];</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDraughtingPreDefinedColour : IfcPreDefinedColour
	{
		public IfcDraughtingPreDefinedColour() : base()
		{
		}
		public IfcDraughtingPreDefinedColour(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDraughtingPreDefinedCurveFont
	/// <para>ENTITY IfcDraughtingPreDefinedCurveFont</para>
	/// <para> SUBTYPE OF (IfcPreDefinedCurveFont);</para>
	/// <para> WHERE</para>
	/// <para>	PreDefinedCurveFontNames : SELF\IfcPredefinedItem.Name IN</para>
	/// <para>       ['continuous',</para>
	/// <para>        'chain',</para>
	/// <para>        'chain double dash',</para>
	/// <para>        'dashed',</para>
	/// <para>        'dotted',</para>
	/// <para>        'by layer'];</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDraughtingPreDefinedCurveFont : IfcPreDefinedCurveFont
	{
		public IfcDraughtingPreDefinedCurveFont() : base()
		{
		}
		public IfcDraughtingPreDefinedCurveFont(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDuctFitting
	/// <para>ENTITY IfcDuctFitting</para>
	/// <para> SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDuctFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcDuctFittingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDuctFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCDUCTFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctFitting : IfcFlowFitting
	{
		public IfcDuctFittingTypeEnum? PredefinedType { get; set; }
		public IfcDuctFitting() : base()
		{
		}
		public IfcDuctFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDuctFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctFittingType
	/// <para>ENTITY IfcDuctFittingType</para>
	/// <para> SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>	PredefinedType : IfcDuctFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDuctFittingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDuctFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctFittingType : IfcFlowFittingType
	{
		public IfcDuctFittingTypeEnum PredefinedType { get; set; }
		public IfcDuctFittingType() : base()
		{
			PredefinedType = new IfcDuctFittingTypeEnum();
		}
		public IfcDuctFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDuctFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSegment
	/// <para>ENTITY IfcDuctSegment</para>
	/// <para> SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDuctSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcDuctSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDuctSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCDUCTSEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSegment : IfcFlowSegment
	{
		public IfcDuctSegmentTypeEnum? PredefinedType { get; set; }
		public IfcDuctSegment() : base()
		{
		}
		public IfcDuctSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDuctSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSegmentType
	/// <para>ENTITY IfcDuctSegmentType</para>
	/// <para> SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>	PredefinedType : IfcDuctSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDuctSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDuctSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSegmentType : IfcFlowSegmentType
	{
		public IfcDuctSegmentTypeEnum PredefinedType { get; set; }
		public IfcDuctSegmentType() : base()
		{
			PredefinedType = new IfcDuctSegmentTypeEnum();
		}
		public IfcDuctSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDuctSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSilencer
	/// <para>ENTITY IfcDuctSilencer</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDuctSilencerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcDuctSilencerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDuctSilencerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCDUCTSILENCERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSilencer : IfcFlowTreatmentDevice
	{
		public IfcDuctSilencerTypeEnum? PredefinedType { get; set; }
		public IfcDuctSilencer() : base()
		{
		}
		public IfcDuctSilencer(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDuctSilencerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSilencerType
	/// <para>ENTITY IfcDuctSilencerType</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDeviceType);</para>
	/// <para>	PredefinedType : IfcDuctSilencerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDuctSilencerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcDuctSilencerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSilencerType : IfcFlowTreatmentDeviceType
	{
		public IfcDuctSilencerTypeEnum PredefinedType { get; set; }
		public IfcDuctSilencerType() : base()
		{
			PredefinedType = new IfcDuctSilencerTypeEnum();
		}
		public IfcDuctSilencerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDuctSilencerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEarthworksCut
	/// <para>ENTITY IfcEarthworksCut</para>
	/// <para> SUBTYPE OF (IfcFeatureElementSubtraction);</para>
	/// <para>	PredefinedType : OPTIONAL IfcEarthworksCutTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcEarthworksCutTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcEarthworksCutTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEarthworksCut : IfcFeatureElementSubtraction
	{
		public IfcEarthworksCutTypeEnum? PredefinedType { get; set; }
		public IfcEarthworksCut() : base()
		{
		}
		public IfcEarthworksCut(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEarthworksCutTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEarthworksElement
	/// <para>ENTITY IfcEarthworksElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcEarthworksFill</para>
	/// <para>	,IfcReinforcedSoil))</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEarthworksElement : IfcBuiltElement
	{
		public IfcEarthworksElement() : base()
		{
		}
		public IfcEarthworksElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcEarthworksFill
	/// <para>ENTITY IfcEarthworksFill</para>
	/// <para> SUBTYPE OF (IfcEarthworksElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcEarthworksFillTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcEarthworksFillTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcEarthworksFillTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEarthworksFill : IfcEarthworksElement
	{
		public IfcEarthworksFillTypeEnum? PredefinedType { get; set; }
		public IfcEarthworksFill() : base()
		{
		}
		public IfcEarthworksFill(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEarthworksFillTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEdge
	/// <para>ENTITY IfcEdge</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcEdgeCurve</para>
	/// <para>	,IfcOrientedEdge</para>
	/// <para>	,IfcSubedge))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>	EdgeStart : IfcVertex;</para>
	/// <para>	EdgeEnd : IfcVertex;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEdge : IfcTopologicalRepresentationItem
	{
		public IfcVertex EdgeStart { get; set; }
		public IfcVertex EdgeEnd { get; set; }
		public IfcEdge() : base()
		{
			EdgeStart = new IfcVertex();
			EdgeEnd = new IfcVertex();
		}
		public IfcEdge(IfcVertex EdgeStart, IfcVertex EdgeEnd) : base ()
		{
			this.EdgeStart = EdgeStart;
			this.EdgeEnd = EdgeEnd;
		}
	}
	/// <summary>
	/// ENTITY IfcEdgeCurve
	/// <para>ENTITY IfcEdgeCurve</para>
	/// <para> SUBTYPE OF (IfcEdge);</para>
	/// <para>	EdgeGeometry : IfcCurve;</para>
	/// <para>	SameSense : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEdgeCurve : IfcEdge, IfcCurveOrEdgeCurve
	{
		public IfcCurve EdgeGeometry { get; set; }
		public IfcBoolean SameSense { get; set; }
		public IfcEdgeCurve() : base()
		{
			EdgeGeometry = new IfcCurve();
			SameSense = new IfcBoolean();
		}
		public IfcEdgeCurve(IfcVertex EdgeStart, IfcVertex EdgeEnd, IfcCurve EdgeGeometry, IfcBoolean SameSense) : base (EdgeStart, EdgeEnd)
		{
			this.EdgeGeometry = EdgeGeometry;
			this.SameSense = SameSense;
		}
	}
	/// <summary>
	/// ENTITY IfcEdgeLoop
	/// <para>ENTITY IfcEdgeLoop</para>
	/// <para> SUBTYPE OF (IfcLoop);</para>
	/// <para>	EdgeList : LIST [1:?] OF IfcOrientedEdge;</para>
	/// <para> DERIVE</para>
	/// <para>	 Ne : IfcInteger := SIZEOF(EdgeList);</para>
	/// <para> WHERE</para>
	/// <para>	IsClosed : (EdgeList[1].EdgeStart) :=: (EdgeList[Ne].EdgeEnd);</para>
	/// <para>	IsContinuous : IfcLoopHeadToTail(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEdgeLoop : IfcLoop
	{
		public List<IfcOrientedEdge> EdgeList { get; set; }
		public IfcEdgeLoop() : base()
		{
			EdgeList = new List<IfcOrientedEdge>();
		}
		public IfcEdgeLoop(List<IfcOrientedEdge> EdgeList) : base ()
		{
			this.EdgeList = EdgeList;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricAppliance
	/// <para>ENTITY IfcElectricAppliance</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcElectricApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCELECTRICAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricAppliance : IfcFlowTerminal
	{
		public IfcElectricApplianceTypeEnum? PredefinedType { get; set; }
		public IfcElectricAppliance() : base()
		{
		}
		public IfcElectricAppliance(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricApplianceType
	/// <para>ENTITY IfcElectricApplianceType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcElectricApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricApplianceType : IfcFlowTerminalType
	{
		public IfcElectricApplianceTypeEnum PredefinedType { get; set; }
		public IfcElectricApplianceType() : base()
		{
			PredefinedType = new IfcElectricApplianceTypeEnum();
		}
		public IfcElectricApplianceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricDistributionBoard
	/// <para>ENTITY IfcElectricDistributionBoard</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricDistributionBoardTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcElectricDistributionBoardTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricDistributionBoardTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCELECTRICDISTRIBUTIONBOARDTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricDistributionBoard : IfcFlowController
	{
		public IfcElectricDistributionBoardTypeEnum? PredefinedType { get; set; }
		public IfcElectricDistributionBoard() : base()
		{
		}
		public IfcElectricDistributionBoard(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricDistributionBoardTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricDistributionBoardType
	/// <para>ENTITY IfcElectricDistributionBoardType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcElectricDistributionBoardTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricDistributionBoardTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricDistributionBoardTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricDistributionBoardType : IfcFlowControllerType
	{
		public IfcElectricDistributionBoardTypeEnum PredefinedType { get; set; }
		public IfcElectricDistributionBoardType() : base()
		{
			PredefinedType = new IfcElectricDistributionBoardTypeEnum();
		}
		public IfcElectricDistributionBoardType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricDistributionBoardTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricFlowStorageDevice
	/// <para>ENTITY IfcElectricFlowStorageDevice</para>
	/// <para> SUBTYPE OF (IfcFlowStorageDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricFlowStorageDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCELECTRICFLOWSTORAGEDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricFlowStorageDevice : IfcFlowStorageDevice
	{
		public IfcElectricFlowStorageDeviceTypeEnum? PredefinedType { get; set; }
		public IfcElectricFlowStorageDevice() : base()
		{
		}
		public IfcElectricFlowStorageDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricFlowStorageDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricFlowStorageDeviceType
	/// <para>ENTITY IfcElectricFlowStorageDeviceType</para>
	/// <para> SUBTYPE OF (IfcFlowStorageDeviceType);</para>
	/// <para>	PredefinedType : IfcElectricFlowStorageDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricFlowStorageDeviceType : IfcFlowStorageDeviceType
	{
		public IfcElectricFlowStorageDeviceTypeEnum PredefinedType { get; set; }
		public IfcElectricFlowStorageDeviceType() : base()
		{
			PredefinedType = new IfcElectricFlowStorageDeviceTypeEnum();
		}
		public IfcElectricFlowStorageDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricFlowStorageDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricFlowTreatmentDevice
	/// <para>ENTITY IfcElectricFlowTreatmentDevice</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricFlowTreatmentDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcElectricFlowTreatmentDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricFlowTreatmentDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCELECTRICFLOWTREATMENTDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricFlowTreatmentDevice : IfcFlowTreatmentDevice
	{
		public IfcElectricFlowTreatmentDeviceTypeEnum? PredefinedType { get; set; }
		public IfcElectricFlowTreatmentDevice() : base()
		{
		}
		public IfcElectricFlowTreatmentDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricFlowTreatmentDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricFlowTreatmentDeviceType
	/// <para>ENTITY IfcElectricFlowTreatmentDeviceType</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDeviceType);</para>
	/// <para>	PredefinedType : IfcElectricFlowTreatmentDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricFlowTreatmentDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricFlowTreatmentDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricFlowTreatmentDeviceType : IfcFlowTreatmentDeviceType
	{
		public IfcElectricFlowTreatmentDeviceTypeEnum PredefinedType { get; set; }
		public IfcElectricFlowTreatmentDeviceType() : base()
		{
			PredefinedType = new IfcElectricFlowTreatmentDeviceTypeEnum();
		}
		public IfcElectricFlowTreatmentDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricFlowTreatmentDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricGenerator
	/// <para>ENTITY IfcElectricGenerator</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricGeneratorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcElectricGeneratorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricGeneratorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCELECTRICGENERATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricGenerator : IfcEnergyConversionDevice
	{
		public IfcElectricGeneratorTypeEnum? PredefinedType { get; set; }
		public IfcElectricGenerator() : base()
		{
		}
		public IfcElectricGenerator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricGeneratorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricGeneratorType
	/// <para>ENTITY IfcElectricGeneratorType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcElectricGeneratorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricGeneratorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricGeneratorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricGeneratorType : IfcEnergyConversionDeviceType
	{
		public IfcElectricGeneratorTypeEnum PredefinedType { get; set; }
		public IfcElectricGeneratorType() : base()
		{
			PredefinedType = new IfcElectricGeneratorTypeEnum();
		}
		public IfcElectricGeneratorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricGeneratorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricMotor
	/// <para>ENTITY IfcElectricMotor</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricMotorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcElectricMotorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricMotorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCELECTRICMOTORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricMotor : IfcEnergyConversionDevice
	{
		public IfcElectricMotorTypeEnum? PredefinedType { get; set; }
		public IfcElectricMotor() : base()
		{
		}
		public IfcElectricMotor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricMotorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricMotorType
	/// <para>ENTITY IfcElectricMotorType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcElectricMotorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricMotorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricMotorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricMotorType : IfcEnergyConversionDeviceType
	{
		public IfcElectricMotorTypeEnum PredefinedType { get; set; }
		public IfcElectricMotorType() : base()
		{
			PredefinedType = new IfcElectricMotorTypeEnum();
		}
		public IfcElectricMotorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricMotorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricTimeControl
	/// <para>ENTITY IfcElectricTimeControl</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricTimeControlTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcElectricTimeControlTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricTimeControlTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCELECTRICTIMECONTROLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricTimeControl : IfcFlowController
	{
		public IfcElectricTimeControlTypeEnum? PredefinedType { get; set; }
		public IfcElectricTimeControl() : base()
		{
		}
		public IfcElectricTimeControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricTimeControlTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricTimeControlType
	/// <para>ENTITY IfcElectricTimeControlType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcElectricTimeControlTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricTimeControlTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElectricTimeControlTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricTimeControlType : IfcFlowControllerType
	{
		public IfcElectricTimeControlTypeEnum PredefinedType { get; set; }
		public IfcElectricTimeControlType() : base()
		{
			PredefinedType = new IfcElectricTimeControlTypeEnum();
		}
		public IfcElectricTimeControlType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricTimeControlTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElement
	/// <para>ENTITY IfcElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBuiltElement</para>
	/// <para>	,IfcCivilElement</para>
	/// <para>	,IfcDistributionElement</para>
	/// <para>	,IfcElementAssembly</para>
	/// <para>	,IfcElementComponent</para>
	/// <para>	,IfcFeatureElement</para>
	/// <para>	,IfcFurnishingElement</para>
	/// <para>	,IfcGeographicElement</para>
	/// <para>	,IfcGeotechnicalElement</para>
	/// <para>	,IfcTransportationDevice</para>
	/// <para>	,IfcVirtualElement))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para>	Tag : OPTIONAL IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	FillsVoids : SET [0:1] OF IfcRelFillsElement FOR RelatedBuildingElement;</para>
	/// <para>	ConnectedTo : SET [0:?] OF IfcRelConnectsElements FOR RelatingElement;</para>
	/// <para>	IsInterferedByElements : SET [0:?] OF IfcRelInterferesElements FOR RelatedElement;</para>
	/// <para>	InterferesElements : SET [0:?] OF IfcRelInterferesElements FOR RelatingElement;</para>
	/// <para>	HasProjections : SET [0:?] OF IfcRelProjectsElement FOR RelatingElement;</para>
	/// <para>	HasOpenings : SET [0:?] OF IfcRelVoidsElement FOR RelatingBuildingElement;</para>
	/// <para>	IsConnectionRealization : SET [0:?] OF IfcRelConnectsWithRealizingElements FOR RealizingElements;</para>
	/// <para>	ProvidesBoundaries : SET [0:?] OF IfcRelSpaceBoundary FOR RelatedBuildingElement;</para>
	/// <para>	ConnectedFrom : SET [0:?] OF IfcRelConnectsElements FOR RelatedElement;</para>
	/// <para>	ContainedInStructure : SET [0:1] OF IfcRelContainedInSpatialStructure FOR RelatedElements;</para>
	/// <para>	HasCoverings : SET [0:?] OF IfcRelCoversBldgElements FOR RelatingBuildingElement;</para>
	/// <para>	HasSurfaceFeatures : SET [0:?] OF IfcRelAdheresToElement FOR RelatingElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElement : IfcProduct, IfcInterferenceSelect, IfcStructuralActivityAssignmentSelect
	{
		public IfcIdentifier? Tag { get; set; }
		public IfcElement() : base()
		{
		}
		public IfcElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.Tag = Tag;
		}
	}
	/// <summary>
	/// ENTITY IfcElementAssembly
	/// <para>ENTITY IfcElementAssembly</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>	AssemblyPlace : OPTIONAL IfcAssemblyPlaceEnum;</para>
	/// <para>	PredefinedType : OPTIONAL IfcElementAssemblyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcElementAssemblyTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElementAssemblyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCELEMENTASSEMBLYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElementAssembly : IfcElement
	{
		public IfcAssemblyPlaceEnum? AssemblyPlace { get; set; }
		public IfcElementAssemblyTypeEnum? PredefinedType { get; set; }
		public IfcElementAssembly() : base()
		{
		}
		public IfcElementAssembly(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAssemblyPlaceEnum AssemblyPlace, IfcElementAssemblyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.AssemblyPlace = AssemblyPlace;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElementAssemblyType
	/// <para>ENTITY IfcElementAssemblyType</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>	PredefinedType : IfcElementAssemblyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElementAssemblyTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElementAssemblyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElementAssemblyType : IfcElementType
	{
		public IfcElementAssemblyTypeEnum PredefinedType { get; set; }
		public IfcElementAssemblyType() : base()
		{
			PredefinedType = new IfcElementAssemblyTypeEnum();
		}
		public IfcElementAssemblyType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElementAssemblyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElementComponent
	/// <para>ENTITY IfcElementComponent</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBuildingElementPart</para>
	/// <para>	,IfcDiscreteAccessory</para>
	/// <para>	,IfcFastener</para>
	/// <para>	,IfcImpactProtectionDevice</para>
	/// <para>	,IfcMechanicalFastener</para>
	/// <para>	,IfcReinforcingElement</para>
	/// <para>	,IfcSign</para>
	/// <para>	,IfcVibrationDamper</para>
	/// <para>	,IfcVibrationIsolator))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementComponent : IfcElement
	{
		public IfcElementComponent() : base()
		{
		}
		public IfcElementComponent(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcElementComponentType
	/// <para>ENTITY IfcElementComponentType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBuildingElementPartType</para>
	/// <para>	,IfcDiscreteAccessoryType</para>
	/// <para>	,IfcFastenerType</para>
	/// <para>	,IfcImpactProtectionDeviceType</para>
	/// <para>	,IfcMechanicalFastenerType</para>
	/// <para>	,IfcReinforcingElementType</para>
	/// <para>	,IfcSignType</para>
	/// <para>	,IfcVibrationDamperType</para>
	/// <para>	,IfcVibrationIsolatorType))</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementComponentType : IfcElementType
	{
		public IfcElementComponentType() : base()
		{
		}
		public IfcElementComponentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcElementQuantity
	/// <para>ENTITY IfcElementQuantity</para>
	/// <para> SUBTYPE OF (IfcQuantitySet);</para>
	/// <para>	MethodOfMeasurement : OPTIONAL IfcLabel;</para>
	/// <para>	Quantities : SET [1:?] OF IfcPhysicalQuantity;</para>
	/// <para> WHERE</para>
	/// <para>	UniqueQuantityNames : IfcUniqueQuantityNames(Quantities);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElementQuantity : IfcQuantitySet
	{
		public IfcLabel? MethodOfMeasurement { get; set; }
		public List<IfcPhysicalQuantity> Quantities { get; set; }
		public IfcElementQuantity() : base()
		{
			Quantities = new List<IfcPhysicalQuantity>();
		}
		public IfcElementQuantity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel MethodOfMeasurement, List<IfcPhysicalQuantity> Quantities) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.MethodOfMeasurement = MethodOfMeasurement;
			this.Quantities = Quantities;
		}
	}
	/// <summary>
	/// ENTITY IfcElementType
	/// <para>ENTITY IfcElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBuiltElementType</para>
	/// <para>	,IfcCivilElementType</para>
	/// <para>	,IfcDistributionElementType</para>
	/// <para>	,IfcElementAssemblyType</para>
	/// <para>	,IfcElementComponentType</para>
	/// <para>	,IfcFurnishingElementType</para>
	/// <para>	,IfcGeographicElementType</para>
	/// <para>	,IfcTransportationDeviceType))</para>
	/// <para> SUBTYPE OF (IfcTypeProduct);</para>
	/// <para>	ElementType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementType : IfcTypeProduct
	{
		public IfcLabel? ElementType { get; set; }
		public IfcElementType() : base()
		{
		}
		public IfcElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.ElementType = ElementType;
		}
	}
	/// <summary>
	/// ENTITY IfcElementarySurface
	/// <para>ENTITY IfcElementarySurface</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCylindricalSurface</para>
	/// <para>	,IfcPlane</para>
	/// <para>	,IfcSphericalSurface</para>
	/// <para>	,IfcToroidalSurface))</para>
	/// <para> SUBTYPE OF (IfcSurface);</para>
	/// <para>	Position : IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementarySurface : IfcSurface
	{
		public IfcAxis2Placement3D Position { get; set; }
		public IfcElementarySurface() : base()
		{
			Position = new IfcAxis2Placement3D();
		}
		public IfcElementarySurface(IfcAxis2Placement3D Position) : base ()
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcEllipse
	/// <para>ENTITY IfcEllipse</para>
	/// <para> SUBTYPE OF (IfcConic);</para>
	/// <para>	SemiAxis1 : IfcPositiveLengthMeasure;</para>
	/// <para>	SemiAxis2 : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEllipse : IfcConic
	{
		public IfcPositiveLengthMeasure SemiAxis1 { get; set; }
		public IfcPositiveLengthMeasure SemiAxis2 { get; set; }
		public IfcEllipse() : base()
		{
			SemiAxis1 = new IfcPositiveLengthMeasure();
			SemiAxis2 = new IfcPositiveLengthMeasure();
		}
		public IfcEllipse(IfcAxis2Placement Position, IfcPositiveLengthMeasure SemiAxis1, IfcPositiveLengthMeasure SemiAxis2) : base (Position)
		{
			this.SemiAxis1 = SemiAxis1;
			this.SemiAxis2 = SemiAxis2;
		}
	}
	/// <summary>
	/// ENTITY IfcEllipseProfileDef
	/// <para>ENTITY IfcEllipseProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	SemiAxis1 : IfcPositiveLengthMeasure;</para>
	/// <para>	SemiAxis2 : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEllipseProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure SemiAxis1 { get; set; }
		public IfcPositiveLengthMeasure SemiAxis2 { get; set; }
		public IfcEllipseProfileDef() : base()
		{
			SemiAxis1 = new IfcPositiveLengthMeasure();
			SemiAxis2 = new IfcPositiveLengthMeasure();
		}
		public IfcEllipseProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure SemiAxis1, IfcPositiveLengthMeasure SemiAxis2) : base (ProfileType, ProfileName, Position)
		{
			this.SemiAxis1 = SemiAxis1;
			this.SemiAxis2 = SemiAxis2;
		}
	}
	/// <summary>
	/// ENTITY IfcEnergyConversionDevice
	/// <para>ENTITY IfcEnergyConversionDevice</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAirToAirHeatRecovery</para>
	/// <para>	,IfcBoiler</para>
	/// <para>	,IfcBurner</para>
	/// <para>	,IfcChiller</para>
	/// <para>	,IfcCoil</para>
	/// <para>	,IfcCondenser</para>
	/// <para>	,IfcCooledBeam</para>
	/// <para>	,IfcCoolingTower</para>
	/// <para>	,IfcElectricGenerator</para>
	/// <para>	,IfcElectricMotor</para>
	/// <para>	,IfcEngine</para>
	/// <para>	,IfcEvaporativeCooler</para>
	/// <para>	,IfcEvaporator</para>
	/// <para>	,IfcHeatExchanger</para>
	/// <para>	,IfcHumidifier</para>
	/// <para>	,IfcMotorConnection</para>
	/// <para>	,IfcSolarDevice</para>
	/// <para>	,IfcTransformer</para>
	/// <para>	,IfcTubeBundle</para>
	/// <para>	,IfcUnitaryEquipment))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEnergyConversionDevice : IfcDistributionFlowElement
	{
		public IfcEnergyConversionDevice() : base()
		{
		}
		public IfcEnergyConversionDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcEnergyConversionDeviceType
	/// <para>ENTITY IfcEnergyConversionDeviceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAirToAirHeatRecoveryType</para>
	/// <para>	,IfcBoilerType</para>
	/// <para>	,IfcBurnerType</para>
	/// <para>	,IfcChillerType</para>
	/// <para>	,IfcCoilType</para>
	/// <para>	,IfcCondenserType</para>
	/// <para>	,IfcCooledBeamType</para>
	/// <para>	,IfcCoolingTowerType</para>
	/// <para>	,IfcElectricGeneratorType</para>
	/// <para>	,IfcElectricMotorType</para>
	/// <para>	,IfcEngineType</para>
	/// <para>	,IfcEvaporativeCoolerType</para>
	/// <para>	,IfcEvaporatorType</para>
	/// <para>	,IfcHeatExchangerType</para>
	/// <para>	,IfcHumidifierType</para>
	/// <para>	,IfcMotorConnectionType</para>
	/// <para>	,IfcSolarDeviceType</para>
	/// <para>	,IfcTransformerType</para>
	/// <para>	,IfcTubeBundleType</para>
	/// <para>	,IfcUnitaryEquipmentType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcEnergyConversionDeviceType : IfcDistributionFlowElementType
	{
		public IfcEnergyConversionDeviceType() : base()
		{
		}
		public IfcEnergyConversionDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcEngine
	/// <para>ENTITY IfcEngine</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcEngineTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcEngineTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcEngineTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCENGINETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEngine : IfcEnergyConversionDevice
	{
		public IfcEngineTypeEnum? PredefinedType { get; set; }
		public IfcEngine() : base()
		{
		}
		public IfcEngine(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEngineTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEngineType
	/// <para>ENTITY IfcEngineType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcEngineTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcEngineTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcEngineTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEngineType : IfcEnergyConversionDeviceType
	{
		public IfcEngineTypeEnum PredefinedType { get; set; }
		public IfcEngineType() : base()
		{
			PredefinedType = new IfcEngineTypeEnum();
		}
		public IfcEngineType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcEngineTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporativeCooler
	/// <para>ENTITY IfcEvaporativeCooler</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcEvaporativeCoolerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcEvaporativeCoolerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcEvaporativeCoolerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCEVAPORATIVECOOLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporativeCooler : IfcEnergyConversionDevice
	{
		public IfcEvaporativeCoolerTypeEnum? PredefinedType { get; set; }
		public IfcEvaporativeCooler() : base()
		{
		}
		public IfcEvaporativeCooler(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEvaporativeCoolerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporativeCoolerType
	/// <para>ENTITY IfcEvaporativeCoolerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcEvaporativeCoolerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcEvaporativeCoolerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcEvaporativeCoolerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporativeCoolerType : IfcEnergyConversionDeviceType
	{
		public IfcEvaporativeCoolerTypeEnum PredefinedType { get; set; }
		public IfcEvaporativeCoolerType() : base()
		{
			PredefinedType = new IfcEvaporativeCoolerTypeEnum();
		}
		public IfcEvaporativeCoolerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcEvaporativeCoolerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporator
	/// <para>ENTITY IfcEvaporator</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcEvaporatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcEvaporatorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcEvaporatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCEVAPORATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporator : IfcEnergyConversionDevice
	{
		public IfcEvaporatorTypeEnum? PredefinedType { get; set; }
		public IfcEvaporator() : base()
		{
		}
		public IfcEvaporator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEvaporatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporatorType
	/// <para>ENTITY IfcEvaporatorType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcEvaporatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcEvaporatorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcEvaporatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporatorType : IfcEnergyConversionDeviceType
	{
		public IfcEvaporatorTypeEnum PredefinedType { get; set; }
		public IfcEvaporatorType() : base()
		{
			PredefinedType = new IfcEvaporatorTypeEnum();
		}
		public IfcEvaporatorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcEvaporatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvent
	/// <para>ENTITY IfcEvent</para>
	/// <para> SUBTYPE OF (IfcProcess);</para>
	/// <para>	PredefinedType : OPTIONAL IfcEventTypeEnum;</para>
	/// <para>	EventTriggerType : OPTIONAL IfcEventTriggerTypeEnum;</para>
	/// <para>	UserDefinedEventTriggerType : OPTIONAL IfcLabel;</para>
	/// <para>	EventOccurenceTime : OPTIONAL IfcEventTime;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcEventTypeEnum.USERDEFINED) OR ((PredefinedType = IfcEventTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : NOT(EXISTS(EventTriggerType)) OR (EventTriggerType <> IfcEventTriggerTypeEnum.USERDEFINED) OR ((EventTriggerType = IfcEventTriggerTypeEnum.USERDEFINED) AND EXISTS(UserDefinedEventTriggerType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvent : IfcProcess
	{
		public IfcEventTypeEnum? PredefinedType { get; set; }
		public IfcEventTriggerTypeEnum? EventTriggerType { get; set; }
		public IfcLabel? UserDefinedEventTriggerType { get; set; }
		public IfcEventTime? EventOccurenceTime { get; set; }
		public IfcEvent() : base()
		{
		}
		public IfcEvent(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcEventTypeEnum PredefinedType, IfcEventTriggerTypeEnum EventTriggerType, IfcLabel UserDefinedEventTriggerType, IfcEventTime EventOccurenceTime) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.PredefinedType = PredefinedType;
			this.EventTriggerType = EventTriggerType;
			this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
			this.EventOccurenceTime = EventOccurenceTime;
		}
	}
	/// <summary>
	/// ENTITY IfcEventTime
	/// <para>ENTITY IfcEventTime</para>
	/// <para> SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>	ActualDate : OPTIONAL IfcDateTime;</para>
	/// <para>	EarlyDate : OPTIONAL IfcDateTime;</para>
	/// <para>	LateDate : OPTIONAL IfcDateTime;</para>
	/// <para>	ScheduleDate : OPTIONAL IfcDateTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEventTime : IfcSchedulingTime
	{
		public IfcDateTime? ActualDate { get; set; }
		public IfcDateTime? EarlyDate { get; set; }
		public IfcDateTime? LateDate { get; set; }
		public IfcDateTime? ScheduleDate { get; set; }
		public IfcEventTime() : base()
		{
		}
		public IfcEventTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcDateTime ActualDate, IfcDateTime EarlyDate, IfcDateTime LateDate, IfcDateTime ScheduleDate) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.ActualDate = ActualDate;
			this.EarlyDate = EarlyDate;
			this.LateDate = LateDate;
			this.ScheduleDate = ScheduleDate;
		}
	}
	/// <summary>
	/// ENTITY IfcEventType
	/// <para>ENTITY IfcEventType</para>
	/// <para> SUBTYPE OF (IfcTypeProcess);</para>
	/// <para>	PredefinedType : IfcEventTypeEnum;</para>
	/// <para>	EventTriggerType : IfcEventTriggerTypeEnum;</para>
	/// <para>	UserDefinedEventTriggerType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectEventTriggerType : (EventTriggerType <> IfcEventTriggerTypeEnum.USERDEFINED) OR ((EventTriggerType = IfcEventTriggerTypeEnum.USERDEFINED) AND EXISTS(UserDefinedEventTriggerType)) ;</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcEventTypeEnum.USERDEFINED) OR ((PredefinedType = IfcEventTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEventType : IfcTypeProcess
	{
		public IfcEventTypeEnum PredefinedType { get; set; }
		public IfcEventTriggerTypeEnum EventTriggerType { get; set; }
		public IfcLabel? UserDefinedEventTriggerType { get; set; }
		public IfcEventType() : base()
		{
			PredefinedType = new IfcEventTypeEnum();
			EventTriggerType = new IfcEventTriggerTypeEnum();
		}
		public IfcEventType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType, IfcEventTypeEnum PredefinedType, IfcEventTriggerTypeEnum EventTriggerType, IfcLabel UserDefinedEventTriggerType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType)
		{
			this.PredefinedType = PredefinedType;
			this.EventTriggerType = EventTriggerType;
			this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
		}
	}
	/// <summary>
	/// ENTITY IfcExtendedProperties
	/// <para>ENTITY IfcExtendedProperties</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMaterialProperties</para>
	/// <para>	,IfcProfileProperties))</para>
	/// <para> SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>	Name : OPTIONAL IfcIdentifier;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Properties : SET [1:?] OF IfcProperty;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExtendedProperties : IfcPropertyAbstraction
	{
		public IfcIdentifier? Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcProperty> Properties { get; set; }
		public IfcExtendedProperties() : base()
		{
			Properties = new List<IfcProperty>();
		}
		public IfcExtendedProperties(IfcIdentifier Name, IfcText Description, List<IfcProperty> Properties) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Properties = Properties;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalInformation
	/// <para>ENTITY IfcExternalInformation</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcClassification</para>
	/// <para>	,IfcDocumentInformation</para>
	/// <para>	,IfcLibraryInformation));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExternalInformationENTITY, IfcResourceObjectSelect
	{
		public IfcExternalInformation() : base()
		{
		}
		public IfcExternalInformation() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternalReference
	/// <para>ENTITY IfcExternalReference</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcClassificationReference</para>
	/// <para>	,IfcDocumentReference</para>
	/// <para>	,IfcExternallyDefinedHatchStyle</para>
	/// <para>	,IfcExternallyDefinedSurfaceStyle</para>
	/// <para>	,IfcExternallyDefinedTextFont</para>
	/// <para>	,IfcLibraryReference));</para>
	/// <para>	Location : OPTIONAL IfcURIReference;</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ExternalReferenceForResources : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatingReference;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : EXISTS(Identification) OR EXISTS(Location) OR EXISTS(Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExternalReferenceENTITY, IfcLightDistributionDataSourceSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcURIReference? Location { get; set; }
		public IfcIdentifier? Identification { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcExternalReference() : base()
		{
		}
		public IfcExternalReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base ()
		{
			this.Location = Location;
			this.Identification = Identification;
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalReferenceRelationship
	/// <para>ENTITY IfcExternalReferenceRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingReference : IfcExternalReference;</para>
	/// <para>	RelatedResourceObjects : SET [1:?] OF IfcResourceObjectSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternalReferenceRelationship : IfcResourceLevelRelationship
	{
		public IfcExternalReference RelatingReference { get; set; }
		public List<IfcResourceObjectSelect> RelatedResourceObjects { get; set; }
		public IfcExternalReferenceRelationship() : base()
		{
			RelatingReference = new IfcExternalReference();
			RelatedResourceObjects = new List<IfcResourceObjectSelect>();
		}
		public IfcExternalReferenceRelationship(IfcLabel Name, IfcText Description, IfcExternalReference RelatingReference, List<IfcResourceObjectSelect> RelatedResourceObjects) : base (Name, Description)
		{
			this.RelatingReference = RelatingReference;
			this.RelatedResourceObjects = RelatedResourceObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalSpatialElement
	/// <para>ENTITY IfcExternalSpatialElement</para>
	/// <para> SUBTYPE OF (IfcExternalSpatialStructureElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcExternalSpatialElementTypeEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	BoundedBy : SET [0:?] OF IfcRelSpaceBoundary FOR RelatingSpace;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternalSpatialElement : IfcExternalSpatialStructureElement, IfcSpaceBoundarySelect
	{
		public IfcExternalSpatialElementTypeEnum? PredefinedType { get; set; }
		public IfcExternalSpatialElement() : base()
		{
		}
		public IfcExternalSpatialElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcExternalSpatialElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalSpatialStructureElement
	/// <para>ENTITY IfcExternalSpatialStructureElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcExternalSpatialElement))</para>
	/// <para> SUBTYPE OF (IfcSpatialElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExternalSpatialStructureElement : IfcSpatialElement
	{
		public IfcExternalSpatialStructureElement() : base()
		{
		}
		public IfcExternalSpatialStructureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternallyDefinedHatchStyle
	/// <para>ENTITY IfcExternallyDefinedHatchStyle</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternallyDefinedHatchStyle : IfcExternalReference, IfcFillStyleSelect
	{
		public IfcExternallyDefinedHatchStyle() : base()
		{
		}
		public IfcExternallyDefinedHatchStyle(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base (Location, Identification, Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternallyDefinedSurfaceStyle
	/// <para>ENTITY IfcExternallyDefinedSurfaceStyle</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternallyDefinedSurfaceStyle : IfcExternalReference, IfcSurfaceStyleElementSelect
	{
		public IfcExternallyDefinedSurfaceStyle() : base()
		{
		}
		public IfcExternallyDefinedSurfaceStyle(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base (Location, Identification, Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternallyDefinedTextFont
	/// <para>ENTITY IfcExternallyDefinedTextFont</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternallyDefinedTextFont : IfcExternalReference, IfcTextFontSelect
	{
		public IfcExternallyDefinedTextFont() : base()
		{
		}
		public IfcExternallyDefinedTextFont(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base (Location, Identification, Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExtrudedAreaSolid
	/// <para>ENTITY IfcExtrudedAreaSolid</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcExtrudedAreaSolidTapered))</para>
	/// <para> SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>	ExtrudedDirection : IfcDirection;</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidExtrusionDirection : IfcDotProduct(IfcRepresentationItem() || IfcGeometricRepresentationItem() || IfcDirection([0.0,0.0,1.0]), SELF.ExtrudedDirection) <> 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExtrudedAreaSolid : IfcSweptAreaSolid
	{
		public IfcDirection ExtrudedDirection { get; set; }
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcExtrudedAreaSolid() : base()
		{
			ExtrudedDirection = new IfcDirection();
			Depth = new IfcPositiveLengthMeasure();
		}
		public IfcExtrudedAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcDirection ExtrudedDirection, IfcPositiveLengthMeasure Depth) : base (SweptArea, Position)
		{
			this.ExtrudedDirection = ExtrudedDirection;
			this.Depth = Depth;
		}
	}
	/// <summary>
	/// ENTITY IfcExtrudedAreaSolidTapered
	/// <para>ENTITY IfcExtrudedAreaSolidTapered</para>
	/// <para> SUBTYPE OF (IfcExtrudedAreaSolid);</para>
	/// <para>	EndSweptArea : IfcProfileDef;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectProfileAssignment : IfcTaperedSweptAreaProfiles(SELF\IfcSweptAreaSolid.SweptArea, SELF.EndSweptArea);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExtrudedAreaSolidTapered : IfcExtrudedAreaSolid
	{
		public IfcProfileDef EndSweptArea { get; set; }
		public IfcExtrudedAreaSolidTapered() : base()
		{
			EndSweptArea = new IfcProfileDef();
		}
		public IfcExtrudedAreaSolidTapered(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcDirection ExtrudedDirection, IfcPositiveLengthMeasure Depth, IfcProfileDef EndSweptArea) : base (SweptArea, Position, ExtrudedDirection, Depth)
		{
			this.EndSweptArea = EndSweptArea;
		}
	}
	/// <summary>
	/// ENTITY IfcFace
	/// <para>ENTITY IfcFace</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcFaceSurface))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>	Bounds : SET [1:?] OF IfcFaceBound;</para>
	/// <para> INVERSE</para>
	/// <para>	HasTextureMaps : SET [0:?] OF IfcTextureMap FOR MappedTo;</para>
	/// <para> WHERE</para>
	/// <para>	HasOuterBound : SIZEOF(QUERY(temp <* Bounds | 'IFC4X3_ADD2.IFCFACEOUTERBOUND' IN TYPEOF(temp))) <= 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFace : IfcTopologicalRepresentationItem
	{
		public List<IfcFaceBound> Bounds { get; set; }
		public IfcFace() : base()
		{
			Bounds = new List<IfcFaceBound>();
		}
		public IfcFace(List<IfcFaceBound> Bounds) : base ()
		{
			this.Bounds = Bounds;
		}
	}
	/// <summary>
	/// ENTITY IfcFaceBasedSurfaceModel
	/// <para>ENTITY IfcFaceBasedSurfaceModel</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	FbsmFaces : SET [1:?] OF IfcConnectedFaceSet;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceBasedSurfaceModel : IfcGeometricRepresentationItem, IfcSurfaceOrFaceSurface
	{
		public List<IfcConnectedFaceSet> FbsmFaces { get; set; }
		public IfcFaceBasedSurfaceModel() : base()
		{
			FbsmFaces = new List<IfcConnectedFaceSet>();
		}
		public IfcFaceBasedSurfaceModel(List<IfcConnectedFaceSet> FbsmFaces) : base ()
		{
			this.FbsmFaces = FbsmFaces;
		}
	}
	/// <summary>
	/// ENTITY IfcFaceBound
	/// <para>ENTITY IfcFaceBound</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcFaceOuterBound))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>	Bound : IfcLoop;</para>
	/// <para>	Orientation : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceBound : IfcTopologicalRepresentationItem
	{
		public IfcLoop Bound { get; set; }
		public IfcBoolean Orientation { get; set; }
		public IfcFaceBound() : base()
		{
			Bound = new IfcLoop();
			Orientation = new IfcBoolean();
		}
		public IfcFaceBound(IfcLoop Bound, IfcBoolean Orientation) : base ()
		{
			this.Bound = Bound;
			this.Orientation = Orientation;
		}
	}
	/// <summary>
	/// ENTITY IfcFaceOuterBound
	/// <para>ENTITY IfcFaceOuterBound</para>
	/// <para> SUBTYPE OF (IfcFaceBound);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceOuterBound : IfcFaceBound
	{
		public IfcFaceOuterBound() : base()
		{
		}
		public IfcFaceOuterBound(IfcLoop Bound, IfcBoolean Orientation) : base (Bound, Orientation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFaceSurface
	/// <para>ENTITY IfcFaceSurface</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAdvancedFace))</para>
	/// <para> SUBTYPE OF (IfcFace);</para>
	/// <para>	FaceSurface : IfcSurface;</para>
	/// <para>	SameSense : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceSurface : IfcFace, IfcSurfaceOrFaceSurface
	{
		public IfcSurface FaceSurface { get; set; }
		public IfcBoolean SameSense { get; set; }
		public IfcFaceSurface() : base()
		{
			FaceSurface = new IfcSurface();
			SameSense = new IfcBoolean();
		}
		public IfcFaceSurface(List<IfcFaceBound> Bounds, IfcSurface FaceSurface, IfcBoolean SameSense) : base (Bounds)
		{
			this.FaceSurface = FaceSurface;
			this.SameSense = SameSense;
		}
	}
	/// <summary>
	/// ENTITY IfcFacetedBrep
	/// <para>ENTITY IfcFacetedBrep</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcFacetedBrepWithVoids))</para>
	/// <para> SUBTYPE OF (IfcManifoldSolidBrep);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFacetedBrep : IfcManifoldSolidBrep
	{
		public IfcFacetedBrep() : base()
		{
		}
		public IfcFacetedBrep(IfcClosedShell Outer) : base (Outer)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFacetedBrepWithVoids
	/// <para>ENTITY IfcFacetedBrepWithVoids</para>
	/// <para> SUBTYPE OF (IfcFacetedBrep);</para>
	/// <para>	Voids : SET [1:?] OF IfcClosedShell;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFacetedBrepWithVoids : IfcFacetedBrep
	{
		public List<IfcClosedShell> Voids { get; set; }
		public IfcFacetedBrepWithVoids() : base()
		{
			Voids = new List<IfcClosedShell>();
		}
		public IfcFacetedBrepWithVoids(IfcClosedShell Outer, List<IfcClosedShell> Voids) : base (Outer)
		{
			this.Voids = Voids;
		}
	}
	/// <summary>
	/// ENTITY IfcFacility
	/// <para>ENTITY IfcFacility</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBridge</para>
	/// <para>	,IfcBuilding</para>
	/// <para>	,IfcMarineFacility</para>
	/// <para>	,IfcRailway</para>
	/// <para>	,IfcRoad))</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFacility : IfcSpatialStructureElement
	{
		public IfcFacility() : base()
		{
		}
		public IfcFacility(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFacilityPart
	/// <para>ENTITY IfcFacilityPart</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBridgePart</para>
	/// <para>	,IfcFacilityPartCommon</para>
	/// <para>	,IfcMarinePart</para>
	/// <para>	,IfcRailwayPart</para>
	/// <para>	,IfcRoadPart))</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>	UsageType : IfcFacilityUsageEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFacilityPart : IfcSpatialStructureElement
	{
		public IfcFacilityUsageEnum UsageType { get; set; }
		public IfcFacilityPart() : base()
		{
			UsageType = new IfcFacilityUsageEnum();
		}
		public IfcFacilityPart(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcFacilityUsageEnum UsageType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.UsageType = UsageType;
		}
	}
	/// <summary>
	/// ENTITY IfcFacilityPartCommon
	/// <para>ENTITY IfcFacilityPartCommon</para>
	/// <para> SUBTYPE OF (IfcFacilityPart);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFacilityPartCommonTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcFacilityPartCommonTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFacilityPartCommonTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFacilityPartCommon : IfcFacilityPart
	{
		public IfcFacilityPartCommonTypeEnum? PredefinedType { get; set; }
		public IfcFacilityPartCommon() : base()
		{
		}
		public IfcFacilityPartCommon(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcFacilityUsageEnum UsageType, IfcFacilityPartCommonTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, UsageType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFailureConnectionCondition
	/// <para>ENTITY IfcFailureConnectionCondition</para>
	/// <para> SUBTYPE OF (IfcStructuralConnectionCondition);</para>
	/// <para>	TensionFailureX : OPTIONAL IfcForceMeasure;</para>
	/// <para>	TensionFailureY : OPTIONAL IfcForceMeasure;</para>
	/// <para>	TensionFailureZ : OPTIONAL IfcForceMeasure;</para>
	/// <para>	CompressionFailureX : OPTIONAL IfcForceMeasure;</para>
	/// <para>	CompressionFailureY : OPTIONAL IfcForceMeasure;</para>
	/// <para>	CompressionFailureZ : OPTIONAL IfcForceMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFailureConnectionCondition : IfcStructuralConnectionCondition
	{
		public IfcForceMeasure? TensionFailureX { get; set; }
		public IfcForceMeasure? TensionFailureY { get; set; }
		public IfcForceMeasure? TensionFailureZ { get; set; }
		public IfcForceMeasure? CompressionFailureX { get; set; }
		public IfcForceMeasure? CompressionFailureY { get; set; }
		public IfcForceMeasure? CompressionFailureZ { get; set; }
		public IfcFailureConnectionCondition() : base()
		{
		}
		public IfcFailureConnectionCondition(IfcLabel Name, IfcForceMeasure TensionFailureX, IfcForceMeasure TensionFailureY, IfcForceMeasure TensionFailureZ, IfcForceMeasure CompressionFailureX, IfcForceMeasure CompressionFailureY, IfcForceMeasure CompressionFailureZ) : base (Name)
		{
			this.TensionFailureX = TensionFailureX;
			this.TensionFailureY = TensionFailureY;
			this.TensionFailureZ = TensionFailureZ;
			this.CompressionFailureX = CompressionFailureX;
			this.CompressionFailureY = CompressionFailureY;
			this.CompressionFailureZ = CompressionFailureZ;
		}
	}
	/// <summary>
	/// ENTITY IfcFan
	/// <para>ENTITY IfcFan</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFanTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcFanTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFanTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCFANTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFan : IfcFlowMovingDevice
	{
		public IfcFanTypeEnum? PredefinedType { get; set; }
		public IfcFan() : base()
		{
		}
		public IfcFan(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFanTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFanType
	/// <para>ENTITY IfcFanType</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDeviceType);</para>
	/// <para>	PredefinedType : IfcFanTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFanTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFanTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFanType : IfcFlowMovingDeviceType
	{
		public IfcFanTypeEnum PredefinedType { get; set; }
		public IfcFanType() : base()
		{
			PredefinedType = new IfcFanTypeEnum();
		}
		public IfcFanType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFanTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFastener
	/// <para>ENTITY IfcFastener</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFastenerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFastenerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCFASTENERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFastener : IfcElementComponent
	{
		public IfcFastenerTypeEnum? PredefinedType { get; set; }
		public IfcFastener() : base()
		{
		}
		public IfcFastener(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFastenerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFastenerType
	/// <para>ENTITY IfcFastenerType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcFastenerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFastenerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFastenerType : IfcElementComponentType
	{
		public IfcFastenerTypeEnum PredefinedType { get; set; }
		public IfcFastenerType() : base()
		{
			PredefinedType = new IfcFastenerTypeEnum();
		}
		public IfcFastenerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFastenerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFeatureElement
	/// <para>ENTITY IfcFeatureElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcFeatureElementAddition</para>
	/// <para>	,IfcFeatureElementSubtraction</para>
	/// <para>	,IfcSurfaceFeature))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para> WHERE</para>
	/// <para>	NotContained : SIZEOF(ContainedInStructure) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFeatureElement : IfcElement
	{
		public IfcFeatureElement() : base()
		{
		}
		public IfcFeatureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFeatureElementAddition
	/// <para>ENTITY IfcFeatureElementAddition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcProjectionElement))</para>
	/// <para> SUBTYPE OF (IfcFeatureElement);</para>
	/// <para> INVERSE</para>
	/// <para>	ProjectsElements : IfcRelProjectsElement FOR RelatedFeatureElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFeatureElementAddition : IfcFeatureElement
	{
		public IfcFeatureElementAddition() : base()
		{
		}
		public IfcFeatureElementAddition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFeatureElementSubtraction
	/// <para>ENTITY IfcFeatureElementSubtraction</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcEarthworksCut</para>
	/// <para>	,IfcOpeningElement</para>
	/// <para>	,IfcVoidingFeature))</para>
	/// <para> SUBTYPE OF (IfcFeatureElement);</para>
	/// <para> INVERSE</para>
	/// <para>	VoidsElements : IfcRelVoidsElement FOR RelatedOpeningElement;</para>
	/// <para> WHERE</para>
	/// <para>	HasNoSubtraction : SIZEOF(SELF\IfcElement.HasOpenings) = 0;</para>
	/// <para>	IsNotFilling : SIZEOF(SELF\IfcElement.FillsVoids) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFeatureElementSubtraction : IfcFeatureElement
	{
		public IfcFeatureElementSubtraction() : base()
		{
		}
		public IfcFeatureElementSubtraction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFillAreaStyle
	/// <para>ENTITY IfcFillAreaStyle</para>
	/// <para> SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>	FillStyles : SET [1:?] OF IfcFillStyleSelect;</para>
	/// <para>	ModelOrDraughting : OPTIONAL IfcBoolean;</para>
	/// <para> WHERE</para>
	/// <para>	ConsistentHatchStyleDef : IfcCorrectFillAreaStyle(SELF.FillStyles);</para>
	/// <para>	MaxOneColour : SIZEOF(QUERY(Style <* SELF.FillStyles |</para>
	/// <para>  'IFC4X3_ADD2.IFCCOLOUR' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	MaxOneExtHatchStyle : SIZEOF(QUERY(Style <* SELF.FillStyles |</para>
	/// <para>  'IFC4X3_ADD2.IFCEXTERNALLYDEFINEDHATCHSTYLE' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFillAreaStyle : IfcPresentationStyle
	{
		public List<IfcFillStyleSelect> FillStyles { get; set; }
		public IfcBoolean? ModelOrDraughting { get; set; }
		public IfcFillAreaStyle() : base()
		{
			FillStyles = new List<IfcFillStyleSelect>();
		}
		public IfcFillAreaStyle(IfcLabel Name, List<IfcFillStyleSelect> FillStyles, IfcBoolean ModelOrDraughting) : base (Name)
		{
			this.FillStyles = FillStyles;
			this.ModelOrDraughting = ModelOrDraughting;
		}
	}
	/// <summary>
	/// ENTITY IfcFillAreaStyleHatching
	/// <para>ENTITY IfcFillAreaStyleHatching</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	HatchLineAppearance : IfcCurveStyle;</para>
	/// <para>	StartOfNextHatchLine : IfcHatchLineDistanceSelect;</para>
	/// <para>	PointOfReferenceHatchLine : OPTIONAL IfcCartesianPoint;</para>
	/// <para>	PatternStart : OPTIONAL IfcCartesianPoint;</para>
	/// <para>	HatchLineAngle : IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	PatternStart2D : NOT(EXISTS(PatternStart)) OR (PatternStart.Dim = 2)</para>
	/// <para>;</para>
	/// <para>	RefHatchLine2D : NOT(EXISTS(PointOfReferenceHatchLine)) OR (PointOfReferenceHatchLine.Dim = 2);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFillAreaStyleHatching : IfcGeometricRepresentationItem, IfcFillStyleSelect
	{
		public IfcCurveStyle HatchLineAppearance { get; set; }
		public IfcHatchLineDistanceSelect StartOfNextHatchLine { get; set; }
		public IfcCartesianPoint? PointOfReferenceHatchLine { get; set; }
		public IfcCartesianPoint? PatternStart { get; set; }
		public IfcPlaneAngleMeasure HatchLineAngle { get; set; }
		public IfcFillAreaStyleHatching() : base()
		{
			HatchLineAppearance = new IfcCurveStyle();
			StartOfNextHatchLine = new IfcHatchLineDistanceSelect();
			HatchLineAngle = new IfcPlaneAngleMeasure();
		}
		public IfcFillAreaStyleHatching(IfcCurveStyle HatchLineAppearance, IfcHatchLineDistanceSelect StartOfNextHatchLine, IfcCartesianPoint PointOfReferenceHatchLine, IfcCartesianPoint PatternStart, IfcPlaneAngleMeasure HatchLineAngle) : base ()
		{
			this.HatchLineAppearance = HatchLineAppearance;
			this.StartOfNextHatchLine = StartOfNextHatchLine;
			this.PointOfReferenceHatchLine = PointOfReferenceHatchLine;
			this.PatternStart = PatternStart;
			this.HatchLineAngle = HatchLineAngle;
		}
	}
	/// <summary>
	/// ENTITY IfcFillAreaStyleTiles
	/// <para>ENTITY IfcFillAreaStyleTiles</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	TilingPattern : LIST [2:2] OF IfcVector;</para>
	/// <para>	Tiles : SET [1:?] OF IfcStyledItem;</para>
	/// <para>	TilingScale : IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFillAreaStyleTiles : IfcGeometricRepresentationItem, IfcFillStyleSelect
	{
		public List<IfcVector> TilingPattern { get; set; }
		public List<IfcStyledItem> Tiles { get; set; }
		public IfcPositiveRatioMeasure TilingScale { get; set; }
		public IfcFillAreaStyleTiles() : base()
		{
			TilingPattern = new List<IfcVector>();
			Tiles = new List<IfcStyledItem>();
			TilingScale = new IfcPositiveRatioMeasure();
		}
		public IfcFillAreaStyleTiles(List<IfcVector> TilingPattern, List<IfcStyledItem> Tiles, IfcPositiveRatioMeasure TilingScale) : base ()
		{
			this.TilingPattern = TilingPattern;
			this.Tiles = Tiles;
			this.TilingScale = TilingScale;
		}
	}
	/// <summary>
	/// ENTITY IfcFilter
	/// <para>ENTITY IfcFilter</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFilterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcFilterTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFilterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCFILTERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFilter : IfcFlowTreatmentDevice
	{
		public IfcFilterTypeEnum? PredefinedType { get; set; }
		public IfcFilter() : base()
		{
		}
		public IfcFilter(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFilterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFilterType
	/// <para>ENTITY IfcFilterType</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDeviceType);</para>
	/// <para>	PredefinedType : IfcFilterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFilterTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFilterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFilterType : IfcFlowTreatmentDeviceType
	{
		public IfcFilterTypeEnum PredefinedType { get; set; }
		public IfcFilterType() : base()
		{
			PredefinedType = new IfcFilterTypeEnum();
		}
		public IfcFilterType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFilterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFireSuppressionTerminal
	/// <para>ENTITY IfcFireSuppressionTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFireSuppressionTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcFireSuppressionTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFireSuppressionTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCFIRESUPPRESSIONTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFireSuppressionTerminal : IfcFlowTerminal
	{
		public IfcFireSuppressionTerminalTypeEnum? PredefinedType { get; set; }
		public IfcFireSuppressionTerminal() : base()
		{
		}
		public IfcFireSuppressionTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFireSuppressionTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFireSuppressionTerminalType
	/// <para>ENTITY IfcFireSuppressionTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcFireSuppressionTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFireSuppressionTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFireSuppressionTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFireSuppressionTerminalType : IfcFlowTerminalType
	{
		public IfcFireSuppressionTerminalTypeEnum PredefinedType { get; set; }
		public IfcFireSuppressionTerminalType() : base()
		{
			PredefinedType = new IfcFireSuppressionTerminalTypeEnum();
		}
		public IfcFireSuppressionTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFireSuppressionTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFixedReferenceSweptAreaSolid
	/// <para>ENTITY IfcFixedReferenceSweptAreaSolid</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDirectrixDerivedReferenceSweptAreaSolid))</para>
	/// <para> SUBTYPE OF (IfcDirectrixCurveSweptAreaSolid);</para>
	/// <para>	FixedReference : IfcDirection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFixedReferenceSweptAreaSolid : IfcDirectrixCurveSweptAreaSolid
	{
		public IfcDirection FixedReference { get; set; }
		public IfcFixedReferenceSweptAreaSolid() : base()
		{
			FixedReference = new IfcDirection();
		}
		public IfcFixedReferenceSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcCurve Directrix, IfcCurveMeasureSelect StartParam, IfcCurveMeasureSelect EndParam, IfcDirection FixedReference) : base (SweptArea, Position, Directrix, StartParam, EndParam)
		{
			this.FixedReference = FixedReference;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowController
	/// <para>ENTITY IfcFlowController</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAirTerminalBox</para>
	/// <para>	,IfcDamper</para>
	/// <para>	,IfcDistributionBoard</para>
	/// <para>	,IfcElectricDistributionBoard</para>
	/// <para>	,IfcElectricTimeControl</para>
	/// <para>	,IfcFlowMeter</para>
	/// <para>	,IfcProtectiveDevice</para>
	/// <para>	,IfcSwitchingDevice</para>
	/// <para>	,IfcValve))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowController : IfcDistributionFlowElement
	{
		public IfcFlowController() : base()
		{
		}
		public IfcFlowController(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowControllerType
	/// <para>ENTITY IfcFlowControllerType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAirTerminalBoxType</para>
	/// <para>	,IfcDamperType</para>
	/// <para>	,IfcDistributionBoardType</para>
	/// <para>	,IfcElectricDistributionBoardType</para>
	/// <para>	,IfcElectricTimeControlType</para>
	/// <para>	,IfcFlowMeterType</para>
	/// <para>	,IfcProtectiveDeviceType</para>
	/// <para>	,IfcSwitchingDeviceType</para>
	/// <para>	,IfcValveType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowControllerType : IfcDistributionFlowElementType
	{
		public IfcFlowControllerType() : base()
		{
		}
		public IfcFlowControllerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowFitting
	/// <para>ENTITY IfcFlowFitting</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCableCarrierFitting</para>
	/// <para>	,IfcCableFitting</para>
	/// <para>	,IfcDuctFitting</para>
	/// <para>	,IfcJunctionBox</para>
	/// <para>	,IfcPipeFitting))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowFitting : IfcDistributionFlowElement
	{
		public IfcFlowFitting() : base()
		{
		}
		public IfcFlowFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowFittingType
	/// <para>ENTITY IfcFlowFittingType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCableCarrierFittingType</para>
	/// <para>	,IfcCableFittingType</para>
	/// <para>	,IfcDuctFittingType</para>
	/// <para>	,IfcJunctionBoxType</para>
	/// <para>	,IfcPipeFittingType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowFittingType : IfcDistributionFlowElementType
	{
		public IfcFlowFittingType() : base()
		{
		}
		public IfcFlowFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowInstrument
	/// <para>ENTITY IfcFlowInstrument</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFlowInstrumentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcFlowInstrumentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFlowInstrumentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCFLOWINSTRUMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowInstrument : IfcDistributionControlElement
	{
		public IfcFlowInstrumentTypeEnum? PredefinedType { get; set; }
		public IfcFlowInstrument() : base()
		{
		}
		public IfcFlowInstrument(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFlowInstrumentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowInstrumentType
	/// <para>ENTITY IfcFlowInstrumentType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcFlowInstrumentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFlowInstrumentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFlowInstrumentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowInstrumentType : IfcDistributionControlElementType
	{
		public IfcFlowInstrumentTypeEnum PredefinedType { get; set; }
		public IfcFlowInstrumentType() : base()
		{
			PredefinedType = new IfcFlowInstrumentTypeEnum();
		}
		public IfcFlowInstrumentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFlowInstrumentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMeter
	/// <para>ENTITY IfcFlowMeter</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFlowMeterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcFlowMeterTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFlowMeterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCFLOWMETERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowMeter : IfcFlowController
	{
		public IfcFlowMeterTypeEnum? PredefinedType { get; set; }
		public IfcFlowMeter() : base()
		{
		}
		public IfcFlowMeter(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFlowMeterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMeterType
	/// <para>ENTITY IfcFlowMeterType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcFlowMeterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFlowMeterTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFlowMeterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowMeterType : IfcFlowControllerType
	{
		public IfcFlowMeterTypeEnum PredefinedType { get; set; }
		public IfcFlowMeterType() : base()
		{
			PredefinedType = new IfcFlowMeterTypeEnum();
		}
		public IfcFlowMeterType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFlowMeterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMovingDevice
	/// <para>ENTITY IfcFlowMovingDevice</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCompressor</para>
	/// <para>	,IfcFan</para>
	/// <para>	,IfcPump))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowMovingDevice : IfcDistributionFlowElement
	{
		public IfcFlowMovingDevice() : base()
		{
		}
		public IfcFlowMovingDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMovingDeviceType
	/// <para>ENTITY IfcFlowMovingDeviceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCompressorType</para>
	/// <para>	,IfcFanType</para>
	/// <para>	,IfcPumpType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowMovingDeviceType : IfcDistributionFlowElementType
	{
		public IfcFlowMovingDeviceType() : base()
		{
		}
		public IfcFlowMovingDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowSegment
	/// <para>ENTITY IfcFlowSegment</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCableCarrierSegment</para>
	/// <para>	,IfcCableSegment</para>
	/// <para>	,IfcConveyorSegment</para>
	/// <para>	,IfcDuctSegment</para>
	/// <para>	,IfcPipeSegment))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowSegment : IfcDistributionFlowElement
	{
		public IfcFlowSegment() : base()
		{
		}
		public IfcFlowSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowSegmentType
	/// <para>ENTITY IfcFlowSegmentType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCableCarrierSegmentType</para>
	/// <para>	,IfcCableSegmentType</para>
	/// <para>	,IfcConveyorSegmentType</para>
	/// <para>	,IfcDuctSegmentType</para>
	/// <para>	,IfcPipeSegmentType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowSegmentType : IfcDistributionFlowElementType
	{
		public IfcFlowSegmentType() : base()
		{
		}
		public IfcFlowSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowStorageDevice
	/// <para>ENTITY IfcFlowStorageDevice</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcElectricFlowStorageDevice</para>
	/// <para>	,IfcTank))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowStorageDevice : IfcDistributionFlowElement
	{
		public IfcFlowStorageDevice() : base()
		{
		}
		public IfcFlowStorageDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowStorageDeviceType
	/// <para>ENTITY IfcFlowStorageDeviceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcElectricFlowStorageDeviceType</para>
	/// <para>	,IfcTankType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowStorageDeviceType : IfcDistributionFlowElementType
	{
		public IfcFlowStorageDeviceType() : base()
		{
		}
		public IfcFlowStorageDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTerminal
	/// <para>ENTITY IfcFlowTerminal</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAirTerminal</para>
	/// <para>	,IfcAudioVisualAppliance</para>
	/// <para>	,IfcCommunicationsAppliance</para>
	/// <para>	,IfcElectricAppliance</para>
	/// <para>	,IfcFireSuppressionTerminal</para>
	/// <para>	,IfcLamp</para>
	/// <para>	,IfcLightFixture</para>
	/// <para>	,IfcLiquidTerminal</para>
	/// <para>	,IfcMedicalDevice</para>
	/// <para>	,IfcMobileTelecommunicationsAppliance</para>
	/// <para>	,IfcOutlet</para>
	/// <para>	,IfcSanitaryTerminal</para>
	/// <para>	,IfcSignal</para>
	/// <para>	,IfcSpaceHeater</para>
	/// <para>	,IfcStackTerminal</para>
	/// <para>	,IfcWasteTerminal))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowTerminal : IfcDistributionFlowElement
	{
		public IfcFlowTerminal() : base()
		{
		}
		public IfcFlowTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTerminalType
	/// <para>ENTITY IfcFlowTerminalType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAirTerminalType</para>
	/// <para>	,IfcAudioVisualApplianceType</para>
	/// <para>	,IfcCommunicationsApplianceType</para>
	/// <para>	,IfcElectricApplianceType</para>
	/// <para>	,IfcFireSuppressionTerminalType</para>
	/// <para>	,IfcLampType</para>
	/// <para>	,IfcLightFixtureType</para>
	/// <para>	,IfcLiquidTerminalType</para>
	/// <para>	,IfcMedicalDeviceType</para>
	/// <para>	,IfcMobileTelecommunicationsApplianceType</para>
	/// <para>	,IfcOutletType</para>
	/// <para>	,IfcSanitaryTerminalType</para>
	/// <para>	,IfcSignalType</para>
	/// <para>	,IfcSpaceHeaterType</para>
	/// <para>	,IfcStackTerminalType</para>
	/// <para>	,IfcWasteTerminalType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowTerminalType : IfcDistributionFlowElementType
	{
		public IfcFlowTerminalType() : base()
		{
		}
		public IfcFlowTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTreatmentDevice
	/// <para>ENTITY IfcFlowTreatmentDevice</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDuctSilencer</para>
	/// <para>	,IfcElectricFlowTreatmentDevice</para>
	/// <para>	,IfcFilter</para>
	/// <para>	,IfcInterceptor))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowTreatmentDevice : IfcDistributionFlowElement
	{
		public IfcFlowTreatmentDevice() : base()
		{
		}
		public IfcFlowTreatmentDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTreatmentDeviceType
	/// <para>ENTITY IfcFlowTreatmentDeviceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDuctSilencerType</para>
	/// <para>	,IfcElectricFlowTreatmentDeviceType</para>
	/// <para>	,IfcFilterType</para>
	/// <para>	,IfcInterceptorType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowTreatmentDeviceType : IfcDistributionFlowElementType
	{
		public IfcFlowTreatmentDeviceType() : base()
		{
		}
		public IfcFlowTreatmentDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFooting
	/// <para>ENTITY IfcFooting</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFootingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcFootingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFootingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCFOOTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFooting : IfcBuiltElement
	{
		public IfcFootingTypeEnum? PredefinedType { get; set; }
		public IfcFooting() : base()
		{
		}
		public IfcFooting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFootingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFootingType
	/// <para>ENTITY IfcFootingType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcFootingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFootingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFootingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFootingType : IfcBuiltElementType
	{
		public IfcFootingTypeEnum PredefinedType { get; set; }
		public IfcFootingType() : base()
		{
			PredefinedType = new IfcFootingTypeEnum();
		}
		public IfcFootingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFootingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFurnishingElement
	/// <para>ENTITY IfcFurnishingElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcFurniture</para>
	/// <para>	,IfcSystemFurnitureElement))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurnishingElement : IfcElement
	{
		public IfcFurnishingElement() : base()
		{
		}
		public IfcFurnishingElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFurnishingElementType
	/// <para>ENTITY IfcFurnishingElementType</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcFurnitureType</para>
	/// <para>	,IfcSystemFurnitureElementType))</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurnishingElementType : IfcElementType
	{
		public IfcFurnishingElementType() : base()
		{
		}
		public IfcFurnishingElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFurniture
	/// <para>ENTITY IfcFurniture</para>
	/// <para> SUBTYPE OF (IfcFurnishingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFurnitureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcFurnitureTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFurnitureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCFURNITURETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurniture : IfcFurnishingElement
	{
		public IfcFurnitureTypeEnum? PredefinedType { get; set; }
		public IfcFurniture() : base()
		{
		}
		public IfcFurniture(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFurnitureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFurnitureType
	/// <para>ENTITY IfcFurnitureType</para>
	/// <para> SUBTYPE OF (IfcFurnishingElementType);</para>
	/// <para>	AssemblyPlace : IfcAssemblyPlaceEnum;</para>
	/// <para>	PredefinedType : OPTIONAL IfcFurnitureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcFurnitureTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcFurnitureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurnitureType : IfcFurnishingElementType
	{
		public IfcAssemblyPlaceEnum AssemblyPlace { get; set; }
		public IfcFurnitureTypeEnum? PredefinedType { get; set; }
		public IfcFurnitureType() : base()
		{
			AssemblyPlace = new IfcAssemblyPlaceEnum();
		}
		public IfcFurnitureType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAssemblyPlaceEnum AssemblyPlace, IfcFurnitureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.AssemblyPlace = AssemblyPlace;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcGeographicCRS
	/// <para>ENTITY IfcGeographicCRS</para>
	/// <para> SUBTYPE OF (IfcCoordinateReferenceSystem);</para>
	/// <para>	PrimeMeridian : OPTIONAL IfcIdentifier;</para>
	/// <para>	AngleUnit : OPTIONAL IfcNamedUnit;</para>
	/// <para>	HeightUnit : OPTIONAL IfcNamedUnit;</para>
	/// <para> WHERE</para>
	/// <para>	AngleUnitIsPlaneAngle : NOT(EXISTS(SELF.AngleUnit)) OR (SELF.AngleUnit.UnitType=IfcUnitEnum.PLANEANGLEUNIT);</para>
	/// <para>	HeightUnitIsLength : NOT(EXISTS(SELF.HeightUnit)) OR (SELF.HeightUnit.UnitType=IfcUnitEnum.LENGTHUNIT);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeographicCRS : IfcCoordinateReferenceSystem
	{
		public IfcIdentifier? PrimeMeridian { get; set; }
		public IfcNamedUnit? AngleUnit { get; set; }
		public IfcNamedUnit? HeightUnit { get; set; }
		public IfcGeographicCRS() : base()
		{
		}
		public IfcGeographicCRS(IfcLabel Name, IfcText Description, IfcIdentifier GeodeticDatum, IfcIdentifier PrimeMeridian, IfcNamedUnit AngleUnit, IfcNamedUnit HeightUnit) : base (Name, Description, GeodeticDatum)
		{
			this.PrimeMeridian = PrimeMeridian;
			this.AngleUnit = AngleUnit;
			this.HeightUnit = HeightUnit;
		}
	}
	/// <summary>
	/// ENTITY IfcGeographicElement
	/// <para>ENTITY IfcGeographicElement</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcGeographicElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcGeographicElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcGeographicElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCGEOGRAPHICELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeographicElement : IfcElement
	{
		public IfcGeographicElementTypeEnum? PredefinedType { get; set; }
		public IfcGeographicElement() : base()
		{
		}
		public IfcGeographicElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcGeographicElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcGeographicElementType
	/// <para>ENTITY IfcGeographicElementType</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>	PredefinedType : IfcGeographicElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcGeographicElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcGeographicElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeographicElementType : IfcElementType
	{
		public IfcGeographicElementTypeEnum PredefinedType { get; set; }
		public IfcGeographicElementType() : base()
		{
			PredefinedType = new IfcGeographicElementTypeEnum();
		}
		public IfcGeographicElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcGeographicElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricCurveSet
	/// <para>ENTITY IfcGeometricCurveSet</para>
	/// <para> SUBTYPE OF (IfcGeometricSet);</para>
	/// <para> WHERE</para>
	/// <para>	NoSurfaces : SIZEOF(QUERY(Temp <* SELF\IfcGeometricSet.Elements |</para>
	/// <para>'IFC4X3_ADD2.IFCSURFACE' IN TYPEOF(Temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricCurveSet : IfcGeometricSet
	{
		public IfcGeometricCurveSet() : base()
		{
		}
		public IfcGeometricCurveSet(List<IfcGeometricSetSelect> Elements) : base (Elements)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricRepresentationContext
	/// <para>ENTITY IfcGeometricRepresentationContext</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcGeometricRepresentationSubContext))</para>
	/// <para> SUBTYPE OF (IfcRepresentationContext);</para>
	/// <para>	CoordinateSpaceDimension : IfcDimensionCount;</para>
	/// <para>	Precision : OPTIONAL IfcReal;</para>
	/// <para>	WorldCoordinateSystem : IfcAxis2Placement;</para>
	/// <para>	TrueNorth : OPTIONAL IfcDirection;</para>
	/// <para> INVERSE</para>
	/// <para>	HasSubContexts : SET [0:?] OF IfcGeometricRepresentationSubContext FOR ParentContext;</para>
	/// <para>	HasCoordinateOperation : SET [0:1] OF IfcCoordinateOperation FOR SourceCRS;</para>
	/// <para> WHERE</para>
	/// <para>	North2D : NOT(EXISTS(TrueNorth)) OR (HIINDEX(TrueNorth.DirectionRatios) = 2);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricRepresentationContext : IfcRepresentationContext, IfcCoordinateReferenceSystemSelect
	{
		public IfcDimensionCount CoordinateSpaceDimension { get; set; }
		public IfcReal? Precision { get; set; }
		public IfcAxis2Placement WorldCoordinateSystem { get; set; }
		public IfcDirection? TrueNorth { get; set; }
		public IfcGeometricRepresentationContext() : base()
		{
			CoordinateSpaceDimension = new IfcDimensionCount();
			WorldCoordinateSystem = new IfcAxis2Placement();
		}
		public IfcGeometricRepresentationContext(IfcLabel ContextIdentifier, IfcLabel ContextType, IfcDimensionCount CoordinateSpaceDimension, IfcReal Precision, IfcAxis2Placement WorldCoordinateSystem, IfcDirection TrueNorth) : base (ContextIdentifier, ContextType)
		{
			this.CoordinateSpaceDimension = CoordinateSpaceDimension;
			this.Precision = Precision;
			this.WorldCoordinateSystem = WorldCoordinateSystem;
			this.TrueNorth = TrueNorth;
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricRepresentationItem
	/// <para>ENTITY IfcGeometricRepresentationItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAnnotationFillArea</para>
	/// <para>	,IfcBooleanResult</para>
	/// <para>	,IfcBoundingBox</para>
	/// <para>	,IfcCartesianPointList</para>
	/// <para>	,IfcCartesianTransformationOperator</para>
	/// <para>	,IfcCsgPrimitive3D</para>
	/// <para>	,IfcCurve</para>
	/// <para>	,IfcDirection</para>
	/// <para>	,IfcFaceBasedSurfaceModel</para>
	/// <para>	,IfcFillAreaStyleHatching</para>
	/// <para>	,IfcFillAreaStyleTiles</para>
	/// <para>	,IfcGeometricSet</para>
	/// <para>	,IfcHalfSpaceSolid</para>
	/// <para>	,IfcLightSource</para>
	/// <para>	,IfcPlacement</para>
	/// <para>	,IfcPlanarExtent</para>
	/// <para>	,IfcPoint</para>
	/// <para>	,IfcSectionedSpine</para>
	/// <para>	,IfcSegment</para>
	/// <para>	,IfcShellBasedSurfaceModel</para>
	/// <para>	,IfcSolidModel</para>
	/// <para>	,IfcSurface</para>
	/// <para>	,IfcTessellatedItem</para>
	/// <para>	,IfcTextLiteral</para>
	/// <para>	,IfcVector))</para>
	/// <para> SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcGeometricRepresentationItem : IfcRepresentationItem
	{
		public IfcGeometricRepresentationItem() : base()
		{
		}
		public IfcGeometricRepresentationItem() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricRepresentationSubContext
	/// <para>ENTITY IfcGeometricRepresentationSubContext</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationContext);</para>
	/// <para>	ParentContext : IfcGeometricRepresentationContext;</para>
	/// <para>	TargetScale : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>	TargetView : IfcGeometricProjectionEnum;</para>
	/// <para>	UserDefinedTargetView : OPTIONAL IfcLabel;</para>
	/// <para> DERIVE</para>
	/// <para>	 SELF\IfcGeometricRepresentationContext.WorldCoordinateSystem : IfcAxis2Placement := ParentContext.WorldCoordinateSystem;</para>
	/// <para>	 SELF\IfcGeometricRepresentationContext.CoordinateSpaceDimension : IfcDimensionCount := ParentContext.CoordinateSpaceDimension;</para>
	/// <para>	 SELF\IfcGeometricRepresentationContext.TrueNorth : IfcDirection := NVL(ParentContext.TrueNorth, IfcConvertDirectionInto2D(SELF\IfcGeometricRepresentationContext.WorldCoordinateSystem.P[2]));</para>
	/// <para>	 SELF\IfcGeometricRepresentationContext.Precision : IfcReal := NVL(ParentContext.Precision,1.E-5);</para>
	/// <para> WHERE</para>
	/// <para>	NoCoordOperation : SIZEOF(SELF\IfcGeometricRepresentationContext.HasCoordinateOperation) = 0;</para>
	/// <para>	ParentNoSub : NOT('IFC4X3_ADD2.IFCGEOMETRICREPRESENTATIONSUBCONTEXT' IN TYPEOF(ParentContext));</para>
	/// <para>	UserTargetProvided :  (TargetView <> IfcGeometricProjectionEnum.USERDEFINED) OR </para>
	/// <para>((TargetView =  IfcGeometricProjectionEnum.USERDEFINED) AND EXISTS(UserDefinedTargetView)) ;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricRepresentationSubContext : IfcGeometricRepresentationContext
	{
		public IfcGeometricRepresentationContext ParentContext { get; set; }
		public IfcPositiveRatioMeasure? TargetScale { get; set; }
		public IfcGeometricProjectionEnum TargetView { get; set; }
		public IfcLabel? UserDefinedTargetView { get; set; }
		public IfcGeometricRepresentationSubContext() : base()
		{
			ParentContext = new IfcGeometricRepresentationContext();
			TargetView = new IfcGeometricProjectionEnum();
		}
		public IfcGeometricRepresentationSubContext(IfcLabel ContextIdentifier, IfcLabel ContextType, IfcDimensionCount CoordinateSpaceDimension, IfcReal Precision, IfcAxis2Placement WorldCoordinateSystem, IfcDirection TrueNorth, IfcGeometricRepresentationContext ParentContext, IfcPositiveRatioMeasure TargetScale, IfcGeometricProjectionEnum TargetView, IfcLabel UserDefinedTargetView) : base (ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth)
		{
			this.ParentContext = ParentContext;
			this.TargetScale = TargetScale;
			this.TargetView = TargetView;
			this.UserDefinedTargetView = UserDefinedTargetView;
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricSet
	/// <para>ENTITY IfcGeometricSet</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcGeometricCurveSet))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Elements : SET [1:?] OF IfcGeometricSetSelect;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := Elements[1].Dim;</para>
	/// <para> WHERE</para>
	/// <para>	ConsistentDim : SIZEOF(QUERY(Temp <* Elements |</para>
	/// <para>  Temp.Dim <> Elements[1].Dim))</para>
	/// <para>= 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricSet : IfcGeometricRepresentationItem
	{
		public List<IfcGeometricSetSelect> Elements { get; set; }
		public IfcGeometricSet() : base()
		{
			Elements = new List<IfcGeometricSetSelect>();
		}
		public IfcGeometricSet(List<IfcGeometricSetSelect> Elements) : base ()
		{
			this.Elements = Elements;
		}
	}
	/// <summary>
	/// ENTITY IfcGeomodel
	/// <para>ENTITY IfcGeomodel</para>
	/// <para> SUBTYPE OF (IfcGeotechnicalAssembly);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeomodel : IfcGeotechnicalAssembly
	{
		public IfcGeomodel() : base()
		{
		}
		public IfcGeomodel(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGeoslice
	/// <para>ENTITY IfcGeoslice</para>
	/// <para> SUBTYPE OF (IfcGeotechnicalAssembly);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeoslice : IfcGeotechnicalAssembly
	{
		public IfcGeoslice() : base()
		{
		}
		public IfcGeoslice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGeotechnicalAssembly
	/// <para>ENTITY IfcGeotechnicalAssembly</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBorehole</para>
	/// <para>	,IfcGeomodel</para>
	/// <para>	,IfcGeoslice))</para>
	/// <para> SUBTYPE OF (IfcGeotechnicalElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcGeotechnicalAssembly : IfcGeotechnicalElement
	{
		public IfcGeotechnicalAssembly() : base()
		{
		}
		public IfcGeotechnicalAssembly(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGeotechnicalElement
	/// <para>ENTITY IfcGeotechnicalElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcGeotechnicalAssembly</para>
	/// <para>	,IfcGeotechnicalStratum))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcGeotechnicalElement : IfcElement
	{
		public IfcGeotechnicalElement() : base()
		{
		}
		public IfcGeotechnicalElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGeotechnicalStratum
	/// <para>ENTITY IfcGeotechnicalStratum</para>
	/// <para> SUBTYPE OF (IfcGeotechnicalElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcGeotechnicalStratumTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcGeotechnicalStratumTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcGeotechnicalStratumTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeotechnicalStratum : IfcGeotechnicalElement
	{
		public IfcGeotechnicalStratumTypeEnum? PredefinedType { get; set; }
		public IfcGeotechnicalStratum() : base()
		{
		}
		public IfcGeotechnicalStratum(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcGeotechnicalStratumTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcGradientCurve
	/// <para>ENTITY IfcGradientCurve</para>
	/// <para> SUBTYPE OF (IfcCompositeCurve);</para>
	/// <para>	BaseCurve : IfcBoundedCurve;</para>
	/// <para>	EndPoint : OPTIONAL IfcPlacement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGradientCurve : IfcCompositeCurve
	{
		public IfcBoundedCurve BaseCurve { get; set; }
		public IfcPlacement? EndPoint { get; set; }
		public IfcGradientCurve() : base()
		{
			BaseCurve = new IfcBoundedCurve();
		}
		public IfcGradientCurve(List<IfcSegment> Segments, IfcLogical SelfIntersect, IfcBoundedCurve BaseCurve, IfcPlacement EndPoint) : base (Segments, SelfIntersect)
		{
			this.BaseCurve = BaseCurve;
			this.EndPoint = EndPoint;
		}
	}
	/// <summary>
	/// ENTITY IfcGrid
	/// <para>ENTITY IfcGrid</para>
	/// <para> SUBTYPE OF (IfcPositioningElement);</para>
	/// <para>	UAxes : LIST [1:?] OF UNIQUE IfcGridAxis;</para>
	/// <para>	VAxes : LIST [1:?] OF UNIQUE IfcGridAxis;</para>
	/// <para>	WAxes : OPTIONAL LIST [1:?] OF UNIQUE IfcGridAxis;</para>
	/// <para>	PredefinedType : OPTIONAL IfcGridTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGrid : IfcPositioningElement
	{
		public IfcGrid() : base()
		{
		}
		public IfcGrid(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGridAxis;
	/// <para>ENTITY IfcGridAxis;</para>
	/// <para>	AxisTag : OPTIONAL IfcLabel;</para>
	/// <para>	AxisCurve : IfcCurve;</para>
	/// <para>	SameSense : IfcBoolean;</para>
	/// <para> INVERSE</para>
	/// <para>	PartOfW : SET [0:1] OF IfcGrid FOR WAxes;</para>
	/// <para>	PartOfV : SET [0:1] OF IfcGrid FOR VAxes;</para>
	/// <para>	PartOfU : SET [0:1] OF IfcGrid FOR UAxes;</para>
	/// <para>	HasIntersections : SET [0:?] OF IfcVirtualGridIntersection FOR IntersectingAxes;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : AxisCurve.Dim = 2;</para>
	/// <para>	WR2 : (SIZEOF(PartOfU) = 1) XOR (SIZEOF(PartOfV) = 1) XOR (SIZEOF(PartOfW) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGridAxisENTITY
	{
		public IfcLabel? AxisTag { get; set; }
		public IfcCurve AxisCurve { get; set; }
		public IfcBoolean SameSense { get; set; }
		public IfcGridAxis() : base()
		{
			AxisCurve = new IfcCurve();
			SameSense = new IfcBoolean();
		}
		public IfcGridAxis(IfcLabel AxisTag, IfcCurve AxisCurve, IfcBoolean SameSense) : base ()
		{
			this.AxisTag = AxisTag;
			this.AxisCurve = AxisCurve;
			this.SameSense = SameSense;
		}
	}
	/// <summary>
	/// ENTITY IfcGridPlacement
	/// <para>ENTITY IfcGridPlacement</para>
	/// <para> SUBTYPE OF (IfcObjectPlacement);</para>
	/// <para>	PlacementLocation : IfcVirtualGridIntersection;</para>
	/// <para>	PlacementRefDirection : OPTIONAL IfcGridPlacementDirectionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGridPlacement : IfcObjectPlacement
	{
		public IfcVirtualGridIntersection PlacementLocation { get; set; }
		public IfcGridPlacementDirectionSelect? PlacementRefDirection { get; set; }
		public IfcGridPlacement() : base()
		{
			PlacementLocation = new IfcVirtualGridIntersection();
		}
		public IfcGridPlacement(IfcObjectPlacement PlacementRelTo, IfcVirtualGridIntersection PlacementLocation, IfcGridPlacementDirectionSelect PlacementRefDirection) : base (PlacementRelTo)
		{
			this.PlacementLocation = PlacementLocation;
			this.PlacementRefDirection = PlacementRefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcGroup
	/// <para>ENTITY IfcGroup</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAsset</para>
	/// <para>	,IfcInventory</para>
	/// <para>	,IfcStructuralLoadGroup</para>
	/// <para>	,IfcStructuralResultGroup</para>
	/// <para>	,IfcSystem))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para> INVERSE</para>
	/// <para>	IsGroupedBy : SET [0:?] OF IfcRelAssignsToGroup FOR RelatingGroup;</para>
	/// <para>	ReferencedInStructures : SET [0:?] OF IfcRelReferencedInSpatialStructure FOR RelatedElements;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGroup : IfcObject, IfcSpatialReferenceSelect
	{
		public IfcGroup() : base()
		{
		}
		public IfcGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcHalfSpaceSolid
	/// <para>ENTITY IfcHalfSpaceSolid</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBoxedHalfSpace</para>
	/// <para>	,IfcPolygonalBoundedHalfSpace))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	BaseSurface : IfcSurface;</para>
	/// <para>	AgreementFlag : IfcBoolean;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHalfSpaceSolid : IfcGeometricRepresentationItem, IfcBooleanOperand
	{
		public IfcSurface BaseSurface { get; set; }
		public IfcBoolean AgreementFlag { get; set; }
		public IfcHalfSpaceSolid() : base()
		{
			BaseSurface = new IfcSurface();
			AgreementFlag = new IfcBoolean();
		}
		public IfcHalfSpaceSolid(IfcSurface BaseSurface, IfcBoolean AgreementFlag) : base ()
		{
			this.BaseSurface = BaseSurface;
			this.AgreementFlag = AgreementFlag;
		}
	}
	/// <summary>
	/// ENTITY IfcHeatExchanger
	/// <para>ENTITY IfcHeatExchanger</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcHeatExchangerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcHeatExchangerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcHeatExchangerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCHEATEXCHANGERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHeatExchanger : IfcEnergyConversionDevice
	{
		public IfcHeatExchangerTypeEnum? PredefinedType { get; set; }
		public IfcHeatExchanger() : base()
		{
		}
		public IfcHeatExchanger(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcHeatExchangerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcHeatExchangerType
	/// <para>ENTITY IfcHeatExchangerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcHeatExchangerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcHeatExchangerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcHeatExchangerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHeatExchangerType : IfcEnergyConversionDeviceType
	{
		public IfcHeatExchangerTypeEnum PredefinedType { get; set; }
		public IfcHeatExchangerType() : base()
		{
			PredefinedType = new IfcHeatExchangerTypeEnum();
		}
		public IfcHeatExchangerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcHeatExchangerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcHumidifier
	/// <para>ENTITY IfcHumidifier</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcHumidifierTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcHumidifierTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcHumidifierTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCHUMIDIFIERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHumidifier : IfcEnergyConversionDevice
	{
		public IfcHumidifierTypeEnum? PredefinedType { get; set; }
		public IfcHumidifier() : base()
		{
		}
		public IfcHumidifier(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcHumidifierTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcHumidifierType
	/// <para>ENTITY IfcHumidifierType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcHumidifierTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcHumidifierTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcHumidifierTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHumidifierType : IfcEnergyConversionDeviceType
	{
		public IfcHumidifierTypeEnum PredefinedType { get; set; }
		public IfcHumidifierType() : base()
		{
			PredefinedType = new IfcHumidifierTypeEnum();
		}
		public IfcHumidifierType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcHumidifierTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcIShapeProfileDef
	/// <para>ENTITY IfcIShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	OverallWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	OverallDepth : IfcPositiveLengthMeasure;</para>
	/// <para>	WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	FlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	FlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidFilletRadius : NOT(EXISTS(FilletRadius)) OR</para>
	/// <para>((FilletRadius <= (OverallWidth - WebThickness)/2.) AND </para>
	/// <para> (FilletRadius <= (OverallDepth - (2. * FlangeThickness))/2.));</para>
	/// <para>	ValidFlangeThickness : (2. * FlangeThickness) < OverallDepth;</para>
	/// <para>	ValidWebThickness : WebThickness < OverallWidth;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure OverallWidth { get; set; }
		public IfcPositiveLengthMeasure OverallDepth { get; set; }
		public IfcPositiveLengthMeasure WebThickness { get; set; }
		public IfcPositiveLengthMeasure FlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? FlangeEdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? FlangeSlope { get; set; }
		public IfcIShapeProfileDef() : base()
		{
			OverallWidth = new IfcPositiveLengthMeasure();
			OverallDepth = new IfcPositiveLengthMeasure();
			WebThickness = new IfcPositiveLengthMeasure();
			FlangeThickness = new IfcPositiveLengthMeasure();
		}
		public IfcIShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure OverallWidth, IfcPositiveLengthMeasure OverallDepth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure FlangeEdgeRadius, IfcPlaneAngleMeasure FlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.OverallWidth = OverallWidth;
			this.OverallDepth = OverallDepth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.FlangeEdgeRadius = FlangeEdgeRadius;
			this.FlangeSlope = FlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcImageTexture
	/// <para>ENTITY IfcImageTexture</para>
	/// <para> SUBTYPE OF (IfcSurfaceTexture);</para>
	/// <para>	URLReference : IfcURIReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcImageTexture : IfcSurfaceTexture
	{
		public IfcURIReference URLReference { get; set; }
		public IfcImageTexture() : base()
		{
			URLReference = new IfcURIReference();
		}
		public IfcImageTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter, IfcURIReference URLReference) : base (RepeatS, RepeatT, Mode, TextureTransform, Parameter)
		{
			this.URLReference = URLReference;
		}
	}
	/// <summary>
	/// ENTITY IfcImpactProtectionDevice
	/// <para>ENTITY IfcImpactProtectionDevice</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcImpactProtectionDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcImpactProtectionDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcImpactProtectionDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCIMPACTPROTECTIONDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcImpactProtectionDevice : IfcElementComponent
	{
		public IfcImpactProtectionDeviceTypeEnum? PredefinedType { get; set; }
		public IfcImpactProtectionDevice() : base()
		{
		}
		public IfcImpactProtectionDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcImpactProtectionDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcImpactProtectionDeviceType
	/// <para>ENTITY IfcImpactProtectionDeviceType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcImpactProtectionDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcImpactProtectionDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcImpactProtectionDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcImpactProtectionDeviceType : IfcElementComponentType
	{
		public IfcImpactProtectionDeviceTypeEnum PredefinedType { get; set; }
		public IfcImpactProtectionDeviceType() : base()
		{
			PredefinedType = new IfcImpactProtectionDeviceTypeEnum();
		}
		public IfcImpactProtectionDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcImpactProtectionDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedColourMap
	/// <para>ENTITY IfcIndexedColourMap</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	MappedTo : IfcTessellatedFaceSet;</para>
	/// <para>	Opacity : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	Colours : IfcColourRgbList;</para>
	/// <para>	ColourIndex : LIST [1:?] OF IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedColourMap : IfcPresentationItem
	{
		public IfcTessellatedFaceSet MappedTo { get; set; }
		public IfcNormalisedRatioMeasure? Opacity { get; set; }
		public IfcColourRgbList Colours { get; set; }
		public List<IfcPositiveInteger> ColourIndex { get; set; }
		public IfcIndexedColourMap() : base()
		{
			MappedTo = new IfcTessellatedFaceSet();
			Colours = new IfcColourRgbList();
			ColourIndex = new List<IfcPositiveInteger>();
		}
		public IfcIndexedColourMap(IfcTessellatedFaceSet MappedTo, IfcNormalisedRatioMeasure Opacity, IfcColourRgbList Colours, List<IfcPositiveInteger> ColourIndex) : base ()
		{
			this.MappedTo = MappedTo;
			this.Opacity = Opacity;
			this.Colours = Colours;
			this.ColourIndex = ColourIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedPolyCurve
	/// <para>ENTITY IfcIndexedPolyCurve</para>
	/// <para> SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>	Points : IfcCartesianPointList;</para>
	/// <para>	Segments : OPTIONAL LIST [1:?] OF IfcSegmentIndexSelect;</para>
	/// <para>	SelfIntersect : OPTIONAL IfcBoolean;</para>
	/// <para> WHERE</para>
	/// <para>	Consecutive : NOT(EXISTS(Segments)) OR IfcConsecutiveSegments(Segments);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedPolyCurve : IfcBoundedCurve
	{
		public IfcCartesianPointList Points { get; set; }
		public List<IfcSegmentIndexSelect>? Segments { get; set; }
		public IfcBoolean? SelfIntersect { get; set; }
		public IfcIndexedPolyCurve() : base()
		{
			Points = new IfcCartesianPointList();
		}
		public IfcIndexedPolyCurve(IfcCartesianPointList Points, List<IfcSegmentIndexSelect> Segments, IfcBoolean SelfIntersect) : base ()
		{
			this.Points = Points;
			this.Segments = Segments;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedPolygonalFace
	/// <para>ENTITY IfcIndexedPolygonalFace</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcIndexedPolygonalFaceWithVoids))</para>
	/// <para> SUBTYPE OF (IfcTessellatedItem);</para>
	/// <para>	CoordIndex : LIST [3:?] OF IfcPositiveInteger;</para>
	/// <para> INVERSE</para>
	/// <para>	ToFaceSet : SET [1:?] OF IfcPolygonalFaceSet FOR Faces;</para>
	/// <para>	HasTexCoords : SET [0:1] OF IfcTextureCoordinateIndices FOR TexCoordsOf;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedPolygonalFace : IfcTessellatedItem
	{
		public List<IfcPositiveInteger> CoordIndex { get; set; }
		public IfcIndexedPolygonalFace() : base()
		{
			CoordIndex = new List<IfcPositiveInteger>();
		}
		public IfcIndexedPolygonalFace(List<IfcPositiveInteger> CoordIndex) : base ()
		{
			this.CoordIndex = CoordIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedPolygonalFaceWithVoids
	/// <para>ENTITY IfcIndexedPolygonalFaceWithVoids</para>
	/// <para> SUBTYPE OF (IfcIndexedPolygonalFace);</para>
	/// <para>	InnerCoordIndices : LIST [1:?] OF LIST [3:?] OF UNIQUE IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedPolygonalFaceWithVoids : IfcIndexedPolygonalFace
	{
		public IfcIndexedPolygonalFaceWithVoids() : base()
		{
		}
		public IfcIndexedPolygonalFaceWithVoids(List<IfcPositiveInteger> CoordIndex) : base (CoordIndex)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedPolygonalTextureMap
	/// <para>ENTITY IfcIndexedPolygonalTextureMap</para>
	/// <para> SUBTYPE OF (IfcIndexedTextureMap);</para>
	/// <para>	TexCoordIndices : SET [1:?] OF IfcTextureCoordinateIndices;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedPolygonalTextureMap : IfcIndexedTextureMap
	{
		public List<IfcTextureCoordinateIndices> TexCoordIndices { get; set; }
		public IfcIndexedPolygonalTextureMap() : base()
		{
			TexCoordIndices = new List<IfcTextureCoordinateIndices>();
		}
		public IfcIndexedPolygonalTextureMap(List<IfcSurfaceTexture> Maps, IfcTessellatedFaceSet MappedTo, IfcTextureVertexList TexCoords, List<IfcTextureCoordinateIndices> TexCoordIndices) : base (Maps, MappedTo, TexCoords)
		{
			this.TexCoordIndices = TexCoordIndices;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedTextureMap
	/// <para>ENTITY IfcIndexedTextureMap</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcIndexedPolygonalTextureMap</para>
	/// <para>	,IfcIndexedTriangleTextureMap))</para>
	/// <para> SUBTYPE OF (IfcTextureCoordinate);</para>
	/// <para>	MappedTo : IfcTessellatedFaceSet;</para>
	/// <para>	TexCoords : IfcTextureVertexList;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcIndexedTextureMap : IfcTextureCoordinate
	{
		public IfcTessellatedFaceSet MappedTo { get; set; }
		public IfcTextureVertexList TexCoords { get; set; }
		public IfcIndexedTextureMap() : base()
		{
			MappedTo = new IfcTessellatedFaceSet();
			TexCoords = new IfcTextureVertexList();
		}
		public IfcIndexedTextureMap(List<IfcSurfaceTexture> Maps, IfcTessellatedFaceSet MappedTo, IfcTextureVertexList TexCoords) : base (Maps)
		{
			this.MappedTo = MappedTo;
			this.TexCoords = TexCoords;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedTriangleTextureMap
	/// <para>ENTITY IfcIndexedTriangleTextureMap</para>
	/// <para> SUBTYPE OF (IfcIndexedTextureMap);</para>
	/// <para>	TexCoordIndex : OPTIONAL LIST [1:?] OF LIST [3:3] OF IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedTriangleTextureMap : IfcIndexedTextureMap
	{
		public List<List<IfcPositiveInteger >>? TexCoordIndex { get; set; }
		public IfcIndexedTriangleTextureMap() : base()
		{
		}
		public IfcIndexedTriangleTextureMap(List<IfcSurfaceTexture> Maps, IfcTessellatedFaceSet MappedTo, IfcTextureVertexList TexCoords, List<List<IfcPositiveInteger >> TexCoordIndex) : base (Maps, MappedTo, TexCoords)
		{
			this.TexCoordIndex = TexCoordIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcInterceptor
	/// <para>ENTITY IfcInterceptor</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcInterceptorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcInterceptorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcInterceptorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCINTERCEPTORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcInterceptor : IfcFlowTreatmentDevice
	{
		public IfcInterceptorTypeEnum? PredefinedType { get; set; }
		public IfcInterceptor() : base()
		{
		}
		public IfcInterceptor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcInterceptorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcInterceptorType
	/// <para>ENTITY IfcInterceptorType</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDeviceType);</para>
	/// <para>	PredefinedType : IfcInterceptorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcInterceptorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcInterceptorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcInterceptorType : IfcFlowTreatmentDeviceType
	{
		public IfcInterceptorTypeEnum PredefinedType { get; set; }
		public IfcInterceptorType() : base()
		{
			PredefinedType = new IfcInterceptorTypeEnum();
		}
		public IfcInterceptorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcInterceptorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcIntersectionCurve
	/// <para>ENTITY IfcIntersectionCurve</para>
	/// <para> SUBTYPE OF (IfcSurfaceCurve);</para>
	/// <para> WHERE</para>
	/// <para>	DistinctSurfaces : IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[1]) <> IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[2]);</para>
	/// <para>	TwoPCurves : SIZEOF(SELF\IfcSurfaceCurve.AssociatedGeometry) = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIntersectionCurve : IfcSurfaceCurve
	{
		public IfcIntersectionCurve() : base()
		{
		}
		public IfcIntersectionCurve(IfcCurve Curve3D, List<IfcPcurve> AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation MasterRepresentation) : base (Curve3D, AssociatedGeometry, MasterRepresentation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcInventory
	/// <para>ENTITY IfcInventory</para>
	/// <para> SUBTYPE OF (IfcGroup);</para>
	/// <para>	PredefinedType : OPTIONAL IfcInventoryTypeEnum;</para>
	/// <para>	Jurisdiction : OPTIONAL IfcActorSelect;</para>
	/// <para>	ResponsiblePersons : OPTIONAL SET [1:?] OF IfcPerson;</para>
	/// <para>	LastUpdateDate : OPTIONAL IfcDate;</para>
	/// <para>	CurrentValue : OPTIONAL IfcCostValue;</para>
	/// <para>	OriginalValue : OPTIONAL IfcCostValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcInventory : IfcGroup
	{
		public IfcInventoryTypeEnum? PredefinedType { get; set; }
		public IfcActorSelect? Jurisdiction { get; set; }
		public List<IfcPerson>? ResponsiblePersons { get; set; }
		public IfcDate? LastUpdateDate { get; set; }
		public IfcCostValue? CurrentValue { get; set; }
		public IfcCostValue? OriginalValue { get; set; }
		public IfcInventory() : base()
		{
		}
		public IfcInventory(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcInventoryTypeEnum PredefinedType, IfcActorSelect Jurisdiction, List<IfcPerson> ResponsiblePersons, IfcDate LastUpdateDate, IfcCostValue CurrentValue, IfcCostValue OriginalValue) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.Jurisdiction = Jurisdiction;
			this.ResponsiblePersons = ResponsiblePersons;
			this.LastUpdateDate = LastUpdateDate;
			this.CurrentValue = CurrentValue;
			this.OriginalValue = OriginalValue;
		}
	}
	/// <summary>
	/// ENTITY IfcIrregularTimeSeries
	/// <para>ENTITY IfcIrregularTimeSeries</para>
	/// <para> SUBTYPE OF (IfcTimeSeries);</para>
	/// <para>	Values : LIST [1:?] OF IfcIrregularTimeSeriesValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIrregularTimeSeries : IfcTimeSeries
	{
		public List<IfcIrregularTimeSeriesValue> Values { get; set; }
		public IfcIrregularTimeSeries() : base()
		{
			Values = new List<IfcIrregularTimeSeriesValue>();
		}
		public IfcIrregularTimeSeries(IfcLabel Name, IfcText Description, IfcDateTime StartTime, IfcDateTime EndTime, IfcTimeSeriesDataTypeEnum TimeSeriesDataType, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcUnit Unit, List<IfcIrregularTimeSeriesValue> Values) : base (Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit)
		{
			this.Values = Values;
		}
	}
	/// <summary>
	/// ENTITY IfcIrregularTimeSeriesValue;
	/// <para>ENTITY IfcIrregularTimeSeriesValue;</para>
	/// <para>	TimeStamp : IfcDateTime;</para>
	/// <para>	ListValues : LIST [1:?] OF IfcValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIrregularTimeSeriesValueENTITY
	{
		public IfcDateTime TimeStamp { get; set; }
		public List<IfcValue> ListValues { get; set; }
		public IfcIrregularTimeSeriesValue() : base()
		{
			TimeStamp = new IfcDateTime();
			ListValues = new List<IfcValue>();
		}
		public IfcIrregularTimeSeriesValue(IfcDateTime TimeStamp, List<IfcValue> ListValues) : base ()
		{
			this.TimeStamp = TimeStamp;
			this.ListValues = ListValues;
		}
	}
	/// <summary>
	/// ENTITY IfcJunctionBox
	/// <para>ENTITY IfcJunctionBox</para>
	/// <para> SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>	PredefinedType : OPTIONAL IfcJunctionBoxTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcJunctionBoxTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcJunctionBoxTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCJUNCTIONBOXTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcJunctionBox : IfcFlowFitting
	{
		public IfcJunctionBoxTypeEnum? PredefinedType { get; set; }
		public IfcJunctionBox() : base()
		{
		}
		public IfcJunctionBox(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcJunctionBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcJunctionBoxType
	/// <para>ENTITY IfcJunctionBoxType</para>
	/// <para> SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>	PredefinedType : IfcJunctionBoxTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcJunctionBoxTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcJunctionBoxTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcJunctionBoxType : IfcFlowFittingType
	{
		public IfcJunctionBoxTypeEnum PredefinedType { get; set; }
		public IfcJunctionBoxType() : base()
		{
			PredefinedType = new IfcJunctionBoxTypeEnum();
		}
		public IfcJunctionBoxType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcJunctionBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcKerb
	/// <para>ENTITY IfcKerb</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcKerbTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcKerbTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcKerbTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCKERBTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcKerb : IfcBuiltElement
	{
		public IfcKerbTypeEnum? PredefinedType { get; set; }
		public IfcKerb() : base()
		{
		}
		public IfcKerb(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcKerbTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcKerbType
	/// <para>ENTITY IfcKerbType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcKerbTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcKerbTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcKerbTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcKerbType : IfcBuiltElementType
	{
		public IfcKerbTypeEnum PredefinedType { get; set; }
		public IfcKerbType() : base()
		{
			PredefinedType = new IfcKerbTypeEnum();
		}
		public IfcKerbType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcKerbTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLShapeProfileDef
	/// <para>ENTITY IfcLShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para>	Width : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	Thickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	EdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	LegSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidThickness : (Thickness < Depth) AND (NOT(EXISTS(Width)) OR (Thickness < Width));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcPositiveLengthMeasure? Width { get; set; }
		public IfcPositiveLengthMeasure Thickness { get; set; }
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? EdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? LegSlope { get; set; }
		public IfcLShapeProfileDef() : base()
		{
			Depth = new IfcPositiveLengthMeasure();
			Thickness = new IfcPositiveLengthMeasure();
		}
		public IfcLShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure Width, IfcPositiveLengthMeasure Thickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure EdgeRadius, IfcPlaneAngleMeasure LegSlope) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.Width = Width;
			this.Thickness = Thickness;
			this.FilletRadius = FilletRadius;
			this.EdgeRadius = EdgeRadius;
			this.LegSlope = LegSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcLaborResource
	/// <para>ENTITY IfcLaborResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcLaborResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcLaborResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcLaborResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLaborResource : IfcConstructionResource
	{
		public IfcLaborResourceTypeEnum? PredefinedType { get; set; }
		public IfcLaborResource() : base()
		{
		}
		public IfcLaborResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcLaborResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLaborResourceType
	/// <para>ENTITY IfcLaborResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcLaborResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcLaborResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcLaborResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLaborResourceType : IfcConstructionResourceType
	{
		public IfcLaborResourceTypeEnum PredefinedType { get; set; }
		public IfcLaborResourceType() : base()
		{
			PredefinedType = new IfcLaborResourceTypeEnum();
		}
		public IfcLaborResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcLaborResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLagTime
	/// <para>ENTITY IfcLagTime</para>
	/// <para> SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>	LagValue : IfcTimeOrRatioSelect;</para>
	/// <para>	DurationType : IfcTaskDurationEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLagTime : IfcSchedulingTime
	{
		public IfcTimeOrRatioSelect LagValue { get; set; }
		public IfcTaskDurationEnum DurationType { get; set; }
		public IfcLagTime() : base()
		{
			LagValue = new IfcTimeOrRatioSelect();
			DurationType = new IfcTaskDurationEnum();
		}
		public IfcLagTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcTimeOrRatioSelect LagValue, IfcTaskDurationEnum DurationType) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.LagValue = LagValue;
			this.DurationType = DurationType;
		}
	}
	/// <summary>
	/// ENTITY IfcLamp
	/// <para>ENTITY IfcLamp</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcLampTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcLampTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcLampTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCLAMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLamp : IfcFlowTerminal
	{
		public IfcLampTypeEnum? PredefinedType { get; set; }
		public IfcLamp() : base()
		{
		}
		public IfcLamp(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLampType
	/// <para>ENTITY IfcLampType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcLampTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcLampTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcLampTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLampType : IfcFlowTerminalType
	{
		public IfcLampTypeEnum PredefinedType { get; set; }
		public IfcLampType() : base()
		{
			PredefinedType = new IfcLampTypeEnum();
		}
		public IfcLampType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcLampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLibraryInformation
	/// <para>ENTITY IfcLibraryInformation</para>
	/// <para> SUBTYPE OF (IfcExternalInformation);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Version : OPTIONAL IfcLabel;</para>
	/// <para>	Publisher : OPTIONAL IfcActorSelect;</para>
	/// <para>	VersionDate : OPTIONAL IfcDateTime;</para>
	/// <para>	Location : OPTIONAL IfcURIReference;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	LibraryInfoForObjects : SET [0:?] OF IfcRelAssociatesLibrary FOR RelatingLibrary;</para>
	/// <para>	HasLibraryReferences : SET [0:?] OF IfcLibraryReference FOR ReferencedLibrary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLibraryInformation : IfcExternalInformation, IfcLibrarySelect
	{
		public IfcLabel Name { get; set; }
		public IfcLabel? Version { get; set; }
		public IfcActorSelect? Publisher { get; set; }
		public IfcDateTime? VersionDate { get; set; }
		public IfcURIReference? Location { get; set; }
		public IfcText? Description { get; set; }
		public IfcLibraryInformation() : base()
		{
			Name = new IfcLabel();
		}
		public IfcLibraryInformation(IfcLabel Name, IfcLabel Version, IfcActorSelect Publisher, IfcDateTime VersionDate, IfcURIReference Location, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Version = Version;
			this.Publisher = Publisher;
			this.VersionDate = VersionDate;
			this.Location = Location;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcLibraryReference
	/// <para>ENTITY IfcLibraryReference</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Language : OPTIONAL IfcLanguageId;</para>
	/// <para>	ReferencedLibrary : OPTIONAL IfcLibraryInformation;</para>
	/// <para> INVERSE</para>
	/// <para>	LibraryRefForObjects : SET [0:?] OF IfcRelAssociatesLibrary FOR RelatingLibrary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLibraryReference : IfcExternalReference, IfcLibrarySelect
	{
		public IfcText? Description { get; set; }
		public IfcLanguageId? Language { get; set; }
		public IfcLibraryInformation? ReferencedLibrary { get; set; }
		public IfcLibraryReference() : base()
		{
		}
		public IfcLibraryReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name, IfcText Description, IfcLanguageId Language, IfcLibraryInformation ReferencedLibrary) : base (Location, Identification, Name)
		{
			this.Description = Description;
			this.Language = Language;
			this.ReferencedLibrary = ReferencedLibrary;
		}
	}
	/// <summary>
	/// ENTITY IfcLightDistributionData;
	/// <para>ENTITY IfcLightDistributionData;</para>
	/// <para>	MainPlaneAngle : IfcPlaneAngleMeasure;</para>
	/// <para>	SecondaryPlaneAngle : LIST [1:?] OF IfcPlaneAngleMeasure;</para>
	/// <para>	LuminousIntensity : LIST [1:?] OF IfcLuminousIntensityDistributionMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightDistributionDataENTITY
	{
		public IfcPlaneAngleMeasure MainPlaneAngle { get; set; }
		public List<IfcPlaneAngleMeasure> SecondaryPlaneAngle { get; set; }
		public List<IfcLuminousIntensityDistributionMeasure> LuminousIntensity { get; set; }
		public IfcLightDistributionData() : base()
		{
			MainPlaneAngle = new IfcPlaneAngleMeasure();
			SecondaryPlaneAngle = new List<IfcPlaneAngleMeasure>();
			LuminousIntensity = new List<IfcLuminousIntensityDistributionMeasure>();
		}
		public IfcLightDistributionData(IfcPlaneAngleMeasure MainPlaneAngle, List<IfcPlaneAngleMeasure> SecondaryPlaneAngle, List<IfcLuminousIntensityDistributionMeasure> LuminousIntensity) : base ()
		{
			this.MainPlaneAngle = MainPlaneAngle;
			this.SecondaryPlaneAngle = SecondaryPlaneAngle;
			this.LuminousIntensity = LuminousIntensity;
		}
	}
	/// <summary>
	/// ENTITY IfcLightFixture
	/// <para>ENTITY IfcLightFixture</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcLightFixtureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcLightFixtureTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcLightFixtureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCLIGHTFIXTURETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightFixture : IfcFlowTerminal
	{
		public IfcLightFixtureTypeEnum? PredefinedType { get; set; }
		public IfcLightFixture() : base()
		{
		}
		public IfcLightFixture(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLightFixtureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLightFixtureType
	/// <para>ENTITY IfcLightFixtureType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcLightFixtureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcLightFixtureTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcLightFixtureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightFixtureType : IfcFlowTerminalType
	{
		public IfcLightFixtureTypeEnum PredefinedType { get; set; }
		public IfcLightFixtureType() : base()
		{
			PredefinedType = new IfcLightFixtureTypeEnum();
		}
		public IfcLightFixtureType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcLightFixtureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLightIntensityDistribution;
	/// <para>ENTITY IfcLightIntensityDistribution;</para>
	/// <para>	LightDistributionCurve : IfcLightDistributionCurveEnum;</para>
	/// <para>	DistributionData : LIST [1:?] OF IfcLightDistributionData;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightIntensityDistributionENTITY, IfcLightDistributionDataSourceSelect
	{
		public IfcLightDistributionCurveEnum LightDistributionCurve { get; set; }
		public List<IfcLightDistributionData> DistributionData { get; set; }
		public IfcLightIntensityDistribution() : base()
		{
			LightDistributionCurve = new IfcLightDistributionCurveEnum();
			DistributionData = new List<IfcLightDistributionData>();
		}
		public IfcLightIntensityDistribution(IfcLightDistributionCurveEnum LightDistributionCurve, List<IfcLightDistributionData> DistributionData) : base ()
		{
			this.LightDistributionCurve = LightDistributionCurve;
			this.DistributionData = DistributionData;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSource
	/// <para>ENTITY IfcLightSource</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcLightSourceAmbient</para>
	/// <para>	,IfcLightSourceDirectional</para>
	/// <para>	,IfcLightSourceGoniometric</para>
	/// <para>	,IfcLightSourcePositional))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	LightColour : IfcColourRgb;</para>
	/// <para>	AmbientIntensity : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	Intensity : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcLightSource : IfcGeometricRepresentationItem
	{
		public IfcLabel? Name { get; set; }
		public IfcColourRgb LightColour { get; set; }
		public IfcNormalisedRatioMeasure? AmbientIntensity { get; set; }
		public IfcNormalisedRatioMeasure? Intensity { get; set; }
		public IfcLightSource() : base()
		{
			LightColour = new IfcColourRgb();
		}
		public IfcLightSource(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity) : base ()
		{
			this.Name = Name;
			this.LightColour = LightColour;
			this.AmbientIntensity = AmbientIntensity;
			this.Intensity = Intensity;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceAmbient
	/// <para>ENTITY IfcLightSourceAmbient</para>
	/// <para> SUBTYPE OF (IfcLightSource);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceAmbient : IfcLightSource
	{
		public IfcLightSourceAmbient() : base()
		{
		}
		public IfcLightSourceAmbient(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceDirectional
	/// <para>ENTITY IfcLightSourceDirectional</para>
	/// <para> SUBTYPE OF (IfcLightSource);</para>
	/// <para>	Orientation : IfcDirection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceDirectional : IfcLightSource
	{
		public IfcDirection Orientation { get; set; }
		public IfcLightSourceDirectional() : base()
		{
			Orientation = new IfcDirection();
		}
		public IfcLightSourceDirectional(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcDirection Orientation) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
			this.Orientation = Orientation;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceGoniometric
	/// <para>ENTITY IfcLightSourceGoniometric</para>
	/// <para> SUBTYPE OF (IfcLightSource);</para>
	/// <para>	Position : IfcAxis2Placement3D;</para>
	/// <para>	ColourAppearance : OPTIONAL IfcColourRgb;</para>
	/// <para>	ColourTemperature : IfcThermodynamicTemperatureMeasure;</para>
	/// <para>	LuminousFlux : IfcLuminousFluxMeasure;</para>
	/// <para>	LightEmissionSource : IfcLightEmissionSourceEnum;</para>
	/// <para>	LightDistributionDataSource : IfcLightDistributionDataSourceSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceGoniometric : IfcLightSource
	{
		public IfcAxis2Placement3D Position { get; set; }
		public IfcColourRgb? ColourAppearance { get; set; }
		public IfcThermodynamicTemperatureMeasure ColourTemperature { get; set; }
		public IfcLuminousFluxMeasure LuminousFlux { get; set; }
		public IfcLightEmissionSourceEnum LightEmissionSource { get; set; }
		public IfcLightDistributionDataSourceSelect LightDistributionDataSource { get; set; }
		public IfcLightSourceGoniometric() : base()
		{
			Position = new IfcAxis2Placement3D();
			ColourTemperature = new IfcThermodynamicTemperatureMeasure();
			LuminousFlux = new IfcLuminousFluxMeasure();
			LightEmissionSource = new IfcLightEmissionSourceEnum();
			LightDistributionDataSource = new IfcLightDistributionDataSourceSelect();
		}
		public IfcLightSourceGoniometric(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcAxis2Placement3D Position, IfcColourRgb ColourAppearance, IfcThermodynamicTemperatureMeasure ColourTemperature, IfcLuminousFluxMeasure LuminousFlux, IfcLightEmissionSourceEnum LightEmissionSource, IfcLightDistributionDataSourceSelect LightDistributionDataSource) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
			this.Position = Position;
			this.ColourAppearance = ColourAppearance;
			this.ColourTemperature = ColourTemperature;
			this.LuminousFlux = LuminousFlux;
			this.LightEmissionSource = LightEmissionSource;
			this.LightDistributionDataSource = LightDistributionDataSource;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourcePositional
	/// <para>ENTITY IfcLightSourcePositional</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcLightSourceSpot))</para>
	/// <para> SUBTYPE OF (IfcLightSource);</para>
	/// <para>	Position : IfcCartesianPoint;</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>	ConstantAttenuation : IfcReal;</para>
	/// <para>	DistanceAttenuation : IfcReal;</para>
	/// <para>	QuadricAttenuation : IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourcePositional : IfcLightSource
	{
		public IfcCartesianPoint Position { get; set; }
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcReal ConstantAttenuation { get; set; }
		public IfcReal DistanceAttenuation { get; set; }
		public IfcReal QuadricAttenuation { get; set; }
		public IfcLightSourcePositional() : base()
		{
			Position = new IfcCartesianPoint();
			Radius = new IfcPositiveLengthMeasure();
			ConstantAttenuation = new IfcReal();
			DistanceAttenuation = new IfcReal();
			QuadricAttenuation = new IfcReal();
		}
		public IfcLightSourcePositional(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcCartesianPoint Position, IfcPositiveLengthMeasure Radius, IfcReal ConstantAttenuation, IfcReal DistanceAttenuation, IfcReal QuadricAttenuation) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
			this.Position = Position;
			this.Radius = Radius;
			this.ConstantAttenuation = ConstantAttenuation;
			this.DistanceAttenuation = DistanceAttenuation;
			this.QuadricAttenuation = QuadricAttenuation;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceSpot
	/// <para>ENTITY IfcLightSourceSpot</para>
	/// <para> SUBTYPE OF (IfcLightSourcePositional);</para>
	/// <para>	Orientation : IfcDirection;</para>
	/// <para>	ConcentrationExponent : OPTIONAL IfcReal;</para>
	/// <para>	SpreadAngle : IfcPositivePlaneAngleMeasure;</para>
	/// <para>	BeamWidthAngle : IfcPositivePlaneAngleMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceSpot : IfcLightSourcePositional
	{
		public IfcDirection Orientation { get; set; }
		public IfcReal? ConcentrationExponent { get; set; }
		public IfcPositivePlaneAngleMeasure SpreadAngle { get; set; }
		public IfcPositivePlaneAngleMeasure BeamWidthAngle { get; set; }
		public IfcLightSourceSpot() : base()
		{
			Orientation = new IfcDirection();
			SpreadAngle = new IfcPositivePlaneAngleMeasure();
			BeamWidthAngle = new IfcPositivePlaneAngleMeasure();
		}
		public IfcLightSourceSpot(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcCartesianPoint Position, IfcPositiveLengthMeasure Radius, IfcReal ConstantAttenuation, IfcReal DistanceAttenuation, IfcReal QuadricAttenuation, IfcDirection Orientation, IfcReal ConcentrationExponent, IfcPositivePlaneAngleMeasure SpreadAngle, IfcPositivePlaneAngleMeasure BeamWidthAngle) : base (Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation)
		{
			this.Orientation = Orientation;
			this.ConcentrationExponent = ConcentrationExponent;
			this.SpreadAngle = SpreadAngle;
			this.BeamWidthAngle = BeamWidthAngle;
		}
	}
	/// <summary>
	/// ENTITY IfcLine
	/// <para>ENTITY IfcLine</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	Pnt : IfcCartesianPoint;</para>
	/// <para>	Dir : IfcVector;</para>
	/// <para> WHERE</para>
	/// <para>	SameDim : Dir.Dim = Pnt.Dim;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLine : IfcCurve
	{
		public IfcCartesianPoint Pnt { get; set; }
		public IfcVector Dir { get; set; }
		public IfcLine() : base()
		{
			Pnt = new IfcCartesianPoint();
			Dir = new IfcVector();
		}
		public IfcLine(IfcCartesianPoint Pnt, IfcVector Dir) : base ()
		{
			this.Pnt = Pnt;
			this.Dir = Dir;
		}
	}
	/// <summary>
	/// ENTITY IfcLinearElement
	/// <para>ENTITY IfcLinearElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAlignmentCant</para>
	/// <para>	,IfcAlignmentHorizontal</para>
	/// <para>	,IfcAlignmentSegment</para>
	/// <para>	,IfcAlignmentVertical))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLinearElement : IfcProduct
	{
		public IfcLinearElement() : base()
		{
		}
		public IfcLinearElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcLinearPlacement
	/// <para>ENTITY IfcLinearPlacement</para>
	/// <para> SUBTYPE OF (IfcObjectPlacement);</para>
	/// <para>	RelativePlacement : IfcAxis2PlacementLinear;</para>
	/// <para>	CartesianPosition : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLinearPlacement : IfcObjectPlacement
	{
		public IfcAxis2PlacementLinear RelativePlacement { get; set; }
		public IfcAxis2Placement3D? CartesianPosition { get; set; }
		public IfcLinearPlacement() : base()
		{
			RelativePlacement = new IfcAxis2PlacementLinear();
		}
		public IfcLinearPlacement(IfcObjectPlacement PlacementRelTo, IfcAxis2PlacementLinear RelativePlacement, IfcAxis2Placement3D CartesianPosition) : base (PlacementRelTo)
		{
			this.RelativePlacement = RelativePlacement;
			this.CartesianPosition = CartesianPosition;
		}
	}
	/// <summary>
	/// ENTITY IfcLinearPositioningElement
	/// <para>ENTITY IfcLinearPositioningElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAlignment))</para>
	/// <para> SUBTYPE OF (IfcPositioningElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLinearPositioningElement : IfcPositioningElement
	{
		public IfcLinearPositioningElement() : base()
		{
		}
		public IfcLinearPositioningElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcLiquidTerminal
	/// <para>ENTITY IfcLiquidTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcLiquidTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcLiquidTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcLiquidTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCLIQUIDTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLiquidTerminal : IfcFlowTerminal
	{
		public IfcLiquidTerminalTypeEnum? PredefinedType { get; set; }
		public IfcLiquidTerminal() : base()
		{
		}
		public IfcLiquidTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLiquidTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLiquidTerminalType
	/// <para>ENTITY IfcLiquidTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcLiquidTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcLiquidTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcLiquidTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLiquidTerminalType : IfcFlowTerminalType
	{
		public IfcLiquidTerminalTypeEnum PredefinedType { get; set; }
		public IfcLiquidTerminalType() : base()
		{
			PredefinedType = new IfcLiquidTerminalTypeEnum();
		}
		public IfcLiquidTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcLiquidTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLocalPlacement
	/// <para>ENTITY IfcLocalPlacement</para>
	/// <para> SUBTYPE OF (IfcObjectPlacement);</para>
	/// <para>	RelativePlacement : IfcAxis2Placement;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : IfcCorrectLocalPlacement(RelativePlacement, PlacementRelTo);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLocalPlacement : IfcObjectPlacement
	{
		public IfcAxis2Placement RelativePlacement { get; set; }
		public IfcLocalPlacement() : base()
		{
			RelativePlacement = new IfcAxis2Placement();
		}
		public IfcLocalPlacement(IfcObjectPlacement PlacementRelTo, IfcAxis2Placement RelativePlacement) : base (PlacementRelTo)
		{
			this.RelativePlacement = RelativePlacement;
		}
	}
	/// <summary>
	/// ENTITY IfcLoop
	/// <para>ENTITY IfcLoop</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcEdgeLoop</para>
	/// <para>	,IfcPolyLoop</para>
	/// <para>	,IfcVertexLoop))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLoop : IfcTopologicalRepresentationItem
	{
		public IfcLoop() : base()
		{
		}
		public IfcLoop() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcManifoldSolidBrep
	/// <para>ENTITY IfcManifoldSolidBrep</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAdvancedBrep</para>
	/// <para>	,IfcFacetedBrep))</para>
	/// <para> SUBTYPE OF (IfcSolidModel);</para>
	/// <para>	Outer : IfcClosedShell;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcManifoldSolidBrep : IfcSolidModel
	{
		public IfcClosedShell Outer { get; set; }
		public IfcManifoldSolidBrep() : base()
		{
			Outer = new IfcClosedShell();
		}
		public IfcManifoldSolidBrep(IfcClosedShell Outer) : base ()
		{
			this.Outer = Outer;
		}
	}
	/// <summary>
	/// ENTITY IfcMapConversion
	/// <para>ENTITY IfcMapConversion</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMapConversionScaled))</para>
	/// <para> SUBTYPE OF (IfcCoordinateOperation);</para>
	/// <para>	Eastings : IfcLengthMeasure;</para>
	/// <para>	Northings : IfcLengthMeasure;</para>
	/// <para>	OrthogonalHeight : IfcLengthMeasure;</para>
	/// <para>	XAxisAbscissa : OPTIONAL IfcReal;</para>
	/// <para>	XAxisOrdinate : OPTIONAL IfcReal;</para>
	/// <para>	Scale : OPTIONAL IfcReal;</para>
	/// <para> WHERE</para>
	/// <para>	TargetCRSOnlyProjected : 'IFC4X3_ADD2.IFCPROJECTEDCRS' IN TYPEOF(SELF\IfcCoordinateOperation.TargetCRS);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMapConversion : IfcCoordinateOperation
	{
		public IfcLengthMeasure Eastings { get; set; }
		public IfcLengthMeasure Northings { get; set; }
		public IfcLengthMeasure OrthogonalHeight { get; set; }
		public IfcReal? XAxisAbscissa { get; set; }
		public IfcReal? XAxisOrdinate { get; set; }
		public IfcReal? Scale { get; set; }
		public IfcMapConversion() : base()
		{
			Eastings = new IfcLengthMeasure();
			Northings = new IfcLengthMeasure();
			OrthogonalHeight = new IfcLengthMeasure();
		}
		public IfcMapConversion(IfcCoordinateReferenceSystemSelect SourceCRS, IfcCoordinateReferenceSystem TargetCRS, IfcLengthMeasure Eastings, IfcLengthMeasure Northings, IfcLengthMeasure OrthogonalHeight, IfcReal XAxisAbscissa, IfcReal XAxisOrdinate, IfcReal Scale) : base (SourceCRS, TargetCRS)
		{
			this.Eastings = Eastings;
			this.Northings = Northings;
			this.OrthogonalHeight = OrthogonalHeight;
			this.XAxisAbscissa = XAxisAbscissa;
			this.XAxisOrdinate = XAxisOrdinate;
			this.Scale = Scale;
		}
	}
	/// <summary>
	/// ENTITY IfcMapConversionScaled
	/// <para>ENTITY IfcMapConversionScaled</para>
	/// <para> SUBTYPE OF (IfcMapConversion);</para>
	/// <para>	FactorX : IfcReal;</para>
	/// <para>	FactorY : IfcReal;</para>
	/// <para>	FactorZ : IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMapConversionScaled : IfcMapConversion
	{
		public IfcReal FactorX { get; set; }
		public IfcReal FactorY { get; set; }
		public IfcReal FactorZ { get; set; }
		public IfcMapConversionScaled() : base()
		{
			FactorX = new IfcReal();
			FactorY = new IfcReal();
			FactorZ = new IfcReal();
		}
		public IfcMapConversionScaled(IfcCoordinateReferenceSystemSelect SourceCRS, IfcCoordinateReferenceSystem TargetCRS, IfcLengthMeasure Eastings, IfcLengthMeasure Northings, IfcLengthMeasure OrthogonalHeight, IfcReal XAxisAbscissa, IfcReal XAxisOrdinate, IfcReal Scale, IfcReal FactorX, IfcReal FactorY, IfcReal FactorZ) : base (SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale)
		{
			this.FactorX = FactorX;
			this.FactorY = FactorY;
			this.FactorZ = FactorZ;
		}
	}
	/// <summary>
	/// ENTITY IfcMappedItem
	/// <para>ENTITY IfcMappedItem</para>
	/// <para> SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>	MappingSource : IfcRepresentationMap;</para>
	/// <para>	MappingTarget : IfcCartesianTransformationOperator;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMappedItem : IfcRepresentationItem
	{
		public IfcRepresentationMap MappingSource { get; set; }
		public IfcCartesianTransformationOperator MappingTarget { get; set; }
		public IfcMappedItem() : base()
		{
			MappingSource = new IfcRepresentationMap();
			MappingTarget = new IfcCartesianTransformationOperator();
		}
		public IfcMappedItem(IfcRepresentationMap MappingSource, IfcCartesianTransformationOperator MappingTarget) : base ()
		{
			this.MappingSource = MappingSource;
			this.MappingTarget = MappingTarget;
		}
	}
	/// <summary>
	/// ENTITY IfcMarineFacility
	/// <para>ENTITY IfcMarineFacility</para>
	/// <para> SUBTYPE OF (IfcFacility);</para>
	/// <para>	PredefinedType : OPTIONAL IfcMarineFacilityTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcMarineFacilityTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMarineFacilityTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMarineFacility : IfcFacility
	{
		public IfcMarineFacilityTypeEnum? PredefinedType { get; set; }
		public IfcMarineFacility() : base()
		{
		}
		public IfcMarineFacility(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcMarineFacilityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMarinePart
	/// <para>ENTITY IfcMarinePart</para>
	/// <para> SUBTYPE OF (IfcFacilityPart);</para>
	/// <para>	PredefinedType : OPTIONAL IfcMarinePartTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcMarinePartTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMarinePartTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMarinePart : IfcFacilityPart
	{
		public IfcMarinePartTypeEnum? PredefinedType { get; set; }
		public IfcMarinePart() : base()
		{
		}
		public IfcMarinePart(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcFacilityUsageEnum UsageType, IfcMarinePartTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, UsageType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterial
	/// <para>ENTITY IfcMaterial</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Category : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	HasRepresentation : SET [0:1] OF IfcMaterialDefinitionRepresentation FOR RepresentedMaterial;</para>
	/// <para>	IsRelatedWith : SET [0:?] OF IfcMaterialRelationship FOR RelatedMaterials;</para>
	/// <para>	RelatesTo : SET [0:1] OF IfcMaterialRelationship FOR RelatingMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterial : IfcMaterialDefinition
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcLabel? Category { get; set; }
		public IfcMaterial() : base()
		{
			Name = new IfcLabel();
		}
		public IfcMaterial(IfcLabel Name, IfcText Description, IfcLabel Category) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Category = Category;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialClassificationRelationship;
	/// <para>ENTITY IfcMaterialClassificationRelationship;</para>
	/// <para>	MaterialClassifications : SET [1:?] OF IfcClassificationSelect;</para>
	/// <para>	ClassifiedMaterial : IfcMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialClassificationRelationshipENTITY
	{
		public List<IfcClassificationSelect> MaterialClassifications { get; set; }
		public IfcMaterial ClassifiedMaterial { get; set; }
		public IfcMaterialClassificationRelationship() : base()
		{
			MaterialClassifications = new List<IfcClassificationSelect>();
			ClassifiedMaterial = new IfcMaterial();
		}
		public IfcMaterialClassificationRelationship(List<IfcClassificationSelect> MaterialClassifications, IfcMaterial ClassifiedMaterial) : base ()
		{
			this.MaterialClassifications = MaterialClassifications;
			this.ClassifiedMaterial = ClassifiedMaterial;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialConstituent
	/// <para>ENTITY IfcMaterialConstituent</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Material : IfcMaterial;</para>
	/// <para>	Fraction : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	Category : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ToMaterialConstituentSet : IfcMaterialConstituentSet FOR MaterialConstituents;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialConstituent : IfcMaterialDefinition
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcMaterial Material { get; set; }
		public IfcNormalisedRatioMeasure? Fraction { get; set; }
		public IfcLabel? Category { get; set; }
		public IfcMaterialConstituent() : base()
		{
			Material = new IfcMaterial();
		}
		public IfcMaterialConstituent(IfcLabel Name, IfcText Description, IfcMaterial Material, IfcNormalisedRatioMeasure Fraction, IfcLabel Category) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Material = Material;
			this.Fraction = Fraction;
			this.Category = Category;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialConstituentSet
	/// <para>ENTITY IfcMaterialConstituentSet</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	MaterialConstituents : OPTIONAL SET [1:?] OF IfcMaterialConstituent;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialConstituentSet : IfcMaterialDefinition
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcMaterialConstituent>? MaterialConstituents { get; set; }
		public IfcMaterialConstituentSet() : base()
		{
		}
		public IfcMaterialConstituentSet(IfcLabel Name, IfcText Description, List<IfcMaterialConstituent> MaterialConstituents) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.MaterialConstituents = MaterialConstituents;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialDefinition
	/// <para>ENTITY IfcMaterialDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMaterial</para>
	/// <para>	,IfcMaterialConstituent</para>
	/// <para>	,IfcMaterialConstituentSet</para>
	/// <para>	,IfcMaterialLayer</para>
	/// <para>	,IfcMaterialLayerSet</para>
	/// <para>	,IfcMaterialProfile</para>
	/// <para>	,IfcMaterialProfileSet));</para>
	/// <para> INVERSE</para>
	/// <para>	AssociatedTo : SET [0:?] OF IfcRelAssociatesMaterial FOR RelatingMaterial;</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>	HasProperties : SET [0:?] OF IfcMaterialProperties FOR Material;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcMaterialDefinitionENTITY, IfcMaterialSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcMaterialDefinition() : base()
		{
		}
		public IfcMaterialDefinition() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialDefinitionRepresentation
	/// <para>ENTITY IfcMaterialDefinitionRepresentation</para>
	/// <para> SUBTYPE OF (IfcProductRepresentation);</para>
	/// <para>	RepresentedMaterial : IfcMaterial;</para>
	/// <para> WHERE</para>
	/// <para>	OnlyStyledRepresentations : SIZEOF(QUERY(temp <* Representations | </para>
	/// <para>  (NOT('IFC4X3_ADD2.IFCSTYLEDREPRESENTATION' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialDefinitionRepresentation : IfcProductRepresentation
	{
		public IfcMaterial RepresentedMaterial { get; set; }
		public IfcMaterialDefinitionRepresentation() : base()
		{
			RepresentedMaterial = new IfcMaterial();
		}
		public IfcMaterialDefinitionRepresentation(IfcLabel Name, IfcText Description, List<IfcRepresentation> Representations, IfcMaterial RepresentedMaterial) : base (Name, Description, Representations)
		{
			this.RepresentedMaterial = RepresentedMaterial;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayer
	/// <para>ENTITY IfcMaterialLayer</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMaterialLayerWithOffsets))</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Material : OPTIONAL IfcMaterial;</para>
	/// <para>	LayerThickness : IfcNonNegativeLengthMeasure;</para>
	/// <para>	IsVentilated : OPTIONAL IfcLogical;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Category : OPTIONAL IfcLabel;</para>
	/// <para>	Priority : OPTIONAL IfcInteger;</para>
	/// <para> INVERSE</para>
	/// <para>	ToMaterialLayerSet : IfcMaterialLayerSet FOR MaterialLayers;</para>
	/// <para> WHERE</para>
	/// <para>	NormalizedPriority : NOT(EXISTS(Priority)) OR {0 <= Priority <= 100};</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayer : IfcMaterialDefinition
	{
		public IfcMaterial? Material { get; set; }
		public IfcNonNegativeLengthMeasure LayerThickness { get; set; }
		public IfcLogical? IsVentilated { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcLabel? Category { get; set; }
		public IfcInteger? Priority { get; set; }
		public IfcMaterialLayer() : base()
		{
			LayerThickness = new IfcNonNegativeLengthMeasure();
		}
		public IfcMaterialLayer(IfcMaterial Material, IfcNonNegativeLengthMeasure LayerThickness, IfcLogical IsVentilated, IfcLabel Name, IfcText Description, IfcLabel Category, IfcInteger Priority) : base ()
		{
			this.Material = Material;
			this.LayerThickness = LayerThickness;
			this.IsVentilated = IsVentilated;
			this.Name = Name;
			this.Description = Description;
			this.Category = Category;
			this.Priority = Priority;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayerSet
	/// <para>ENTITY IfcMaterialLayerSet</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	MaterialLayers : LIST [1:?] OF IfcMaterialLayer;</para>
	/// <para>	LayerSetName : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> DERIVE</para>
	/// <para>	 TotalThickness : IfcLengthMeasure := IfcMlsTotalThickness(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayerSet : IfcMaterialDefinition
	{
		public List<IfcMaterialLayer> MaterialLayers { get; set; }
		public IfcLabel? LayerSetName { get; set; }
		public IfcText? Description { get; set; }
		public IfcMaterialLayerSet() : base()
		{
			MaterialLayers = new List<IfcMaterialLayer>();
		}
		public IfcMaterialLayerSet(List<IfcMaterialLayer> MaterialLayers, IfcLabel LayerSetName, IfcText Description) : base ()
		{
			this.MaterialLayers = MaterialLayers;
			this.LayerSetName = LayerSetName;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayerSetUsage
	/// <para>ENTITY IfcMaterialLayerSetUsage</para>
	/// <para> SUBTYPE OF (IfcMaterialUsageDefinition);</para>
	/// <para>	ForLayerSet : IfcMaterialLayerSet;</para>
	/// <para>	LayerSetDirection : IfcLayerSetDirectionEnum;</para>
	/// <para>	DirectionSense : IfcDirectionSenseEnum;</para>
	/// <para>	OffsetFromReferenceLine : IfcLengthMeasure;</para>
	/// <para>	ReferenceExtent : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayerSetUsage : IfcMaterialUsageDefinition
	{
		public IfcMaterialLayerSet ForLayerSet { get; set; }
		public IfcLayerSetDirectionEnum LayerSetDirection { get; set; }
		public IfcDirectionSenseEnum DirectionSense { get; set; }
		public IfcLengthMeasure OffsetFromReferenceLine { get; set; }
		public IfcPositiveLengthMeasure? ReferenceExtent { get; set; }
		public IfcMaterialLayerSetUsage() : base()
		{
			ForLayerSet = new IfcMaterialLayerSet();
			LayerSetDirection = new IfcLayerSetDirectionEnum();
			DirectionSense = new IfcDirectionSenseEnum();
			OffsetFromReferenceLine = new IfcLengthMeasure();
		}
		public IfcMaterialLayerSetUsage(IfcMaterialLayerSet ForLayerSet, IfcLayerSetDirectionEnum LayerSetDirection, IfcDirectionSenseEnum DirectionSense, IfcLengthMeasure OffsetFromReferenceLine, IfcPositiveLengthMeasure ReferenceExtent) : base ()
		{
			this.ForLayerSet = ForLayerSet;
			this.LayerSetDirection = LayerSetDirection;
			this.DirectionSense = DirectionSense;
			this.OffsetFromReferenceLine = OffsetFromReferenceLine;
			this.ReferenceExtent = ReferenceExtent;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayerWithOffsets
	/// <para>ENTITY IfcMaterialLayerWithOffsets</para>
	/// <para> SUBTYPE OF (IfcMaterialLayer);</para>
	/// <para>	OffsetDirection : IfcLayerSetDirectionEnum;</para>
	/// <para>	OffsetValues : ARRAY [1:2] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayerWithOffsets : IfcMaterialLayer
	{
		public IfcLayerSetDirectionEnum OffsetDirection { get; set; }
		public List<IfcLengthMeasure> OffsetValues { get; set; }
		public IfcMaterialLayerWithOffsets() : base()
		{
			OffsetDirection = new IfcLayerSetDirectionEnum();
			OffsetValues = new List<IfcLengthMeasure>();
		}
		public IfcMaterialLayerWithOffsets(IfcMaterial Material, IfcNonNegativeLengthMeasure LayerThickness, IfcLogical IsVentilated, IfcLabel Name, IfcText Description, IfcLabel Category, IfcInteger Priority, IfcLayerSetDirectionEnum OffsetDirection, List<IfcLengthMeasure> OffsetValues) : base (Material, LayerThickness, IsVentilated, Name, Description, Category, Priority)
		{
			this.OffsetDirection = OffsetDirection;
			this.OffsetValues = OffsetValues;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialList;
	/// <para>ENTITY IfcMaterialList;</para>
	/// <para>	Materials : LIST [1:?] OF IfcMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialListENTITY, IfcMaterialSelect
	{
		public List<IfcMaterial> Materials { get; set; }
		public IfcMaterialList() : base()
		{
			Materials = new List<IfcMaterial>();
		}
		public IfcMaterialList(List<IfcMaterial> Materials) : base ()
		{
			this.Materials = Materials;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfile
	/// <para>ENTITY IfcMaterialProfile</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMaterialProfileWithOffsets))</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Material : OPTIONAL IfcMaterial;</para>
	/// <para>	Profile : IfcProfileDef;</para>
	/// <para>	Priority : OPTIONAL IfcInteger;</para>
	/// <para>	Category : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ToMaterialProfileSet : IfcMaterialProfileSet FOR MaterialProfiles;</para>
	/// <para> WHERE</para>
	/// <para>	NormalizedPriority : NOT(EXISTS(Priority)) OR {0 <= Priority <= 100};</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfile : IfcMaterialDefinition
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcMaterial? Material { get; set; }
		public IfcProfileDef Profile { get; set; }
		public IfcInteger? Priority { get; set; }
		public IfcLabel? Category { get; set; }
		public IfcMaterialProfile() : base()
		{
			Profile = new IfcProfileDef();
		}
		public IfcMaterialProfile(IfcLabel Name, IfcText Description, IfcMaterial Material, IfcProfileDef Profile, IfcInteger Priority, IfcLabel Category) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Material = Material;
			this.Profile = Profile;
			this.Priority = Priority;
			this.Category = Category;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileSet
	/// <para>ENTITY IfcMaterialProfileSet</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	MaterialProfiles : LIST [1:?] OF IfcMaterialProfile;</para>
	/// <para>	CompositeProfile : OPTIONAL IfcCompositeProfileDef;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileSet : IfcMaterialDefinition
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcMaterialProfile> MaterialProfiles { get; set; }
		public IfcCompositeProfileDef? CompositeProfile { get; set; }
		public IfcMaterialProfileSet() : base()
		{
			MaterialProfiles = new List<IfcMaterialProfile>();
		}
		public IfcMaterialProfileSet(IfcLabel Name, IfcText Description, List<IfcMaterialProfile> MaterialProfiles, IfcCompositeProfileDef CompositeProfile) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.MaterialProfiles = MaterialProfiles;
			this.CompositeProfile = CompositeProfile;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileSetUsage
	/// <para>ENTITY IfcMaterialProfileSetUsage</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMaterialProfileSetUsageTapering))</para>
	/// <para> SUBTYPE OF (IfcMaterialUsageDefinition);</para>
	/// <para>	ForProfileSet : IfcMaterialProfileSet;</para>
	/// <para>	CardinalPoint : OPTIONAL IfcCardinalPointReference;</para>
	/// <para>	ReferenceExtent : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileSetUsage : IfcMaterialUsageDefinition
	{
		public IfcMaterialProfileSet ForProfileSet { get; set; }
		public IfcCardinalPointReference? CardinalPoint { get; set; }
		public IfcPositiveLengthMeasure? ReferenceExtent { get; set; }
		public IfcMaterialProfileSetUsage() : base()
		{
			ForProfileSet = new IfcMaterialProfileSet();
		}
		public IfcMaterialProfileSetUsage(IfcMaterialProfileSet ForProfileSet, IfcCardinalPointReference CardinalPoint, IfcPositiveLengthMeasure ReferenceExtent) : base ()
		{
			this.ForProfileSet = ForProfileSet;
			this.CardinalPoint = CardinalPoint;
			this.ReferenceExtent = ReferenceExtent;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileSetUsageTapering
	/// <para>ENTITY IfcMaterialProfileSetUsageTapering</para>
	/// <para> SUBTYPE OF (IfcMaterialProfileSetUsage);</para>
	/// <para>	ForProfileEndSet : IfcMaterialProfileSet;</para>
	/// <para>	CardinalEndPoint : OPTIONAL IfcCardinalPointReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileSetUsageTapering : IfcMaterialProfileSetUsage
	{
		public IfcMaterialProfileSet ForProfileEndSet { get; set; }
		public IfcCardinalPointReference? CardinalEndPoint { get; set; }
		public IfcMaterialProfileSetUsageTapering() : base()
		{
			ForProfileEndSet = new IfcMaterialProfileSet();
		}
		public IfcMaterialProfileSetUsageTapering(IfcMaterialProfileSet ForProfileSet, IfcCardinalPointReference CardinalPoint, IfcPositiveLengthMeasure ReferenceExtent, IfcMaterialProfileSet ForProfileEndSet, IfcCardinalPointReference CardinalEndPoint) : base (ForProfileSet, CardinalPoint, ReferenceExtent)
		{
			this.ForProfileEndSet = ForProfileEndSet;
			this.CardinalEndPoint = CardinalEndPoint;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileWithOffsets
	/// <para>ENTITY IfcMaterialProfileWithOffsets</para>
	/// <para> SUBTYPE OF (IfcMaterialProfile);</para>
	/// <para>	OffsetValues : ARRAY [1:2] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileWithOffsets : IfcMaterialProfile
	{
		public List<IfcLengthMeasure> OffsetValues { get; set; }
		public IfcMaterialProfileWithOffsets() : base()
		{
			OffsetValues = new List<IfcLengthMeasure>();
		}
		public IfcMaterialProfileWithOffsets(IfcLabel Name, IfcText Description, IfcMaterial Material, IfcProfileDef Profile, IfcInteger Priority, IfcLabel Category, List<IfcLengthMeasure> OffsetValues) : base (Name, Description, Material, Profile, Priority, Category)
		{
			this.OffsetValues = OffsetValues;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProperties
	/// <para>ENTITY IfcMaterialProperties</para>
	/// <para> SUBTYPE OF (IfcExtendedProperties);</para>
	/// <para>	Material : IfcMaterialDefinition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProperties : IfcExtendedProperties
	{
		public IfcMaterialDefinition Material { get; set; }
		public IfcMaterialProperties() : base()
		{
			Material = new IfcMaterialDefinition();
		}
		public IfcMaterialProperties(IfcIdentifier Name, IfcText Description, List<IfcProperty> Properties, IfcMaterialDefinition Material) : base (Name, Description, Properties)
		{
			this.Material = Material;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialRelationship
	/// <para>ENTITY IfcMaterialRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingMaterial : IfcMaterial;</para>
	/// <para>	RelatedMaterials : SET [1:?] OF IfcMaterial;</para>
	/// <para>	MaterialExpression : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialRelationship : IfcResourceLevelRelationship
	{
		public IfcMaterial RelatingMaterial { get; set; }
		public List<IfcMaterial> RelatedMaterials { get; set; }
		public IfcLabel? MaterialExpression { get; set; }
		public IfcMaterialRelationship() : base()
		{
			RelatingMaterial = new IfcMaterial();
			RelatedMaterials = new List<IfcMaterial>();
		}
		public IfcMaterialRelationship(IfcLabel Name, IfcText Description, IfcMaterial RelatingMaterial, List<IfcMaterial> RelatedMaterials, IfcLabel MaterialExpression) : base (Name, Description)
		{
			this.RelatingMaterial = RelatingMaterial;
			this.RelatedMaterials = RelatedMaterials;
			this.MaterialExpression = MaterialExpression;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialUsageDefinition
	/// <para>ENTITY IfcMaterialUsageDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMaterialLayerSetUsage</para>
	/// <para>	,IfcMaterialProfileSetUsage));</para>
	/// <para> INVERSE</para>
	/// <para>	AssociatedTo : SET [1:?] OF IfcRelAssociatesMaterial FOR RelatingMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcMaterialUsageDefinitionENTITY, IfcMaterialSelect
	{
		public IfcMaterialUsageDefinition() : base()
		{
		}
		public IfcMaterialUsageDefinition() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMeasureWithUnit;
	/// <para>ENTITY IfcMeasureWithUnit;</para>
	/// <para>	ValueComponent : IfcValue;</para>
	/// <para>	UnitComponent : IfcUnit;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMeasureWithUnitENTITY, IfcAppliedValueSelect, IfcMetricValueSelect
	{
		public IfcValue ValueComponent { get; set; }
		public IfcUnit UnitComponent { get; set; }
		public IfcMeasureWithUnit() : base()
		{
			ValueComponent = new IfcValue();
			UnitComponent = new IfcUnit();
		}
		public IfcMeasureWithUnit(IfcValue ValueComponent, IfcUnit UnitComponent) : base ()
		{
			this.ValueComponent = ValueComponent;
			this.UnitComponent = UnitComponent;
		}
	}
	/// <summary>
	/// ENTITY IfcMechanicalFastener
	/// <para>ENTITY IfcMechanicalFastener</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	NominalLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcMechanicalFastenerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcMechanicalFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMechanicalFastenerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCMECHANICALFASTENERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMechanicalFastener : IfcElementComponent
	{
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcPositiveLengthMeasure? NominalLength { get; set; }
		public IfcMechanicalFastenerTypeEnum? PredefinedType { get; set; }
		public IfcMechanicalFastener() : base()
		{
		}
		public IfcMechanicalFastener(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure NominalDiameter, IfcPositiveLengthMeasure NominalLength, IfcMechanicalFastenerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.NominalDiameter = NominalDiameter;
			this.NominalLength = NominalLength;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMechanicalFastenerType
	/// <para>ENTITY IfcMechanicalFastenerType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcMechanicalFastenerTypeEnum;</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	NominalLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcMechanicalFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMechanicalFastenerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMechanicalFastenerType : IfcElementComponentType
	{
		public IfcMechanicalFastenerTypeEnum PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcPositiveLengthMeasure? NominalLength { get; set; }
		public IfcMechanicalFastenerType() : base()
		{
			PredefinedType = new IfcMechanicalFastenerTypeEnum();
		}
		public IfcMechanicalFastenerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMechanicalFastenerTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcPositiveLengthMeasure NominalLength) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.NominalLength = NominalLength;
		}
	}
	/// <summary>
	/// ENTITY IfcMedicalDevice
	/// <para>ENTITY IfcMedicalDevice</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcMedicalDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcMedicalDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMedicalDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCMEDICALDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMedicalDevice : IfcFlowTerminal
	{
		public IfcMedicalDeviceTypeEnum? PredefinedType { get; set; }
		public IfcMedicalDevice() : base()
		{
		}
		public IfcMedicalDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMedicalDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMedicalDeviceType
	/// <para>ENTITY IfcMedicalDeviceType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcMedicalDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcMedicalDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMedicalDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMedicalDeviceType : IfcFlowTerminalType
	{
		public IfcMedicalDeviceTypeEnum PredefinedType { get; set; }
		public IfcMedicalDeviceType() : base()
		{
			PredefinedType = new IfcMedicalDeviceTypeEnum();
		}
		public IfcMedicalDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMedicalDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMember
	/// <para>ENTITY IfcMember</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcMemberTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcMemberTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMemberTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCMEMBERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMember : IfcBuiltElement
	{
		public IfcMemberTypeEnum? PredefinedType { get; set; }
		public IfcMember() : base()
		{
		}
		public IfcMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMemberTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMemberType
	/// <para>ENTITY IfcMemberType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcMemberTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcMemberTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMemberTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMemberType : IfcBuiltElementType
	{
		public IfcMemberTypeEnum PredefinedType { get; set; }
		public IfcMemberType() : base()
		{
			PredefinedType = new IfcMemberTypeEnum();
		}
		public IfcMemberType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMemberTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMetric
	/// <para>ENTITY IfcMetric</para>
	/// <para> SUBTYPE OF (IfcConstraint);</para>
	/// <para>	Benchmark : IfcBenchmarkEnum;</para>
	/// <para>	ValueSource : OPTIONAL IfcLabel;</para>
	/// <para>	DataValue : OPTIONAL IfcMetricValueSelect;</para>
	/// <para>	ReferencePath : OPTIONAL IfcReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMetric : IfcConstraint
	{
		public IfcBenchmarkEnum Benchmark { get; set; }
		public IfcLabel? ValueSource { get; set; }
		public IfcMetricValueSelect? DataValue { get; set; }
		public IfcReference? ReferencePath { get; set; }
		public IfcMetric() : base()
		{
			Benchmark = new IfcBenchmarkEnum();
		}
		public IfcMetric(IfcLabel Name, IfcText Description, IfcConstraintEnum ConstraintGrade, IfcLabel ConstraintSource, IfcActorSelect CreatingActor, IfcDateTime CreationTime, IfcLabel UserDefinedGrade, IfcBenchmarkEnum Benchmark, IfcLabel ValueSource, IfcMetricValueSelect DataValue, IfcReference ReferencePath) : base (Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade)
		{
			this.Benchmark = Benchmark;
			this.ValueSource = ValueSource;
			this.DataValue = DataValue;
			this.ReferencePath = ReferencePath;
		}
	}
	/// <summary>
	/// ENTITY IfcMirroredProfileDef
	/// <para>ENTITY IfcMirroredProfileDef</para>
	/// <para> SUBTYPE OF (IfcDerivedProfileDef);</para>
	/// <para> DERIVE</para>
	/// <para>	 SELF\IfcDerivedProfileDef.Operator : IfcCartesianTransformationOperator2D := </para>
	/// <para>IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>IfcCartesianTransformationOperator(</para>
	/// <para>    -- Axis1</para>
	/// <para>    IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>    IfcDirection([-1., 0.]),</para>
	/// <para>    -- Axis2</para>
	/// <para>    IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>    IfcDirection([ 0., 1.]),</para>
	/// <para>    -- LocalOrigin</para>
	/// <para>    IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>    IfcPoint() || IfcCartesianPoint([0., 0.]),</para>
	/// <para>    -- Scale</para>
	/// <para>    1.) ||</para>
	/// <para>IfcCartesianTransformationOperator2D();</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMirroredProfileDef : IfcDerivedProfileDef
	{
		public IfcMirroredProfileDef() : base()
		{
		}
		public IfcMirroredProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcProfileDef ParentProfile, IfcCartesianTransformationOperator2D Operator, IfcLabel Label) : base (ProfileType, ProfileName, ParentProfile, Operator, Label)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMobileTelecommunicationsAppliance
	/// <para>ENTITY IfcMobileTelecommunicationsAppliance</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcMobileTelecommunicationsApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcMobileTelecommunicationsApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMobileTelecommunicationsApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMobileTelecommunicationsAppliance : IfcFlowTerminal
	{
		public IfcMobileTelecommunicationsApplianceTypeEnum? PredefinedType { get; set; }
		public IfcMobileTelecommunicationsAppliance() : base()
		{
		}
		public IfcMobileTelecommunicationsAppliance(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMobileTelecommunicationsApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMobileTelecommunicationsApplianceType
	/// <para>ENTITY IfcMobileTelecommunicationsApplianceType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcMobileTelecommunicationsApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcMobileTelecommunicationsApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMobileTelecommunicationsApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMobileTelecommunicationsApplianceType : IfcFlowTerminalType
	{
		public IfcMobileTelecommunicationsApplianceTypeEnum PredefinedType { get; set; }
		public IfcMobileTelecommunicationsApplianceType() : base()
		{
			PredefinedType = new IfcMobileTelecommunicationsApplianceTypeEnum();
		}
		public IfcMobileTelecommunicationsApplianceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMobileTelecommunicationsApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMonetaryUnit;
	/// <para>ENTITY IfcMonetaryUnit;</para>
	/// <para>	Currency : IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMonetaryUnitENTITY, IfcUnit
	{
		public IfcLabel Currency { get; set; }
		public IfcMonetaryUnit() : base()
		{
			Currency = new IfcLabel();
		}
		public IfcMonetaryUnit(IfcLabel Currency) : base ()
		{
			this.Currency = Currency;
		}
	}
	/// <summary>
	/// ENTITY IfcMooringDevice
	/// <para>ENTITY IfcMooringDevice</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcMooringDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcMooringDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMooringDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCMOORINGDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMooringDevice : IfcBuiltElement
	{
		public IfcMooringDeviceTypeEnum? PredefinedType { get; set; }
		public IfcMooringDevice() : base()
		{
		}
		public IfcMooringDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMooringDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMooringDeviceType
	/// <para>ENTITY IfcMooringDeviceType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcMooringDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcMooringDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMooringDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMooringDeviceType : IfcBuiltElementType
	{
		public IfcMooringDeviceTypeEnum PredefinedType { get; set; }
		public IfcMooringDeviceType() : base()
		{
			PredefinedType = new IfcMooringDeviceTypeEnum();
		}
		public IfcMooringDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMooringDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMotorConnection
	/// <para>ENTITY IfcMotorConnection</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcMotorConnectionTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcMotorConnectionTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMotorConnectionTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCMOTORCONNECTIONTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMotorConnection : IfcEnergyConversionDevice
	{
		public IfcMotorConnectionTypeEnum? PredefinedType { get; set; }
		public IfcMotorConnection() : base()
		{
		}
		public IfcMotorConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMotorConnectionTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMotorConnectionType
	/// <para>ENTITY IfcMotorConnectionType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcMotorConnectionTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcMotorConnectionTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMotorConnectionTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMotorConnectionType : IfcEnergyConversionDeviceType
	{
		public IfcMotorConnectionTypeEnum PredefinedType { get; set; }
		public IfcMotorConnectionType() : base()
		{
			PredefinedType = new IfcMotorConnectionTypeEnum();
		}
		public IfcMotorConnectionType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMotorConnectionTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcNamedUnit
	/// <para>ENTITY IfcNamedUnit</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcContextDependentUnit</para>
	/// <para>	,IfcConversionBasedUnit</para>
	/// <para>	,IfcSIUnit));</para>
	/// <para>	Dimensions : IfcDimensionalExponents;</para>
	/// <para>	UnitType : IfcUnitEnum;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : IfcCorrectDimensions (SELF.UnitType, SELF.Dimensions);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcNamedUnitENTITY, IfcUnit
	{
		public IfcDimensionalExponents Dimensions { get; set; }
		public IfcUnitEnum UnitType { get; set; }
		public IfcNamedUnit() : base()
		{
			Dimensions = new IfcDimensionalExponents();
			UnitType = new IfcUnitEnum();
		}
		public IfcNamedUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType) : base ()
		{
			this.Dimensions = Dimensions;
			this.UnitType = UnitType;
		}
	}
	/// <summary>
	/// ENTITY IfcNavigationElement
	/// <para>ENTITY IfcNavigationElement</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcNavigationElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcNavigationElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcNavigationElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCNAVIGATIONELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcNavigationElement : IfcBuiltElement
	{
		public IfcNavigationElementTypeEnum? PredefinedType { get; set; }
		public IfcNavigationElement() : base()
		{
		}
		public IfcNavigationElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcNavigationElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcNavigationElementType
	/// <para>ENTITY IfcNavigationElementType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcNavigationElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcNavigationElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcNavigationElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcNavigationElementType : IfcBuiltElementType
	{
		public IfcNavigationElementTypeEnum PredefinedType { get; set; }
		public IfcNavigationElementType() : base()
		{
			PredefinedType = new IfcNavigationElementTypeEnum();
		}
		public IfcNavigationElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcNavigationElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcObject
	/// <para>ENTITY IfcObject</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcActor</para>
	/// <para>	,IfcControl</para>
	/// <para>	,IfcGroup</para>
	/// <para>	,IfcProcess</para>
	/// <para>	,IfcProduct</para>
	/// <para>	,IfcResource))</para>
	/// <para> SUBTYPE OF (IfcObjectDefinition);</para>
	/// <para>	ObjectType : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	IsDeclaredBy : SET [0:1] OF IfcRelDefinesByObject FOR RelatedObjects;</para>
	/// <para>	Declares : SET [0:?] OF IfcRelDefinesByObject FOR RelatingObject;</para>
	/// <para>	IsTypedBy : SET [0:1] OF IfcRelDefinesByType FOR RelatedObjects;</para>
	/// <para>	IsDefinedBy : SET [0:?] OF IfcRelDefinesByProperties FOR RelatedObjects;</para>
	/// <para> WHERE</para>
	/// <para>	UniquePropertySetNames : ((SIZEOF(IsDefinedBy) = 0) OR IfcUniqueDefinitionNames(IsDefinedBy));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcObject : IfcObjectDefinition
	{
		public IfcLabel? ObjectType { get; set; }
		public IfcObject() : base()
		{
		}
		public IfcObject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ObjectType = ObjectType;
		}
	}
	/// <summary>
	/// ENTITY IfcObjectDefinition
	/// <para>ENTITY IfcObjectDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcContext</para>
	/// <para>	,IfcObject</para>
	/// <para>	,IfcTypeObject))</para>
	/// <para> SUBTYPE OF (IfcRoot);</para>
	/// <para> INVERSE</para>
	/// <para>	HasAssignments : SET [0:?] OF IfcRelAssigns FOR RelatedObjects;</para>
	/// <para>	Nests : SET [0:1] OF IfcRelNests FOR RelatedObjects;</para>
	/// <para>	IsNestedBy : SET [0:?] OF IfcRelNests FOR RelatingObject;</para>
	/// <para>	HasContext : SET [0:1] OF IfcRelDeclares FOR RelatedDefinitions;</para>
	/// <para>	IsDecomposedBy : SET [0:?] OF IfcRelAggregates FOR RelatingObject;</para>
	/// <para>	Decomposes : SET [0:1] OF IfcRelAggregates FOR RelatedObjects;</para>
	/// <para>	HasAssociations : SET [0:?] OF IfcRelAssociates FOR RelatedObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcObjectDefinition : IfcRoot, IfcDefinitionSelect
	{
		public IfcObjectDefinition() : base()
		{
		}
		public IfcObjectDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcObjectPlacement
	/// <para>ENTITY IfcObjectPlacement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcGridPlacement</para>
	/// <para>	,IfcLinearPlacement</para>
	/// <para>	,IfcLocalPlacement));</para>
	/// <para>	PlacementRelTo : OPTIONAL IfcObjectPlacement;</para>
	/// <para> INVERSE</para>
	/// <para>	PlacesObject : SET [0:?] OF IfcProduct FOR ObjectPlacement;</para>
	/// <para>	ReferencedByPlacements : SET [0:?] OF IfcObjectPlacement FOR PlacementRelTo;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcObjectPlacementENTITY
	{
		public IfcObjectPlacement? PlacementRelTo { get; set; }
		public IfcObjectPlacement() : base()
		{
		}
		public IfcObjectPlacement(IfcObjectPlacement PlacementRelTo) : base ()
		{
			this.PlacementRelTo = PlacementRelTo;
		}
	}
	/// <summary>
	/// ENTITY IfcObjective
	/// <para>ENTITY IfcObjective</para>
	/// <para> SUBTYPE OF (IfcConstraint);</para>
	/// <para>	BenchmarkValues : OPTIONAL LIST [1:?] OF IfcConstraint;</para>
	/// <para>	LogicalAggregator : OPTIONAL IfcLogicalOperatorEnum;</para>
	/// <para>	ObjectiveQualifier : IfcObjectiveEnum;</para>
	/// <para>	UserDefinedQualifier : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : (ObjectiveQualifier <> IfcObjectiveEnum.USERDEFINED) OR</para>
	/// <para>((ObjectiveQualifier = IfcObjectiveEnum.USERDEFINED) AND EXISTS(SELF\IfcObjective.UserDefinedQualifier));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcObjective : IfcConstraint
	{
		public List<IfcConstraint>? BenchmarkValues { get; set; }
		public IfcLogicalOperatorEnum? LogicalAggregator { get; set; }
		public IfcObjectiveEnum ObjectiveQualifier { get; set; }
		public IfcLabel? UserDefinedQualifier { get; set; }
		public IfcObjective() : base()
		{
			ObjectiveQualifier = new IfcObjectiveEnum();
		}
		public IfcObjective(IfcLabel Name, IfcText Description, IfcConstraintEnum ConstraintGrade, IfcLabel ConstraintSource, IfcActorSelect CreatingActor, IfcDateTime CreationTime, IfcLabel UserDefinedGrade, List<IfcConstraint> BenchmarkValues, IfcLogicalOperatorEnum LogicalAggregator, IfcObjectiveEnum ObjectiveQualifier, IfcLabel UserDefinedQualifier) : base (Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade)
		{
			this.BenchmarkValues = BenchmarkValues;
			this.LogicalAggregator = LogicalAggregator;
			this.ObjectiveQualifier = ObjectiveQualifier;
			this.UserDefinedQualifier = UserDefinedQualifier;
		}
	}
	/// <summary>
	/// ENTITY IfcOccupant
	/// <para>ENTITY IfcOccupant</para>
	/// <para> SUBTYPE OF (IfcActor);</para>
	/// <para>	PredefinedType : OPTIONAL IfcOccupantTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : NOT(PredefinedType = IfcOccupantTypeEnum.USERDEFINED) </para>
	/// <para>OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOccupant : IfcActor
	{
		public IfcOccupantTypeEnum? PredefinedType { get; set; }
		public IfcOccupant() : base()
		{
		}
		public IfcOccupant(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcActorSelect TheActor, IfcOccupantTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOffsetCurve
	/// <para>ENTITY IfcOffsetCurve</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcOffsetCurve2D</para>
	/// <para>	,IfcOffsetCurve3D</para>
	/// <para>	,IfcOffsetCurveByDistances))</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	BasisCurve : IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcOffsetCurve : IfcCurve
	{
		public IfcCurve BasisCurve { get; set; }
		public IfcOffsetCurve() : base()
		{
			BasisCurve = new IfcCurve();
		}
		public IfcOffsetCurve(IfcCurve BasisCurve) : base ()
		{
			this.BasisCurve = BasisCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcOffsetCurve2D
	/// <para>ENTITY IfcOffsetCurve2D</para>
	/// <para> SUBTYPE OF (IfcOffsetCurve);</para>
	/// <para>	Distance : IfcLengthMeasure;</para>
	/// <para>	SelfIntersect : IfcLogical;</para>
	/// <para> WHERE</para>
	/// <para>	DimIs2D : BasisCurve.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOffsetCurve2D : IfcOffsetCurve
	{
		public IfcLengthMeasure Distance { get; set; }
		public IfcLogical SelfIntersect { get; set; }
		public IfcOffsetCurve2D() : base()
		{
			Distance = new IfcLengthMeasure();
			SelfIntersect = new IfcLogical();
		}
		public IfcOffsetCurve2D(IfcCurve BasisCurve, IfcLengthMeasure Distance, IfcLogical SelfIntersect) : base (BasisCurve)
		{
			this.Distance = Distance;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcOffsetCurve3D
	/// <para>ENTITY IfcOffsetCurve3D</para>
	/// <para> SUBTYPE OF (IfcOffsetCurve);</para>
	/// <para>	Distance : IfcLengthMeasure;</para>
	/// <para>	SelfIntersect : IfcLogical;</para>
	/// <para>	RefDirection : IfcDirection;</para>
	/// <para> WHERE</para>
	/// <para>	DimIs2D : BasisCurve.Dim = 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOffsetCurve3D : IfcOffsetCurve
	{
		public IfcLengthMeasure Distance { get; set; }
		public IfcLogical SelfIntersect { get; set; }
		public IfcDirection RefDirection { get; set; }
		public IfcOffsetCurve3D() : base()
		{
			Distance = new IfcLengthMeasure();
			SelfIntersect = new IfcLogical();
			RefDirection = new IfcDirection();
		}
		public IfcOffsetCurve3D(IfcCurve BasisCurve, IfcLengthMeasure Distance, IfcLogical SelfIntersect, IfcDirection RefDirection) : base (BasisCurve)
		{
			this.Distance = Distance;
			this.SelfIntersect = SelfIntersect;
			this.RefDirection = RefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcOffsetCurveByDistances
	/// <para>ENTITY IfcOffsetCurveByDistances</para>
	/// <para> SUBTYPE OF (IfcOffsetCurve);</para>
	/// <para>	OffsetValues : LIST [1:?] OF IfcPointByDistanceExpression;</para>
	/// <para>	Tag : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOffsetCurveByDistances : IfcOffsetCurve
	{
		public List<IfcPointByDistanceExpression> OffsetValues { get; set; }
		public IfcLabel? Tag { get; set; }
		public IfcOffsetCurveByDistances() : base()
		{
			OffsetValues = new List<IfcPointByDistanceExpression>();
		}
		public IfcOffsetCurveByDistances(IfcCurve BasisCurve, List<IfcPointByDistanceExpression> OffsetValues, IfcLabel Tag) : base (BasisCurve)
		{
			this.OffsetValues = OffsetValues;
			this.Tag = Tag;
		}
	}
	/// <summary>
	/// ENTITY IfcOpenCrossProfileDef
	/// <para>ENTITY IfcOpenCrossProfileDef</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	HorizontalWidths : IfcBoolean;</para>
	/// <para>	Widths : LIST [1:?] OF IfcNonNegativeLengthMeasure;</para>
	/// <para>	Slopes : LIST [1:?] OF IfcPlaneAngleMeasure;</para>
	/// <para>	Tags : OPTIONAL LIST [2:?] OF IfcLabel;</para>
	/// <para>	OffsetPoint : OPTIONAL IfcCartesianPoint;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectProfileType : SELF\IfcProfileDef.ProfileType = IfcProfileTypeEnum.CURVE;</para>
	/// <para>	CorrespondingSlopeWidths : SIZEOF(Slopes) = SIZEOF(Widths);</para>
	/// <para>	CorrespondingTags : (NOT EXISTS (Tags)) OR (SIZEOF(Tags) = (SIZEOF(Slopes) + 1));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOpenCrossProfileDef : IfcProfileDef
	{
		public IfcBoolean HorizontalWidths { get; set; }
		public List<IfcNonNegativeLengthMeasure> Widths { get; set; }
		public List<IfcPlaneAngleMeasure> Slopes { get; set; }
		public List<IfcLabel>? Tags { get; set; }
		public IfcCartesianPoint? OffsetPoint { get; set; }
		public IfcOpenCrossProfileDef() : base()
		{
			HorizontalWidths = new IfcBoolean();
			Widths = new List<IfcNonNegativeLengthMeasure>();
			Slopes = new List<IfcPlaneAngleMeasure>();
		}
		public IfcOpenCrossProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcBoolean HorizontalWidths, List<IfcNonNegativeLengthMeasure> Widths, List<IfcPlaneAngleMeasure> Slopes, List<IfcLabel> Tags, IfcCartesianPoint OffsetPoint) : base (ProfileType, ProfileName)
		{
			this.HorizontalWidths = HorizontalWidths;
			this.Widths = Widths;
			this.Slopes = Slopes;
			this.Tags = Tags;
			this.OffsetPoint = OffsetPoint;
		}
	}
	/// <summary>
	/// ENTITY IfcOpenShell
	/// <para>ENTITY IfcOpenShell</para>
	/// <para> SUBTYPE OF (IfcConnectedFaceSet);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOpenShell : IfcConnectedFaceSet, IfcShell
	{
		public IfcOpenShell() : base()
		{
		}
		public IfcOpenShell(List<IfcFace> CfsFaces) : base (CfsFaces)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcOpeningElement
	/// <para>ENTITY IfcOpeningElement</para>
	/// <para> SUBTYPE OF (IfcFeatureElementSubtraction);</para>
	/// <para>	PredefinedType : OPTIONAL IfcOpeningElementTypeEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	HasFillings : SET [0:?] OF IfcRelFillsElement FOR RelatingOpeningElement;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcOpeningElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcOpeningElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOpeningElement : IfcFeatureElementSubtraction
	{
		public IfcOpeningElementTypeEnum? PredefinedType { get; set; }
		public IfcOpeningElement() : base()
		{
		}
		public IfcOpeningElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcOpeningElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOrganization;
	/// <para>ENTITY IfcOrganization;</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Roles : OPTIONAL LIST [1:?] OF IfcActorRole;</para>
	/// <para>	Addresses : OPTIONAL LIST [1:?] OF IfcAddress;</para>
	/// <para> INVERSE</para>
	/// <para>	IsRelatedBy : SET [0:?] OF IfcOrganizationRelationship FOR RelatedOrganizations;</para>
	/// <para>	Relates : SET [0:?] OF IfcOrganizationRelationship FOR RelatingOrganization;</para>
	/// <para>	Engages : SET [0:?] OF IfcPersonAndOrganization FOR TheOrganization;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOrganizationENTITY, IfcActorSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcActorRole>? Roles { get; set; }
		public List<IfcAddress>? Addresses { get; set; }
		public IfcOrganization() : base()
		{
			Name = new IfcLabel();
		}
		public IfcOrganization(IfcIdentifier Identification, IfcLabel Name, IfcText Description, List<IfcActorRole> Roles, List<IfcAddress> Addresses) : base ()
		{
			this.Identification = Identification;
			this.Name = Name;
			this.Description = Description;
			this.Roles = Roles;
			this.Addresses = Addresses;
		}
	}
	/// <summary>
	/// ENTITY IfcOrganizationRelationship
	/// <para>ENTITY IfcOrganizationRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingOrganization : IfcOrganization;</para>
	/// <para>	RelatedOrganizations : SET [1:?] OF IfcOrganization;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOrganizationRelationship : IfcResourceLevelRelationship
	{
		public IfcOrganization RelatingOrganization { get; set; }
		public List<IfcOrganization> RelatedOrganizations { get; set; }
		public IfcOrganizationRelationship() : base()
		{
			RelatingOrganization = new IfcOrganization();
			RelatedOrganizations = new List<IfcOrganization>();
		}
		public IfcOrganizationRelationship(IfcLabel Name, IfcText Description, IfcOrganization RelatingOrganization, List<IfcOrganization> RelatedOrganizations) : base (Name, Description)
		{
			this.RelatingOrganization = RelatingOrganization;
			this.RelatedOrganizations = RelatedOrganizations;
		}
	}
	/// <summary>
	/// ENTITY IfcOrientedEdge
	/// <para>ENTITY IfcOrientedEdge</para>
	/// <para> SUBTYPE OF (IfcEdge);</para>
	/// <para>	EdgeElement : IfcEdge;</para>
	/// <para>	Orientation : IfcBoolean;</para>
	/// <para> DERIVE</para>
	/// <para>	 SELF\IfcEdge.EdgeStart : IfcVertex := IfcBooleanChoose </para>
	/// <para>(Orientation, EdgeElement.EdgeStart, EdgeElement.EdgeEnd);</para>
	/// <para>	 SELF\IfcEdge.EdgeEnd : IfcVertex := IfcBooleanChoose </para>
	/// <para>(Orientation, EdgeElement.EdgeEnd, EdgeElement.EdgeStart);</para>
	/// <para> WHERE</para>
	/// <para>	EdgeElementNotOriented : NOT('IFC4X3_ADD2.IFCORIENTEDEDGE' IN TYPEOF(EdgeElement));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOrientedEdge : IfcEdge
	{
		public IfcEdge EdgeElement { get; set; }
		public IfcBoolean Orientation { get; set; }
		public IfcOrientedEdge() : base()
		{
			EdgeElement = new IfcEdge();
			Orientation = new IfcBoolean();
		}
		public IfcOrientedEdge(IfcVertex EdgeStart, IfcVertex EdgeEnd, IfcEdge EdgeElement, IfcBoolean Orientation) : base (EdgeStart, EdgeEnd)
		{
			this.EdgeElement = EdgeElement;
			this.Orientation = Orientation;
		}
	}
	/// <summary>
	/// ENTITY IfcOuterBoundaryCurve
	/// <para>ENTITY IfcOuterBoundaryCurve</para>
	/// <para> SUBTYPE OF (IfcBoundaryCurve);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOuterBoundaryCurve : IfcBoundaryCurve
	{
		public IfcOuterBoundaryCurve() : base()
		{
		}
		public IfcOuterBoundaryCurve(List<IfcSegment> Segments, IfcLogical SelfIntersect) : base (Segments, SelfIntersect)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcOutlet
	/// <para>ENTITY IfcOutlet</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcOutletTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcOutletTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcOutletTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCOUTLETTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOutlet : IfcFlowTerminal
	{
		public IfcOutletTypeEnum? PredefinedType { get; set; }
		public IfcOutlet() : base()
		{
		}
		public IfcOutlet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcOutletTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOutletType
	/// <para>ENTITY IfcOutletType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcOutletTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcOutletTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcOutletTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOutletType : IfcFlowTerminalType
	{
		public IfcOutletTypeEnum PredefinedType { get; set; }
		public IfcOutletType() : base()
		{
			PredefinedType = new IfcOutletTypeEnum();
		}
		public IfcOutletType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcOutletTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOwnerHistory;
	/// <para>ENTITY IfcOwnerHistory;</para>
	/// <para>	OwningUser : IfcPersonAndOrganization;</para>
	/// <para>	OwningApplication : IfcApplication;</para>
	/// <para>	State : OPTIONAL IfcStateEnum;</para>
	/// <para>	ChangeAction : OPTIONAL IfcChangeActionEnum;</para>
	/// <para>	LastModifiedDate : OPTIONAL IfcTimeStamp;</para>
	/// <para>	LastModifyingUser : OPTIONAL IfcPersonAndOrganization;</para>
	/// <para>	LastModifyingApplication : OPTIONAL IfcApplication;</para>
	/// <para>	CreationDate : IfcTimeStamp;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectChangeAction : (EXISTS(LastModifiedDate)) OR</para>
	/// <para>(NOT(EXISTS(LastModifiedDate)) AND NOT(EXISTS(ChangeAction))) OR</para>
	/// <para>(NOT(EXISTS(LastModifiedDate)) AND EXISTS(ChangeAction) AND ((ChangeAction = IfcChangeActionEnum.NOTDEFINED) OR (ChangeAction = IfcChangeActionEnum.NOCHANGE)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOwnerHistoryENTITY
	{
		public IfcPersonAndOrganization OwningUser { get; set; }
		public IfcApplication OwningApplication { get; set; }
		public IfcStateEnum? State { get; set; }
		public IfcChangeActionEnum? ChangeAction { get; set; }
		public IfcTimeStamp? LastModifiedDate { get; set; }
		public IfcPersonAndOrganization? LastModifyingUser { get; set; }
		public IfcApplication? LastModifyingApplication { get; set; }
		public IfcTimeStamp CreationDate { get; set; }
		public IfcOwnerHistory() : base()
		{
			OwningUser = new IfcPersonAndOrganization();
			OwningApplication = new IfcApplication();
			CreationDate = new IfcTimeStamp();
		}
		public IfcOwnerHistory(IfcPersonAndOrganization OwningUser, IfcApplication OwningApplication, IfcStateEnum State, IfcChangeActionEnum ChangeAction, IfcTimeStamp LastModifiedDate, IfcPersonAndOrganization LastModifyingUser, IfcApplication LastModifyingApplication, IfcTimeStamp CreationDate) : base ()
		{
			this.OwningUser = OwningUser;
			this.OwningApplication = OwningApplication;
			this.State = State;
			this.ChangeAction = ChangeAction;
			this.LastModifiedDate = LastModifiedDate;
			this.LastModifyingUser = LastModifyingUser;
			this.LastModifyingApplication = LastModifyingApplication;
			this.CreationDate = CreationDate;
		}
	}
	/// <summary>
	/// ENTITY IfcParameterizedProfileDef
	/// <para>ENTITY IfcParameterizedProfileDef</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAsymmetricIShapeProfileDef</para>
	/// <para>	,IfcCShapeProfileDef</para>
	/// <para>	,IfcCircleProfileDef</para>
	/// <para>	,IfcEllipseProfileDef</para>
	/// <para>	,IfcIShapeProfileDef</para>
	/// <para>	,IfcLShapeProfileDef</para>
	/// <para>	,IfcRectangleProfileDef</para>
	/// <para>	,IfcTShapeProfileDef</para>
	/// <para>	,IfcTrapeziumProfileDef</para>
	/// <para>	,IfcUShapeProfileDef</para>
	/// <para>	,IfcZShapeProfileDef))</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	Position : OPTIONAL IfcAxis2Placement2D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcParameterizedProfileDef : IfcProfileDef
	{
		public IfcAxis2Placement2D? Position { get; set; }
		public IfcParameterizedProfileDef() : base()
		{
		}
		public IfcParameterizedProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position) : base (ProfileType, ProfileName)
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcPath
	/// <para>ENTITY IfcPath</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>	EdgeList : LIST [1:?] OF UNIQUE IfcOrientedEdge;</para>
	/// <para> WHERE</para>
	/// <para>	IsContinuous : IfcPathHeadToTail(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPath : IfcTopologicalRepresentationItem
	{
		public IfcPath() : base()
		{
		}
		public IfcPath() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPavement
	/// <para>ENTITY IfcPavement</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPavementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcPavementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPavementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCPAVEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPavement : IfcBuiltElement
	{
		public IfcPavementTypeEnum? PredefinedType { get; set; }
		public IfcPavement() : base()
		{
		}
		public IfcPavement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPavementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPavementType
	/// <para>ENTITY IfcPavementType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcPavementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPavementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPavementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPavementType : IfcBuiltElementType
	{
		public IfcPavementTypeEnum PredefinedType { get; set; }
		public IfcPavementType() : base()
		{
			PredefinedType = new IfcPavementTypeEnum();
		}
		public IfcPavementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPavementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPcurve
	/// <para>ENTITY IfcPcurve</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	BasisSurface : IfcSurface;</para>
	/// <para>	ReferenceCurve : IfcCurve;</para>
	/// <para> WHERE</para>
	/// <para>	DimIs2D : ReferenceCurve.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPcurve : IfcCurve, IfcCurveOnSurface
	{
		public IfcSurface BasisSurface { get; set; }
		public IfcCurve ReferenceCurve { get; set; }
		public IfcPcurve() : base()
		{
			BasisSurface = new IfcSurface();
			ReferenceCurve = new IfcCurve();
		}
		public IfcPcurve(IfcSurface BasisSurface, IfcCurve ReferenceCurve) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.ReferenceCurve = ReferenceCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcPerformanceHistory
	/// <para>ENTITY IfcPerformanceHistory</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	LifeCyclePhase : IfcLabel;</para>
	/// <para>	PredefinedType : OPTIONAL IfcPerformanceHistoryTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPerformanceHistory : IfcControl
	{
		public IfcLabel LifeCyclePhase { get; set; }
		public IfcPerformanceHistoryTypeEnum? PredefinedType { get; set; }
		public IfcPerformanceHistory() : base()
		{
			LifeCyclePhase = new IfcLabel();
		}
		public IfcPerformanceHistory(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcLabel LifeCyclePhase, IfcPerformanceHistoryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.LifeCyclePhase = LifeCyclePhase;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPermeableCoveringProperties
	/// <para>ENTITY IfcPermeableCoveringProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	OperationType : IfcPermeableCoveringOperationEnum;</para>
	/// <para>	PanelPosition : IfcWindowPanelPositionEnum;</para>
	/// <para>	FrameDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	FrameThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPermeableCoveringProperties : IfcPreDefinedPropertySet
	{
		public IfcPermeableCoveringOperationEnum OperationType { get; set; }
		public IfcWindowPanelPositionEnum PanelPosition { get; set; }
		public IfcPositiveLengthMeasure? FrameDepth { get; set; }
		public IfcPositiveLengthMeasure? FrameThickness { get; set; }
		public IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcPermeableCoveringProperties() : base()
		{
			OperationType = new IfcPermeableCoveringOperationEnum();
			PanelPosition = new IfcWindowPanelPositionEnum();
		}
		public IfcPermeableCoveringProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPermeableCoveringOperationEnum OperationType, IfcWindowPanelPositionEnum PanelPosition, IfcPositiveLengthMeasure FrameDepth, IfcPositiveLengthMeasure FrameThickness, IfcShapeAspect ShapeAspectStyle) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.OperationType = OperationType;
			this.PanelPosition = PanelPosition;
			this.FrameDepth = FrameDepth;
			this.FrameThickness = FrameThickness;
			this.ShapeAspectStyle = ShapeAspectStyle;
		}
	}
	/// <summary>
	/// ENTITY IfcPermit
	/// <para>ENTITY IfcPermit</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPermitTypeEnum;</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPermit : IfcControl
	{
		public IfcPermitTypeEnum? PredefinedType { get; set; }
		public IfcLabel? Status { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcPermit() : base()
		{
		}
		public IfcPermit(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcPermitTypeEnum PredefinedType, IfcLabel Status, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcPerson;
	/// <para>ENTITY IfcPerson;</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	FamilyName : OPTIONAL IfcLabel;</para>
	/// <para>	GivenName : OPTIONAL IfcLabel;</para>
	/// <para>	MiddleNames : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	PrefixTitles : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	SuffixTitles : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	Roles : OPTIONAL LIST [1:?] OF IfcActorRole;</para>
	/// <para>	Addresses : OPTIONAL LIST [1:?] OF IfcAddress;</para>
	/// <para> INVERSE</para>
	/// <para>	EngagedIn : SET [0:?] OF IfcPersonAndOrganization FOR ThePerson;</para>
	/// <para> WHERE</para>
	/// <para>	IdentifiablePerson : EXISTS(Identification) OR EXISTS(FamilyName) OR EXISTS(GivenName);</para>
	/// <para>	ValidSetOfNames : NOT EXISTS(MiddleNames) OR EXISTS(FamilyName) OR EXISTS(GivenName);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPersonENTITY, IfcActorSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcLabel? FamilyName { get; set; }
		public IfcLabel? GivenName { get; set; }
		public List<IfcLabel>? MiddleNames { get; set; }
		public List<IfcLabel>? PrefixTitles { get; set; }
		public List<IfcLabel>? SuffixTitles { get; set; }
		public List<IfcActorRole>? Roles { get; set; }
		public List<IfcAddress>? Addresses { get; set; }
		public IfcPerson() : base()
		{
		}
		public IfcPerson(IfcIdentifier Identification, IfcLabel FamilyName, IfcLabel GivenName, List<IfcLabel> MiddleNames, List<IfcLabel> PrefixTitles, List<IfcLabel> SuffixTitles, List<IfcActorRole> Roles, List<IfcAddress> Addresses) : base ()
		{
			this.Identification = Identification;
			this.FamilyName = FamilyName;
			this.GivenName = GivenName;
			this.MiddleNames = MiddleNames;
			this.PrefixTitles = PrefixTitles;
			this.SuffixTitles = SuffixTitles;
			this.Roles = Roles;
			this.Addresses = Addresses;
		}
	}
	/// <summary>
	/// ENTITY IfcPersonAndOrganization;
	/// <para>ENTITY IfcPersonAndOrganization;</para>
	/// <para>	ThePerson : IfcPerson;</para>
	/// <para>	TheOrganization : IfcOrganization;</para>
	/// <para>	Roles : OPTIONAL LIST [1:?] OF IfcActorRole;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPersonAndOrganizationENTITY, IfcActorSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcPerson ThePerson { get; set; }
		public IfcOrganization TheOrganization { get; set; }
		public List<IfcActorRole>? Roles { get; set; }
		public IfcPersonAndOrganization() : base()
		{
			ThePerson = new IfcPerson();
			TheOrganization = new IfcOrganization();
		}
		public IfcPersonAndOrganization(IfcPerson ThePerson, IfcOrganization TheOrganization, List<IfcActorRole> Roles) : base ()
		{
			this.ThePerson = ThePerson;
			this.TheOrganization = TheOrganization;
			this.Roles = Roles;
		}
	}
	/// <summary>
	/// ENTITY IfcPhysicalComplexQuantity
	/// <para>ENTITY IfcPhysicalComplexQuantity</para>
	/// <para> SUBTYPE OF (IfcPhysicalQuantity);</para>
	/// <para>	HasQuantities : SET [1:?] OF IfcPhysicalQuantity;</para>
	/// <para>	Discrimination : IfcLabel;</para>
	/// <para>	Quality : OPTIONAL IfcLabel;</para>
	/// <para>	Usage : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(temp <* HasQuantities | SELF :=: temp)) = 0;</para>
	/// <para>	UniqueQuantityNames : IfcUniqueQuantityNames(HasQuantities);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPhysicalComplexQuantity : IfcPhysicalQuantity
	{
		public List<IfcPhysicalQuantity> HasQuantities { get; set; }
		public IfcLabel Discrimination { get; set; }
		public IfcLabel? Quality { get; set; }
		public IfcLabel? Usage { get; set; }
		public IfcPhysicalComplexQuantity() : base()
		{
			HasQuantities = new List<IfcPhysicalQuantity>();
			Discrimination = new IfcLabel();
		}
		public IfcPhysicalComplexQuantity(IfcLabel Name, IfcText Description, List<IfcPhysicalQuantity> HasQuantities, IfcLabel Discrimination, IfcLabel Quality, IfcLabel Usage) : base (Name, Description)
		{
			this.HasQuantities = HasQuantities;
			this.Discrimination = Discrimination;
			this.Quality = Quality;
			this.Usage = Usage;
		}
	}
	/// <summary>
	/// ENTITY IfcPhysicalQuantity
	/// <para>ENTITY IfcPhysicalQuantity</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcPhysicalComplexQuantity</para>
	/// <para>	,IfcPhysicalSimpleQuantity));</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>	PartOfComplex : SET [0:1] OF IfcPhysicalComplexQuantity FOR HasQuantities;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPhysicalQuantityENTITY, IfcResourceObjectSelect
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcPhysicalQuantity() : base()
		{
			Name = new IfcLabel();
		}
		public IfcPhysicalQuantity(IfcLabel Name, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcPhysicalSimpleQuantity
	/// <para>ENTITY IfcPhysicalSimpleQuantity</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcQuantityArea</para>
	/// <para>	,IfcQuantityCount</para>
	/// <para>	,IfcQuantityLength</para>
	/// <para>	,IfcQuantityNumber</para>
	/// <para>	,IfcQuantityTime</para>
	/// <para>	,IfcQuantityVolume</para>
	/// <para>	,IfcQuantityWeight))</para>
	/// <para> SUBTYPE OF (IfcPhysicalQuantity);</para>
	/// <para>	Unit : OPTIONAL IfcNamedUnit;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPhysicalSimpleQuantity : IfcPhysicalQuantity
	{
		public IfcNamedUnit? Unit { get; set; }
		public IfcPhysicalSimpleQuantity() : base()
		{
		}
		public IfcPhysicalSimpleQuantity(IfcLabel Name, IfcText Description, IfcNamedUnit Unit) : base (Name, Description)
		{
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcPile
	/// <para>ENTITY IfcPile</para>
	/// <para> SUBTYPE OF (IfcDeepFoundation);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPileTypeEnum;</para>
	/// <para>	ConstructionType : OPTIONAL IfcPileConstructionEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcPileTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPileTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCPILETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPile : IfcDeepFoundation
	{
		public IfcPileTypeEnum? PredefinedType { get; set; }
		public IfcPileConstructionEnum? ConstructionType { get; set; }
		public IfcPile() : base()
		{
		}
		public IfcPile(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPileTypeEnum PredefinedType, IfcPileConstructionEnum ConstructionType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
			this.ConstructionType = ConstructionType;
		}
	}
	/// <summary>
	/// ENTITY IfcPileType
	/// <para>ENTITY IfcPileType</para>
	/// <para> SUBTYPE OF (IfcDeepFoundationType);</para>
	/// <para>	PredefinedType : IfcPileTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPileTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPileTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPileType : IfcDeepFoundationType
	{
		public IfcPileTypeEnum PredefinedType { get; set; }
		public IfcPileType() : base()
		{
			PredefinedType = new IfcPileTypeEnum();
		}
		public IfcPileType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPileTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeFitting
	/// <para>ENTITY IfcPipeFitting</para>
	/// <para> SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPipeFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcPipeFittingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPipeFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCPIPEFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeFitting : IfcFlowFitting
	{
		public IfcPipeFittingTypeEnum? PredefinedType { get; set; }
		public IfcPipeFitting() : base()
		{
		}
		public IfcPipeFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPipeFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeFittingType
	/// <para>ENTITY IfcPipeFittingType</para>
	/// <para> SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>	PredefinedType : IfcPipeFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPipeFittingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPipeFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeFittingType : IfcFlowFittingType
	{
		public IfcPipeFittingTypeEnum PredefinedType { get; set; }
		public IfcPipeFittingType() : base()
		{
			PredefinedType = new IfcPipeFittingTypeEnum();
		}
		public IfcPipeFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPipeFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeSegment
	/// <para>ENTITY IfcPipeSegment</para>
	/// <para> SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPipeSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcPipeSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPipeSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCPIPESEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeSegment : IfcFlowSegment
	{
		public IfcPipeSegmentTypeEnum? PredefinedType { get; set; }
		public IfcPipeSegment() : base()
		{
		}
		public IfcPipeSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPipeSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeSegmentType
	/// <para>ENTITY IfcPipeSegmentType</para>
	/// <para> SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>	PredefinedType : IfcPipeSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPipeSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPipeSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeSegmentType : IfcFlowSegmentType
	{
		public IfcPipeSegmentTypeEnum PredefinedType { get; set; }
		public IfcPipeSegmentType() : base()
		{
			PredefinedType = new IfcPipeSegmentTypeEnum();
		}
		public IfcPipeSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPipeSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPixelTexture
	/// <para>ENTITY IfcPixelTexture</para>
	/// <para> SUBTYPE OF (IfcSurfaceTexture);</para>
	/// <para>	Width : IfcInteger;</para>
	/// <para>	Height : IfcInteger;</para>
	/// <para>	ColourComponents : IfcInteger;</para>
	/// <para>	Pixel : LIST [1:?] OF IfcBinary;</para>
	/// <para> WHERE</para>
	/// <para>	MinPixelInS : Width >= 1;</para>
	/// <para>	MinPixelInT : Height >= 1;</para>
	/// <para>	NumberOfColours : {1 <= ColourComponents <= 4};</para>
	/// <para>	PixelAsByteAndSameLength : SIZEOF(QUERY(temp<* Pixel |</para>
	/// <para> (BLENGTH(temp) MOD 8 = 0) AND</para>
	/// <para> (BLENGTH(temp) = BLENGTH(Pixel[1]))</para>
	/// <para>)) = SIZEOF(Pixel);</para>
	/// <para>	SizeOfPixelList : SIZEOF(Pixel) = (Width * Height);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPixelTexture : IfcSurfaceTexture
	{
		public IfcInteger Width { get; set; }
		public IfcInteger Height { get; set; }
		public IfcInteger ColourComponents { get; set; }
		public List<IfcBinary> Pixel { get; set; }
		public IfcPixelTexture() : base()
		{
			Width = new IfcInteger();
			Height = new IfcInteger();
			ColourComponents = new IfcInteger();
			Pixel = new List<IfcBinary>();
		}
		public IfcPixelTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter, IfcInteger Width, IfcInteger Height, IfcInteger ColourComponents, List<IfcBinary> Pixel) : base (RepeatS, RepeatT, Mode, TextureTransform, Parameter)
		{
			this.Width = Width;
			this.Height = Height;
			this.ColourComponents = ColourComponents;
			this.Pixel = Pixel;
		}
	}
	/// <summary>
	/// ENTITY IfcPlacement
	/// <para>ENTITY IfcPlacement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAxis1Placement</para>
	/// <para>	,IfcAxis2Placement2D</para>
	/// <para>	,IfcAxis2Placement3D</para>
	/// <para>	,IfcAxis2PlacementLinear))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Location : IfcPoint;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := Location.Dim;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPlacement : IfcGeometricRepresentationItem
	{
		public IfcPoint Location { get; set; }
		public IfcPlacement() : base()
		{
			Location = new IfcPoint();
		}
		public IfcPlacement(IfcPoint Location) : base ()
		{
			this.Location = Location;
		}
	}
	/// <summary>
	/// ENTITY IfcPlanarBox
	/// <para>ENTITY IfcPlanarBox</para>
	/// <para> SUBTYPE OF (IfcPlanarExtent);</para>
	/// <para>	Placement : IfcAxis2Placement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlanarBox : IfcPlanarExtent
	{
		public IfcAxis2Placement Placement { get; set; }
		public IfcPlanarBox() : base()
		{
			Placement = new IfcAxis2Placement();
		}
		public IfcPlanarBox(IfcLengthMeasure SizeInX, IfcLengthMeasure SizeInY, IfcAxis2Placement Placement) : base (SizeInX, SizeInY)
		{
			this.Placement = Placement;
		}
	}
	/// <summary>
	/// ENTITY IfcPlanarExtent
	/// <para>ENTITY IfcPlanarExtent</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcPlanarBox))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	SizeInX : IfcLengthMeasure;</para>
	/// <para>	SizeInY : IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlanarExtent : IfcGeometricRepresentationItem
	{
		public IfcLengthMeasure SizeInX { get; set; }
		public IfcLengthMeasure SizeInY { get; set; }
		public IfcPlanarExtent() : base()
		{
			SizeInX = new IfcLengthMeasure();
			SizeInY = new IfcLengthMeasure();
		}
		public IfcPlanarExtent(IfcLengthMeasure SizeInX, IfcLengthMeasure SizeInY) : base ()
		{
			this.SizeInX = SizeInX;
			this.SizeInY = SizeInY;
		}
	}
	/// <summary>
	/// ENTITY IfcPlane
	/// <para>ENTITY IfcPlane</para>
	/// <para> SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlane : IfcElementarySurface
	{
		public IfcPlane() : base()
		{
		}
		public IfcPlane(IfcAxis2Placement3D Position) : base (Position)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPlate
	/// <para>ENTITY IfcPlate</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPlateTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcPlateTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPlateTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCPLATETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlate : IfcBuiltElement
	{
		public IfcPlateTypeEnum? PredefinedType { get; set; }
		public IfcPlate() : base()
		{
		}
		public IfcPlate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPlateTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPlateType
	/// <para>ENTITY IfcPlateType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcPlateTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPlateTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPlateTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlateType : IfcBuiltElementType
	{
		public IfcPlateTypeEnum PredefinedType { get; set; }
		public IfcPlateType() : base()
		{
			PredefinedType = new IfcPlateTypeEnum();
		}
		public IfcPlateType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPlateTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPoint
	/// <para>ENTITY IfcPoint</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCartesianPoint</para>
	/// <para>	,IfcPointByDistanceExpression</para>
	/// <para>	,IfcPointOnCurve</para>
	/// <para>	,IfcPointOnSurface))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := IfcPointDim(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPoint : IfcGeometricRepresentationItem, IfcGeometricSetSelect, IfcPointOrVertexPoint
	{
		public IfcPoint() : base()
		{
		}
		public IfcPoint() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPointByDistanceExpression
	/// <para>ENTITY IfcPointByDistanceExpression</para>
	/// <para> SUBTYPE OF (IfcPoint);</para>
	/// <para>	DistanceAlong : IfcCurveMeasureSelect;</para>
	/// <para>	OffsetLateral : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	OffsetVertical : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	OffsetLongitudinal : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	BasisCurve : IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPointByDistanceExpression : IfcPoint
	{
		public IfcCurveMeasureSelect DistanceAlong { get; set; }
		public IfcLengthMeasure? OffsetLateral { get; set; }
		public IfcLengthMeasure? OffsetVertical { get; set; }
		public IfcLengthMeasure? OffsetLongitudinal { get; set; }
		public IfcCurve BasisCurve { get; set; }
		public IfcPointByDistanceExpression() : base()
		{
			DistanceAlong = new IfcCurveMeasureSelect();
			BasisCurve = new IfcCurve();
		}
		public IfcPointByDistanceExpression(IfcCurveMeasureSelect DistanceAlong, IfcLengthMeasure OffsetLateral, IfcLengthMeasure OffsetVertical, IfcLengthMeasure OffsetLongitudinal, IfcCurve BasisCurve) : base ()
		{
			this.DistanceAlong = DistanceAlong;
			this.OffsetLateral = OffsetLateral;
			this.OffsetVertical = OffsetVertical;
			this.OffsetLongitudinal = OffsetLongitudinal;
			this.BasisCurve = BasisCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcPointOnCurve
	/// <para>ENTITY IfcPointOnCurve</para>
	/// <para> SUBTYPE OF (IfcPoint);</para>
	/// <para>	BasisCurve : IfcCurve;</para>
	/// <para>	PointParameter : IfcParameterValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPointOnCurve : IfcPoint
	{
		public IfcCurve BasisCurve { get; set; }
		public IfcParameterValue PointParameter { get; set; }
		public IfcPointOnCurve() : base()
		{
			BasisCurve = new IfcCurve();
			PointParameter = new IfcParameterValue();
		}
		public IfcPointOnCurve(IfcCurve BasisCurve, IfcParameterValue PointParameter) : base ()
		{
			this.BasisCurve = BasisCurve;
			this.PointParameter = PointParameter;
		}
	}
	/// <summary>
	/// ENTITY IfcPointOnSurface
	/// <para>ENTITY IfcPointOnSurface</para>
	/// <para> SUBTYPE OF (IfcPoint);</para>
	/// <para>	BasisSurface : IfcSurface;</para>
	/// <para>	PointParameterU : IfcParameterValue;</para>
	/// <para>	PointParameterV : IfcParameterValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPointOnSurface : IfcPoint
	{
		public IfcSurface BasisSurface { get; set; }
		public IfcParameterValue PointParameterU { get; set; }
		public IfcParameterValue PointParameterV { get; set; }
		public IfcPointOnSurface() : base()
		{
			BasisSurface = new IfcSurface();
			PointParameterU = new IfcParameterValue();
			PointParameterV = new IfcParameterValue();
		}
		public IfcPointOnSurface(IfcSurface BasisSurface, IfcParameterValue PointParameterU, IfcParameterValue PointParameterV) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.PointParameterU = PointParameterU;
			this.PointParameterV = PointParameterV;
		}
	}
	/// <summary>
	/// ENTITY IfcPolyLoop
	/// <para>ENTITY IfcPolyLoop</para>
	/// <para> SUBTYPE OF (IfcLoop);</para>
	/// <para>	Polygon : LIST [3:?] OF UNIQUE IfcCartesianPoint;</para>
	/// <para> WHERE</para>
	/// <para>	AllPointsSameDim : SIZEOF(QUERY(Temp <* Polygon | Temp.Dim <> Polygon[1].Dim)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolyLoop : IfcLoop
	{
		public IfcPolyLoop() : base()
		{
		}
		public IfcPolyLoop() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPolygonalBoundedHalfSpace
	/// <para>ENTITY IfcPolygonalBoundedHalfSpace</para>
	/// <para> SUBTYPE OF (IfcHalfSpaceSolid);</para>
	/// <para>	Position : IfcAxis2Placement3D;</para>
	/// <para>	PolygonalBoundary : IfcBoundedCurve;</para>
	/// <para> WHERE</para>
	/// <para>	BoundaryDim : PolygonalBoundary.Dim = 2;</para>
	/// <para>	BoundaryType : SIZEOF(TYPEOF(PolygonalBoundary) * [</para>
	/// <para>    'IFC4X3_ADD2.IFCPOLYLINE',</para>
	/// <para>    'IFC4X3_ADD2.IFCCOMPOSITECURVE',</para>
	/// <para>    'IFC4X3_ADD2.IFCINDEXEDPOLYCURVE'</para>
	/// <para>  ]) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolygonalBoundedHalfSpace : IfcHalfSpaceSolid
	{
		public IfcAxis2Placement3D Position { get; set; }
		public IfcBoundedCurve PolygonalBoundary { get; set; }
		public IfcPolygonalBoundedHalfSpace() : base()
		{
			Position = new IfcAxis2Placement3D();
			PolygonalBoundary = new IfcBoundedCurve();
		}
		public IfcPolygonalBoundedHalfSpace(IfcSurface BaseSurface, IfcBoolean AgreementFlag, IfcAxis2Placement3D Position, IfcBoundedCurve PolygonalBoundary) : base (BaseSurface, AgreementFlag)
		{
			this.Position = Position;
			this.PolygonalBoundary = PolygonalBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcPolygonalFaceSet
	/// <para>ENTITY IfcPolygonalFaceSet</para>
	/// <para> SUBTYPE OF (IfcTessellatedFaceSet);</para>
	/// <para>	Closed : OPTIONAL IfcBoolean;</para>
	/// <para>	Faces : LIST [1:?] OF UNIQUE IfcIndexedPolygonalFace;</para>
	/// <para>	PnIndex : OPTIONAL LIST [1:?] OF IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolygonalFaceSet : IfcTessellatedFaceSet
	{
		public IfcBoolean? Closed { get; set; }
		public IfcPolygonalFaceSet() : base()
		{
		}
		public IfcPolygonalFaceSet(IfcCartesianPointList3D Coordinates, IfcBoolean Closed) : base (Coordinates)
		{
			this.Closed = Closed;
		}
	}
	/// <summary>
	/// ENTITY IfcPolyline
	/// <para>ENTITY IfcPolyline</para>
	/// <para> SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>	Points : LIST [2:?] OF IfcCartesianPoint;</para>
	/// <para> WHERE</para>
	/// <para>	SameDim : SIZEOF(QUERY(Temp <* Points | Temp.Dim <> Points[1].Dim)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolyline : IfcBoundedCurve
	{
		public List<IfcCartesianPoint> Points { get; set; }
		public IfcPolyline() : base()
		{
			Points = new List<IfcCartesianPoint>();
		}
		public IfcPolyline(List<IfcCartesianPoint> Points) : base ()
		{
			this.Points = Points;
		}
	}
	/// <summary>
	/// ENTITY IfcPolynomialCurve
	/// <para>ENTITY IfcPolynomialCurve</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	Position : IfcPlacement;</para>
	/// <para>	CoefficientsX : OPTIONAL LIST [2:?] OF IfcReal;</para>
	/// <para>	CoefficientsY : OPTIONAL LIST [2:?] OF IfcReal;</para>
	/// <para>	CoefficientsZ : OPTIONAL LIST [2:?] OF IfcReal;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPositionDim : ((Position.Dim=2) AND (NOT EXISTS(CoefficientsZ))) OR (Position.Dim=3);</para>
	/// <para>	ValidCoefficients : (EXISTS(CoefficientsX) AND EXISTS(CoefficientsY)) OR (EXISTS(CoefficientsX) AND EXISTS(CoefficientsZ)) OR (EXISTS(CoefficientsY) AND EXISTS(CoefficientsZ)) OR (EXISTS(CoefficientsX) AND EXISTS(CoefficientsY) AND EXISTS(CoefficientsZ));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolynomialCurve : IfcCurve
	{
		public IfcPlacement Position { get; set; }
		public List<IfcReal>? CoefficientsX { get; set; }
		public List<IfcReal>? CoefficientsY { get; set; }
		public List<IfcReal>? CoefficientsZ { get; set; }
		public IfcPolynomialCurve() : base()
		{
			Position = new IfcPlacement();
		}
		public IfcPolynomialCurve(IfcPlacement Position, List<IfcReal> CoefficientsX, List<IfcReal> CoefficientsY, List<IfcReal> CoefficientsZ) : base ()
		{
			this.Position = Position;
			this.CoefficientsX = CoefficientsX;
			this.CoefficientsY = CoefficientsY;
			this.CoefficientsZ = CoefficientsZ;
		}
	}
	/// <summary>
	/// ENTITY IfcPort
	/// <para>ENTITY IfcPort</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDistributionPort))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para> INVERSE</para>
	/// <para>	ContainedIn : SET [0:1] OF IfcRelConnectsPortToElement FOR RelatingPort;</para>
	/// <para>	ConnectedFrom : SET [0:1] OF IfcRelConnectsPorts FOR RelatedPort;</para>
	/// <para>	ConnectedTo : SET [0:1] OF IfcRelConnectsPorts FOR RelatingPort;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPort : IfcProduct
	{
		public IfcPort() : base()
		{
		}
		public IfcPort(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPositioningElement
	/// <para>ENTITY IfcPositioningElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcGrid</para>
	/// <para>	,IfcLinearPositioningElement</para>
	/// <para>	,IfcReferent))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para> INVERSE</para>
	/// <para>	ContainedInStructure : SET [0:1] OF IfcRelContainedInSpatialStructure FOR RelatedElements;</para>
	/// <para>	Positions : SET [0:?] OF IfcRelPositions FOR RelatingPositioningElement;</para>
	/// <para> WHERE</para>
	/// <para>	HasPlacement : EXISTS(SELF\IfcProduct.ObjectPlacement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPositioningElement : IfcProduct
	{
		public IfcPositioningElement() : base()
		{
		}
		public IfcPositioningElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPostalAddress
	/// <para>ENTITY IfcPostalAddress</para>
	/// <para> SUBTYPE OF (IfcAddress);</para>
	/// <para>	InternalLocation : OPTIONAL IfcLabel;</para>
	/// <para>	AddressLines : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	PostalBox : OPTIONAL IfcLabel;</para>
	/// <para>	Town : OPTIONAL IfcLabel;</para>
	/// <para>	Region : OPTIONAL IfcLabel;</para>
	/// <para>	PostalCode : OPTIONAL IfcLabel;</para>
	/// <para>	Country : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : EXISTS (InternalLocation) OR </para>
	/// <para>EXISTS (AddressLines) OR</para>
	/// <para>EXISTS (PostalBox) OR</para>
	/// <para>EXISTS (PostalCode) OR</para>
	/// <para>EXISTS (Town) OR </para>
	/// <para>EXISTS (Region) OR  </para>
	/// <para>EXISTS (Country);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPostalAddress : IfcAddress
	{
		public IfcLabel? InternalLocation { get; set; }
		public List<IfcLabel>? AddressLines { get; set; }
		public IfcLabel? PostalBox { get; set; }
		public IfcLabel? Town { get; set; }
		public IfcLabel? Region { get; set; }
		public IfcLabel? PostalCode { get; set; }
		public IfcLabel? Country { get; set; }
		public IfcPostalAddress() : base()
		{
		}
		public IfcPostalAddress(IfcAddressTypeEnum Purpose, IfcText Description, IfcLabel UserDefinedPurpose, IfcLabel InternalLocation, List<IfcLabel> AddressLines, IfcLabel PostalBox, IfcLabel Town, IfcLabel Region, IfcLabel PostalCode, IfcLabel Country) : base (Purpose, Description, UserDefinedPurpose)
		{
			this.InternalLocation = InternalLocation;
			this.AddressLines = AddressLines;
			this.PostalBox = PostalBox;
			this.Town = Town;
			this.Region = Region;
			this.PostalCode = PostalCode;
			this.Country = Country;
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedColour
	/// <para>ENTITY IfcPreDefinedColour</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDraughtingPreDefinedColour))</para>
	/// <para> SUBTYPE OF (IfcPreDefinedItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedColour : IfcPreDefinedItem, IfcColour
	{
		public IfcPreDefinedColour() : base()
		{
		}
		public IfcPreDefinedColour(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedCurveFont
	/// <para>ENTITY IfcPreDefinedCurveFont</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDraughtingPreDefinedCurveFont))</para>
	/// <para> SUBTYPE OF (IfcPreDefinedItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedCurveFont : IfcPreDefinedItem, IfcCurveStyleFontSelect
	{
		public IfcPreDefinedCurveFont() : base()
		{
		}
		public IfcPreDefinedCurveFont(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedItem
	/// <para>ENTITY IfcPreDefinedItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcPreDefinedColour</para>
	/// <para>	,IfcPreDefinedCurveFont</para>
	/// <para>	,IfcPreDefinedTextFont))</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedItem : IfcPresentationItem
	{
		public IfcLabel Name { get; set; }
		public IfcPreDefinedItem() : base()
		{
			Name = new IfcLabel();
		}
		public IfcPreDefinedItem(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedProperties
	/// <para>ENTITY IfcPreDefinedProperties</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcReinforcementBarProperties</para>
	/// <para>	,IfcSectionProperties</para>
	/// <para>	,IfcSectionReinforcementProperties))</para>
	/// <para> SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedProperties : IfcPropertyAbstraction
	{
		public IfcPreDefinedProperties() : base()
		{
		}
		public IfcPreDefinedProperties() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedPropertySet
	/// <para>ENTITY IfcPreDefinedPropertySet</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDoorLiningProperties</para>
	/// <para>	,IfcDoorPanelProperties</para>
	/// <para>	,IfcPermeableCoveringProperties</para>
	/// <para>	,IfcReinforcementDefinitionProperties</para>
	/// <para>	,IfcWindowLiningProperties</para>
	/// <para>	,IfcWindowPanelProperties))</para>
	/// <para> SUBTYPE OF (IfcPropertySetDefinition);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedPropertySet : IfcPropertySetDefinition
	{
		public IfcPreDefinedPropertySet() : base()
		{
		}
		public IfcPreDefinedPropertySet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedTextFont
	/// <para>ENTITY IfcPreDefinedTextFont</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcTextStyleFontModel))</para>
	/// <para> SUBTYPE OF (IfcPreDefinedItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedTextFont : IfcPreDefinedItem, IfcTextFontSelect
	{
		public IfcPreDefinedTextFont() : base()
		{
		}
		public IfcPreDefinedTextFont(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationItem
	/// <para>ENTITY IfcPresentationItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcColourRgbList</para>
	/// <para>	,IfcColourSpecification</para>
	/// <para>	,IfcCurveStyleFont</para>
	/// <para>	,IfcCurveStyleFontAndScaling</para>
	/// <para>	,IfcCurveStyleFontPattern</para>
	/// <para>	,IfcIndexedColourMap</para>
	/// <para>	,IfcPreDefinedItem</para>
	/// <para>	,IfcSurfaceStyleLighting</para>
	/// <para>	,IfcSurfaceStyleRefraction</para>
	/// <para>	,IfcSurfaceStyleShading</para>
	/// <para>	,IfcSurfaceStyleWithTextures</para>
	/// <para>	,IfcSurfaceTexture</para>
	/// <para>	,IfcTextStyleForDefinedFont</para>
	/// <para>	,IfcTextStyleTextModel</para>
	/// <para>	,IfcTextureCoordinate</para>
	/// <para>	,IfcTextureVertex</para>
	/// <para>	,IfcTextureVertexList));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPresentationItemENTITY
	{
		public IfcPresentationItem() : base()
		{
		}
		public IfcPresentationItem() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationLayerAssignment
	/// <para>ENTITY IfcPresentationLayerAssignment</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcPresentationLayerWithStyle));</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	AssignedItems : SET [1:?] OF IfcLayeredItem;</para>
	/// <para>	Identifier : OPTIONAL IfcIdentifier;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableItems : SIZEOF(QUERY(temp <* AssignedItems | (</para>
	/// <para>  SIZEOF(TYPEOF(temp) * [</para>
	/// <para>    'IFC4X3_ADD2.IFCSHAPEREPRESENTATION',</para>
	/// <para>    'IFC4X3_ADD2.IFCGEOMETRICREPRESENTATIONITEM',</para>
	/// <para>    'IFC4X3_ADD2.IFCMAPPEDITEM']) = 1)</para>
	/// <para>)) = SIZEOF(AssignedItems);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPresentationLayerAssignmentENTITY
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcLayeredItem> AssignedItems { get; set; }
		public IfcIdentifier? Identifier { get; set; }
		public IfcPresentationLayerAssignment() : base()
		{
			Name = new IfcLabel();
			AssignedItems = new List<IfcLayeredItem>();
		}
		public IfcPresentationLayerAssignment(IfcLabel Name, IfcText Description, List<IfcLayeredItem> AssignedItems, IfcIdentifier Identifier) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.AssignedItems = AssignedItems;
			this.Identifier = Identifier;
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationLayerWithStyle
	/// <para>ENTITY IfcPresentationLayerWithStyle</para>
	/// <para> SUBTYPE OF (IfcPresentationLayerAssignment);</para>
	/// <para>	LayerOn : IfcLogical;</para>
	/// <para>	LayerFrozen : IfcLogical;</para>
	/// <para>	LayerBlocked : IfcLogical;</para>
	/// <para>	LayerStyles : SET [0:?] OF IfcPresentationStyle;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableOnlyToItems : SIZEOF(QUERY(temp <* AssignedItems | (SIZEOF(TYPEOF(temp) * ['IFC4X3_ADD2.IfcGeometricRepresentationItem','IFC4X3_ADD2.IfcMappedItem']) >= 1))) = SIZEOF(AssignedItems);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPresentationLayerWithStyle : IfcPresentationLayerAssignment
	{
		public IfcLogical LayerOn { get; set; }
		public IfcLogical LayerFrozen { get; set; }
		public IfcLogical LayerBlocked { get; set; }
		public List<IfcPresentationStyle> LayerStyles { get; set; }
		public IfcPresentationLayerWithStyle() : base()
		{
			LayerOn = new IfcLogical();
			LayerFrozen = new IfcLogical();
			LayerBlocked = new IfcLogical();
			LayerStyles = new List<IfcPresentationStyle>();
		}
		public IfcPresentationLayerWithStyle(IfcLabel Name, IfcText Description, List<IfcLayeredItem> AssignedItems, IfcIdentifier Identifier, IfcLogical LayerOn, IfcLogical LayerFrozen, IfcLogical LayerBlocked, List<IfcPresentationStyle> LayerStyles) : base (Name, Description, AssignedItems, Identifier)
		{
			this.LayerOn = LayerOn;
			this.LayerFrozen = LayerFrozen;
			this.LayerBlocked = LayerBlocked;
			this.LayerStyles = LayerStyles;
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationStyle
	/// <para>ENTITY IfcPresentationStyle</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCurveStyle</para>
	/// <para>	,IfcFillAreaStyle</para>
	/// <para>	,IfcSurfaceStyle</para>
	/// <para>	,IfcTextStyle));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPresentationStyleENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcPresentationStyle() : base()
		{
		}
		public IfcPresentationStyle(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcProcedure
	/// <para>ENTITY IfcProcedure</para>
	/// <para> SUBTYPE OF (IfcProcess);</para>
	/// <para>	PredefinedType : OPTIONAL IfcProcedureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcProcedureTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcProcedureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>	HasName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProcedure : IfcProcess
	{
		public IfcProcedureTypeEnum? PredefinedType { get; set; }
		public IfcProcedure() : base()
		{
		}
		public IfcProcedure(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcProcedureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProcedureType
	/// <para>ENTITY IfcProcedureType</para>
	/// <para> SUBTYPE OF (IfcTypeProcess);</para>
	/// <para>	PredefinedType : IfcProcedureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcProcedureTypeEnum.USERDEFINED) OR ((PredefinedType = IfcProcedureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProcedureType : IfcTypeProcess
	{
		public IfcProcedureTypeEnum PredefinedType { get; set; }
		public IfcProcedureType() : base()
		{
			PredefinedType = new IfcProcedureTypeEnum();
		}
		public IfcProcedureType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType, IfcProcedureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProcess
	/// <para>ENTITY IfcProcess</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcEvent</para>
	/// <para>	,IfcProcedure</para>
	/// <para>	,IfcTask))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	IsPredecessorTo : SET [0:?] OF IfcRelSequence FOR RelatingProcess;</para>
	/// <para>	IsSuccessorFrom : SET [0:?] OF IfcRelSequence FOR RelatedProcess;</para>
	/// <para>	OperatesOn : SET [0:?] OF IfcRelAssignsToProcess FOR RelatingProcess;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProcess : IfcObject, IfcProcessSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcProcess() : base()
		{
		}
		public IfcProcess(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcProduct
	/// <para>ENTITY IfcProduct</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcAnnotation</para>
	/// <para>	,IfcElement</para>
	/// <para>	,IfcLinearElement</para>
	/// <para>	,IfcPort</para>
	/// <para>	,IfcPositioningElement</para>
	/// <para>	,IfcSpatialElement</para>
	/// <para>	,IfcStructuralActivity</para>
	/// <para>	,IfcStructuralItem))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para>	ObjectPlacement : OPTIONAL IfcObjectPlacement;</para>
	/// <para>	Representation : OPTIONAL IfcProductRepresentation;</para>
	/// <para> INVERSE</para>
	/// <para>	ReferencedBy : SET [0:?] OF IfcRelAssignsToProduct FOR RelatingProduct;</para>
	/// <para>	PositionedRelativeTo : SET [0:?] OF IfcRelPositions FOR RelatedProducts;</para>
	/// <para>	ReferencedInStructures : SET [0:?] OF IfcRelReferencedInSpatialStructure FOR RelatedElements;</para>
	/// <para> WHERE</para>
	/// <para>	PlacementForShapeRepresentation : (EXISTS(Representation) AND EXISTS(ObjectPlacement))</para>
	/// <para>            OR (EXISTS(Representation) AND </para>
	/// <para>      (SIZEOF(QUERY(temp <* Representation.Representations | 'IFC4X3_ADD2.IFCSHAPEREPRESENTATION' IN TYPEOF(temp))) = 0))</para>
	/// <para>            OR (NOT(EXISTS(Representation)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProduct : IfcObject, IfcProductSelect, IfcSpatialReferenceSelect
	{
		public IfcObjectPlacement? ObjectPlacement { get; set; }
		public IfcProductRepresentation? Representation { get; set; }
		public IfcProduct() : base()
		{
		}
		public IfcProduct(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.ObjectPlacement = ObjectPlacement;
			this.Representation = Representation;
		}
	}
	/// <summary>
	/// ENTITY IfcProductDefinitionShape
	/// <para>ENTITY IfcProductDefinitionShape</para>
	/// <para> SUBTYPE OF (IfcProductRepresentation);</para>
	/// <para> INVERSE</para>
	/// <para>	ShapeOfProduct : SET [1:?] OF IfcProduct FOR Representation;</para>
	/// <para>	HasShapeAspects : SET [0:?] OF IfcShapeAspect FOR PartOfProductDefinitionShape;</para>
	/// <para> WHERE</para>
	/// <para>	OnlyShapeModel : SIZEOF(QUERY(temp <* Representations | </para>
	/// <para>  (NOT('IFC4X3_ADD2.IFCSHAPEMODEL' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProductDefinitionShape : IfcProductRepresentation, IfcProductRepresentationSelect
	{
		public IfcProductDefinitionShape() : base()
		{
		}
		public IfcProductDefinitionShape(IfcLabel Name, IfcText Description, List<IfcRepresentation> Representations) : base (Name, Description, Representations)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProductRepresentation
	/// <para>ENTITY IfcProductRepresentation</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcMaterialDefinitionRepresentation</para>
	/// <para>	,IfcProductDefinitionShape));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Representations : LIST [1:?] OF IfcRepresentation;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProductRepresentationENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcRepresentation> Representations { get; set; }
		public IfcProductRepresentation() : base()
		{
			Representations = new List<IfcRepresentation>();
		}
		public IfcProductRepresentation(IfcLabel Name, IfcText Description, List<IfcRepresentation> Representations) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Representations = Representations;
		}
	}
	/// <summary>
	/// ENTITY IfcProfileDef
	/// <para>ENTITY IfcProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcArbitraryClosedProfileDef</para>
	/// <para>	,IfcArbitraryOpenProfileDef</para>
	/// <para>	,IfcCompositeProfileDef</para>
	/// <para>	,IfcDerivedProfileDef</para>
	/// <para>	,IfcOpenCrossProfileDef</para>
	/// <para>	,IfcParameterizedProfileDef));</para>
	/// <para>	ProfileType : IfcProfileTypeEnum;</para>
	/// <para>	ProfileName : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>	HasProperties : SET [0:?] OF IfcProfileProperties FOR ProfileDefinition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProfileDefENTITY, IfcResourceObjectSelect
	{
		public IfcProfileTypeEnum ProfileType { get; set; }
		public IfcLabel? ProfileName { get; set; }
		public IfcProfileDef() : base()
		{
			ProfileType = new IfcProfileTypeEnum();
		}
		public IfcProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName) : base ()
		{
			this.ProfileType = ProfileType;
			this.ProfileName = ProfileName;
		}
	}
	/// <summary>
	/// ENTITY IfcProfileProperties
	/// <para>ENTITY IfcProfileProperties</para>
	/// <para> SUBTYPE OF (IfcExtendedProperties);</para>
	/// <para>	ProfileDefinition : IfcProfileDef;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProfileProperties : IfcExtendedProperties
	{
		public IfcProfileDef ProfileDefinition { get; set; }
		public IfcProfileProperties() : base()
		{
			ProfileDefinition = new IfcProfileDef();
		}
		public IfcProfileProperties(IfcIdentifier Name, IfcText Description, List<IfcProperty> Properties, IfcProfileDef ProfileDefinition) : base (Name, Description, Properties)
		{
			this.ProfileDefinition = ProfileDefinition;
		}
	}
	/// <summary>
	/// ENTITY IfcProject
	/// <para>ENTITY IfcProject</para>
	/// <para> SUBTYPE OF (IfcContext);</para>
	/// <para> WHERE</para>
	/// <para>	CorrectContext : NOT(EXISTS(SELF\IfcContext.RepresentationContexts)) OR</para>
	/// <para>(SIZEOF(QUERY(Temp <* SELF\IfcContext.RepresentationContexts |</para>
	/// <para> 'IFC4X3_ADD2.IFCGEOMETRICREPRESENTATIONSUBCONTEXT' IN TYPEOF(Temp)</para>
	/// <para>  )) = 0);</para>
	/// <para>	HasName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	NoDecomposition : SIZEOF(SELF\IfcObjectDefinition.Decomposes) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProject : IfcContext
	{
		public IfcProject() : base()
		{
		}
		public IfcProject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcLabel Phase, List<IfcRepresentationContext> RepresentationContexts, IfcUnitAssignment UnitsInContext) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProjectLibrary
	/// <para>ENTITY IfcProjectLibrary</para>
	/// <para> SUBTYPE OF (IfcContext);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectLibrary : IfcContext
	{
		public IfcProjectLibrary() : base()
		{
		}
		public IfcProjectLibrary(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcLabel Phase, List<IfcRepresentationContext> RepresentationContexts, IfcUnitAssignment UnitsInContext) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProjectOrder
	/// <para>ENTITY IfcProjectOrder</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcProjectOrderTypeEnum;</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectOrder : IfcControl
	{
		public IfcProjectOrderTypeEnum? PredefinedType { get; set; }
		public IfcLabel? Status { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcProjectOrder() : base()
		{
		}
		public IfcProjectOrder(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcProjectOrderTypeEnum PredefinedType, IfcLabel Status, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcProjectedCRS
	/// <para>ENTITY IfcProjectedCRS</para>
	/// <para> SUBTYPE OF (IfcCoordinateReferenceSystem);</para>
	/// <para>	VerticalDatum : OPTIONAL IfcIdentifier;</para>
	/// <para>	MapProjection : OPTIONAL IfcIdentifier;</para>
	/// <para>	MapZone : OPTIONAL IfcIdentifier;</para>
	/// <para>	MapUnit : OPTIONAL IfcNamedUnit;</para>
	/// <para> WHERE</para>
	/// <para>	MapUnitIsLength : NOT(EXISTS(SELF.MapUnit)) OR (SELF.MapUnit.UnitType = IfcUnitEnum.LENGTHUNIT);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectedCRS : IfcCoordinateReferenceSystem
	{
		public IfcIdentifier? VerticalDatum { get; set; }
		public IfcIdentifier? MapProjection { get; set; }
		public IfcIdentifier? MapZone { get; set; }
		public IfcNamedUnit? MapUnit { get; set; }
		public IfcProjectedCRS() : base()
		{
		}
		public IfcProjectedCRS(IfcLabel Name, IfcText Description, IfcIdentifier GeodeticDatum, IfcIdentifier VerticalDatum, IfcIdentifier MapProjection, IfcIdentifier MapZone, IfcNamedUnit MapUnit) : base (Name, Description, GeodeticDatum)
		{
			this.VerticalDatum = VerticalDatum;
			this.MapProjection = MapProjection;
			this.MapZone = MapZone;
			this.MapUnit = MapUnit;
		}
	}
	/// <summary>
	/// ENTITY IfcProjectionElement
	/// <para>ENTITY IfcProjectionElement</para>
	/// <para> SUBTYPE OF (IfcFeatureElementAddition);</para>
	/// <para>	PredefinedType : OPTIONAL IfcProjectionElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcProjectionElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcProjectionElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectionElement : IfcFeatureElementAddition
	{
		public IfcProjectionElementTypeEnum? PredefinedType { get; set; }
		public IfcProjectionElement() : base()
		{
		}
		public IfcProjectionElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcProjectionElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProperty
	/// <para>ENTITY IfcProperty</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcComplexProperty</para>
	/// <para>	,IfcSimpleProperty))</para>
	/// <para> SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>	Name : IfcIdentifier;</para>
	/// <para>	Specification : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	PartOfPset : SET [0:?] OF IfcPropertySet FOR HasProperties;</para>
	/// <para>	PropertyForDependance : SET [0:?] OF IfcPropertyDependencyRelationship FOR DependingProperty;</para>
	/// <para>	PropertyDependsOn : SET [0:?] OF IfcPropertyDependencyRelationship FOR DependantProperty;</para>
	/// <para>	PartOfComplex : SET [0:?] OF IfcComplexProperty FOR HasProperties;</para>
	/// <para>	HasConstraints : SET [0:?] OF IfcResourceConstraintRelationship FOR RelatedResourceObjects;</para>
	/// <para>	HasApprovals : SET [0:?] OF IfcResourceApprovalRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProperty : IfcPropertyAbstraction
	{
		public IfcIdentifier Name { get; set; }
		public IfcText? Specification { get; set; }
		public IfcProperty() : base()
		{
			Name = new IfcIdentifier();
		}
		public IfcProperty(IfcIdentifier Name, IfcText Specification) : base ()
		{
			this.Name = Name;
			this.Specification = Specification;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyAbstraction
	/// <para>ENTITY IfcPropertyAbstraction</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcExtendedProperties</para>
	/// <para>	,IfcPreDefinedProperties</para>
	/// <para>	,IfcProperty</para>
	/// <para>	,IfcPropertyEnumeration));</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyAbstractionENTITY, IfcResourceObjectSelect
	{
		public IfcPropertyAbstraction() : base()
		{
		}
		public IfcPropertyAbstraction() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyBoundedValue
	/// <para>ENTITY IfcPropertyBoundedValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	UpperBoundValue : OPTIONAL IfcValue;</para>
	/// <para>	LowerBoundValue : OPTIONAL IfcValue;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para>	SetPointValue : OPTIONAL IfcValue;</para>
	/// <para> WHERE</para>
	/// <para>	SameUnitLowerSet : NOT(EXISTS(LowerBoundValue)) OR NOT(EXISTS(SetPointValue)) OR</para>
	/// <para>(TYPEOF(LowerBoundValue) = TYPEOF(SetPointValue));</para>
	/// <para>	SameUnitUpperLower : NOT(EXISTS(UpperBoundValue)) OR NOT(EXISTS(LowerBoundValue)) OR</para>
	/// <para>(TYPEOF(UpperBoundValue) = TYPEOF(LowerBoundValue));</para>
	/// <para>	SameUnitUpperSet : NOT(EXISTS(UpperBoundValue)) OR NOT(EXISTS(SetPointValue)) OR</para>
	/// <para>(TYPEOF(UpperBoundValue) = TYPEOF(SetPointValue));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyBoundedValue : IfcSimpleProperty
	{
		public IfcValue? UpperBoundValue { get; set; }
		public IfcValue? LowerBoundValue { get; set; }
		public IfcUnit? Unit { get; set; }
		public IfcValue? SetPointValue { get; set; }
		public IfcPropertyBoundedValue() : base()
		{
		}
		public IfcPropertyBoundedValue(IfcIdentifier Name, IfcText Specification, IfcValue UpperBoundValue, IfcValue LowerBoundValue, IfcUnit Unit, IfcValue SetPointValue) : base (Name, Specification)
		{
			this.UpperBoundValue = UpperBoundValue;
			this.LowerBoundValue = LowerBoundValue;
			this.Unit = Unit;
			this.SetPointValue = SetPointValue;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyDefinition
	/// <para>ENTITY IfcPropertyDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcPropertySetDefinition</para>
	/// <para>	,IfcPropertyTemplateDefinition))</para>
	/// <para> SUBTYPE OF (IfcRoot);</para>
	/// <para> INVERSE</para>
	/// <para>	HasContext : SET [0:1] OF IfcRelDeclares FOR RelatedDefinitions;</para>
	/// <para>	HasAssociations : SET [0:?] OF IfcRelAssociates FOR RelatedObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyDefinition : IfcRoot, IfcDefinitionSelect
	{
		public IfcPropertyDefinition() : base()
		{
		}
		public IfcPropertyDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyDependencyRelationship
	/// <para>ENTITY IfcPropertyDependencyRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	DependingProperty : IfcProperty;</para>
	/// <para>	DependantProperty : IfcProperty;</para>
	/// <para>	Expression : OPTIONAL IfcText;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : DependingProperty :<>: DependantProperty;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyDependencyRelationship : IfcResourceLevelRelationship
	{
		public IfcProperty DependingProperty { get; set; }
		public IfcProperty DependantProperty { get; set; }
		public IfcText? Expression { get; set; }
		public IfcPropertyDependencyRelationship() : base()
		{
			DependingProperty = new IfcProperty();
			DependantProperty = new IfcProperty();
		}
		public IfcPropertyDependencyRelationship(IfcLabel Name, IfcText Description, IfcProperty DependingProperty, IfcProperty DependantProperty, IfcText Expression) : base (Name, Description)
		{
			this.DependingProperty = DependingProperty;
			this.DependantProperty = DependantProperty;
			this.Expression = Expression;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyEnumeratedValue
	/// <para>ENTITY IfcPropertyEnumeratedValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	EnumerationValues : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>	EnumerationReference : OPTIONAL IfcPropertyEnumeration;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(EnumerationReference)) </para>
	/// <para>OR  NOT(EXISTS(EnumerationValues)) </para>
	/// <para>OR  (SIZEOF(QUERY(temp <* EnumerationValues |</para>
	/// <para>    temp IN EnumerationReference.EnumerationValues))</para>
	/// <para>    = SIZEOF(EnumerationValues));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyEnumeratedValue : IfcSimpleProperty
	{
		public List<IfcValue>? EnumerationValues { get; set; }
		public IfcPropertyEnumeration? EnumerationReference { get; set; }
		public IfcPropertyEnumeratedValue() : base()
		{
		}
		public IfcPropertyEnumeratedValue(IfcIdentifier Name, IfcText Specification, List<IfcValue> EnumerationValues, IfcPropertyEnumeration EnumerationReference) : base (Name, Specification)
		{
			this.EnumerationValues = EnumerationValues;
			this.EnumerationReference = EnumerationReference;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyEnumeration
	/// <para>ENTITY IfcPropertyEnumeration</para>
	/// <para> SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	EnumerationValues : LIST [1:?] OF UNIQUE IfcValue;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para> UNIQUE</para>
	/// <para>	UR1 : Name;</para>
	/// <para> WHERE</para>
	/// <para>	WR01 : SIZEOF(QUERY(temp <* SELF.EnumerationValues | </para>
	/// <para>  NOT(TYPEOF(SELF.EnumerationValues[1]) = TYPEOF(temp))</para>
	/// <para>  )) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyEnumeration : IfcPropertyAbstraction
	{
		public IfcLabel Name { get; set; }
		public IfcPropertyEnumeration() : base()
		{
			Name = new IfcLabel();
		}
		public IfcPropertyEnumeration(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyListValue
	/// <para>ENTITY IfcPropertyListValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	ListValues : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : SIZEOF(QUERY(temp <* SELF.ListValues | </para>
	/// <para>  NOT(TYPEOF(SELF.ListValues[1]) = TYPEOF(temp))</para>
	/// <para>  )) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyListValue : IfcSimpleProperty
	{
		public List<IfcValue>? ListValues { get; set; }
		public IfcUnit? Unit { get; set; }
		public IfcPropertyListValue() : base()
		{
		}
		public IfcPropertyListValue(IfcIdentifier Name, IfcText Specification, List<IfcValue> ListValues, IfcUnit Unit) : base (Name, Specification)
		{
			this.ListValues = ListValues;
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyReferenceValue
	/// <para>ENTITY IfcPropertyReferenceValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	UsageName : OPTIONAL IfcText;</para>
	/// <para>	PropertyReference : OPTIONAL IfcObjectReferenceSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyReferenceValue : IfcSimpleProperty
	{
		public IfcText? UsageName { get; set; }
		public IfcObjectReferenceSelect? PropertyReference { get; set; }
		public IfcPropertyReferenceValue() : base()
		{
		}
		public IfcPropertyReferenceValue(IfcIdentifier Name, IfcText Specification, IfcText UsageName, IfcObjectReferenceSelect PropertyReference) : base (Name, Specification)
		{
			this.UsageName = UsageName;
			this.PropertyReference = PropertyReference;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySet
	/// <para>ENTITY IfcPropertySet</para>
	/// <para> SUBTYPE OF (IfcPropertySetDefinition);</para>
	/// <para>	HasProperties : SET [1:?] OF IfcProperty;</para>
	/// <para> WHERE</para>
	/// <para>	ExistsName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	UniquePropertyNames : IfcUniquePropertyName(HasProperties);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertySet : IfcPropertySetDefinition
	{
		public List<IfcProperty> HasProperties { get; set; }
		public IfcPropertySet() : base()
		{
			HasProperties = new List<IfcProperty>();
		}
		public IfcPropertySet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcProperty> HasProperties) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.HasProperties = HasProperties;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySetDefinition
	/// <para>ENTITY IfcPropertySetDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcPreDefinedPropertySet</para>
	/// <para>	,IfcPropertySet</para>
	/// <para>	,IfcQuantitySet))</para>
	/// <para> SUBTYPE OF (IfcPropertyDefinition);</para>
	/// <para> INVERSE</para>
	/// <para>	DefinesType : SET [0:?] OF IfcTypeObject FOR HasPropertySets;</para>
	/// <para>	IsDefinedBy : SET [0:?] OF IfcRelDefinesByTemplate FOR RelatedPropertySets;</para>
	/// <para>	DefinesOccurrence : SET [0:?] OF IfcRelDefinesByProperties FOR RelatingPropertyDefinition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertySetDefinition : IfcPropertyDefinition, IfcPropertySetDefinitionSelect
	{
		public IfcPropertySetDefinition() : base()
		{
		}
		public IfcPropertySetDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySetTemplate
	/// <para>ENTITY IfcPropertySetTemplate</para>
	/// <para> SUBTYPE OF (IfcPropertyTemplateDefinition);</para>
	/// <para>	TemplateType : OPTIONAL IfcPropertySetTemplateTypeEnum;</para>
	/// <para>	ApplicableEntity : OPTIONAL IfcIdentifier;</para>
	/// <para>	HasPropertyTemplates : SET [1:?] OF IfcPropertyTemplate;</para>
	/// <para> INVERSE</para>
	/// <para>	Defines : SET [0:?] OF IfcRelDefinesByTemplate FOR RelatingTemplate;</para>
	/// <para> WHERE</para>
	/// <para>	ExistsName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	UniquePropertyNames : IfcUniquePropertyTemplateNames(HasPropertyTemplates);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertySetTemplate : IfcPropertyTemplateDefinition
	{
		public IfcPropertySetTemplateTypeEnum? TemplateType { get; set; }
		public IfcIdentifier? ApplicableEntity { get; set; }
		public List<IfcPropertyTemplate> HasPropertyTemplates { get; set; }
		public IfcPropertySetTemplate() : base()
		{
			HasPropertyTemplates = new List<IfcPropertyTemplate>();
		}
		public IfcPropertySetTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPropertySetTemplateTypeEnum TemplateType, IfcIdentifier ApplicableEntity, List<IfcPropertyTemplate> HasPropertyTemplates) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.TemplateType = TemplateType;
			this.ApplicableEntity = ApplicableEntity;
			this.HasPropertyTemplates = HasPropertyTemplates;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySingleValue
	/// <para>ENTITY IfcPropertySingleValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	NominalValue : OPTIONAL IfcValue;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertySingleValue : IfcSimpleProperty
	{
		public IfcValue? NominalValue { get; set; }
		public IfcUnit? Unit { get; set; }
		public IfcPropertySingleValue() : base()
		{
		}
		public IfcPropertySingleValue(IfcIdentifier Name, IfcText Specification, IfcValue NominalValue, IfcUnit Unit) : base (Name, Specification)
		{
			this.NominalValue = NominalValue;
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyTableValue
	/// <para>ENTITY IfcPropertyTableValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	DefiningValues : OPTIONAL LIST [1:?] OF UNIQUE IfcValue;</para>
	/// <para>	DefinedValues : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>	Expression : OPTIONAL IfcText;</para>
	/// <para>	DefiningUnit : OPTIONAL IfcUnit;</para>
	/// <para>	DefinedUnit : OPTIONAL IfcUnit;</para>
	/// <para>	CurveInterpolation : OPTIONAL IfcCurveInterpolationEnum;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : (NOT(EXISTS(DefiningValues)) AND NOT(EXISTS(DefinedValues)))</para>
	/// <para>OR (SIZEOF(DefiningValues) = SIZEOF(DefinedValues));</para>
	/// <para>	WR22 : NOT(EXISTS(DefiningValues)) OR </para>
	/// <para>(SIZEOF(QUERY(temp <* SELF.DefiningValues | TYPEOF(temp) <> TYPEOF(SELF.DefiningValues[1])</para>
	/// <para>)) = 0);</para>
	/// <para>	WR23 : NOT(EXISTS(DefinedValues)) OR </para>
	/// <para>(SIZEOF(QUERY(temp <* SELF.DefinedValues | TYPEOF(temp) <> TYPEOF(SELF.DefinedValues[1])</para>
	/// <para>)) = 0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyTableValue : IfcSimpleProperty
	{
		public IfcPropertyTableValue() : base()
		{
		}
		public IfcPropertyTableValue(IfcIdentifier Name, IfcText Specification) : base (Name, Specification)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyTemplate
	/// <para>ENTITY IfcPropertyTemplate</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcComplexPropertyTemplate</para>
	/// <para>	,IfcSimplePropertyTemplate))</para>
	/// <para> SUBTYPE OF (IfcPropertyTemplateDefinition);</para>
	/// <para> INVERSE</para>
	/// <para>	PartOfComplexTemplate : SET [0:?] OF IfcComplexPropertyTemplate FOR HasPropertyTemplates;</para>
	/// <para>	PartOfPsetTemplate : SET [0:?] OF IfcPropertySetTemplate FOR HasPropertyTemplates;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyTemplate : IfcPropertyTemplateDefinition
	{
		public IfcPropertyTemplate() : base()
		{
		}
		public IfcPropertyTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyTemplateDefinition
	/// <para>ENTITY IfcPropertyTemplateDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcPropertySetTemplate</para>
	/// <para>	,IfcPropertyTemplate))</para>
	/// <para> SUBTYPE OF (IfcPropertyDefinition);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyTemplateDefinition : IfcPropertyDefinition
	{
		public IfcPropertyTemplateDefinition() : base()
		{
		}
		public IfcPropertyTemplateDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDevice
	/// <para>ENTITY IfcProtectiveDevice</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcProtectiveDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcProtectiveDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcProtectiveDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCPROTECTIVEDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDevice : IfcFlowController
	{
		public IfcProtectiveDeviceTypeEnum? PredefinedType { get; set; }
		public IfcProtectiveDevice() : base()
		{
		}
		public IfcProtectiveDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcProtectiveDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDeviceTrippingUnit
	/// <para>ENTITY IfcProtectiveDeviceTrippingUnit</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcProtectiveDeviceTrippingUnitTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCPROTECTIVEDEVICETRIPPINGUNITTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDeviceTrippingUnit : IfcDistributionControlElement
	{
		public IfcProtectiveDeviceTrippingUnitTypeEnum? PredefinedType { get; set; }
		public IfcProtectiveDeviceTrippingUnit() : base()
		{
		}
		public IfcProtectiveDeviceTrippingUnit(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcProtectiveDeviceTrippingUnitTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDeviceTrippingUnitType
	/// <para>ENTITY IfcProtectiveDeviceTrippingUnitType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcProtectiveDeviceTrippingUnitTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDeviceTrippingUnitType : IfcDistributionControlElementType
	{
		public IfcProtectiveDeviceTrippingUnitTypeEnum PredefinedType { get; set; }
		public IfcProtectiveDeviceTrippingUnitType() : base()
		{
			PredefinedType = new IfcProtectiveDeviceTrippingUnitTypeEnum();
		}
		public IfcProtectiveDeviceTrippingUnitType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcProtectiveDeviceTrippingUnitTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDeviceType
	/// <para>ENTITY IfcProtectiveDeviceType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcProtectiveDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcProtectiveDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcProtectiveDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDeviceType : IfcFlowControllerType
	{
		public IfcProtectiveDeviceTypeEnum PredefinedType { get; set; }
		public IfcProtectiveDeviceType() : base()
		{
			PredefinedType = new IfcProtectiveDeviceTypeEnum();
		}
		public IfcProtectiveDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcProtectiveDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPump
	/// <para>ENTITY IfcPump</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPumpTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcPumpTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPumpTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCPUMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPump : IfcFlowMovingDevice
	{
		public IfcPumpTypeEnum? PredefinedType { get; set; }
		public IfcPump() : base()
		{
		}
		public IfcPump(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPumpTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPumpType
	/// <para>ENTITY IfcPumpType</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDeviceType);</para>
	/// <para>	PredefinedType : IfcPumpTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPumpTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPumpTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPumpType : IfcFlowMovingDeviceType
	{
		public IfcPumpTypeEnum PredefinedType { get; set; }
		public IfcPumpType() : base()
		{
			PredefinedType = new IfcPumpTypeEnum();
		}
		public IfcPumpType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPumpTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityArea
	/// <para>ENTITY IfcQuantityArea</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	AreaValue : IfcAreaMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.AREAUNIT);</para>
	/// <para>	WR22 : AreaValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityArea : IfcPhysicalSimpleQuantity
	{
		public IfcAreaMeasure AreaValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityArea() : base()
		{
			AreaValue = new IfcAreaMeasure();
		}
		public IfcQuantityArea(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcAreaMeasure AreaValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.AreaValue = AreaValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityCount
	/// <para>ENTITY IfcQuantityCount</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	CountValue : IfcCountMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : CountValue >= 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityCount : IfcPhysicalSimpleQuantity
	{
		public IfcCountMeasure CountValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityCount() : base()
		{
			CountValue = new IfcCountMeasure();
		}
		public IfcQuantityCount(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcCountMeasure CountValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.CountValue = CountValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityLength
	/// <para>ENTITY IfcQuantityLength</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	LengthValue : IfcLengthMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.LENGTHUNIT);</para>
	/// <para>	WR22 : LengthValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityLength : IfcPhysicalSimpleQuantity
	{
		public IfcLengthMeasure LengthValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityLength() : base()
		{
			LengthValue = new IfcLengthMeasure();
		}
		public IfcQuantityLength(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcLengthMeasure LengthValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.LengthValue = LengthValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityNumber
	/// <para>ENTITY IfcQuantityNumber</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	NumberValue : IfcNumericMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityNumber : IfcPhysicalSimpleQuantity
	{
		public IfcNumericMeasure NumberValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityNumber() : base()
		{
			NumberValue = new IfcNumericMeasure();
		}
		public IfcQuantityNumber(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcNumericMeasure NumberValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.NumberValue = NumberValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantitySet
	/// <para>ENTITY IfcQuantitySet</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcElementQuantity))</para>
	/// <para> SUBTYPE OF (IfcPropertySetDefinition);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcQuantitySet : IfcPropertySetDefinition
	{
		public IfcQuantitySet() : base()
		{
		}
		public IfcQuantitySet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityTime
	/// <para>ENTITY IfcQuantityTime</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	TimeValue : IfcTimeMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.TIMEUNIT);</para>
	/// <para>	WR22 : TimeValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityTime : IfcPhysicalSimpleQuantity
	{
		public IfcTimeMeasure TimeValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityTime() : base()
		{
			TimeValue = new IfcTimeMeasure();
		}
		public IfcQuantityTime(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcTimeMeasure TimeValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.TimeValue = TimeValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityVolume
	/// <para>ENTITY IfcQuantityVolume</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	VolumeValue : IfcVolumeMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.VOLUMEUNIT);</para>
	/// <para>	WR22 : VolumeValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityVolume : IfcPhysicalSimpleQuantity
	{
		public IfcVolumeMeasure VolumeValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityVolume() : base()
		{
			VolumeValue = new IfcVolumeMeasure();
		}
		public IfcQuantityVolume(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcVolumeMeasure VolumeValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.VolumeValue = VolumeValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityWeight
	/// <para>ENTITY IfcQuantityWeight</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	WeightValue : IfcMassMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.MASSUNIT);</para>
	/// <para>	WR22 : WeightValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityWeight : IfcPhysicalSimpleQuantity
	{
		public IfcMassMeasure WeightValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityWeight() : base()
		{
			WeightValue = new IfcMassMeasure();
		}
		public IfcQuantityWeight(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcMassMeasure WeightValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.WeightValue = WeightValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcRail
	/// <para>ENTITY IfcRail</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRailTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRailTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRailTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCRAILTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRail : IfcBuiltElement
	{
		public IfcRailTypeEnum? PredefinedType { get; set; }
		public IfcRail() : base()
		{
		}
		public IfcRail(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRailTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRailType
	/// <para>ENTITY IfcRailType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcRailTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcRailTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRailTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRailType : IfcBuiltElementType
	{
		public IfcRailTypeEnum PredefinedType { get; set; }
		public IfcRailType() : base()
		{
			PredefinedType = new IfcRailTypeEnum();
		}
		public IfcRailType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRailTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRailing
	/// <para>ENTITY IfcRailing</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRailingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRailingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRailingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCRAILINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRailing : IfcBuiltElement
	{
		public IfcRailingTypeEnum? PredefinedType { get; set; }
		public IfcRailing() : base()
		{
		}
		public IfcRailing(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRailingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRailingType
	/// <para>ENTITY IfcRailingType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcRailingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcRailingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRailingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRailingType : IfcBuiltElementType
	{
		public IfcRailingTypeEnum PredefinedType { get; set; }
		public IfcRailingType() : base()
		{
			PredefinedType = new IfcRailingTypeEnum();
		}
		public IfcRailingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRailingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRailway
	/// <para>ENTITY IfcRailway</para>
	/// <para> SUBTYPE OF (IfcFacility);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRailwayTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRailwayTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRailwayTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRailway : IfcFacility
	{
		public IfcRailwayTypeEnum? PredefinedType { get; set; }
		public IfcRailway() : base()
		{
		}
		public IfcRailway(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcRailwayTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRailwayPart
	/// <para>ENTITY IfcRailwayPart</para>
	/// <para> SUBTYPE OF (IfcFacilityPart);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRailwayPartTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRailwayPartTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRailwayPartTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRailwayPart : IfcFacilityPart
	{
		public IfcRailwayPartTypeEnum? PredefinedType { get; set; }
		public IfcRailwayPart() : base()
		{
		}
		public IfcRailwayPart(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcFacilityUsageEnum UsageType, IfcRailwayPartTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, UsageType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRamp
	/// <para>ENTITY IfcRamp</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRampTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRampTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRampTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCRAMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRamp : IfcBuiltElement
	{
		public IfcRampTypeEnum? PredefinedType { get; set; }
		public IfcRamp() : base()
		{
		}
		public IfcRamp(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRampFlight
	/// <para>ENTITY IfcRampFlight</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRampFlightTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRampFlightTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRampFlightTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCRAMPFLIGHTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRampFlight : IfcBuiltElement
	{
		public IfcRampFlightTypeEnum? PredefinedType { get; set; }
		public IfcRampFlight() : base()
		{
		}
		public IfcRampFlight(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRampFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRampFlightType
	/// <para>ENTITY IfcRampFlightType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcRampFlightTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcRampFlightTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRampFlightTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRampFlightType : IfcBuiltElementType
	{
		public IfcRampFlightTypeEnum PredefinedType { get; set; }
		public IfcRampFlightType() : base()
		{
			PredefinedType = new IfcRampFlightTypeEnum();
		}
		public IfcRampFlightType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRampFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRampType
	/// <para>ENTITY IfcRampType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcRampTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcRampTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRampTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRampType : IfcBuiltElementType
	{
		public IfcRampTypeEnum PredefinedType { get; set; }
		public IfcRampType() : base()
		{
			PredefinedType = new IfcRampTypeEnum();
		}
		public IfcRampType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRationalBSplineCurveWithKnots
	/// <para>ENTITY IfcRationalBSplineCurveWithKnots</para>
	/// <para> SUBTYPE OF (IfcBSplineCurveWithKnots);</para>
	/// <para>	WeightsData : LIST [2:?] OF IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	 Weights : ARRAY [0:UpperIndexOnControlPoints] OF IfcReal := IfcListToArray(WeightsData,0,SELF\IfcBSplineCurve.UpperIndexOnControlPoints);</para>
	/// <para> WHERE</para>
	/// <para>	SameNumOfWeightsAndPoints : SIZEOF(WeightsData) = SIZEOF(SELF\IfcBSplineCurve.ControlPointsList);</para>
	/// <para>	WeightsGreaterZero : IfcCurveWeightsPositive(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRationalBSplineCurveWithKnots : IfcBSplineCurveWithKnots
	{
		public List<IfcReal> WeightsData { get; set; }
		public IfcRationalBSplineCurveWithKnots() : base()
		{
			WeightsData = new List<IfcReal>();
		}
		public IfcRationalBSplineCurveWithKnots(IfcInteger Degree, List<IfcCartesianPoint> ControlPointsList, IfcBSplineCurveForm CurveForm, IfcLogical ClosedCurve, IfcLogical SelfIntersect, List<IfcInteger> KnotMultiplicities, List<IfcParameterValue> Knots, IfcKnotType KnotSpec, List<IfcReal> WeightsData) : base (Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec)
		{
			this.WeightsData = WeightsData;
		}
	}
	/// <summary>
	/// ENTITY IfcRationalBSplineSurfaceWithKnots
	/// <para>ENTITY IfcRationalBSplineSurfaceWithKnots</para>
	/// <para> SUBTYPE OF (IfcBSplineSurfaceWithKnots);</para>
	/// <para>	WeightsData : LIST [2:?] OF LIST [2:?] OF IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	 Weights : ARRAY [0:UUpper] OF ARRAY [0:VUpper] OF IfcReal := IfcMakeArrayOfArray(WeightsData,0,UUpper,0,VUpper);</para>
	/// <para> WHERE</para>
	/// <para>	CorrespondingWeightsDataLists : (SIZEOF(WeightsData) = SIZEOF(SELF\IfcBSplineSurface.ControlPointsList))</para>
	/// <para>AND </para>
	/// <para>(SIZEOF(WeightsData[1]) = SIZEOF(SELF\IfcBSplineSurface.ControlPointsList[1]));</para>
	/// <para>	WeightValuesGreaterZero : IfcSurfaceWeightsPositive(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRationalBSplineSurfaceWithKnots : IfcBSplineSurfaceWithKnots
	{
		public List<List<IfcReal >> WeightsData { get; set; }
		public IfcRationalBSplineSurfaceWithKnots() : base()
		{
			WeightsData = new List<List<IfcReal >>();
		}
		public IfcRationalBSplineSurfaceWithKnots(IfcInteger UDegree, IfcInteger VDegree, List<List<IfcCartesianPoint >> ControlPointsList, IfcBSplineSurfaceForm SurfaceForm, IfcLogical UClosed, IfcLogical VClosed, IfcLogical SelfIntersect, List<IfcInteger> UMultiplicities, List<IfcInteger> VMultiplicities, List<IfcParameterValue> UKnots, List<IfcParameterValue> VKnots, IfcKnotType KnotSpec, List<List<IfcReal >> WeightsData) : base (UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec)
		{
			this.WeightsData = WeightsData;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangleHollowProfileDef
	/// <para>ENTITY IfcRectangleHollowProfileDef</para>
	/// <para> SUBTYPE OF (IfcRectangleProfileDef);</para>
	/// <para>	WallThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	InnerFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	OuterFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidInnerRadius : NOT(EXISTS(InnerFilletRadius)) OR </para>
	/// <para>((InnerFilletRadius <= (SELF\IfcRectangleProfileDef.XDim/2. - WallThickness)) AND </para>
	/// <para> (InnerFilletRadius <= (SELF\IfcRectangleProfileDef.YDim/2. - WallThickness)))</para>
	/// <para>;</para>
	/// <para>	ValidOuterRadius : NOT(EXISTS(OuterFilletRadius)) OR </para>
	/// <para>((OuterFilletRadius <= (SELF\IfcRectangleProfileDef.XDim/2.)) AND </para>
	/// <para> (OuterFilletRadius <= (SELF\IfcRectangleProfileDef.YDim/2.)));</para>
	/// <para>	ValidWallThickness : (WallThickness < (SELF\IfcRectangleProfileDef.XDim/2.)) AND </para>
	/// <para>(WallThickness < (SELF\IfcRectangleProfileDef.YDim/2.));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangleHollowProfileDef : IfcRectangleProfileDef
	{
		public IfcPositiveLengthMeasure WallThickness { get; set; }
		public IfcNonNegativeLengthMeasure? InnerFilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? OuterFilletRadius { get; set; }
		public IfcRectangleHollowProfileDef() : base()
		{
			WallThickness = new IfcPositiveLengthMeasure();
		}
		public IfcRectangleHollowProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim, IfcPositiveLengthMeasure WallThickness, IfcNonNegativeLengthMeasure InnerFilletRadius, IfcNonNegativeLengthMeasure OuterFilletRadius) : base (ProfileType, ProfileName, Position, XDim, YDim)
		{
			this.WallThickness = WallThickness;
			this.InnerFilletRadius = InnerFilletRadius;
			this.OuterFilletRadius = OuterFilletRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangleProfileDef
	/// <para>ENTITY IfcRectangleProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRectangleHollowProfileDef</para>
	/// <para>	,IfcRoundedRectangleProfileDef))</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	XDim : IfcPositiveLengthMeasure;</para>
	/// <para>	YDim : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangleProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure XDim { get; set; }
		public IfcPositiveLengthMeasure YDim { get; set; }
		public IfcRectangleProfileDef() : base()
		{
			XDim = new IfcPositiveLengthMeasure();
			YDim = new IfcPositiveLengthMeasure();
		}
		public IfcRectangleProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim) : base (ProfileType, ProfileName, Position)
		{
			this.XDim = XDim;
			this.YDim = YDim;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangularPyramid
	/// <para>ENTITY IfcRectangularPyramid</para>
	/// <para> SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>	XLength : IfcPositiveLengthMeasure;</para>
	/// <para>	YLength : IfcPositiveLengthMeasure;</para>
	/// <para>	Height : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangularPyramid : IfcCsgPrimitive3D
	{
		public IfcPositiveLengthMeasure XLength { get; set; }
		public IfcPositiveLengthMeasure YLength { get; set; }
		public IfcPositiveLengthMeasure Height { get; set; }
		public IfcRectangularPyramid() : base()
		{
			XLength = new IfcPositiveLengthMeasure();
			YLength = new IfcPositiveLengthMeasure();
			Height = new IfcPositiveLengthMeasure();
		}
		public IfcRectangularPyramid(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure XLength, IfcPositiveLengthMeasure YLength, IfcPositiveLengthMeasure Height) : base (Position)
		{
			this.XLength = XLength;
			this.YLength = YLength;
			this.Height = Height;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangularTrimmedSurface
	/// <para>ENTITY IfcRectangularTrimmedSurface</para>
	/// <para> SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>	BasisSurface : IfcSurface;</para>
	/// <para>	U1 : IfcParameterValue;</para>
	/// <para>	V1 : IfcParameterValue;</para>
	/// <para>	U2 : IfcParameterValue;</para>
	/// <para>	V2 : IfcParameterValue;</para>
	/// <para>	Usense : IfcBoolean;</para>
	/// <para>	Vsense : IfcBoolean;</para>
	/// <para> WHERE</para>
	/// <para>	U1AndU2Different : U1 <> U2;</para>
	/// <para>	UsenseCompatible : (('IFC4X3_ADD2.IFCELEMENTARYSURFACE' IN TYPEOF(BasisSurface)) AND</para>
	/// <para>         (NOT ('IFC4X3_ADD2.IFCPLANE' IN TYPEOF(BasisSurface)))) OR</para>
	/// <para>         ('IFC4X3_ADD2.IFCSURFACEOFREVOLUTION' IN TYPEOF(BasisSurface)) OR</para>
	/// <para>         (Usense = (U2 > U1));</para>
	/// <para>	V1AndV2Different : V1 <> V2;</para>
	/// <para>	VsenseCompatible : Vsense = (V2 > V1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangularTrimmedSurface : IfcBoundedSurface
	{
		public IfcSurface BasisSurface { get; set; }
		public IfcParameterValue U1 { get; set; }
		public IfcParameterValue V1 { get; set; }
		public IfcParameterValue U2 { get; set; }
		public IfcParameterValue V2 { get; set; }
		public IfcBoolean Usense { get; set; }
		public IfcBoolean Vsense { get; set; }
		public IfcRectangularTrimmedSurface() : base()
		{
			BasisSurface = new IfcSurface();
			U1 = new IfcParameterValue();
			V1 = new IfcParameterValue();
			U2 = new IfcParameterValue();
			V2 = new IfcParameterValue();
			Usense = new IfcBoolean();
			Vsense = new IfcBoolean();
		}
		public IfcRectangularTrimmedSurface(IfcSurface BasisSurface, IfcParameterValue U1, IfcParameterValue V1, IfcParameterValue U2, IfcParameterValue V2, IfcBoolean Usense, IfcBoolean Vsense) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.U1 = U1;
			this.V1 = V1;
			this.U2 = U2;
			this.V2 = V2;
			this.Usense = Usense;
			this.Vsense = Vsense;
		}
	}
	/// <summary>
	/// ENTITY IfcRecurrencePattern;
	/// <para>ENTITY IfcRecurrencePattern;</para>
	/// <para>	RecurrenceType : IfcRecurrenceTypeEnum;</para>
	/// <para>	DayComponent : OPTIONAL SET [1:?] OF IfcDayInMonthNumber;</para>
	/// <para>	WeekdayComponent : OPTIONAL SET [1:?] OF IfcDayInWeekNumber;</para>
	/// <para>	MonthComponent : OPTIONAL SET [1:?] OF IfcMonthInYearNumber;</para>
	/// <para>	Position : OPTIONAL IfcInteger;</para>
	/// <para>	Interval : OPTIONAL IfcInteger;</para>
	/// <para>	Occurrences : OPTIONAL IfcInteger;</para>
	/// <para>	TimePeriods : OPTIONAL LIST [1:?] OF IfcTimePeriod;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRecurrencePatternENTITY
	{
		public IfcRecurrenceTypeEnum RecurrenceType { get; set; }
		public List<IfcDayInMonthNumber>? DayComponent { get; set; }
		public List<IfcDayInWeekNumber>? WeekdayComponent { get; set; }
		public List<IfcMonthInYearNumber>? MonthComponent { get; set; }
		public IfcInteger? Position { get; set; }
		public IfcInteger? Interval { get; set; }
		public IfcInteger? Occurrences { get; set; }
		public List<IfcTimePeriod>? TimePeriods { get; set; }
		public IfcRecurrencePattern() : base()
		{
			RecurrenceType = new IfcRecurrenceTypeEnum();
		}
		public IfcRecurrencePattern(IfcRecurrenceTypeEnum RecurrenceType, List<IfcDayInMonthNumber> DayComponent, List<IfcDayInWeekNumber> WeekdayComponent, List<IfcMonthInYearNumber> MonthComponent, IfcInteger Position, IfcInteger Interval, IfcInteger Occurrences, List<IfcTimePeriod> TimePeriods) : base ()
		{
			this.RecurrenceType = RecurrenceType;
			this.DayComponent = DayComponent;
			this.WeekdayComponent = WeekdayComponent;
			this.MonthComponent = MonthComponent;
			this.Position = Position;
			this.Interval = Interval;
			this.Occurrences = Occurrences;
			this.TimePeriods = TimePeriods;
		}
	}
	/// <summary>
	/// ENTITY IfcReference;
	/// <para>ENTITY IfcReference;</para>
	/// <para>	TypeIdentifier : OPTIONAL IfcIdentifier;</para>
	/// <para>	AttributeIdentifier : OPTIONAL IfcIdentifier;</para>
	/// <para>	InstanceName : OPTIONAL IfcLabel;</para>
	/// <para>	ListPositions : OPTIONAL LIST [1:?] OF IfcInteger;</para>
	/// <para>	InnerReference : OPTIONAL IfcReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReferenceENTITY, IfcAppliedValueSelect, IfcMetricValueSelect
	{
		public IfcIdentifier? TypeIdentifier { get; set; }
		public IfcIdentifier? AttributeIdentifier { get; set; }
		public IfcLabel? InstanceName { get; set; }
		public List<IfcInteger>? ListPositions { get; set; }
		public IfcReference? InnerReference { get; set; }
		public IfcReference() : base()
		{
		}
		public IfcReference(IfcIdentifier TypeIdentifier, IfcIdentifier AttributeIdentifier, IfcLabel InstanceName, List<IfcInteger> ListPositions, IfcReference InnerReference) : base ()
		{
			this.TypeIdentifier = TypeIdentifier;
			this.AttributeIdentifier = AttributeIdentifier;
			this.InstanceName = InstanceName;
			this.ListPositions = ListPositions;
			this.InnerReference = InnerReference;
		}
	}
	/// <summary>
	/// ENTITY IfcReferent
	/// <para>ENTITY IfcReferent</para>
	/// <para> SUBTYPE OF (IfcPositioningElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcReferentTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReferent : IfcPositioningElement
	{
		public IfcReferentTypeEnum? PredefinedType { get; set; }
		public IfcReferent() : base()
		{
		}
		public IfcReferent(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcReferentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRegularTimeSeries
	/// <para>ENTITY IfcRegularTimeSeries</para>
	/// <para> SUBTYPE OF (IfcTimeSeries);</para>
	/// <para>	TimeStep : IfcTimeMeasure;</para>
	/// <para>	Values : LIST [1:?] OF IfcTimeSeriesValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRegularTimeSeries : IfcTimeSeries
	{
		public IfcTimeMeasure TimeStep { get; set; }
		public List<IfcTimeSeriesValue> Values { get; set; }
		public IfcRegularTimeSeries() : base()
		{
			TimeStep = new IfcTimeMeasure();
			Values = new List<IfcTimeSeriesValue>();
		}
		public IfcRegularTimeSeries(IfcLabel Name, IfcText Description, IfcDateTime StartTime, IfcDateTime EndTime, IfcTimeSeriesDataTypeEnum TimeSeriesDataType, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcUnit Unit, IfcTimeMeasure TimeStep, List<IfcTimeSeriesValue> Values) : base (Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit)
		{
			this.TimeStep = TimeStep;
			this.Values = Values;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcedSoil
	/// <para>ENTITY IfcReinforcedSoil</para>
	/// <para> SUBTYPE OF (IfcEarthworksElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcReinforcedSoilTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcReinforcedSoilTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcReinforcedSoilTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcedSoil : IfcEarthworksElement
	{
		public IfcReinforcedSoilTypeEnum? PredefinedType { get; set; }
		public IfcReinforcedSoil() : base()
		{
		}
		public IfcReinforcedSoil(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcReinforcedSoilTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcementBarProperties
	/// <para>ENTITY IfcReinforcementBarProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedProperties);</para>
	/// <para>	TotalCrossSectionArea : IfcAreaMeasure;</para>
	/// <para>	SteelGrade : IfcLabel;</para>
	/// <para>	BarSurface : OPTIONAL IfcReinforcingBarSurfaceEnum;</para>
	/// <para>	EffectiveDepth : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	NominalBarDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	BarCount : OPTIONAL IfcCountMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcementBarProperties : IfcPreDefinedProperties
	{
		public IfcAreaMeasure TotalCrossSectionArea { get; set; }
		public IfcLabel SteelGrade { get; set; }
		public IfcReinforcingBarSurfaceEnum? BarSurface { get; set; }
		public IfcLengthMeasure? EffectiveDepth { get; set; }
		public IfcPositiveLengthMeasure? NominalBarDiameter { get; set; }
		public IfcCountMeasure? BarCount { get; set; }
		public IfcReinforcementBarProperties() : base()
		{
			TotalCrossSectionArea = new IfcAreaMeasure();
			SteelGrade = new IfcLabel();
		}
		public IfcReinforcementBarProperties(IfcAreaMeasure TotalCrossSectionArea, IfcLabel SteelGrade, IfcReinforcingBarSurfaceEnum BarSurface, IfcLengthMeasure EffectiveDepth, IfcPositiveLengthMeasure NominalBarDiameter, IfcCountMeasure BarCount) : base ()
		{
			this.TotalCrossSectionArea = TotalCrossSectionArea;
			this.SteelGrade = SteelGrade;
			this.BarSurface = BarSurface;
			this.EffectiveDepth = EffectiveDepth;
			this.NominalBarDiameter = NominalBarDiameter;
			this.BarCount = BarCount;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcementDefinitionProperties
	/// <para>ENTITY IfcReinforcementDefinitionProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	DefinitionType : OPTIONAL IfcLabel;</para>
	/// <para>	ReinforcementSectionDefinitions : LIST [1:?] OF IfcSectionReinforcementProperties;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcementDefinitionProperties : IfcPreDefinedPropertySet
	{
		public IfcLabel? DefinitionType { get; set; }
		public List<IfcSectionReinforcementProperties> ReinforcementSectionDefinitions { get; set; }
		public IfcReinforcementDefinitionProperties() : base()
		{
			ReinforcementSectionDefinitions = new List<IfcSectionReinforcementProperties>();
		}
		public IfcReinforcementDefinitionProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel DefinitionType, List<IfcSectionReinforcementProperties> ReinforcementSectionDefinitions) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.DefinitionType = DefinitionType;
			this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingBar
	/// <para>ENTITY IfcReinforcingBar</para>
	/// <para> SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	BarLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcReinforcingBarTypeEnum;</para>
	/// <para>	BarSurface : OPTIONAL IfcReinforcingBarSurfaceEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcReinforcingBarTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcReinforcingBarTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCREINFORCINGBARTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingBar : IfcReinforcingElement
	{
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcAreaMeasure? CrossSectionArea { get; set; }
		public IfcPositiveLengthMeasure? BarLength { get; set; }
		public IfcReinforcingBarTypeEnum? PredefinedType { get; set; }
		public IfcReinforcingBarSurfaceEnum? BarSurface { get; set; }
		public IfcReinforcingBar() : base()
		{
		}
		public IfcReinforcingBar(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcPositiveLengthMeasure BarLength, IfcReinforcingBarTypeEnum PredefinedType, IfcReinforcingBarSurfaceEnum BarSurface) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.BarLength = BarLength;
			this.PredefinedType = PredefinedType;
			this.BarSurface = BarSurface;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingBarType
	/// <para>ENTITY IfcReinforcingBarType</para>
	/// <para> SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>	PredefinedType : IfcReinforcingBarTypeEnum;</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	BarLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	BarSurface : OPTIONAL IfcReinforcingBarSurfaceEnum;</para>
	/// <para>	BendingShapeCode : OPTIONAL IfcLabel;</para>
	/// <para>	BendingParameters : OPTIONAL LIST [1:?] OF IfcBendingParameterSelect;</para>
	/// <para> WHERE</para>
	/// <para>	BendingShapeCodeProvided : NOT EXISTS(BendingParameters) OR EXISTS(BendingShapeCode);</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcReinforcingBarTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcReinforcingBarTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingBarType : IfcReinforcingElementType
	{
		public IfcReinforcingBarTypeEnum PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcAreaMeasure? CrossSectionArea { get; set; }
		public IfcPositiveLengthMeasure? BarLength { get; set; }
		public IfcReinforcingBarSurfaceEnum? BarSurface { get; set; }
		public IfcLabel? BendingShapeCode { get; set; }
		public List<IfcBendingParameterSelect>? BendingParameters { get; set; }
		public IfcReinforcingBarType() : base()
		{
			PredefinedType = new IfcReinforcingBarTypeEnum();
		}
		public IfcReinforcingBarType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcReinforcingBarTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcPositiveLengthMeasure BarLength, IfcReinforcingBarSurfaceEnum BarSurface, IfcLabel BendingShapeCode, List<IfcBendingParameterSelect> BendingParameters) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.BarLength = BarLength;
			this.BarSurface = BarSurface;
			this.BendingShapeCode = BendingShapeCode;
			this.BendingParameters = BendingParameters;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingElement
	/// <para>ENTITY IfcReinforcingElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcReinforcingBar</para>
	/// <para>	,IfcReinforcingMesh</para>
	/// <para>	,IfcTendon</para>
	/// <para>	,IfcTendonAnchor</para>
	/// <para>	,IfcTendonConduit))</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	SteelGrade : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcReinforcingElement : IfcElementComponent
	{
		public IfcLabel? SteelGrade { get; set; }
		public IfcReinforcingElement() : base()
		{
		}
		public IfcReinforcingElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.SteelGrade = SteelGrade;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingElementType
	/// <para>ENTITY IfcReinforcingElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcReinforcingBarType</para>
	/// <para>	,IfcReinforcingMeshType</para>
	/// <para>	,IfcTendonAnchorType</para>
	/// <para>	,IfcTendonConduitType</para>
	/// <para>	,IfcTendonType))</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcReinforcingElementType : IfcElementComponentType
	{
		public IfcReinforcingElementType() : base()
		{
		}
		public IfcReinforcingElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingMesh
	/// <para>ENTITY IfcReinforcingMesh</para>
	/// <para> SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>	MeshLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	MeshWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LongitudinalBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TransverseBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LongitudinalBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	TransverseBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	LongitudinalBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TransverseBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcReinforcingMeshTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcReinforcingMeshTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcReinforcingMeshTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCREINFORCINGMESHTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingMesh : IfcReinforcingElement
	{
		public IfcPositiveLengthMeasure? MeshLength { get; set; }
		public IfcPositiveLengthMeasure? MeshWidth { get; set; }
		public IfcPositiveLengthMeasure? LongitudinalBarNominalDiameter { get; set; }
		public IfcPositiveLengthMeasure? TransverseBarNominalDiameter { get; set; }
		public IfcAreaMeasure? LongitudinalBarCrossSectionArea { get; set; }
		public IfcAreaMeasure? TransverseBarCrossSectionArea { get; set; }
		public IfcPositiveLengthMeasure? LongitudinalBarSpacing { get; set; }
		public IfcPositiveLengthMeasure? TransverseBarSpacing { get; set; }
		public IfcReinforcingMeshTypeEnum? PredefinedType { get; set; }
		public IfcReinforcingMesh() : base()
		{
		}
		public IfcReinforcingMesh(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcPositiveLengthMeasure MeshLength, IfcPositiveLengthMeasure MeshWidth, IfcPositiveLengthMeasure LongitudinalBarNominalDiameter, IfcPositiveLengthMeasure TransverseBarNominalDiameter, IfcAreaMeasure LongitudinalBarCrossSectionArea, IfcAreaMeasure TransverseBarCrossSectionArea, IfcPositiveLengthMeasure LongitudinalBarSpacing, IfcPositiveLengthMeasure TransverseBarSpacing, IfcReinforcingMeshTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.MeshLength = MeshLength;
			this.MeshWidth = MeshWidth;
			this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
			this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
			this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
			this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
			this.LongitudinalBarSpacing = LongitudinalBarSpacing;
			this.TransverseBarSpacing = TransverseBarSpacing;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingMeshType
	/// <para>ENTITY IfcReinforcingMeshType</para>
	/// <para> SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>	PredefinedType : IfcReinforcingMeshTypeEnum;</para>
	/// <para>	MeshLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	MeshWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LongitudinalBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TransverseBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LongitudinalBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	TransverseBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	LongitudinalBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TransverseBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	BendingShapeCode : OPTIONAL IfcLabel;</para>
	/// <para>	BendingParameters : OPTIONAL LIST [1:?] OF IfcBendingParameterSelect;</para>
	/// <para> WHERE</para>
	/// <para>	BendingShapeCodeProvided : NOT EXISTS(BendingParameters) OR EXISTS(BendingShapeCode);</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcReinforcingMeshTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcReinforcingMeshTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingMeshType : IfcReinforcingElementType
	{
		public IfcReinforcingMeshTypeEnum PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? MeshLength { get; set; }
		public IfcPositiveLengthMeasure? MeshWidth { get; set; }
		public IfcPositiveLengthMeasure? LongitudinalBarNominalDiameter { get; set; }
		public IfcPositiveLengthMeasure? TransverseBarNominalDiameter { get; set; }
		public IfcAreaMeasure? LongitudinalBarCrossSectionArea { get; set; }
		public IfcAreaMeasure? TransverseBarCrossSectionArea { get; set; }
		public IfcPositiveLengthMeasure? LongitudinalBarSpacing { get; set; }
		public IfcPositiveLengthMeasure? TransverseBarSpacing { get; set; }
		public IfcLabel? BendingShapeCode { get; set; }
		public List<IfcBendingParameterSelect>? BendingParameters { get; set; }
		public IfcReinforcingMeshType() : base()
		{
			PredefinedType = new IfcReinforcingMeshTypeEnum();
		}
		public IfcReinforcingMeshType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcReinforcingMeshTypeEnum PredefinedType, IfcPositiveLengthMeasure MeshLength, IfcPositiveLengthMeasure MeshWidth, IfcPositiveLengthMeasure LongitudinalBarNominalDiameter, IfcPositiveLengthMeasure TransverseBarNominalDiameter, IfcAreaMeasure LongitudinalBarCrossSectionArea, IfcAreaMeasure TransverseBarCrossSectionArea, IfcPositiveLengthMeasure LongitudinalBarSpacing, IfcPositiveLengthMeasure TransverseBarSpacing, IfcLabel BendingShapeCode, List<IfcBendingParameterSelect> BendingParameters) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.MeshLength = MeshLength;
			this.MeshWidth = MeshWidth;
			this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
			this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
			this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
			this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
			this.LongitudinalBarSpacing = LongitudinalBarSpacing;
			this.TransverseBarSpacing = TransverseBarSpacing;
			this.BendingShapeCode = BendingShapeCode;
			this.BendingParameters = BendingParameters;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAdheresToElement
	/// <para>ENTITY IfcRelAdheresToElement</para>
	/// <para> SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>	RelatingElement : IfcElement;</para>
	/// <para>	RelatedSurfaceFeatures : SET [1:?] OF IfcSurfaceFeature;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAdheresToElement : IfcRelDecomposes
	{
		public IfcElement RelatingElement { get; set; }
		public List<IfcSurfaceFeature> RelatedSurfaceFeatures { get; set; }
		public IfcRelAdheresToElement() : base()
		{
			RelatingElement = new IfcElement();
			RelatedSurfaceFeatures = new List<IfcSurfaceFeature>();
		}
		public IfcRelAdheresToElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingElement, List<IfcSurfaceFeature> RelatedSurfaceFeatures) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingElement = RelatingElement;
			this.RelatedSurfaceFeatures = RelatedSurfaceFeatures;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAggregates
	/// <para>ENTITY IfcRelAggregates</para>
	/// <para> SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>	RelatingObject : IfcObjectDefinition;</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcObjectDefinition;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* RelatedObjects | RelatingObject :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAggregates : IfcRelDecomposes
	{
		public IfcObjectDefinition RelatingObject { get; set; }
		public List<IfcObjectDefinition> RelatedObjects { get; set; }
		public IfcRelAggregates() : base()
		{
			RelatingObject = new IfcObjectDefinition();
			RelatedObjects = new List<IfcObjectDefinition>();
		}
		public IfcRelAggregates(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcObjectDefinition RelatingObject, List<IfcObjectDefinition> RelatedObjects) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingObject = RelatingObject;
			this.RelatedObjects = RelatedObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssigns
	/// <para>ENTITY IfcRelAssigns</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelAssignsToActor</para>
	/// <para>	,IfcRelAssignsToControl</para>
	/// <para>	,IfcRelAssignsToGroup</para>
	/// <para>	,IfcRelAssignsToProcess</para>
	/// <para>	,IfcRelAssignsToProduct</para>
	/// <para>	,IfcRelAssignsToResource))</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcObjectDefinition;</para>
	/// <para>	RelatedObjectsType : OPTIONAL IfcStrippedOptional;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelAssigns : IfcRelationship
	{
		public List<IfcObjectDefinition> RelatedObjects { get; set; }
		public IfcStrippedOptional? RelatedObjectsType { get; set; }
		public IfcRelAssigns() : base()
		{
			RelatedObjects = new List<IfcObjectDefinition>();
		}
		public IfcRelAssigns(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcStrippedOptional RelatedObjectsType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatedObjectsType = RelatedObjectsType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToActor
	/// <para>ENTITY IfcRelAssignsToActor</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingActor : IfcActor;</para>
	/// <para>	ActingRole : OPTIONAL IfcActorRole;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingActor :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToActor : IfcRelAssigns
	{
		public IfcActor RelatingActor { get; set; }
		public IfcActorRole? ActingRole { get; set; }
		public IfcRelAssignsToActor() : base()
		{
			RelatingActor = new IfcActor();
		}
		public IfcRelAssignsToActor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcStrippedOptional RelatedObjectsType, IfcActor RelatingActor, IfcActorRole ActingRole) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingActor = RelatingActor;
			this.ActingRole = ActingRole;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToControl
	/// <para>ENTITY IfcRelAssignsToControl</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingControl : IfcControl;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingControl :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToControl : IfcRelAssigns
	{
		public IfcControl RelatingControl { get; set; }
		public IfcRelAssignsToControl() : base()
		{
			RelatingControl = new IfcControl();
		}
		public IfcRelAssignsToControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcStrippedOptional RelatedObjectsType, IfcControl RelatingControl) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingControl = RelatingControl;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToGroup
	/// <para>ENTITY IfcRelAssignsToGroup</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelAssignsToGroupByFactor))</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingGroup : IfcGroup;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingGroup :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToGroup : IfcRelAssigns
	{
		public IfcGroup RelatingGroup { get; set; }
		public IfcRelAssignsToGroup() : base()
		{
			RelatingGroup = new IfcGroup();
		}
		public IfcRelAssignsToGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcStrippedOptional RelatedObjectsType, IfcGroup RelatingGroup) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingGroup = RelatingGroup;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToGroupByFactor
	/// <para>ENTITY IfcRelAssignsToGroupByFactor</para>
	/// <para> SUBTYPE OF (IfcRelAssignsToGroup);</para>
	/// <para>	Factor : IfcRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToGroupByFactor : IfcRelAssignsToGroup
	{
		public IfcRatioMeasure Factor { get; set; }
		public IfcRelAssignsToGroupByFactor() : base()
		{
			Factor = new IfcRatioMeasure();
		}
		public IfcRelAssignsToGroupByFactor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcStrippedOptional RelatedObjectsType, IfcGroup RelatingGroup, IfcRatioMeasure Factor) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup)
		{
			this.Factor = Factor;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToProcess
	/// <para>ENTITY IfcRelAssignsToProcess</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingProcess : IfcProcessSelect;</para>
	/// <para>	QuantityInProcess : OPTIONAL IfcMeasureWithUnit;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingProcess :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToProcess : IfcRelAssigns
	{
		public IfcProcessSelect RelatingProcess { get; set; }
		public IfcMeasureWithUnit? QuantityInProcess { get; set; }
		public IfcRelAssignsToProcess() : base()
		{
			RelatingProcess = new IfcProcessSelect();
		}
		public IfcRelAssignsToProcess(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcStrippedOptional RelatedObjectsType, IfcProcessSelect RelatingProcess, IfcMeasureWithUnit QuantityInProcess) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingProcess = RelatingProcess;
			this.QuantityInProcess = QuantityInProcess;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToProduct
	/// <para>ENTITY IfcRelAssignsToProduct</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingProduct : IfcProductSelect;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingProduct :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToProduct : IfcRelAssigns
	{
		public IfcProductSelect RelatingProduct { get; set; }
		public IfcRelAssignsToProduct() : base()
		{
			RelatingProduct = new IfcProductSelect();
		}
		public IfcRelAssignsToProduct(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcStrippedOptional RelatedObjectsType, IfcProductSelect RelatingProduct) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingProduct = RelatingProduct;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToResource
	/// <para>ENTITY IfcRelAssignsToResource</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingResource : IfcResourceSelect;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingResource :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToResource : IfcRelAssigns
	{
		public IfcResourceSelect RelatingResource { get; set; }
		public IfcRelAssignsToResource() : base()
		{
			RelatingResource = new IfcResourceSelect();
		}
		public IfcRelAssignsToResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcStrippedOptional RelatedObjectsType, IfcResourceSelect RelatingResource) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingResource = RelatingResource;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociates
	/// <para>ENTITY IfcRelAssociates</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelAssociatesApproval</para>
	/// <para>	,IfcRelAssociatesClassification</para>
	/// <para>	,IfcRelAssociatesConstraint</para>
	/// <para>	,IfcRelAssociatesDocument</para>
	/// <para>	,IfcRelAssociatesLibrary</para>
	/// <para>	,IfcRelAssociatesMaterial</para>
	/// <para>	,IfcRelAssociatesProfileDef))</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcDefinitionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelAssociates : IfcRelationship
	{
		public List<IfcDefinitionSelect> RelatedObjects { get; set; }
		public IfcRelAssociates() : base()
		{
			RelatedObjects = new List<IfcDefinitionSelect>();
		}
		public IfcRelAssociates(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesApproval
	/// <para>ENTITY IfcRelAssociatesApproval</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingApproval : IfcApproval;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesApproval : IfcRelAssociates
	{
		public IfcApproval RelatingApproval { get; set; }
		public IfcRelAssociatesApproval() : base()
		{
			RelatingApproval = new IfcApproval();
		}
		public IfcRelAssociatesApproval(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcApproval RelatingApproval) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingApproval = RelatingApproval;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesClassification
	/// <para>ENTITY IfcRelAssociatesClassification</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingClassification : IfcClassificationSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesClassification : IfcRelAssociates
	{
		public IfcClassificationSelect RelatingClassification { get; set; }
		public IfcRelAssociatesClassification() : base()
		{
			RelatingClassification = new IfcClassificationSelect();
		}
		public IfcRelAssociatesClassification(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcClassificationSelect RelatingClassification) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingClassification = RelatingClassification;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesConstraint
	/// <para>ENTITY IfcRelAssociatesConstraint</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	Intent : OPTIONAL IfcLabel;</para>
	/// <para>	RelatingConstraint : IfcConstraint;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesConstraint : IfcRelAssociates
	{
		public IfcLabel? Intent { get; set; }
		public IfcConstraint RelatingConstraint { get; set; }
		public IfcRelAssociatesConstraint() : base()
		{
			RelatingConstraint = new IfcConstraint();
		}
		public IfcRelAssociatesConstraint(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcLabel Intent, IfcConstraint RelatingConstraint) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.Intent = Intent;
			this.RelatingConstraint = RelatingConstraint;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesDocument
	/// <para>ENTITY IfcRelAssociatesDocument</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingDocument : IfcDocumentSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesDocument : IfcRelAssociates
	{
		public IfcDocumentSelect RelatingDocument { get; set; }
		public IfcRelAssociatesDocument() : base()
		{
			RelatingDocument = new IfcDocumentSelect();
		}
		public IfcRelAssociatesDocument(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcDocumentSelect RelatingDocument) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingDocument = RelatingDocument;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesLibrary
	/// <para>ENTITY IfcRelAssociatesLibrary</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingLibrary : IfcLibrarySelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesLibrary : IfcRelAssociates
	{
		public IfcLibrarySelect RelatingLibrary { get; set; }
		public IfcRelAssociatesLibrary() : base()
		{
			RelatingLibrary = new IfcLibrarySelect();
		}
		public IfcRelAssociatesLibrary(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcLibrarySelect RelatingLibrary) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingLibrary = RelatingLibrary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesMaterial
	/// <para>ENTITY IfcRelAssociatesMaterial</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingMaterial : IfcMaterialSelect;</para>
	/// <para> WHERE</para>
	/// <para>	AllowedElements : SIZEOF(QUERY(temp <* SELF\IfcRelAssociates.RelatedObjects | (</para>
	/// <para>  SIZEOF(TYPEOF(temp) * [   </para>
	/// <para>    'IFC4X3_ADD2.IFCELEMENT', </para>
	/// <para>    'IFC4X3_ADD2.IFCELEMENTTYPE',</para>
	/// <para>    'IFC4X3_ADD2.IFCSTRUCTURALMEMBER',</para>
	/// <para>    'IFC4X3_ADD2.IFCPORT']) = 0) </para>
	/// <para>)) = 0;</para>
	/// <para>	NoVoidElement : SIZEOF(QUERY(temp <* SELF\IfcRelAssociates.RelatedObjects | </para>
	/// <para>  ('IFC4X3_ADD2.IFCFEATUREELEMENTSUBTRACTION' IN TYPEOF(temp)) OR </para>
	/// <para>  ('IFC4X3_ADD2.IFCVIRTUALELEMENT' IN TYPEOF(temp)) </para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesMaterial : IfcRelAssociates
	{
		public IfcMaterialSelect RelatingMaterial { get; set; }
		public IfcRelAssociatesMaterial() : base()
		{
			RelatingMaterial = new IfcMaterialSelect();
		}
		public IfcRelAssociatesMaterial(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcMaterialSelect RelatingMaterial) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingMaterial = RelatingMaterial;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesProfileDef
	/// <para>ENTITY IfcRelAssociatesProfileDef</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingProfileDef : IfcProfileDef;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesProfileDef : IfcRelAssociates
	{
		public IfcProfileDef RelatingProfileDef { get; set; }
		public IfcRelAssociatesProfileDef() : base()
		{
			RelatingProfileDef = new IfcProfileDef();
		}
		public IfcRelAssociatesProfileDef(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcProfileDef RelatingProfileDef) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingProfileDef = RelatingProfileDef;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnects
	/// <para>ENTITY IfcRelConnects</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelConnectsElements</para>
	/// <para>	,IfcRelConnectsPortToElement</para>
	/// <para>	,IfcRelConnectsPorts</para>
	/// <para>	,IfcRelConnectsStructuralActivity</para>
	/// <para>	,IfcRelConnectsStructuralMember</para>
	/// <para>	,IfcRelContainedInSpatialStructure</para>
	/// <para>	,IfcRelCoversBldgElements</para>
	/// <para>	,IfcRelCoversSpaces</para>
	/// <para>	,IfcRelFillsElement</para>
	/// <para>	,IfcRelFlowControlElements</para>
	/// <para>	,IfcRelInterferesElements</para>
	/// <para>	,IfcRelPositions</para>
	/// <para>	,IfcRelReferencedInSpatialStructure</para>
	/// <para>	,IfcRelSequence</para>
	/// <para>	,IfcRelServicesBuildings</para>
	/// <para>	,IfcRelSpaceBoundary))</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelConnects : IfcRelationship
	{
		public IfcRelConnects() : base()
		{
		}
		public IfcRelConnects(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsElements
	/// <para>ENTITY IfcRelConnectsElements</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelConnectsPathElements</para>
	/// <para>	,IfcRelConnectsWithRealizingElements))</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	ConnectionGeometry : OPTIONAL IfcConnectionGeometry;</para>
	/// <para>	RelatingElement : IfcElement;</para>
	/// <para>	RelatedElement : IfcElement;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : RelatingElement :<>: RelatedElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsElements : IfcRelConnects
	{
		public IfcConnectionGeometry? ConnectionGeometry { get; set; }
		public IfcElement RelatingElement { get; set; }
		public IfcElement RelatedElement { get; set; }
		public IfcRelConnectsElements() : base()
		{
			RelatingElement = new IfcElement();
			RelatedElement = new IfcElement();
		}
		public IfcRelConnectsElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcConnectionGeometry ConnectionGeometry, IfcElement RelatingElement, IfcElement RelatedElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ConnectionGeometry = ConnectionGeometry;
			this.RelatingElement = RelatingElement;
			this.RelatedElement = RelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsPathElements
	/// <para>ENTITY IfcRelConnectsPathElements</para>
	/// <para> SUBTYPE OF (IfcRelConnectsElements);</para>
	/// <para>	RelatingPriorities : LIST [0:?] OF IfcInteger;</para>
	/// <para>	RelatedPriorities : LIST [0:?] OF IfcInteger;</para>
	/// <para>	RelatedConnectionType : IfcConnectionTypeEnum;</para>
	/// <para>	RelatingConnectionType : IfcConnectionTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	NormalizedRelatedPriorities : (SIZEOF(RelatedPriorities) = 0)</para>
	/// <para>OR</para>
	/// <para>(SIZEOF (QUERY (temp <* RelatedPriorities</para>
	/// <para>  | {0 <= temp <= 100}</para>
	/// <para>  )) = SIZEOF(RelatedPriorities));</para>
	/// <para>	NormalizedRelatingPriorities : (SIZEOF(RelatingPriorities) = 0)</para>
	/// <para>OR</para>
	/// <para>(SIZEOF (QUERY (temp <* RelatingPriorities</para>
	/// <para>  | {0 <= temp <= 100}</para>
	/// <para>  )) = SIZEOF(RelatingPriorities));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsPathElements : IfcRelConnectsElements
	{
		public List<IfcInteger> RelatingPriorities { get; set; }
		public List<IfcInteger> RelatedPriorities { get; set; }
		public IfcConnectionTypeEnum RelatedConnectionType { get; set; }
		public IfcConnectionTypeEnum RelatingConnectionType { get; set; }
		public IfcRelConnectsPathElements() : base()
		{
			RelatingPriorities = new List<IfcInteger>();
			RelatedPriorities = new List<IfcInteger>();
			RelatedConnectionType = new IfcConnectionTypeEnum();
			RelatingConnectionType = new IfcConnectionTypeEnum();
		}
		public IfcRelConnectsPathElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcConnectionGeometry ConnectionGeometry, IfcElement RelatingElement, IfcElement RelatedElement, List<IfcInteger> RelatingPriorities, List<IfcInteger> RelatedPriorities, IfcConnectionTypeEnum RelatedConnectionType, IfcConnectionTypeEnum RelatingConnectionType) : base (GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement)
		{
			this.RelatingPriorities = RelatingPriorities;
			this.RelatedPriorities = RelatedPriorities;
			this.RelatedConnectionType = RelatedConnectionType;
			this.RelatingConnectionType = RelatingConnectionType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsPortToElement
	/// <para>ENTITY IfcRelConnectsPortToElement</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingPort : IfcPort;</para>
	/// <para>	RelatedElement : IfcDistributionElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsPortToElement : IfcRelConnects
	{
		public IfcPort RelatingPort { get; set; }
		public IfcDistributionElement RelatedElement { get; set; }
		public IfcRelConnectsPortToElement() : base()
		{
			RelatingPort = new IfcPort();
			RelatedElement = new IfcDistributionElement();
		}
		public IfcRelConnectsPortToElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPort RelatingPort, IfcDistributionElement RelatedElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingPort = RelatingPort;
			this.RelatedElement = RelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsPorts
	/// <para>ENTITY IfcRelConnectsPorts</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingPort : IfcPort;</para>
	/// <para>	RelatedPort : IfcPort;</para>
	/// <para>	RealizingElement : OPTIONAL IfcElement;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : RelatingPort :<>: RelatedPort;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsPorts : IfcRelConnects
	{
		public IfcPort RelatingPort { get; set; }
		public IfcPort RelatedPort { get; set; }
		public IfcElement? RealizingElement { get; set; }
		public IfcRelConnectsPorts() : base()
		{
			RelatingPort = new IfcPort();
			RelatedPort = new IfcPort();
		}
		public IfcRelConnectsPorts(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPort RelatingPort, IfcPort RelatedPort, IfcElement RealizingElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingPort = RelatingPort;
			this.RelatedPort = RelatedPort;
			this.RealizingElement = RealizingElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsStructuralActivity
	/// <para>ENTITY IfcRelConnectsStructuralActivity</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingElement : IfcStructuralActivityAssignmentSelect;</para>
	/// <para>	RelatedStructuralActivity : IfcStructuralActivity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsStructuralActivity : IfcRelConnects
	{
		public IfcStructuralActivityAssignmentSelect RelatingElement { get; set; }
		public IfcStructuralActivity RelatedStructuralActivity { get; set; }
		public IfcRelConnectsStructuralActivity() : base()
		{
			RelatingElement = new IfcStructuralActivityAssignmentSelect();
			RelatedStructuralActivity = new IfcStructuralActivity();
		}
		public IfcRelConnectsStructuralActivity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcStructuralActivityAssignmentSelect RelatingElement, IfcStructuralActivity RelatedStructuralActivity) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingElement = RelatingElement;
			this.RelatedStructuralActivity = RelatedStructuralActivity;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsStructuralMember
	/// <para>ENTITY IfcRelConnectsStructuralMember</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelConnectsWithEccentricity))</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingStructuralMember : IfcStructuralMember;</para>
	/// <para>	RelatedStructuralConnection : IfcStructuralConnection;</para>
	/// <para>	AppliedCondition : OPTIONAL IfcBoundaryCondition;</para>
	/// <para>	AdditionalConditions : OPTIONAL IfcStructuralConnectionCondition;</para>
	/// <para>	SupportedLength : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ConditionCoordinateSystem : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsStructuralMember : IfcRelConnects
	{
		public IfcStructuralMember RelatingStructuralMember { get; set; }
		public IfcStructuralConnection RelatedStructuralConnection { get; set; }
		public IfcBoundaryCondition? AppliedCondition { get; set; }
		public IfcStructuralConnectionCondition? AdditionalConditions { get; set; }
		public IfcLengthMeasure? SupportedLength { get; set; }
		public IfcAxis2Placement3D? ConditionCoordinateSystem { get; set; }
		public IfcRelConnectsStructuralMember() : base()
		{
			RelatingStructuralMember = new IfcStructuralMember();
			RelatedStructuralConnection = new IfcStructuralConnection();
		}
		public IfcRelConnectsStructuralMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcStructuralMember RelatingStructuralMember, IfcStructuralConnection RelatedStructuralConnection, IfcBoundaryCondition AppliedCondition, IfcStructuralConnectionCondition AdditionalConditions, IfcLengthMeasure SupportedLength, IfcAxis2Placement3D ConditionCoordinateSystem) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingStructuralMember = RelatingStructuralMember;
			this.RelatedStructuralConnection = RelatedStructuralConnection;
			this.AppliedCondition = AppliedCondition;
			this.AdditionalConditions = AdditionalConditions;
			this.SupportedLength = SupportedLength;
			this.ConditionCoordinateSystem = ConditionCoordinateSystem;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsWithEccentricity
	/// <para>ENTITY IfcRelConnectsWithEccentricity</para>
	/// <para> SUBTYPE OF (IfcRelConnectsStructuralMember);</para>
	/// <para>	ConnectionConstraint : IfcConnectionGeometry;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsWithEccentricity : IfcRelConnectsStructuralMember
	{
		public IfcConnectionGeometry ConnectionConstraint { get; set; }
		public IfcRelConnectsWithEccentricity() : base()
		{
			ConnectionConstraint = new IfcConnectionGeometry();
		}
		public IfcRelConnectsWithEccentricity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcStructuralMember RelatingStructuralMember, IfcStructuralConnection RelatedStructuralConnection, IfcBoundaryCondition AppliedCondition, IfcStructuralConnectionCondition AdditionalConditions, IfcLengthMeasure SupportedLength, IfcAxis2Placement3D ConditionCoordinateSystem, IfcConnectionGeometry ConnectionConstraint) : base (GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem)
		{
			this.ConnectionConstraint = ConnectionConstraint;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsWithRealizingElements
	/// <para>ENTITY IfcRelConnectsWithRealizingElements</para>
	/// <para> SUBTYPE OF (IfcRelConnectsElements);</para>
	/// <para>	RealizingElements : SET [1:?] OF IfcElement;</para>
	/// <para>	ConnectionType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsWithRealizingElements : IfcRelConnectsElements
	{
		public List<IfcElement> RealizingElements { get; set; }
		public IfcLabel? ConnectionType { get; set; }
		public IfcRelConnectsWithRealizingElements() : base()
		{
			RealizingElements = new List<IfcElement>();
		}
		public IfcRelConnectsWithRealizingElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcConnectionGeometry ConnectionGeometry, IfcElement RelatingElement, IfcElement RelatedElement, List<IfcElement> RealizingElements, IfcLabel ConnectionType) : base (GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement)
		{
			this.RealizingElements = RealizingElements;
			this.ConnectionType = ConnectionType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelContainedInSpatialStructure
	/// <para>ENTITY IfcRelContainedInSpatialStructure</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatedElements : SET [1:?] OF IfcProduct;</para>
	/// <para>	RelatingStructure : IfcSpatialElement;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : SIZEOF(QUERY(temp <* RelatedElements | 'IFC4X3_ADD2.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelContainedInSpatialStructure : IfcRelConnects
	{
		public List<IfcProduct> RelatedElements { get; set; }
		public IfcSpatialElement RelatingStructure { get; set; }
		public IfcRelContainedInSpatialStructure() : base()
		{
			RelatedElements = new List<IfcProduct>();
			RelatingStructure = new IfcSpatialElement();
		}
		public IfcRelContainedInSpatialStructure(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcProduct> RelatedElements, IfcSpatialElement RelatingStructure) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedElements = RelatedElements;
			this.RelatingStructure = RelatingStructure;
		}
	}
	/// <summary>
	/// ENTITY IfcRelCoversBldgElements
	/// <para>ENTITY IfcRelCoversBldgElements</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingBuildingElement : IfcElement;</para>
	/// <para>	RelatedCoverings : SET [1:?] OF IfcCovering;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelCoversBldgElements : IfcRelConnects
	{
		public IfcElement RelatingBuildingElement { get; set; }
		public List<IfcCovering> RelatedCoverings { get; set; }
		public IfcRelCoversBldgElements() : base()
		{
			RelatingBuildingElement = new IfcElement();
			RelatedCoverings = new List<IfcCovering>();
		}
		public IfcRelCoversBldgElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingBuildingElement, List<IfcCovering> RelatedCoverings) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingBuildingElement = RelatingBuildingElement;
			this.RelatedCoverings = RelatedCoverings;
		}
	}
	/// <summary>
	/// ENTITY IfcRelCoversSpaces
	/// <para>ENTITY IfcRelCoversSpaces</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingSpace : IfcSpace;</para>
	/// <para>	RelatedCoverings : SET [1:?] OF IfcCovering;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelCoversSpaces : IfcRelConnects
	{
		public IfcSpace RelatingSpace { get; set; }
		public List<IfcCovering> RelatedCoverings { get; set; }
		public IfcRelCoversSpaces() : base()
		{
			RelatingSpace = new IfcSpace();
			RelatedCoverings = new List<IfcCovering>();
		}
		public IfcRelCoversSpaces(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpace RelatingSpace, List<IfcCovering> RelatedCoverings) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingSpace = RelatingSpace;
			this.RelatedCoverings = RelatedCoverings;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDeclares
	/// <para>ENTITY IfcRelDeclares</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>	RelatingContext : IfcContext;</para>
	/// <para>	RelatedDefinitions : SET [1:?] OF IfcDefinitionSelect;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* RelatedDefinitions | RelatingContext :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDeclares : IfcRelationship
	{
		public IfcContext RelatingContext { get; set; }
		public List<IfcDefinitionSelect> RelatedDefinitions { get; set; }
		public IfcRelDeclares() : base()
		{
			RelatingContext = new IfcContext();
			RelatedDefinitions = new List<IfcDefinitionSelect>();
		}
		public IfcRelDeclares(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcContext RelatingContext, List<IfcDefinitionSelect> RelatedDefinitions) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingContext = RelatingContext;
			this.RelatedDefinitions = RelatedDefinitions;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDecomposes
	/// <para>ENTITY IfcRelDecomposes</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelAdheresToElement</para>
	/// <para>	,IfcRelAggregates</para>
	/// <para>	,IfcRelNests</para>
	/// <para>	,IfcRelProjectsElement</para>
	/// <para>	,IfcRelVoidsElement))</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelDecomposes : IfcRelationship
	{
		public IfcRelDecomposes() : base()
		{
		}
		public IfcRelDecomposes(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefines
	/// <para>ENTITY IfcRelDefines</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelDefinesByObject</para>
	/// <para>	,IfcRelDefinesByProperties</para>
	/// <para>	,IfcRelDefinesByTemplate</para>
	/// <para>	,IfcRelDefinesByType))</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelDefines : IfcRelationship
	{
		public IfcRelDefines() : base()
		{
		}
		public IfcRelDefines(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByObject
	/// <para>ENTITY IfcRelDefinesByObject</para>
	/// <para> SUBTYPE OF (IfcRelDefines);</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcObject;</para>
	/// <para>	RelatingObject : IfcObject;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByObject : IfcRelDefines
	{
		public List<IfcObject> RelatedObjects { get; set; }
		public IfcObject RelatingObject { get; set; }
		public IfcRelDefinesByObject() : base()
		{
			RelatedObjects = new List<IfcObject>();
			RelatingObject = new IfcObject();
		}
		public IfcRelDefinesByObject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObject> RelatedObjects, IfcObject RelatingObject) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatingObject = RelatingObject;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByProperties
	/// <para>ENTITY IfcRelDefinesByProperties</para>
	/// <para> SUBTYPE OF (IfcRelDefines);</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcObjectDefinition;</para>
	/// <para>	RelatingPropertyDefinition : IfcPropertySetDefinitionSelect;</para>
	/// <para> WHERE</para>
	/// <para>	NoRelatedTypeObject : SIZEOF(QUERY(Types <* SELF\IfcRelDefinesByProperties.RelatedObjects |  'IFC4X3_ADD2.IFCTYPEOBJECT' IN TYPEOF(Types))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByProperties : IfcRelDefines
	{
		public List<IfcObjectDefinition> RelatedObjects { get; set; }
		public IfcPropertySetDefinitionSelect RelatingPropertyDefinition { get; set; }
		public IfcRelDefinesByProperties() : base()
		{
			RelatedObjects = new List<IfcObjectDefinition>();
			RelatingPropertyDefinition = new IfcPropertySetDefinitionSelect();
		}
		public IfcRelDefinesByProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcPropertySetDefinitionSelect RelatingPropertyDefinition) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatingPropertyDefinition = RelatingPropertyDefinition;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByTemplate
	/// <para>ENTITY IfcRelDefinesByTemplate</para>
	/// <para> SUBTYPE OF (IfcRelDefines);</para>
	/// <para>	RelatedPropertySets : SET [1:?] OF IfcPropertySetDefinition;</para>
	/// <para>	RelatingTemplate : IfcPropertySetTemplate;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByTemplate : IfcRelDefines
	{
		public List<IfcPropertySetDefinition> RelatedPropertySets { get; set; }
		public IfcPropertySetTemplate RelatingTemplate { get; set; }
		public IfcRelDefinesByTemplate() : base()
		{
			RelatedPropertySets = new List<IfcPropertySetDefinition>();
			RelatingTemplate = new IfcPropertySetTemplate();
		}
		public IfcRelDefinesByTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcPropertySetDefinition> RelatedPropertySets, IfcPropertySetTemplate RelatingTemplate) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedPropertySets = RelatedPropertySets;
			this.RelatingTemplate = RelatingTemplate;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByType
	/// <para>ENTITY IfcRelDefinesByType</para>
	/// <para> SUBTYPE OF (IfcRelDefines);</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcObject;</para>
	/// <para>	RelatingType : IfcTypeObject;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByType : IfcRelDefines
	{
		public List<IfcObject> RelatedObjects { get; set; }
		public IfcTypeObject RelatingType { get; set; }
		public IfcRelDefinesByType() : base()
		{
			RelatedObjects = new List<IfcObject>();
			RelatingType = new IfcTypeObject();
		}
		public IfcRelDefinesByType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObject> RelatedObjects, IfcTypeObject RelatingType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatingType = RelatingType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelFillsElement
	/// <para>ENTITY IfcRelFillsElement</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingOpeningElement : IfcOpeningElement;</para>
	/// <para>	RelatedBuildingElement : IfcElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelFillsElement : IfcRelConnects
	{
		public IfcOpeningElement RelatingOpeningElement { get; set; }
		public IfcElement RelatedBuildingElement { get; set; }
		public IfcRelFillsElement() : base()
		{
			RelatingOpeningElement = new IfcOpeningElement();
			RelatedBuildingElement = new IfcElement();
		}
		public IfcRelFillsElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcOpeningElement RelatingOpeningElement, IfcElement RelatedBuildingElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingOpeningElement = RelatingOpeningElement;
			this.RelatedBuildingElement = RelatedBuildingElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelFlowControlElements
	/// <para>ENTITY IfcRelFlowControlElements</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatedControlElements : SET [1:?] OF IfcDistributionControlElement;</para>
	/// <para>	RelatingFlowElement : IfcDistributionFlowElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelFlowControlElements : IfcRelConnects
	{
		public List<IfcDistributionControlElement> RelatedControlElements { get; set; }
		public IfcDistributionFlowElement RelatingFlowElement { get; set; }
		public IfcRelFlowControlElements() : base()
		{
			RelatedControlElements = new List<IfcDistributionControlElement>();
			RelatingFlowElement = new IfcDistributionFlowElement();
		}
		public IfcRelFlowControlElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDistributionControlElement> RelatedControlElements, IfcDistributionFlowElement RelatingFlowElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedControlElements = RelatedControlElements;
			this.RelatingFlowElement = RelatingFlowElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelInterferesElements
	/// <para>ENTITY IfcRelInterferesElements</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingElement : IfcInterferenceSelect;</para>
	/// <para>	RelatedElement : IfcInterferenceSelect;</para>
	/// <para>	InterferenceGeometry : OPTIONAL IfcConnectionGeometry;</para>
	/// <para>	InterferenceType : OPTIONAL IfcIdentifier;</para>
	/// <para>	ImpliedOrder : IfcLogical;</para>
	/// <para>	InterferenceSpace : OPTIONAL IfcSpatialZone;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : RelatingElement :<>: RelatedElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelInterferesElements : IfcRelConnects
	{
		public IfcInterferenceSelect RelatingElement { get; set; }
		public IfcInterferenceSelect RelatedElement { get; set; }
		public IfcConnectionGeometry? InterferenceGeometry { get; set; }
		public IfcIdentifier? InterferenceType { get; set; }
		public IfcLogical ImpliedOrder { get; set; }
		public IfcSpatialZone? InterferenceSpace { get; set; }
		public IfcRelInterferesElements() : base()
		{
			RelatingElement = new IfcInterferenceSelect();
			RelatedElement = new IfcInterferenceSelect();
			ImpliedOrder = new IfcLogical();
		}
		public IfcRelInterferesElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcInterferenceSelect RelatingElement, IfcInterferenceSelect RelatedElement, IfcConnectionGeometry InterferenceGeometry, IfcIdentifier InterferenceType, IfcLogical ImpliedOrder, IfcSpatialZone InterferenceSpace) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingElement = RelatingElement;
			this.RelatedElement = RelatedElement;
			this.InterferenceGeometry = InterferenceGeometry;
			this.InterferenceType = InterferenceType;
			this.ImpliedOrder = ImpliedOrder;
			this.InterferenceSpace = InterferenceSpace;
		}
	}
	/// <summary>
	/// ENTITY IfcRelNests
	/// <para>ENTITY IfcRelNests</para>
	/// <para> SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>	RelatingObject : IfcObjectDefinition;</para>
	/// <para>	RelatedObjects : LIST [1:?] OF IfcObjectDefinition;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* RelatedObjects | RelatingObject :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelNests : IfcRelDecomposes
	{
		public IfcObjectDefinition RelatingObject { get; set; }
		public List<IfcObjectDefinition> RelatedObjects { get; set; }
		public IfcRelNests() : base()
		{
			RelatingObject = new IfcObjectDefinition();
			RelatedObjects = new List<IfcObjectDefinition>();
		}
		public IfcRelNests(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcObjectDefinition RelatingObject, List<IfcObjectDefinition> RelatedObjects) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingObject = RelatingObject;
			this.RelatedObjects = RelatedObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcRelPositions
	/// <para>ENTITY IfcRelPositions</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingPositioningElement : IfcPositioningElement;</para>
	/// <para>	RelatedProducts : SET [1:?] OF IfcProduct;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(temp <* RelatedProducts | RelatingPositioningElement :=: temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelPositions : IfcRelConnects
	{
		public IfcPositioningElement RelatingPositioningElement { get; set; }
		public List<IfcProduct> RelatedProducts { get; set; }
		public IfcRelPositions() : base()
		{
			RelatingPositioningElement = new IfcPositioningElement();
			RelatedProducts = new List<IfcProduct>();
		}
		public IfcRelPositions(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPositioningElement RelatingPositioningElement, List<IfcProduct> RelatedProducts) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingPositioningElement = RelatingPositioningElement;
			this.RelatedProducts = RelatedProducts;
		}
	}
	/// <summary>
	/// ENTITY IfcRelProjectsElement
	/// <para>ENTITY IfcRelProjectsElement</para>
	/// <para> SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>	RelatingElement : IfcElement;</para>
	/// <para>	RelatedFeatureElement : IfcFeatureElementAddition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelProjectsElement : IfcRelDecomposes
	{
		public IfcElement RelatingElement { get; set; }
		public IfcFeatureElementAddition RelatedFeatureElement { get; set; }
		public IfcRelProjectsElement() : base()
		{
			RelatingElement = new IfcElement();
			RelatedFeatureElement = new IfcFeatureElementAddition();
		}
		public IfcRelProjectsElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingElement, IfcFeatureElementAddition RelatedFeatureElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingElement = RelatingElement;
			this.RelatedFeatureElement = RelatedFeatureElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelReferencedInSpatialStructure
	/// <para>ENTITY IfcRelReferencedInSpatialStructure</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatedElements : SET [1:?] OF IfcSpatialReferenceSelect;</para>
	/// <para>	RelatingStructure : IfcSpatialElement;</para>
	/// <para> WHERE</para>
	/// <para>	AllowedRelatedElements : SIZEOF(QUERY(temp <* RelatedElements | ('IFC4X3_ADD2.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF(temp)) AND (NOT ('IFC4X3_ADD2.IFCSPACE' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelReferencedInSpatialStructure : IfcRelConnects
	{
		public List<IfcSpatialReferenceSelect> RelatedElements { get; set; }
		public IfcSpatialElement RelatingStructure { get; set; }
		public IfcRelReferencedInSpatialStructure() : base()
		{
			RelatedElements = new List<IfcSpatialReferenceSelect>();
			RelatingStructure = new IfcSpatialElement();
		}
		public IfcRelReferencedInSpatialStructure(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcSpatialReferenceSelect> RelatedElements, IfcSpatialElement RelatingStructure) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedElements = RelatedElements;
			this.RelatingStructure = RelatingStructure;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSequence
	/// <para>ENTITY IfcRelSequence</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingProcess : IfcProcess;</para>
	/// <para>	RelatedProcess : IfcProcess;</para>
	/// <para>	TimeLag : OPTIONAL IfcLagTime;</para>
	/// <para>	SequenceType : OPTIONAL IfcSequenceEnum;</para>
	/// <para>	UserDefinedSequenceType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	AvoidInconsistentSequence : RelatingProcess :<>: RelatedProcess;</para>
	/// <para>	CorrectSequenceType : (SequenceType <> IfcSequenceEnum.USERDEFINED) OR ((SequenceType = IfcSequenceEnum.USERDEFINED) AND EXISTS(UserDefinedSequenceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSequence : IfcRelConnects
	{
		public IfcProcess RelatingProcess { get; set; }
		public IfcProcess RelatedProcess { get; set; }
		public IfcLagTime? TimeLag { get; set; }
		public IfcSequenceEnum? SequenceType { get; set; }
		public IfcLabel? UserDefinedSequenceType { get; set; }
		public IfcRelSequence() : base()
		{
			RelatingProcess = new IfcProcess();
			RelatedProcess = new IfcProcess();
		}
		public IfcRelSequence(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcProcess RelatingProcess, IfcProcess RelatedProcess, IfcLagTime TimeLag, IfcSequenceEnum SequenceType, IfcLabel UserDefinedSequenceType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingProcess = RelatingProcess;
			this.RelatedProcess = RelatedProcess;
			this.TimeLag = TimeLag;
			this.SequenceType = SequenceType;
			this.UserDefinedSequenceType = UserDefinedSequenceType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelServicesBuildings
	/// <para>ENTITY IfcRelServicesBuildings</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingSystem : IfcSystem;</para>
	/// <para>	RelatedBuildings : SET [1:?] OF IfcSpatialElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelServicesBuildings : IfcRelConnects
	{
		public IfcSystem RelatingSystem { get; set; }
		public List<IfcSpatialElement> RelatedBuildings { get; set; }
		public IfcRelServicesBuildings() : base()
		{
			RelatingSystem = new IfcSystem();
			RelatedBuildings = new List<IfcSpatialElement>();
		}
		public IfcRelServicesBuildings(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSystem RelatingSystem, List<IfcSpatialElement> RelatedBuildings) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingSystem = RelatingSystem;
			this.RelatedBuildings = RelatedBuildings;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSpaceBoundary
	/// <para>ENTITY IfcRelSpaceBoundary</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelSpaceBoundary1stLevel))</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingSpace : IfcSpaceBoundarySelect;</para>
	/// <para>	RelatedBuildingElement : IfcElement;</para>
	/// <para>	ConnectionGeometry : OPTIONAL IfcConnectionGeometry;</para>
	/// <para>	PhysicalOrVirtualBoundary : IfcPhysicalOrVirtualEnum;</para>
	/// <para>	InternalOrExternalBoundary : IfcInternalOrExternalEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPhysOrVirt : ((PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.Physical) </para>
	/// <para>  AND (NOT('IFC4X3_ADD2.IFCVIRTUALELEMENT' IN TYPEOF(RelatedBuildingElement)))) </para>
	/// <para>OR </para>
	/// <para>((PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.Virtual) </para>
	/// <para>  AND (('IFC4X3_ADD2.IFCVIRTUALELEMENT' IN TYPEOF(RelatedBuildingElement)) </para>
	/// <para>  OR   ('IFC4X3_ADD2.IFCOPENINGELEMENT' IN TYPEOF(RelatedBuildingElement)))) </para>
	/// <para>OR </para>
	/// <para>(PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.NotDefined);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSpaceBoundary : IfcRelConnects
	{
		public IfcSpaceBoundarySelect RelatingSpace { get; set; }
		public IfcElement RelatedBuildingElement { get; set; }
		public IfcConnectionGeometry? ConnectionGeometry { get; set; }
		public IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary { get; set; }
		public IfcInternalOrExternalEnum InternalOrExternalBoundary { get; set; }
		public IfcRelSpaceBoundary() : base()
		{
			RelatingSpace = new IfcSpaceBoundarySelect();
			RelatedBuildingElement = new IfcElement();
			PhysicalOrVirtualBoundary = new IfcPhysicalOrVirtualEnum();
			InternalOrExternalBoundary = new IfcInternalOrExternalEnum();
		}
		public IfcRelSpaceBoundary(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpaceBoundarySelect RelatingSpace, IfcElement RelatedBuildingElement, IfcConnectionGeometry ConnectionGeometry, IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum InternalOrExternalBoundary) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingSpace = RelatingSpace;
			this.RelatedBuildingElement = RelatedBuildingElement;
			this.ConnectionGeometry = ConnectionGeometry;
			this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
			this.InternalOrExternalBoundary = InternalOrExternalBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSpaceBoundary1stLevel
	/// <para>ENTITY IfcRelSpaceBoundary1stLevel</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelSpaceBoundary2ndLevel))</para>
	/// <para> SUBTYPE OF (IfcRelSpaceBoundary);</para>
	/// <para>	ParentBoundary : OPTIONAL IfcRelSpaceBoundary1stLevel;</para>
	/// <para> INVERSE</para>
	/// <para>	InnerBoundaries : SET [0:?] OF IfcRelSpaceBoundary1stLevel FOR ParentBoundary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSpaceBoundary1stLevel : IfcRelSpaceBoundary
	{
		public IfcRelSpaceBoundary1stLevel? ParentBoundary { get; set; }
		public IfcRelSpaceBoundary1stLevel() : base()
		{
		}
		public IfcRelSpaceBoundary1stLevel(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpaceBoundarySelect RelatingSpace, IfcElement RelatedBuildingElement, IfcConnectionGeometry ConnectionGeometry, IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel ParentBoundary) : base (GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary)
		{
			this.ParentBoundary = ParentBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSpaceBoundary2ndLevel
	/// <para>ENTITY IfcRelSpaceBoundary2ndLevel</para>
	/// <para> SUBTYPE OF (IfcRelSpaceBoundary1stLevel);</para>
	/// <para>	CorrespondingBoundary : OPTIONAL IfcRelSpaceBoundary2ndLevel;</para>
	/// <para> INVERSE</para>
	/// <para>	Corresponds : SET [0:1] OF IfcRelSpaceBoundary2ndLevel FOR CorrespondingBoundary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSpaceBoundary2ndLevel : IfcRelSpaceBoundary1stLevel
	{
		public IfcRelSpaceBoundary2ndLevel? CorrespondingBoundary { get; set; }
		public IfcRelSpaceBoundary2ndLevel() : base()
		{
		}
		public IfcRelSpaceBoundary2ndLevel(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpaceBoundarySelect RelatingSpace, IfcElement RelatedBuildingElement, IfcConnectionGeometry ConnectionGeometry, IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel ParentBoundary, IfcRelSpaceBoundary2ndLevel CorrespondingBoundary) : base (GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary)
		{
			this.CorrespondingBoundary = CorrespondingBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelVoidsElement
	/// <para>ENTITY IfcRelVoidsElement</para>
	/// <para> SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>	RelatingBuildingElement : IfcElement;</para>
	/// <para>	RelatedOpeningElement : IfcFeatureElementSubtraction;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelVoidsElement : IfcRelDecomposes
	{
		public IfcElement RelatingBuildingElement { get; set; }
		public IfcFeatureElementSubtraction RelatedOpeningElement { get; set; }
		public IfcRelVoidsElement() : base()
		{
			RelatingBuildingElement = new IfcElement();
			RelatedOpeningElement = new IfcFeatureElementSubtraction();
		}
		public IfcRelVoidsElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingBuildingElement, IfcFeatureElementSubtraction RelatedOpeningElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingBuildingElement = RelatingBuildingElement;
			this.RelatedOpeningElement = RelatedOpeningElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelationship
	/// <para>ENTITY IfcRelationship</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRelAssigns</para>
	/// <para>	,IfcRelAssociates</para>
	/// <para>	,IfcRelConnects</para>
	/// <para>	,IfcRelDeclares</para>
	/// <para>	,IfcRelDecomposes</para>
	/// <para>	,IfcRelDefines))</para>
	/// <para> SUBTYPE OF (IfcRoot);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelationship : IfcRoot
	{
		public IfcRelationship() : base()
		{
		}
		public IfcRelationship(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcReparametrisedCompositeCurveSegment
	/// <para>ENTITY IfcReparametrisedCompositeCurveSegment</para>
	/// <para> SUBTYPE OF (IfcCompositeCurveSegment);</para>
	/// <para>	ParamLength : IfcParameterValue;</para>
	/// <para> WHERE</para>
	/// <para>	PositiveLengthParameter : ParamLength > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReparametrisedCompositeCurveSegment : IfcCompositeCurveSegment
	{
		public IfcParameterValue ParamLength { get; set; }
		public IfcReparametrisedCompositeCurveSegment() : base()
		{
			ParamLength = new IfcParameterValue();
		}
		public IfcReparametrisedCompositeCurveSegment(IfcTransitionCode Transition, IfcBoolean SameSense, IfcCurve ParentCurve, IfcParameterValue ParamLength) : base (Transition, SameSense, ParentCurve)
		{
			this.ParamLength = ParamLength;
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentation
	/// <para>ENTITY IfcRepresentation</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcShapeModel</para>
	/// <para>	,IfcStyleModel));</para>
	/// <para>	ContextOfItems : IfcRepresentationContext;</para>
	/// <para>	RepresentationIdentifier : OPTIONAL IfcLabel;</para>
	/// <para>	RepresentationType : OPTIONAL IfcLabel;</para>
	/// <para>	Items : SET [1:?] OF IfcRepresentationItem;</para>
	/// <para> INVERSE</para>
	/// <para>	RepresentationMap : SET [0:1] OF IfcRepresentationMap FOR MappedRepresentation;</para>
	/// <para>	LayerAssignments : SET [0:?] OF IfcPresentationLayerAssignment FOR AssignedItems;</para>
	/// <para>	OfProductRepresentation : SET [0:?] OF IfcProductRepresentation FOR Representations;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRepresentationENTITY, IfcLayeredItem
	{
		public IfcRepresentationContext ContextOfItems { get; set; }
		public IfcLabel? RepresentationIdentifier { get; set; }
		public IfcLabel? RepresentationType { get; set; }
		public List<IfcRepresentationItem> Items { get; set; }
		public IfcRepresentation() : base()
		{
			ContextOfItems = new IfcRepresentationContext();
			Items = new List<IfcRepresentationItem>();
		}
		public IfcRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base ()
		{
			this.ContextOfItems = ContextOfItems;
			this.RepresentationIdentifier = RepresentationIdentifier;
			this.RepresentationType = RepresentationType;
			this.Items = Items;
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentationContext
	/// <para>ENTITY IfcRepresentationContext</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcGeometricRepresentationContext));</para>
	/// <para>	ContextIdentifier : OPTIONAL IfcLabel;</para>
	/// <para>	ContextType : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	RepresentationsInContext : SET [0:?] OF IfcRepresentation FOR ContextOfItems;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRepresentationContextENTITY
	{
		public IfcLabel? ContextIdentifier { get; set; }
		public IfcLabel? ContextType { get; set; }
		public IfcRepresentationContext() : base()
		{
		}
		public IfcRepresentationContext(IfcLabel ContextIdentifier, IfcLabel ContextType) : base ()
		{
			this.ContextIdentifier = ContextIdentifier;
			this.ContextType = ContextType;
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentationItem
	/// <para>ENTITY IfcRepresentationItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcGeometricRepresentationItem</para>
	/// <para>	,IfcMappedItem</para>
	/// <para>	,IfcStyledItem</para>
	/// <para>	,IfcTopologicalRepresentationItem));</para>
	/// <para> INVERSE</para>
	/// <para>	LayerAssignment : SET [0:1] OF IfcPresentationLayerAssignment FOR AssignedItems;</para>
	/// <para>	StyledByItem : SET [0:1] OF IfcStyledItem FOR Item;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRepresentationItemENTITY, IfcLayeredItem
	{
		public IfcRepresentationItem() : base()
		{
		}
		public IfcRepresentationItem() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentationMap;
	/// <para>ENTITY IfcRepresentationMap;</para>
	/// <para>	MappingOrigin : IfcAxis2Placement;</para>
	/// <para>	MappedRepresentation : IfcRepresentation;</para>
	/// <para> INVERSE</para>
	/// <para>	HasShapeAspects : SET [0:?] OF IfcShapeAspect FOR PartOfProductDefinitionShape;</para>
	/// <para>	MapUsage : SET [0:?] OF IfcMappedItem FOR MappingSource;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableMappedRepr : 'IFC4X3_ADD2.IFCSHAPEMODEL' IN TYPEOF(MappedRepresentation);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRepresentationMapENTITY, IfcProductRepresentationSelect
	{
		public IfcAxis2Placement MappingOrigin { get; set; }
		public IfcRepresentation MappedRepresentation { get; set; }
		public IfcRepresentationMap() : base()
		{
			MappingOrigin = new IfcAxis2Placement();
			MappedRepresentation = new IfcRepresentation();
		}
		public IfcRepresentationMap(IfcAxis2Placement MappingOrigin, IfcRepresentation MappedRepresentation) : base ()
		{
			this.MappingOrigin = MappingOrigin;
			this.MappedRepresentation = MappedRepresentation;
		}
	}
	/// <summary>
	/// ENTITY IfcResource
	/// <para>ENTITY IfcResource</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcConstructionResource))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	ResourceOf : SET [0:?] OF IfcRelAssignsToResource FOR RelatingResource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcResource : IfcObject, IfcResourceSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcResource() : base()
		{
		}
		public IfcResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceApprovalRelationship
	/// <para>ENTITY IfcResourceApprovalRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatedResourceObjects : SET [1:?] OF IfcResourceObjectSelect;</para>
	/// <para>	RelatingApproval : IfcApproval;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcResourceApprovalRelationship : IfcResourceLevelRelationship
	{
		public List<IfcResourceObjectSelect> RelatedResourceObjects { get; set; }
		public IfcApproval RelatingApproval { get; set; }
		public IfcResourceApprovalRelationship() : base()
		{
			RelatedResourceObjects = new List<IfcResourceObjectSelect>();
			RelatingApproval = new IfcApproval();
		}
		public IfcResourceApprovalRelationship(IfcLabel Name, IfcText Description, List<IfcResourceObjectSelect> RelatedResourceObjects, IfcApproval RelatingApproval) : base (Name, Description)
		{
			this.RelatedResourceObjects = RelatedResourceObjects;
			this.RelatingApproval = RelatingApproval;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceConstraintRelationship
	/// <para>ENTITY IfcResourceConstraintRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingConstraint : IfcConstraint;</para>
	/// <para>	RelatedResourceObjects : SET [1:?] OF IfcResourceObjectSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcResourceConstraintRelationship : IfcResourceLevelRelationship
	{
		public IfcConstraint RelatingConstraint { get; set; }
		public List<IfcResourceObjectSelect> RelatedResourceObjects { get; set; }
		public IfcResourceConstraintRelationship() : base()
		{
			RelatingConstraint = new IfcConstraint();
			RelatedResourceObjects = new List<IfcResourceObjectSelect>();
		}
		public IfcResourceConstraintRelationship(IfcLabel Name, IfcText Description, IfcConstraint RelatingConstraint, List<IfcResourceObjectSelect> RelatedResourceObjects) : base (Name, Description)
		{
			this.RelatingConstraint = RelatingConstraint;
			this.RelatedResourceObjects = RelatedResourceObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceLevelRelationship
	/// <para>ENTITY IfcResourceLevelRelationship</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcApprovalRelationship</para>
	/// <para>	,IfcCurrencyRelationship</para>
	/// <para>	,IfcDocumentInformationRelationship</para>
	/// <para>	,IfcExternalReferenceRelationship</para>
	/// <para>	,IfcMaterialRelationship</para>
	/// <para>	,IfcOrganizationRelationship</para>
	/// <para>	,IfcPropertyDependencyRelationship</para>
	/// <para>	,IfcResourceApprovalRelationship</para>
	/// <para>	,IfcResourceConstraintRelationship));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcResourceLevelRelationshipENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcResourceLevelRelationship() : base()
		{
		}
		public IfcResourceLevelRelationship(IfcLabel Name, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceTime
	/// <para>ENTITY IfcResourceTime</para>
	/// <para> SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>	ScheduleWork : OPTIONAL IfcDuration;</para>
	/// <para>	ScheduleUsage : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>	ScheduleStart : OPTIONAL IfcDateTime;</para>
	/// <para>	ScheduleFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	ScheduleContour : OPTIONAL IfcLabel;</para>
	/// <para>	LevelingDelay : OPTIONAL IfcDuration;</para>
	/// <para>	IsOverAllocated : OPTIONAL IfcBoolean;</para>
	/// <para>	StatusTime : OPTIONAL IfcDateTime;</para>
	/// <para>	ActualWork : OPTIONAL IfcDuration;</para>
	/// <para>	ActualUsage : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>	ActualStart : OPTIONAL IfcDateTime;</para>
	/// <para>	ActualFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	RemainingWork : OPTIONAL IfcDuration;</para>
	/// <para>	RemainingUsage : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>	Completion : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcResourceTime : IfcSchedulingTime
	{
		public IfcDuration? ScheduleWork { get; set; }
		public IfcPositiveRatioMeasure? ScheduleUsage { get; set; }
		public IfcDateTime? ScheduleStart { get; set; }
		public IfcDateTime? ScheduleFinish { get; set; }
		public IfcLabel? ScheduleContour { get; set; }
		public IfcDuration? LevelingDelay { get; set; }
		public IfcBoolean? IsOverAllocated { get; set; }
		public IfcDateTime? StatusTime { get; set; }
		public IfcDuration? ActualWork { get; set; }
		public IfcPositiveRatioMeasure? ActualUsage { get; set; }
		public IfcDateTime? ActualStart { get; set; }
		public IfcDateTime? ActualFinish { get; set; }
		public IfcDuration? RemainingWork { get; set; }
		public IfcPositiveRatioMeasure? RemainingUsage { get; set; }
		public IfcPositiveRatioMeasure? Completion { get; set; }
		public IfcResourceTime() : base()
		{
		}
		public IfcResourceTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcDuration ScheduleWork, IfcPositiveRatioMeasure ScheduleUsage, IfcDateTime ScheduleStart, IfcDateTime ScheduleFinish, IfcLabel ScheduleContour, IfcDuration LevelingDelay, IfcBoolean IsOverAllocated, IfcDateTime StatusTime, IfcDuration ActualWork, IfcPositiveRatioMeasure ActualUsage, IfcDateTime ActualStart, IfcDateTime ActualFinish, IfcDuration RemainingWork, IfcPositiveRatioMeasure RemainingUsage, IfcPositiveRatioMeasure Completion) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.ScheduleWork = ScheduleWork;
			this.ScheduleUsage = ScheduleUsage;
			this.ScheduleStart = ScheduleStart;
			this.ScheduleFinish = ScheduleFinish;
			this.ScheduleContour = ScheduleContour;
			this.LevelingDelay = LevelingDelay;
			this.IsOverAllocated = IsOverAllocated;
			this.StatusTime = StatusTime;
			this.ActualWork = ActualWork;
			this.ActualUsage = ActualUsage;
			this.ActualStart = ActualStart;
			this.ActualFinish = ActualFinish;
			this.RemainingWork = RemainingWork;
			this.RemainingUsage = RemainingUsage;
			this.Completion = Completion;
		}
	}
	/// <summary>
	/// ENTITY IfcRevolvedAreaSolid
	/// <para>ENTITY IfcRevolvedAreaSolid</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcRevolvedAreaSolidTapered))</para>
	/// <para> SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>	Axis : IfcAxis1Placement;</para>
	/// <para>	Angle : IfcPlaneAngleMeasure;</para>
	/// <para> DERIVE</para>
	/// <para>	 AxisLine : IfcLine := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcCurve() || IfcLine(Axis.Location, </para>
	/// <para>  IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector(Axis.Z,1.0));</para>
	/// <para> WHERE</para>
	/// <para>	AxisDirectionInXY : Axis.Z.DirectionRatios[3] = 0.0;</para>
	/// <para>	AxisStartInXY : ('IFC4X3_ADD2.IFCCARTESIANPOINT' IN TYPEOF(Axis.Location)) AND (Axis.Location\IfcCartesianPoint.Coordinates[3] = 0.0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRevolvedAreaSolid : IfcSweptAreaSolid
	{
		public IfcAxis1Placement Axis { get; set; }
		public IfcPlaneAngleMeasure Angle { get; set; }
		public IfcRevolvedAreaSolid() : base()
		{
			Axis = new IfcAxis1Placement();
			Angle = new IfcPlaneAngleMeasure();
		}
		public IfcRevolvedAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcAxis1Placement Axis, IfcPlaneAngleMeasure Angle) : base (SweptArea, Position)
		{
			this.Axis = Axis;
			this.Angle = Angle;
		}
	}
	/// <summary>
	/// ENTITY IfcRevolvedAreaSolidTapered
	/// <para>ENTITY IfcRevolvedAreaSolidTapered</para>
	/// <para> SUBTYPE OF (IfcRevolvedAreaSolid);</para>
	/// <para>	EndSweptArea : IfcProfileDef;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectProfileAssignment : IfcTaperedSweptAreaProfiles(SELF\IfcSweptAreaSolid.SweptArea, SELF.EndSweptArea);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRevolvedAreaSolidTapered : IfcRevolvedAreaSolid
	{
		public IfcProfileDef EndSweptArea { get; set; }
		public IfcRevolvedAreaSolidTapered() : base()
		{
			EndSweptArea = new IfcProfileDef();
		}
		public IfcRevolvedAreaSolidTapered(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcAxis1Placement Axis, IfcPlaneAngleMeasure Angle, IfcProfileDef EndSweptArea) : base (SweptArea, Position, Axis, Angle)
		{
			this.EndSweptArea = EndSweptArea;
		}
	}
	/// <summary>
	/// ENTITY IfcRightCircularCone
	/// <para>ENTITY IfcRightCircularCone</para>
	/// <para> SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>	Height : IfcPositiveLengthMeasure;</para>
	/// <para>	BottomRadius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRightCircularCone : IfcCsgPrimitive3D
	{
		public IfcPositiveLengthMeasure Height { get; set; }
		public IfcPositiveLengthMeasure BottomRadius { get; set; }
		public IfcRightCircularCone() : base()
		{
			Height = new IfcPositiveLengthMeasure();
			BottomRadius = new IfcPositiveLengthMeasure();
		}
		public IfcRightCircularCone(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Height, IfcPositiveLengthMeasure BottomRadius) : base (Position)
		{
			this.Height = Height;
			this.BottomRadius = BottomRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcRightCircularCylinder
	/// <para>ENTITY IfcRightCircularCylinder</para>
	/// <para> SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>	Height : IfcPositiveLengthMeasure;</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRightCircularCylinder : IfcCsgPrimitive3D
	{
		public IfcPositiveLengthMeasure Height { get; set; }
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcRightCircularCylinder() : base()
		{
			Height = new IfcPositiveLengthMeasure();
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcRightCircularCylinder(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Height, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Height = Height;
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcRigidOperation
	/// <para>ENTITY IfcRigidOperation</para>
	/// <para> SUBTYPE OF (IfcCoordinateOperation);</para>
	/// <para>	FirstCoordinate : IfcMeasureValue;</para>
	/// <para>	SecondCoordinate : IfcMeasureValue;</para>
	/// <para>	Height : OPTIONAL IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	SameCoordinateType : (('IFC4X3_ADD2.IFCLENGTHMEASURE' IN TYPEOF(FirstCoordinate)) AND ('IFC4X3_ADD2.IFCLENGTHMEASURE' IN TYPEOF(SecondCoordinate))) OR (('IFC4X3_ADD2.IFCPLANEANGLEMEASURE' IN TYPEOF(FirstCoordinate)) AND ('IFC4X3_ADD2.IFCPLANEANGLEMEASURE' IN TYPEOF(SecondCoordinate)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRigidOperation : IfcCoordinateOperation
	{
		public IfcMeasureValue FirstCoordinate { get; set; }
		public IfcMeasureValue SecondCoordinate { get; set; }
		public IfcLengthMeasure? Height { get; set; }
		public IfcRigidOperation() : base()
		{
			FirstCoordinate = new IfcMeasureValue();
			SecondCoordinate = new IfcMeasureValue();
		}
		public IfcRigidOperation(IfcCoordinateReferenceSystemSelect SourceCRS, IfcCoordinateReferenceSystem TargetCRS, IfcMeasureValue FirstCoordinate, IfcMeasureValue SecondCoordinate, IfcLengthMeasure Height) : base (SourceCRS, TargetCRS)
		{
			this.FirstCoordinate = FirstCoordinate;
			this.SecondCoordinate = SecondCoordinate;
			this.Height = Height;
		}
	}
	/// <summary>
	/// ENTITY IfcRoad
	/// <para>ENTITY IfcRoad</para>
	/// <para> SUBTYPE OF (IfcFacility);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRoadTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRoadTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRoadTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoad : IfcFacility
	{
		public IfcRoadTypeEnum? PredefinedType { get; set; }
		public IfcRoad() : base()
		{
		}
		public IfcRoad(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcRoadTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRoadPart
	/// <para>ENTITY IfcRoadPart</para>
	/// <para> SUBTYPE OF (IfcFacilityPart);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRoadPartTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRoadPartTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRoadPartTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoadPart : IfcFacilityPart
	{
		public IfcRoadPartTypeEnum? PredefinedType { get; set; }
		public IfcRoadPart() : base()
		{
		}
		public IfcRoadPart(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcFacilityUsageEnum UsageType, IfcRoadPartTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, UsageType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRoof
	/// <para>ENTITY IfcRoof</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRoofTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRoofTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRoofTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCROOFTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoof : IfcBuiltElement
	{
		public IfcRoofTypeEnum? PredefinedType { get; set; }
		public IfcRoof() : base()
		{
		}
		public IfcRoof(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRoofTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRoofType
	/// <para>ENTITY IfcRoofType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcRoofTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcRoofTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRoofTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoofType : IfcBuiltElementType
	{
		public IfcRoofTypeEnum PredefinedType { get; set; }
		public IfcRoofType() : base()
		{
			PredefinedType = new IfcRoofTypeEnum();
		}
		public IfcRoofType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRoofTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRoot
	/// <para>ENTITY IfcRoot</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcObjectDefinition</para>
	/// <para>	,IfcPropertyDefinition</para>
	/// <para>	,IfcRelationship));</para>
	/// <para>	GlobalId : IfcGloballyUniqueId;</para>
	/// <para>	OwnerHistory : OPTIONAL IfcOwnerHistory;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> UNIQUE</para>
	/// <para>	UR1 : GlobalId;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRootENTITY
	{
		public IfcGloballyUniqueId GlobalId { get; set; }
		public IfcOwnerHistory? OwnerHistory { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcRoot() : base()
		{
			GlobalId = new IfcGloballyUniqueId();
		}
		public IfcRoot(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base ()
		{
			this.GlobalId = GlobalId;
			this.OwnerHistory = OwnerHistory;
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcRoundedRectangleProfileDef
	/// <para>ENTITY IfcRoundedRectangleProfileDef</para>
	/// <para> SUBTYPE OF (IfcRectangleProfileDef);</para>
	/// <para>	RoundingRadius : IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidRadius : ((RoundingRadius <= (SELF\IfcRectangleProfileDef.XDim/2.)) AND </para>
	/// <para> (RoundingRadius <= (SELF\IfcRectangleProfileDef.YDim/2.)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoundedRectangleProfileDef : IfcRectangleProfileDef
	{
		public IfcPositiveLengthMeasure RoundingRadius { get; set; }
		public IfcRoundedRectangleProfileDef() : base()
		{
			RoundingRadius = new IfcPositiveLengthMeasure();
		}
		public IfcRoundedRectangleProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim, IfcPositiveLengthMeasure RoundingRadius) : base (ProfileType, ProfileName, Position, XDim, YDim)
		{
			this.RoundingRadius = RoundingRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcSIUnit
	/// <para>ENTITY IfcSIUnit</para>
	/// <para> SUBTYPE OF (IfcNamedUnit);</para>
	/// <para>	Prefix : OPTIONAL IfcSIPrefix;</para>
	/// <para>	Name : IfcSIUnitName;</para>
	/// <para> DERIVE</para>
	/// <para>	 SELF\IfcNamedUnit.Dimensions : IfcDimensionalExponents := IfcDimensionsForSIUnit (SELF.Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSIUnit : IfcNamedUnit
	{
		public IfcSIPrefix? Prefix { get; set; }
		public IfcSIUnitName Name { get; set; }
		public IfcSIUnit() : base()
		{
			Name = new IfcSIUnitName();
		}
		public IfcSIUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcSIPrefix Prefix, IfcSIUnitName Name) : base (Dimensions, UnitType)
		{
			this.Prefix = Prefix;
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcSanitaryTerminal
	/// <para>ENTITY IfcSanitaryTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSanitaryTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSanitaryTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSanitaryTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSANITARYTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSanitaryTerminal : IfcFlowTerminal
	{
		public IfcSanitaryTerminalTypeEnum? PredefinedType { get; set; }
		public IfcSanitaryTerminal() : base()
		{
		}
		public IfcSanitaryTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSanitaryTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSanitaryTerminalType
	/// <para>ENTITY IfcSanitaryTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcSanitaryTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSanitaryTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSanitaryTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSanitaryTerminalType : IfcFlowTerminalType
	{
		public IfcSanitaryTerminalTypeEnum PredefinedType { get; set; }
		public IfcSanitaryTerminalType() : base()
		{
			PredefinedType = new IfcSanitaryTerminalTypeEnum();
		}
		public IfcSanitaryTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSanitaryTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSchedulingTime
	/// <para>ENTITY IfcSchedulingTime</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcEventTime</para>
	/// <para>	,IfcLagTime</para>
	/// <para>	,IfcResourceTime</para>
	/// <para>	,IfcTaskTime</para>
	/// <para>	,IfcWorkTime));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	DataOrigin : OPTIONAL IfcDataOriginEnum;</para>
	/// <para>	UserDefinedDataOrigin : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSchedulingTimeENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcDataOriginEnum? DataOrigin { get; set; }
		public IfcLabel? UserDefinedDataOrigin { get; set; }
		public IfcSchedulingTime() : base()
		{
		}
		public IfcSchedulingTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin) : base ()
		{
			this.Name = Name;
			this.DataOrigin = DataOrigin;
			this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		}
	}
	/// <summary>
	/// ENTITY IfcSeamCurve
	/// <para>ENTITY IfcSeamCurve</para>
	/// <para> SUBTYPE OF (IfcSurfaceCurve);</para>
	/// <para> WHERE</para>
	/// <para>	SameSurface : IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[1]) = IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[2]);</para>
	/// <para>	TwoPCurves : SIZEOF(SELF\IfcSurfaceCurve.AssociatedGeometry) = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSeamCurve : IfcSurfaceCurve
	{
		public IfcSeamCurve() : base()
		{
		}
		public IfcSeamCurve(IfcCurve Curve3D, List<IfcPcurve> AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation MasterRepresentation) : base (Curve3D, AssociatedGeometry, MasterRepresentation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSecondOrderPolynomialSpiral
	/// <para>ENTITY IfcSecondOrderPolynomialSpiral</para>
	/// <para> SUBTYPE OF (IfcSpiral);</para>
	/// <para>	QuadraticTerm : IfcLengthMeasure;</para>
	/// <para>	LinearTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ConstantTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSecondOrderPolynomialSpiral : IfcSpiral
	{
		public IfcLengthMeasure QuadraticTerm { get; set; }
		public IfcLengthMeasure? LinearTerm { get; set; }
		public IfcLengthMeasure? ConstantTerm { get; set; }
		public IfcSecondOrderPolynomialSpiral() : base()
		{
			QuadraticTerm = new IfcLengthMeasure();
		}
		public IfcSecondOrderPolynomialSpiral(IfcAxis2Placement Position, IfcLengthMeasure QuadraticTerm, IfcLengthMeasure LinearTerm, IfcLengthMeasure ConstantTerm) : base (Position)
		{
			this.QuadraticTerm = QuadraticTerm;
			this.LinearTerm = LinearTerm;
			this.ConstantTerm = ConstantTerm;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionProperties
	/// <para>ENTITY IfcSectionProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedProperties);</para>
	/// <para>	SectionType : IfcSectionTypeEnum;</para>
	/// <para>	StartProfile : IfcProfileDef;</para>
	/// <para>	EndProfile : OPTIONAL IfcProfileDef;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionProperties : IfcPreDefinedProperties
	{
		public IfcSectionTypeEnum SectionType { get; set; }
		public IfcProfileDef StartProfile { get; set; }
		public IfcProfileDef? EndProfile { get; set; }
		public IfcSectionProperties() : base()
		{
			SectionType = new IfcSectionTypeEnum();
			StartProfile = new IfcProfileDef();
		}
		public IfcSectionProperties(IfcSectionTypeEnum SectionType, IfcProfileDef StartProfile, IfcProfileDef EndProfile) : base ()
		{
			this.SectionType = SectionType;
			this.StartProfile = StartProfile;
			this.EndProfile = EndProfile;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionReinforcementProperties
	/// <para>ENTITY IfcSectionReinforcementProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedProperties);</para>
	/// <para>	LongitudinalStartPosition : IfcLengthMeasure;</para>
	/// <para>	LongitudinalEndPosition : IfcLengthMeasure;</para>
	/// <para>	TransversePosition : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ReinforcementRole : IfcReinforcingBarRoleEnum;</para>
	/// <para>	SectionDefinition : IfcSectionProperties;</para>
	/// <para>	CrossSectionReinforcementDefinitions : SET [1:?] OF IfcReinforcementBarProperties;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionReinforcementProperties : IfcPreDefinedProperties
	{
		public IfcLengthMeasure LongitudinalStartPosition { get; set; }
		public IfcLengthMeasure LongitudinalEndPosition { get; set; }
		public IfcLengthMeasure? TransversePosition { get; set; }
		public IfcReinforcingBarRoleEnum ReinforcementRole { get; set; }
		public IfcSectionProperties SectionDefinition { get; set; }
		public List<IfcReinforcementBarProperties> CrossSectionReinforcementDefinitions { get; set; }
		public IfcSectionReinforcementProperties() : base()
		{
			LongitudinalStartPosition = new IfcLengthMeasure();
			LongitudinalEndPosition = new IfcLengthMeasure();
			ReinforcementRole = new IfcReinforcingBarRoleEnum();
			SectionDefinition = new IfcSectionProperties();
			CrossSectionReinforcementDefinitions = new List<IfcReinforcementBarProperties>();
		}
		public IfcSectionReinforcementProperties(IfcLengthMeasure LongitudinalStartPosition, IfcLengthMeasure LongitudinalEndPosition, IfcLengthMeasure TransversePosition, IfcReinforcingBarRoleEnum ReinforcementRole, IfcSectionProperties SectionDefinition, List<IfcReinforcementBarProperties> CrossSectionReinforcementDefinitions) : base ()
		{
			this.LongitudinalStartPosition = LongitudinalStartPosition;
			this.LongitudinalEndPosition = LongitudinalEndPosition;
			this.TransversePosition = TransversePosition;
			this.ReinforcementRole = ReinforcementRole;
			this.SectionDefinition = SectionDefinition;
			this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionedSolid
	/// <para>ENTITY IfcSectionedSolid</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcSectionedSolidHorizontal))</para>
	/// <para> SUBTYPE OF (IfcSolidModel);</para>
	/// <para>	Directrix : IfcCurve;</para>
	/// <para>	CrossSections : LIST [2:?] OF IfcProfileDef;</para>
	/// <para> WHERE</para>
	/// <para>	ConsistentProfileTypes : SIZEOF(QUERY(temp <* CrossSections | CrossSections[1].ProfileType <> temp.ProfileType)) = 0;</para>
	/// <para>	DirectrixIs3D : Directrix.Dim = 3;</para>
	/// <para>	SectionsSameType : SIZEOF(QUERY(temp <* CrossSections | TYPEOF(CrossSections[1]) :<>: TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSectionedSolid : IfcSolidModel
	{
		public IfcCurve Directrix { get; set; }
		public List<IfcProfileDef> CrossSections { get; set; }
		public IfcSectionedSolid() : base()
		{
			Directrix = new IfcCurve();
			CrossSections = new List<IfcProfileDef>();
		}
		public IfcSectionedSolid(IfcCurve Directrix, List<IfcProfileDef> CrossSections) : base ()
		{
			this.Directrix = Directrix;
			this.CrossSections = CrossSections;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionedSolidHorizontal
	/// <para>ENTITY IfcSectionedSolidHorizontal</para>
	/// <para> SUBTYPE OF (IfcSectionedSolid);</para>
	/// <para>	CrossSectionPositions : LIST [2:?] OF IfcAxis2PlacementLinear;</para>
	/// <para> WHERE</para>
	/// <para>	CorrespondingSectionPositions : SIZEOF(CrossSections) = SIZEOF(CrossSectionPositions);</para>
	/// <para>	NoLongitudinalOffsets : SIZEOF(QUERY(temp <* CrossSectionPositions | EXISTS(temp.Location.OffsetLongitudinal))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionedSolidHorizontal : IfcSectionedSolid
	{
		public List<IfcAxis2PlacementLinear> CrossSectionPositions { get; set; }
		public IfcSectionedSolidHorizontal() : base()
		{
			CrossSectionPositions = new List<IfcAxis2PlacementLinear>();
		}
		public IfcSectionedSolidHorizontal(IfcCurve Directrix, List<IfcProfileDef> CrossSections, List<IfcAxis2PlacementLinear> CrossSectionPositions) : base (Directrix, CrossSections)
		{
			this.CrossSectionPositions = CrossSectionPositions;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionedSpine
	/// <para>ENTITY IfcSectionedSpine</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	SpineCurve : IfcCompositeCurve;</para>
	/// <para>	CrossSections : LIST [2:?] OF IfcProfileDef;</para>
	/// <para>	CrossSectionPositions : LIST [2:?] OF IfcAxis2Placement3D;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := 3;</para>
	/// <para> WHERE</para>
	/// <para>	ConsistentProfileTypes : SIZEOF(QUERY(temp <* CrossSections | CrossSections[1].ProfileType <> temp.ProfileType)) = 0;</para>
	/// <para>	CorrespondingSectionPositions : SIZEOF(CrossSections) = SIZEOF(CrossSectionPositions);</para>
	/// <para>	SpineCurveDim : SpineCurve.Dim = 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionedSpine : IfcGeometricRepresentationItem
	{
		public IfcCompositeCurve SpineCurve { get; set; }
		public List<IfcProfileDef> CrossSections { get; set; }
		public List<IfcAxis2Placement3D> CrossSectionPositions { get; set; }
		public IfcSectionedSpine() : base()
		{
			SpineCurve = new IfcCompositeCurve();
			CrossSections = new List<IfcProfileDef>();
			CrossSectionPositions = new List<IfcAxis2Placement3D>();
		}
		public IfcSectionedSpine(IfcCompositeCurve SpineCurve, List<IfcProfileDef> CrossSections, List<IfcAxis2Placement3D> CrossSectionPositions) : base ()
		{
			this.SpineCurve = SpineCurve;
			this.CrossSections = CrossSections;
			this.CrossSectionPositions = CrossSectionPositions;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionedSurface
	/// <para>ENTITY IfcSectionedSurface</para>
	/// <para> SUBTYPE OF (IfcSurface);</para>
	/// <para>	Directrix : IfcCurve;</para>
	/// <para>	CrossSectionPositions : LIST [2:?] OF IfcAxis2PlacementLinear;</para>
	/// <para>	CrossSections : LIST [2:?] OF IfcProfileDef;</para>
	/// <para> WHERE</para>
	/// <para>	AreaProfileTypes : SIZEOF(QUERY(temp <* CrossSections | temp.ProfileType = IfcProfileTypeEnum.CURVE)) <> 0;</para>
	/// <para>	CorrespondingSectionPositions : SIZEOF(CrossSections) = SIZEOF(CrossSectionPositions);</para>
	/// <para>	DirectrixIs3D : Directrix.Dim = 3;</para>
	/// <para>	NoOffsets : SIZEOF(QUERY(temp <* CrossSectionPositions | EXISTS(temp.Location.OffsetLateral) OR EXISTS(temp.Location.OffsetVertical) OR EXISTS(temp.Location.OffsetLongitudinal))) = 0;</para>
	/// <para>	SectionsSameType : SIZEOF(QUERY(temp <* CrossSections | TYPEOF(CrossSections[1]) :<>: TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionedSurface : IfcSurface
	{
		public IfcCurve Directrix { get; set; }
		public List<IfcAxis2PlacementLinear> CrossSectionPositions { get; set; }
		public List<IfcProfileDef> CrossSections { get; set; }
		public IfcSectionedSurface() : base()
		{
			Directrix = new IfcCurve();
			CrossSectionPositions = new List<IfcAxis2PlacementLinear>();
			CrossSections = new List<IfcProfileDef>();
		}
		public IfcSectionedSurface(IfcCurve Directrix, List<IfcAxis2PlacementLinear> CrossSectionPositions, List<IfcProfileDef> CrossSections) : base ()
		{
			this.Directrix = Directrix;
			this.CrossSectionPositions = CrossSectionPositions;
			this.CrossSections = CrossSections;
		}
	}
	/// <summary>
	/// ENTITY IfcSegment
	/// <para>ENTITY IfcSegment</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCompositeCurveSegment</para>
	/// <para>	,IfcCurveSegment))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Transition : IfcTransitionCode;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := IfcSegmentDim(SELF);</para>
	/// <para> INVERSE</para>
	/// <para>	UsingCurves : SET [1:?] OF IfcCompositeCurve FOR Segments;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSegment : IfcGeometricRepresentationItem
	{
		public IfcTransitionCode Transition { get; set; }
		public IfcSegment() : base()
		{
			Transition = new IfcTransitionCode();
		}
		public IfcSegment(IfcTransitionCode Transition) : base ()
		{
			this.Transition = Transition;
		}
	}
	/// <summary>
	/// ENTITY IfcSegmentedReferenceCurve
	/// <para>ENTITY IfcSegmentedReferenceCurve</para>
	/// <para> SUBTYPE OF (IfcCompositeCurve);</para>
	/// <para>	BaseCurve : IfcBoundedCurve;</para>
	/// <para>	EndPoint : OPTIONAL IfcPlacement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSegmentedReferenceCurve : IfcCompositeCurve
	{
		public IfcBoundedCurve BaseCurve { get; set; }
		public IfcPlacement? EndPoint { get; set; }
		public IfcSegmentedReferenceCurve() : base()
		{
			BaseCurve = new IfcBoundedCurve();
		}
		public IfcSegmentedReferenceCurve(List<IfcSegment> Segments, IfcLogical SelfIntersect, IfcBoundedCurve BaseCurve, IfcPlacement EndPoint) : base (Segments, SelfIntersect)
		{
			this.BaseCurve = BaseCurve;
			this.EndPoint = EndPoint;
		}
	}
	/// <summary>
	/// ENTITY IfcSensor
	/// <para>ENTITY IfcSensor</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSensorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSensorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSensorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSENSORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSensor : IfcDistributionControlElement
	{
		public IfcSensorTypeEnum? PredefinedType { get; set; }
		public IfcSensor() : base()
		{
		}
		public IfcSensor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSensorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSensorType
	/// <para>ENTITY IfcSensorType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcSensorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSensorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSensorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSensorType : IfcDistributionControlElementType
	{
		public IfcSensorTypeEnum PredefinedType { get; set; }
		public IfcSensorType() : base()
		{
			PredefinedType = new IfcSensorTypeEnum();
		}
		public IfcSensorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSensorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSeventhOrderPolynomialSpiral
	/// <para>ENTITY IfcSeventhOrderPolynomialSpiral</para>
	/// <para> SUBTYPE OF (IfcSpiral);</para>
	/// <para>	SepticTerm : IfcLengthMeasure;</para>
	/// <para>	SexticTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	QuinticTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	QuarticTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	CubicTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	QuadraticTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LinearTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ConstantTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSeventhOrderPolynomialSpiral : IfcSpiral
	{
		public IfcLengthMeasure SepticTerm { get; set; }
		public IfcLengthMeasure? SexticTerm { get; set; }
		public IfcLengthMeasure? QuinticTerm { get; set; }
		public IfcLengthMeasure? QuarticTerm { get; set; }
		public IfcLengthMeasure? CubicTerm { get; set; }
		public IfcLengthMeasure? QuadraticTerm { get; set; }
		public IfcLengthMeasure? LinearTerm { get; set; }
		public IfcLengthMeasure? ConstantTerm { get; set; }
		public IfcSeventhOrderPolynomialSpiral() : base()
		{
			SepticTerm = new IfcLengthMeasure();
		}
		public IfcSeventhOrderPolynomialSpiral(IfcAxis2Placement Position, IfcLengthMeasure SepticTerm, IfcLengthMeasure SexticTerm, IfcLengthMeasure QuinticTerm, IfcLengthMeasure QuarticTerm, IfcLengthMeasure CubicTerm, IfcLengthMeasure QuadraticTerm, IfcLengthMeasure LinearTerm, IfcLengthMeasure ConstantTerm) : base (Position)
		{
			this.SepticTerm = SepticTerm;
			this.SexticTerm = SexticTerm;
			this.QuinticTerm = QuinticTerm;
			this.QuarticTerm = QuarticTerm;
			this.CubicTerm = CubicTerm;
			this.QuadraticTerm = QuadraticTerm;
			this.LinearTerm = LinearTerm;
			this.ConstantTerm = ConstantTerm;
		}
	}
	/// <summary>
	/// ENTITY IfcShadingDevice
	/// <para>ENTITY IfcShadingDevice</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcShadingDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcShadingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcShadingDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSHADINGDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShadingDevice : IfcBuiltElement
	{
		public IfcShadingDeviceTypeEnum? PredefinedType { get; set; }
		public IfcShadingDevice() : base()
		{
		}
		public IfcShadingDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcShadingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcShadingDeviceType
	/// <para>ENTITY IfcShadingDeviceType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcShadingDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcShadingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcShadingDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShadingDeviceType : IfcBuiltElementType
	{
		public IfcShadingDeviceTypeEnum PredefinedType { get; set; }
		public IfcShadingDeviceType() : base()
		{
			PredefinedType = new IfcShadingDeviceTypeEnum();
		}
		public IfcShadingDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcShadingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcShapeAspect;
	/// <para>ENTITY IfcShapeAspect;</para>
	/// <para>	ShapeRepresentations : LIST [1:?] OF IfcShapeModel;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	ProductDefinitional : IfcLogical;</para>
	/// <para>	PartOfProductDefinitionShape : OPTIONAL IfcProductRepresentationSelect;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShapeAspectENTITY, IfcResourceObjectSelect
	{
		public List<IfcShapeModel> ShapeRepresentations { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcLogical ProductDefinitional { get; set; }
		public IfcProductRepresentationSelect? PartOfProductDefinitionShape { get; set; }
		public IfcShapeAspect() : base()
		{
			ShapeRepresentations = new List<IfcShapeModel>();
			ProductDefinitional = new IfcLogical();
		}
		public IfcShapeAspect(List<IfcShapeModel> ShapeRepresentations, IfcLabel Name, IfcText Description, IfcLogical ProductDefinitional, IfcProductRepresentationSelect PartOfProductDefinitionShape) : base ()
		{
			this.ShapeRepresentations = ShapeRepresentations;
			this.Name = Name;
			this.Description = Description;
			this.ProductDefinitional = ProductDefinitional;
			this.PartOfProductDefinitionShape = PartOfProductDefinitionShape;
		}
	}
	/// <summary>
	/// ENTITY IfcShapeModel
	/// <para>ENTITY IfcShapeModel</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcShapeRepresentation</para>
	/// <para>	,IfcTopologyRepresentation))</para>
	/// <para> SUBTYPE OF (IfcRepresentation);</para>
	/// <para> INVERSE</para>
	/// <para>	OfShapeAspect : SET [0:1] OF IfcShapeAspect FOR ShapeRepresentations;</para>
	/// <para> WHERE</para>
	/// <para>	WR11 : (SIZEOF(SELF\IfcRepresentation.OfProductRepresentation) = 1) XOR </para>
	/// <para>(SIZEOF(SELF\IfcRepresentation.RepresentationMap) = 1) XOR</para>
	/// <para>(SIZEOF(OfShapeAspect) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcShapeModel : IfcRepresentation
	{
		public IfcShapeModel() : base()
		{
		}
		public IfcShapeModel(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcShapeRepresentation
	/// <para>ENTITY IfcShapeRepresentation</para>
	/// <para> SUBTYPE OF (IfcShapeModel);</para>
	/// <para> WHERE</para>
	/// <para>	CorrectContext : 'IFC4X3_ADD2.IFCGEOMETRICREPRESENTATIONCONTEXT' </para>
	/// <para>IN TYPEOF(SELF\IfcRepresentation.ContextOfItems);</para>
	/// <para>	CorrectItemsForType : IfcShapeRepresentationTypes(SELF\IfcRepresentation.RepresentationType, SELF\IfcRepresentation.Items);</para>
	/// <para>	HasRepresentationIdentifier : EXISTS(SELF\IfcRepresentation.RepresentationIdentifier);</para>
	/// <para>	HasRepresentationType : EXISTS(SELF\IfcRepresentation.RepresentationType);</para>
	/// <para>	NoTopologicalItem : SIZEOF(QUERY(temp <* Items | </para>
	/// <para>  ('IFC4X3_ADD2.IFCTOPOLOGICALREPRESENTATIONITEM' IN TYPEOF(temp))</para>
	/// <para>    AND (NOT(SIZEOF(</para>
	/// <para>      ['IFC4X3_ADD2.IFCVERTEXPOINT',</para>
	/// <para>       'IFC4X3_ADD2.IFCEDGECURVE',</para>
	/// <para>       'IFC4X3_ADD2.IFCFACESURFACE'] * TYPEOF(temp)) = 1))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShapeRepresentation : IfcShapeModel
	{
		public IfcShapeRepresentation() : base()
		{
		}
		public IfcShapeRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcShellBasedSurfaceModel
	/// <para>ENTITY IfcShellBasedSurfaceModel</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	SbsmBoundary : SET [1:?] OF IfcShell;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShellBasedSurfaceModel : IfcGeometricRepresentationItem
	{
		public List<IfcShell> SbsmBoundary { get; set; }
		public IfcShellBasedSurfaceModel() : base()
		{
			SbsmBoundary = new List<IfcShell>();
		}
		public IfcShellBasedSurfaceModel(List<IfcShell> SbsmBoundary) : base ()
		{
			this.SbsmBoundary = SbsmBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcSign
	/// <para>ENTITY IfcSign</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSignTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSignTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSignTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSIGNTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSign : IfcElementComponent
	{
		public IfcSignTypeEnum? PredefinedType { get; set; }
		public IfcSign() : base()
		{
		}
		public IfcSign(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSignTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSignType
	/// <para>ENTITY IfcSignType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcSignTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSignTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSignTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSignType : IfcElementComponentType
	{
		public IfcSignTypeEnum PredefinedType { get; set; }
		public IfcSignType() : base()
		{
			PredefinedType = new IfcSignTypeEnum();
		}
		public IfcSignType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSignTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSignal
	/// <para>ENTITY IfcSignal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSignalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSignalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSignalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSIGNALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSignal : IfcFlowTerminal
	{
		public IfcSignalTypeEnum? PredefinedType { get; set; }
		public IfcSignal() : base()
		{
		}
		public IfcSignal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSignalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSignalType
	/// <para>ENTITY IfcSignalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcSignalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSignalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSignalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSignalType : IfcFlowTerminalType
	{
		public IfcSignalTypeEnum PredefinedType { get; set; }
		public IfcSignalType() : base()
		{
			PredefinedType = new IfcSignalTypeEnum();
		}
		public IfcSignalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSignalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSimpleProperty
	/// <para>ENTITY IfcSimpleProperty</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcPropertyBoundedValue</para>
	/// <para>	,IfcPropertyEnumeratedValue</para>
	/// <para>	,IfcPropertyListValue</para>
	/// <para>	,IfcPropertyReferenceValue</para>
	/// <para>	,IfcPropertySingleValue</para>
	/// <para>	,IfcPropertyTableValue))</para>
	/// <para> SUBTYPE OF (IfcProperty);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSimpleProperty : IfcProperty
	{
		public IfcSimpleProperty() : base()
		{
		}
		public IfcSimpleProperty(IfcIdentifier Name, IfcText Specification) : base (Name, Specification)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSimplePropertyTemplate
	/// <para>ENTITY IfcSimplePropertyTemplate</para>
	/// <para> SUBTYPE OF (IfcPropertyTemplate);</para>
	/// <para>	TemplateType : OPTIONAL IfcSimplePropertyTemplateTypeEnum;</para>
	/// <para>	PrimaryMeasureType : OPTIONAL IfcLabel;</para>
	/// <para>	SecondaryMeasureType : OPTIONAL IfcLabel;</para>
	/// <para>	Enumerators : OPTIONAL IfcPropertyEnumeration;</para>
	/// <para>	PrimaryUnit : OPTIONAL IfcUnit;</para>
	/// <para>	SecondaryUnit : OPTIONAL IfcUnit;</para>
	/// <para>	Expression : OPTIONAL IfcLabel;</para>
	/// <para>	AccessState : OPTIONAL IfcStateEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSimplePropertyTemplate : IfcPropertyTemplate
	{
		public IfcSimplePropertyTemplateTypeEnum? TemplateType { get; set; }
		public IfcLabel? PrimaryMeasureType { get; set; }
		public IfcLabel? SecondaryMeasureType { get; set; }
		public IfcPropertyEnumeration? Enumerators { get; set; }
		public IfcUnit? PrimaryUnit { get; set; }
		public IfcUnit? SecondaryUnit { get; set; }
		public IfcLabel? Expression { get; set; }
		public IfcStateEnum? AccessState { get; set; }
		public IfcSimplePropertyTemplate() : base()
		{
		}
		public IfcSimplePropertyTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSimplePropertyTemplateTypeEnum TemplateType, IfcLabel PrimaryMeasureType, IfcLabel SecondaryMeasureType, IfcPropertyEnumeration Enumerators, IfcUnit PrimaryUnit, IfcUnit SecondaryUnit, IfcLabel Expression, IfcStateEnum AccessState) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.TemplateType = TemplateType;
			this.PrimaryMeasureType = PrimaryMeasureType;
			this.SecondaryMeasureType = SecondaryMeasureType;
			this.Enumerators = Enumerators;
			this.PrimaryUnit = PrimaryUnit;
			this.SecondaryUnit = SecondaryUnit;
			this.Expression = Expression;
			this.AccessState = AccessState;
		}
	}
	/// <summary>
	/// ENTITY IfcSineSpiral
	/// <para>ENTITY IfcSineSpiral</para>
	/// <para> SUBTYPE OF (IfcSpiral);</para>
	/// <para>	SineTerm : IfcLengthMeasure;</para>
	/// <para>	LinearTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ConstantTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSineSpiral : IfcSpiral
	{
		public IfcLengthMeasure SineTerm { get; set; }
		public IfcLengthMeasure? LinearTerm { get; set; }
		public IfcLengthMeasure? ConstantTerm { get; set; }
		public IfcSineSpiral() : base()
		{
			SineTerm = new IfcLengthMeasure();
		}
		public IfcSineSpiral(IfcAxis2Placement Position, IfcLengthMeasure SineTerm, IfcLengthMeasure LinearTerm, IfcLengthMeasure ConstantTerm) : base (Position)
		{
			this.SineTerm = SineTerm;
			this.LinearTerm = LinearTerm;
			this.ConstantTerm = ConstantTerm;
		}
	}
	/// <summary>
	/// ENTITY IfcSite
	/// <para>ENTITY IfcSite</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>	RefLatitude : OPTIONAL IfcCompoundPlaneAngleMeasure;</para>
	/// <para>	RefLongitude : OPTIONAL IfcCompoundPlaneAngleMeasure;</para>
	/// <para>	RefElevation : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LandTitleNumber : OPTIONAL IfcLabel;</para>
	/// <para>	SiteAddress : OPTIONAL IfcPostalAddress;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSite : IfcSpatialStructureElement
	{
		public IfcCompoundPlaneAngleMeasure? RefLatitude { get; set; }
		public IfcCompoundPlaneAngleMeasure? RefLongitude { get; set; }
		public IfcLengthMeasure? RefElevation { get; set; }
		public IfcLabel? LandTitleNumber { get; set; }
		public IfcPostalAddress? SiteAddress { get; set; }
		public IfcSite() : base()
		{
		}
		public IfcSite(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcCompoundPlaneAngleMeasure RefLatitude, IfcCompoundPlaneAngleMeasure RefLongitude, IfcLengthMeasure RefElevation, IfcLabel LandTitleNumber, IfcPostalAddress SiteAddress) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.RefLatitude = RefLatitude;
			this.RefLongitude = RefLongitude;
			this.RefElevation = RefElevation;
			this.LandTitleNumber = LandTitleNumber;
			this.SiteAddress = SiteAddress;
		}
	}
	/// <summary>
	/// ENTITY IfcSlab
	/// <para>ENTITY IfcSlab</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSlabTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSlabTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSlabTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSLABTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlab : IfcBuiltElement
	{
		public IfcSlabTypeEnum? PredefinedType { get; set; }
		public IfcSlab() : base()
		{
		}
		public IfcSlab(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSlabTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSlabType
	/// <para>ENTITY IfcSlabType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcSlabTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSlabTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSlabTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlabType : IfcBuiltElementType
	{
		public IfcSlabTypeEnum PredefinedType { get; set; }
		public IfcSlabType() : base()
		{
			PredefinedType = new IfcSlabTypeEnum();
		}
		public IfcSlabType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSlabTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSlippageConnectionCondition
	/// <para>ENTITY IfcSlippageConnectionCondition</para>
	/// <para> SUBTYPE OF (IfcStructuralConnectionCondition);</para>
	/// <para>	SlippageX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	SlippageY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	SlippageZ : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlippageConnectionCondition : IfcStructuralConnectionCondition
	{
		public IfcLengthMeasure? SlippageX { get; set; }
		public IfcLengthMeasure? SlippageY { get; set; }
		public IfcLengthMeasure? SlippageZ { get; set; }
		public IfcSlippageConnectionCondition() : base()
		{
		}
		public IfcSlippageConnectionCondition(IfcLabel Name, IfcLengthMeasure SlippageX, IfcLengthMeasure SlippageY, IfcLengthMeasure SlippageZ) : base (Name)
		{
			this.SlippageX = SlippageX;
			this.SlippageY = SlippageY;
			this.SlippageZ = SlippageZ;
		}
	}
	/// <summary>
	/// ENTITY IfcSolarDevice
	/// <para>ENTITY IfcSolarDevice</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSolarDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSolarDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSolarDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSOLARDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSolarDevice : IfcEnergyConversionDevice
	{
		public IfcSolarDeviceTypeEnum? PredefinedType { get; set; }
		public IfcSolarDevice() : base()
		{
		}
		public IfcSolarDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSolarDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSolarDeviceType
	/// <para>ENTITY IfcSolarDeviceType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcSolarDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSolarDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSolarDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSolarDeviceType : IfcEnergyConversionDeviceType
	{
		public IfcSolarDeviceTypeEnum PredefinedType { get; set; }
		public IfcSolarDeviceType() : base()
		{
			PredefinedType = new IfcSolarDeviceTypeEnum();
		}
		public IfcSolarDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSolarDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSolidModel
	/// <para>ENTITY IfcSolidModel</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcCsgSolid</para>
	/// <para>	,IfcManifoldSolidBrep</para>
	/// <para>	,IfcSectionedSolid</para>
	/// <para>	,IfcSweptAreaSolid</para>
	/// <para>	,IfcSweptDiskSolid))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSolidModel : IfcGeometricRepresentationItem, IfcBooleanOperand, IfcSolidOrShell
	{
		public IfcSolidModel() : base()
		{
		}
		public IfcSolidModel() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSpace
	/// <para>ENTITY IfcSpace</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSpaceTypeEnum;</para>
	/// <para>	ElevationWithFlooring : OPTIONAL IfcLengthMeasure;</para>
	/// <para> INVERSE</para>
	/// <para>	HasCoverings : SET [0:?] OF IfcRelCoversSpaces FOR RelatingSpace;</para>
	/// <para>	BoundedBy : SET [0:?] OF IfcRelSpaceBoundary FOR RelatingSpace;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSpaceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSpaceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSPACETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpace : IfcSpatialStructureElement, IfcSpaceBoundarySelect
	{
		public IfcSpaceTypeEnum? PredefinedType { get; set; }
		public IfcLengthMeasure? ElevationWithFlooring { get; set; }
		public IfcSpace() : base()
		{
		}
		public IfcSpace(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcSpaceTypeEnum PredefinedType, IfcLengthMeasure ElevationWithFlooring) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.PredefinedType = PredefinedType;
			this.ElevationWithFlooring = ElevationWithFlooring;
		}
	}
	/// <summary>
	/// ENTITY IfcSpaceHeater
	/// <para>ENTITY IfcSpaceHeater</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSpaceHeaterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSpaceHeaterTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSpaceHeaterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSPACEHEATERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpaceHeater : IfcFlowTerminal
	{
		public IfcSpaceHeaterTypeEnum? PredefinedType { get; set; }
		public IfcSpaceHeater() : base()
		{
		}
		public IfcSpaceHeater(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSpaceHeaterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpaceHeaterType
	/// <para>ENTITY IfcSpaceHeaterType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcSpaceHeaterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSpaceHeaterTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSpaceHeaterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpaceHeaterType : IfcFlowTerminalType
	{
		public IfcSpaceHeaterTypeEnum PredefinedType { get; set; }
		public IfcSpaceHeaterType() : base()
		{
			PredefinedType = new IfcSpaceHeaterTypeEnum();
		}
		public IfcSpaceHeaterType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSpaceHeaterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpaceType
	/// <para>ENTITY IfcSpaceType</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElementType);</para>
	/// <para>	PredefinedType : IfcSpaceTypeEnum;</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSpaceTypeEnum.USERDEFINED) OR </para>
	/// <para>((PredefinedType = IfcSpaceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcSpatialElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpaceType : IfcSpatialStructureElementType
	{
		public IfcSpaceTypeEnum PredefinedType { get; set; }
		public IfcLabel? LongName { get; set; }
		public IfcSpaceType() : base()
		{
			PredefinedType = new IfcSpaceTypeEnum();
		}
		public IfcSpaceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSpaceTypeEnum PredefinedType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialElement
	/// <para>ENTITY IfcSpatialElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcExternalSpatialStructureElement</para>
	/// <para>	,IfcSpatialStructureElement</para>
	/// <para>	,IfcSpatialZone))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ContainsElements : SET [0:?] OF IfcRelContainedInSpatialStructure FOR RelatingStructure;</para>
	/// <para>	ServicedBySystems : SET [0:?] OF IfcRelServicesBuildings FOR RelatedBuildings;</para>
	/// <para>	ReferencesElements : SET [0:?] OF IfcRelReferencedInSpatialStructure FOR RelatingStructure;</para>
	/// <para>	IsInterferedByElements : SET [0:?] OF IfcRelInterferesElements FOR RelatedElement;</para>
	/// <para>	InterferesElements : SET [0:?] OF IfcRelInterferesElements FOR RelatingElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialElement : IfcProduct, IfcInterferenceSelect
	{
		public IfcLabel? LongName { get; set; }
		public IfcSpatialElement() : base()
		{
		}
		public IfcSpatialElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialElementType
	/// <para>ENTITY IfcSpatialElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcSpatialStructureElementType</para>
	/// <para>	,IfcSpatialZoneType))</para>
	/// <para> SUBTYPE OF (IfcTypeProduct);</para>
	/// <para>	ElementType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialElementType : IfcTypeProduct
	{
		public IfcLabel? ElementType { get; set; }
		public IfcSpatialElementType() : base()
		{
		}
		public IfcSpatialElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.ElementType = ElementType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialStructureElement
	/// <para>ENTITY IfcSpatialStructureElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBuildingStorey</para>
	/// <para>	,IfcFacility</para>
	/// <para>	,IfcFacilityPart</para>
	/// <para>	,IfcSite</para>
	/// <para>	,IfcSpace))</para>
	/// <para> SUBTYPE OF (IfcSpatialElement);</para>
	/// <para>	CompositionType : OPTIONAL IfcElementCompositionEnum;</para>
	/// <para> WHERE</para>
	/// <para>	WR41 : (HIINDEX(SELF\IfcObjectDefinition.Decomposes) = 1) </para>
	/// <para>AND</para>
	/// <para>('IFC4X3_ADD2.IFCRELAGGREGATES' IN TYPEOF(SELF\IfcObjectDefinition.Decomposes[1])) </para>
	/// <para>AND</para>
	/// <para>(('IFC4X3_ADD2.IFCPROJECT' IN TYPEOF (SELF\IfcObjectDefinition.Decomposes[1].RelatingObject)) OR</para>
	/// <para> ('IFC4X3_ADD2.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF (SELF\IfcObjectDefinition.Decomposes[1].RelatingObject))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialStructureElement : IfcSpatialElement
	{
		public IfcElementCompositionEnum? CompositionType { get; set; }
		public IfcSpatialStructureElement() : base()
		{
		}
		public IfcSpatialStructureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
			this.CompositionType = CompositionType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialStructureElementType
	/// <para>ENTITY IfcSpatialStructureElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcSpaceType))</para>
	/// <para> SUBTYPE OF (IfcSpatialElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialStructureElementType : IfcSpatialElementType
	{
		public IfcSpatialStructureElementType() : base()
		{
		}
		public IfcSpatialStructureElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialZone
	/// <para>ENTITY IfcSpatialZone</para>
	/// <para> SUBTYPE OF (IfcSpatialElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSpatialZoneTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSpatialZoneTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSpatialZoneTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSPATIALZONETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpatialZone : IfcSpatialElement
	{
		public IfcSpatialZoneTypeEnum? PredefinedType { get; set; }
		public IfcSpatialZone() : base()
		{
		}
		public IfcSpatialZone(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcSpatialZoneTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialZoneType
	/// <para>ENTITY IfcSpatialZoneType</para>
	/// <para> SUBTYPE OF (IfcSpatialElementType);</para>
	/// <para>	PredefinedType : IfcSpatialZoneTypeEnum;</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSpatialZoneTypeEnum.USERDEFINED) OR </para>
	/// <para>((PredefinedType = IfcSpatialZoneTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcSpatialElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpatialZoneType : IfcSpatialElementType
	{
		public IfcSpatialZoneTypeEnum PredefinedType { get; set; }
		public IfcLabel? LongName { get; set; }
		public IfcSpatialZoneType() : base()
		{
			PredefinedType = new IfcSpatialZoneTypeEnum();
		}
		public IfcSpatialZoneType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSpatialZoneTypeEnum PredefinedType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcSphere
	/// <para>ENTITY IfcSphere</para>
	/// <para> SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSphere : IfcCsgPrimitive3D
	{
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcSphere() : base()
		{
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcSphere(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcSphericalSurface
	/// <para>ENTITY IfcSphericalSurface</para>
	/// <para> SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSphericalSurface : IfcElementarySurface
	{
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcSphericalSurface() : base()
		{
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcSphericalSurface(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcSpiral
	/// <para>ENTITY IfcSpiral</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcClothoid</para>
	/// <para>	,IfcCosineSpiral</para>
	/// <para>	,IfcSecondOrderPolynomialSpiral</para>
	/// <para>	,IfcSeventhOrderPolynomialSpiral</para>
	/// <para>	,IfcSineSpiral</para>
	/// <para>	,IfcThirdOrderPolynomialSpiral))</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	Position : IfcAxis2Placement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpiral : IfcCurve
	{
		public IfcAxis2Placement Position { get; set; }
		public IfcSpiral() : base()
		{
			Position = new IfcAxis2Placement();
		}
		public IfcSpiral(IfcAxis2Placement Position) : base ()
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcStackTerminal
	/// <para>ENTITY IfcStackTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcStackTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcStackTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcStackTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSTACKTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStackTerminal : IfcFlowTerminal
	{
		public IfcStackTerminalTypeEnum? PredefinedType { get; set; }
		public IfcStackTerminal() : base()
		{
		}
		public IfcStackTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcStackTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStackTerminalType
	/// <para>ENTITY IfcStackTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcStackTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcStackTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcStackTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStackTerminalType : IfcFlowTerminalType
	{
		public IfcStackTerminalTypeEnum PredefinedType { get; set; }
		public IfcStackTerminalType() : base()
		{
			PredefinedType = new IfcStackTerminalTypeEnum();
		}
		public IfcStackTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcStackTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStair
	/// <para>ENTITY IfcStair</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcStairTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcStairTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcStairTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSTAIRTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStair : IfcBuiltElement
	{
		public IfcStairTypeEnum? PredefinedType { get; set; }
		public IfcStair() : base()
		{
		}
		public IfcStair(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcStairTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStairFlight
	/// <para>ENTITY IfcStairFlight</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	NumberOfRisers : OPTIONAL IfcInteger;</para>
	/// <para>	NumberOfTreads : OPTIONAL IfcInteger;</para>
	/// <para>	RiserHeight : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TreadLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcStairFlightTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcStairFlightTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcStairFlightTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSTAIRFLIGHTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStairFlight : IfcBuiltElement
	{
		public IfcInteger? NumberOfRisers { get; set; }
		public IfcInteger? NumberOfTreads { get; set; }
		public IfcPositiveLengthMeasure? RiserHeight { get; set; }
		public IfcPositiveLengthMeasure? TreadLength { get; set; }
		public IfcStairFlightTypeEnum? PredefinedType { get; set; }
		public IfcStairFlight() : base()
		{
		}
		public IfcStairFlight(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcInteger NumberOfRisers, IfcInteger NumberOfTreads, IfcPositiveLengthMeasure RiserHeight, IfcPositiveLengthMeasure TreadLength, IfcStairFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.NumberOfRisers = NumberOfRisers;
			this.NumberOfTreads = NumberOfTreads;
			this.RiserHeight = RiserHeight;
			this.TreadLength = TreadLength;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStairFlightType
	/// <para>ENTITY IfcStairFlightType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcStairFlightTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcStairFlightTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcStairFlightTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStairFlightType : IfcBuiltElementType
	{
		public IfcStairFlightTypeEnum PredefinedType { get; set; }
		public IfcStairFlightType() : base()
		{
			PredefinedType = new IfcStairFlightTypeEnum();
		}
		public IfcStairFlightType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcStairFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStairType
	/// <para>ENTITY IfcStairType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcStairTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcStairTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcStairTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStairType : IfcBuiltElementType
	{
		public IfcStairTypeEnum PredefinedType { get; set; }
		public IfcStairType() : base()
		{
			PredefinedType = new IfcStairTypeEnum();
		}
		public IfcStairType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcStairTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralAction
	/// <para>ENTITY IfcStructuralAction</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralCurveAction</para>
	/// <para>	,IfcStructuralPointAction</para>
	/// <para>	,IfcStructuralSurfaceAction))</para>
	/// <para> SUBTYPE OF (IfcStructuralActivity);</para>
	/// <para>	DestabilizingLoad : OPTIONAL IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralAction : IfcStructuralActivity
	{
		public IfcBoolean? DestabilizingLoad { get; set; }
		public IfcStructuralAction() : base()
		{
		}
		public IfcStructuralAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
			this.DestabilizingLoad = DestabilizingLoad;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralActivity
	/// <para>ENTITY IfcStructuralActivity</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralAction</para>
	/// <para>	,IfcStructuralReaction))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para>	AppliedLoad : IfcStructuralLoad;</para>
	/// <para>	GlobalOrLocal : IfcGlobalOrLocalEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	AssignedToStructuralItem : SET [0:1] OF IfcRelConnectsStructuralActivity FOR RelatedStructuralActivity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralActivity : IfcProduct
	{
		public IfcStructuralLoad AppliedLoad { get; set; }
		public IfcGlobalOrLocalEnum GlobalOrLocal { get; set; }
		public IfcStructuralActivity() : base()
		{
			AppliedLoad = new IfcStructuralLoad();
			GlobalOrLocal = new IfcGlobalOrLocalEnum();
		}
		public IfcStructuralActivity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.AppliedLoad = AppliedLoad;
			this.GlobalOrLocal = GlobalOrLocal;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralAnalysisModel
	/// <para>ENTITY IfcStructuralAnalysisModel</para>
	/// <para> SUBTYPE OF (IfcSystem);</para>
	/// <para>	PredefinedType : IfcAnalysisModelTypeEnum;</para>
	/// <para>	OrientationOf2DPlane : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>	LoadedBy : OPTIONAL SET [1:?] OF IfcStructuralLoadGroup;</para>
	/// <para>	HasResults : OPTIONAL SET [1:?] OF IfcStructuralResultGroup;</para>
	/// <para>	SharedPlacement : OPTIONAL IfcObjectPlacement;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAnalysisModelTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcAnalysisModelTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralAnalysisModel : IfcSystem
	{
		public IfcAnalysisModelTypeEnum PredefinedType { get; set; }
		public IfcAxis2Placement3D? OrientationOf2DPlane { get; set; }
		public List<IfcStructuralLoadGroup>? LoadedBy { get; set; }
		public List<IfcStructuralResultGroup>? HasResults { get; set; }
		public IfcObjectPlacement? SharedPlacement { get; set; }
		public IfcStructuralAnalysisModel() : base()
		{
			PredefinedType = new IfcAnalysisModelTypeEnum();
		}
		public IfcStructuralAnalysisModel(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcAnalysisModelTypeEnum PredefinedType, IfcAxis2Placement3D OrientationOf2DPlane, List<IfcStructuralLoadGroup> LoadedBy, List<IfcStructuralResultGroup> HasResults, IfcObjectPlacement SharedPlacement) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.OrientationOf2DPlane = OrientationOf2DPlane;
			this.LoadedBy = LoadedBy;
			this.HasResults = HasResults;
			this.SharedPlacement = SharedPlacement;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralConnection
	/// <para>ENTITY IfcStructuralConnection</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralCurveConnection</para>
	/// <para>	,IfcStructuralPointConnection</para>
	/// <para>	,IfcStructuralSurfaceConnection))</para>
	/// <para> SUBTYPE OF (IfcStructuralItem);</para>
	/// <para>	AppliedCondition : OPTIONAL IfcBoundaryCondition;</para>
	/// <para> INVERSE</para>
	/// <para>	ConnectsStructuralMembers : SET [1:?] OF IfcRelConnectsStructuralMember FOR RelatedStructuralConnection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralConnection : IfcStructuralItem
	{
		public IfcBoundaryCondition? AppliedCondition { get; set; }
		public IfcStructuralConnection() : base()
		{
		}
		public IfcStructuralConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.AppliedCondition = AppliedCondition;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralConnectionCondition
	/// <para>ENTITY IfcStructuralConnectionCondition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcFailureConnectionCondition</para>
	/// <para>	,IfcSlippageConnectionCondition));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralConnectionConditionENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcStructuralConnectionCondition() : base()
		{
		}
		public IfcStructuralConnectionCondition(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveAction
	/// <para>ENTITY IfcStructuralCurveAction</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralLinearAction))</para>
	/// <para> SUBTYPE OF (IfcStructuralAction);</para>
	/// <para>	ProjectedOrTrue : OPTIONAL IfcProjectedOrTrueLengthEnum;</para>
	/// <para>	PredefinedType : IfcStructuralCurveActivityTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcStructuralCurveActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>	ProjectedIsGlobal : (NOT EXISTS(ProjectedOrTrue)) OR</para>
	/// <para>((ProjectedOrTrue <> PROJECTED_LENGTH) OR</para>
	/// <para> (SELF\IfcStructuralActivity.GlobalOrLocal = GLOBAL_COORDS));</para>
	/// <para>	SuitablePredefinedType : PredefinedType <> IfcStructuralCurveActivityTypeEnum.EQUIDISTANT;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveAction : IfcStructuralAction
	{
		public IfcProjectedOrTrueLengthEnum? ProjectedOrTrue { get; set; }
		public IfcStructuralCurveActivityTypeEnum PredefinedType { get; set; }
		public IfcStructuralCurveAction() : base()
		{
			PredefinedType = new IfcStructuralCurveActivityTypeEnum();
		}
		public IfcStructuralCurveAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
		{
			this.ProjectedOrTrue = ProjectedOrTrue;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveConnection
	/// <para>ENTITY IfcStructuralCurveConnection</para>
	/// <para> SUBTYPE OF (IfcStructuralConnection);</para>
	/// <para>	AxisDirection : IfcDirection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveConnection : IfcStructuralConnection
	{
		public IfcDirection AxisDirection { get; set; }
		public IfcStructuralCurveConnection() : base()
		{
			AxisDirection = new IfcDirection();
		}
		public IfcStructuralCurveConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition, IfcDirection AxisDirection) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
		{
			this.AxisDirection = AxisDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveMember
	/// <para>ENTITY IfcStructuralCurveMember</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralCurveMemberVarying))</para>
	/// <para> SUBTYPE OF (IfcStructuralMember);</para>
	/// <para>	PredefinedType : IfcStructuralCurveMemberTypeEnum;</para>
	/// <para>	Axis : IfcDirection;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcStructuralCurveMemberTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveMember : IfcStructuralMember
	{
		public IfcStructuralCurveMemberTypeEnum PredefinedType { get; set; }
		public IfcDirection Axis { get; set; }
		public IfcStructuralCurveMember() : base()
		{
			PredefinedType = new IfcStructuralCurveMemberTypeEnum();
			Axis = new IfcDirection();
		}
		public IfcStructuralCurveMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralCurveMemberTypeEnum PredefinedType, IfcDirection Axis) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.PredefinedType = PredefinedType;
			this.Axis = Axis;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveMemberVarying
	/// <para>ENTITY IfcStructuralCurveMemberVarying</para>
	/// <para> SUBTYPE OF (IfcStructuralCurveMember);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveMemberVarying : IfcStructuralCurveMember
	{
		public IfcStructuralCurveMemberVarying() : base()
		{
		}
		public IfcStructuralCurveMemberVarying(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralCurveMemberTypeEnum PredefinedType, IfcDirection Axis) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveReaction
	/// <para>ENTITY IfcStructuralCurveReaction</para>
	/// <para> SUBTYPE OF (IfcStructuralReaction);</para>
	/// <para>	PredefinedType : IfcStructuralCurveActivityTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcStructuralCurveActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>	SuitablePredefinedType : (PredefinedType <> IfcStructuralCurveActivityTypeEnum.SINUS) AND (PredefinedType <> IfcStructuralCurveActivityTypeEnum.PARABOLA);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveReaction : IfcStructuralReaction
	{
		public IfcStructuralCurveActivityTypeEnum PredefinedType { get; set; }
		public IfcStructuralCurveReaction() : base()
		{
			PredefinedType = new IfcStructuralCurveActivityTypeEnum();
		}
		public IfcStructuralCurveReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcStructuralCurveActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralItem
	/// <para>ENTITY IfcStructuralItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralConnection</para>
	/// <para>	,IfcStructuralMember))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para> INVERSE</para>
	/// <para>	AssignedStructuralActivity : SET [0:?] OF IfcRelConnectsStructuralActivity FOR RelatingElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralItem : IfcProduct, IfcStructuralActivityAssignmentSelect
	{
		public IfcStructuralItem() : base()
		{
		}
		public IfcStructuralItem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLinearAction
	/// <para>ENTITY IfcStructuralLinearAction</para>
	/// <para> SUBTYPE OF (IfcStructuralCurveAction);</para>
	/// <para> WHERE</para>
	/// <para>	ConstPredefinedType : SELF\IfcStructuralCurveAction.PredefinedType = IfcStructuralCurveActivityTypeEnum.CONST;</para>
	/// <para>	SuitableLoadType : SIZEOF(['IFC4X3_ADD2.IFCSTRUCTURALLOADLINEARFORCE', 'IFC4X3_ADD2.IFCSTRUCTURALLOADTEMPERATURE'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLinearAction : IfcStructuralCurveAction
	{
		public IfcStructuralLinearAction() : base()
		{
		}
		public IfcStructuralLinearAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoad
	/// <para>ENTITY IfcStructuralLoad</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralLoadConfiguration</para>
	/// <para>	,IfcStructuralLoadOrResult));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralLoadENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcStructuralLoad() : base()
		{
		}
		public IfcStructuralLoad(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadCase
	/// <para>ENTITY IfcStructuralLoadCase</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadGroup);</para>
	/// <para>	SelfWeightCoefficients : OPTIONAL LIST [3:3] OF IfcRatioMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	IsLoadCasePredefinedType : SELF\IfcStructuralLoadGroup.PredefinedType = IfcLoadGroupTypeEnum.LOAD_CASE;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadCase : IfcStructuralLoadGroup
	{
		public List<IfcRatioMeasure>? SelfWeightCoefficients { get; set; }
		public IfcStructuralLoadCase() : base()
		{
		}
		public IfcStructuralLoadCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLoadGroupTypeEnum PredefinedType, IfcActionTypeEnum ActionType, IfcActionSourceTypeEnum ActionSource, IfcRatioMeasure Coefficient, IfcLabel Purpose, List<IfcRatioMeasure> SelfWeightCoefficients) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose)
		{
			this.SelfWeightCoefficients = SelfWeightCoefficients;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadConfiguration
	/// <para>ENTITY IfcStructuralLoadConfiguration</para>
	/// <para> SUBTYPE OF (IfcStructuralLoad);</para>
	/// <para>	Values : LIST [1:?] OF IfcStructuralLoadOrResult;</para>
	/// <para>	Locations : OPTIONAL LIST [1:?] OF UNIQUE LIST [1:2] OF IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidListSize : NOT EXISTS(Locations) OR (SIZEOF(Locations) = SIZEOF(Values));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadConfiguration : IfcStructuralLoad
	{
		public List<IfcStructuralLoadOrResult> Values { get; set; }
		public IfcStructuralLoadConfiguration() : base()
		{
			Values = new List<IfcStructuralLoadOrResult>();
		}
		public IfcStructuralLoadConfiguration(IfcLabel Name, List<IfcStructuralLoadOrResult> Values) : base (Name)
		{
			this.Values = Values;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadGroup
	/// <para>ENTITY IfcStructuralLoadGroup</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralLoadCase))</para>
	/// <para> SUBTYPE OF (IfcGroup);</para>
	/// <para>	PredefinedType : IfcLoadGroupTypeEnum;</para>
	/// <para>	ActionType : IfcActionTypeEnum;</para>
	/// <para>	ActionSource : IfcActionSourceTypeEnum;</para>
	/// <para>	Coefficient : OPTIONAL IfcRatioMeasure;</para>
	/// <para>	Purpose : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	SourceOfResultGroup : SET [0:1] OF IfcStructuralResultGroup FOR ResultForLoadGroup;</para>
	/// <para>	LoadGroupFor : SET [0:?] OF IfcStructuralAnalysisModel FOR LoadedBy;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (</para>
	/// <para>  (PredefinedType <> IfcLoadGroupTypeEnum.USERDEFINED) AND</para>
	/// <para>  (ActionType <> IfcActionTypeEnum.USERDEFINED) AND</para>
	/// <para>  (ActionSource <> IfcActionSourceTypeEnum.USERDEFINED)</para>
	/// <para>) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadGroup : IfcGroup
	{
		public IfcLoadGroupTypeEnum PredefinedType { get; set; }
		public IfcActionTypeEnum ActionType { get; set; }
		public IfcActionSourceTypeEnum ActionSource { get; set; }
		public IfcRatioMeasure? Coefficient { get; set; }
		public IfcLabel? Purpose { get; set; }
		public IfcStructuralLoadGroup() : base()
		{
			PredefinedType = new IfcLoadGroupTypeEnum();
			ActionType = new IfcActionTypeEnum();
			ActionSource = new IfcActionSourceTypeEnum();
		}
		public IfcStructuralLoadGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLoadGroupTypeEnum PredefinedType, IfcActionTypeEnum ActionType, IfcActionSourceTypeEnum ActionSource, IfcRatioMeasure Coefficient, IfcLabel Purpose) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.ActionType = ActionType;
			this.ActionSource = ActionSource;
			this.Coefficient = Coefficient;
			this.Purpose = Purpose;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadLinearForce
	/// <para>ENTITY IfcStructuralLoadLinearForce</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>	LinearForceX : OPTIONAL IfcLinearForceMeasure;</para>
	/// <para>	LinearForceY : OPTIONAL IfcLinearForceMeasure;</para>
	/// <para>	LinearForceZ : OPTIONAL IfcLinearForceMeasure;</para>
	/// <para>	LinearMomentX : OPTIONAL IfcLinearMomentMeasure;</para>
	/// <para>	LinearMomentY : OPTIONAL IfcLinearMomentMeasure;</para>
	/// <para>	LinearMomentZ : OPTIONAL IfcLinearMomentMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadLinearForce : IfcStructuralLoadStatic
	{
		public IfcLinearForceMeasure? LinearForceX { get; set; }
		public IfcLinearForceMeasure? LinearForceY { get; set; }
		public IfcLinearForceMeasure? LinearForceZ { get; set; }
		public IfcLinearMomentMeasure? LinearMomentX { get; set; }
		public IfcLinearMomentMeasure? LinearMomentY { get; set; }
		public IfcLinearMomentMeasure? LinearMomentZ { get; set; }
		public IfcStructuralLoadLinearForce() : base()
		{
		}
		public IfcStructuralLoadLinearForce(IfcLabel Name, IfcLinearForceMeasure LinearForceX, IfcLinearForceMeasure LinearForceY, IfcLinearForceMeasure LinearForceZ, IfcLinearMomentMeasure LinearMomentX, IfcLinearMomentMeasure LinearMomentY, IfcLinearMomentMeasure LinearMomentZ) : base (Name)
		{
			this.LinearForceX = LinearForceX;
			this.LinearForceY = LinearForceY;
			this.LinearForceZ = LinearForceZ;
			this.LinearMomentX = LinearMomentX;
			this.LinearMomentY = LinearMomentY;
			this.LinearMomentZ = LinearMomentZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadOrResult
	/// <para>ENTITY IfcStructuralLoadOrResult</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralLoadStatic</para>
	/// <para>	,IfcSurfaceReinforcementArea))</para>
	/// <para> SUBTYPE OF (IfcStructuralLoad);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralLoadOrResult : IfcStructuralLoad
	{
		public IfcStructuralLoadOrResult() : base()
		{
		}
		public IfcStructuralLoadOrResult(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadPlanarForce
	/// <para>ENTITY IfcStructuralLoadPlanarForce</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>	PlanarForceX : OPTIONAL IfcPlanarForceMeasure;</para>
	/// <para>	PlanarForceY : OPTIONAL IfcPlanarForceMeasure;</para>
	/// <para>	PlanarForceZ : OPTIONAL IfcPlanarForceMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadPlanarForce : IfcStructuralLoadStatic
	{
		public IfcPlanarForceMeasure? PlanarForceX { get; set; }
		public IfcPlanarForceMeasure? PlanarForceY { get; set; }
		public IfcPlanarForceMeasure? PlanarForceZ { get; set; }
		public IfcStructuralLoadPlanarForce() : base()
		{
		}
		public IfcStructuralLoadPlanarForce(IfcLabel Name, IfcPlanarForceMeasure PlanarForceX, IfcPlanarForceMeasure PlanarForceY, IfcPlanarForceMeasure PlanarForceZ) : base (Name)
		{
			this.PlanarForceX = PlanarForceX;
			this.PlanarForceY = PlanarForceY;
			this.PlanarForceZ = PlanarForceZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleDisplacement
	/// <para>ENTITY IfcStructuralLoadSingleDisplacement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralLoadSingleDisplacementDistortion))</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>	DisplacementX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	DisplacementY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	DisplacementZ : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	RotationalDisplacementRX : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>	RotationalDisplacementRY : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>	RotationalDisplacementRZ : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleDisplacement : IfcStructuralLoadStatic
	{
		public IfcLengthMeasure? DisplacementX { get; set; }
		public IfcLengthMeasure? DisplacementY { get; set; }
		public IfcLengthMeasure? DisplacementZ { get; set; }
		public IfcPlaneAngleMeasure? RotationalDisplacementRX { get; set; }
		public IfcPlaneAngleMeasure? RotationalDisplacementRY { get; set; }
		public IfcPlaneAngleMeasure? RotationalDisplacementRZ { get; set; }
		public IfcStructuralLoadSingleDisplacement() : base()
		{
		}
		public IfcStructuralLoadSingleDisplacement(IfcLabel Name, IfcLengthMeasure DisplacementX, IfcLengthMeasure DisplacementY, IfcLengthMeasure DisplacementZ, IfcPlaneAngleMeasure RotationalDisplacementRX, IfcPlaneAngleMeasure RotationalDisplacementRY, IfcPlaneAngleMeasure RotationalDisplacementRZ) : base (Name)
		{
			this.DisplacementX = DisplacementX;
			this.DisplacementY = DisplacementY;
			this.DisplacementZ = DisplacementZ;
			this.RotationalDisplacementRX = RotationalDisplacementRX;
			this.RotationalDisplacementRY = RotationalDisplacementRY;
			this.RotationalDisplacementRZ = RotationalDisplacementRZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleDisplacementDistortion
	/// <para>ENTITY IfcStructuralLoadSingleDisplacementDistortion</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadSingleDisplacement);</para>
	/// <para>	Distortion : OPTIONAL IfcCurvatureMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleDisplacementDistortion : IfcStructuralLoadSingleDisplacement
	{
		public IfcCurvatureMeasure? Distortion { get; set; }
		public IfcStructuralLoadSingleDisplacementDistortion() : base()
		{
		}
		public IfcStructuralLoadSingleDisplacementDistortion(IfcLabel Name, IfcLengthMeasure DisplacementX, IfcLengthMeasure DisplacementY, IfcLengthMeasure DisplacementZ, IfcPlaneAngleMeasure RotationalDisplacementRX, IfcPlaneAngleMeasure RotationalDisplacementRY, IfcPlaneAngleMeasure RotationalDisplacementRZ, IfcCurvatureMeasure Distortion) : base (Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ)
		{
			this.Distortion = Distortion;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleForce
	/// <para>ENTITY IfcStructuralLoadSingleForce</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralLoadSingleForceWarping))</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>	ForceX : OPTIONAL IfcForceMeasure;</para>
	/// <para>	ForceY : OPTIONAL IfcForceMeasure;</para>
	/// <para>	ForceZ : OPTIONAL IfcForceMeasure;</para>
	/// <para>	MomentX : OPTIONAL IfcTorqueMeasure;</para>
	/// <para>	MomentY : OPTIONAL IfcTorqueMeasure;</para>
	/// <para>	MomentZ : OPTIONAL IfcTorqueMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleForce : IfcStructuralLoadStatic
	{
		public IfcForceMeasure? ForceX { get; set; }
		public IfcForceMeasure? ForceY { get; set; }
		public IfcForceMeasure? ForceZ { get; set; }
		public IfcTorqueMeasure? MomentX { get; set; }
		public IfcTorqueMeasure? MomentY { get; set; }
		public IfcTorqueMeasure? MomentZ { get; set; }
		public IfcStructuralLoadSingleForce() : base()
		{
		}
		public IfcStructuralLoadSingleForce(IfcLabel Name, IfcForceMeasure ForceX, IfcForceMeasure ForceY, IfcForceMeasure ForceZ, IfcTorqueMeasure MomentX, IfcTorqueMeasure MomentY, IfcTorqueMeasure MomentZ) : base (Name)
		{
			this.ForceX = ForceX;
			this.ForceY = ForceY;
			this.ForceZ = ForceZ;
			this.MomentX = MomentX;
			this.MomentY = MomentY;
			this.MomentZ = MomentZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleForceWarping
	/// <para>ENTITY IfcStructuralLoadSingleForceWarping</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadSingleForce);</para>
	/// <para>	WarpingMoment : OPTIONAL IfcWarpingMomentMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleForceWarping : IfcStructuralLoadSingleForce
	{
		public IfcWarpingMomentMeasure? WarpingMoment { get; set; }
		public IfcStructuralLoadSingleForceWarping() : base()
		{
		}
		public IfcStructuralLoadSingleForceWarping(IfcLabel Name, IfcForceMeasure ForceX, IfcForceMeasure ForceY, IfcForceMeasure ForceZ, IfcTorqueMeasure MomentX, IfcTorqueMeasure MomentY, IfcTorqueMeasure MomentZ, IfcWarpingMomentMeasure WarpingMoment) : base (Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ)
		{
			this.WarpingMoment = WarpingMoment;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadStatic
	/// <para>ENTITY IfcStructuralLoadStatic</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralLoadLinearForce</para>
	/// <para>	,IfcStructuralLoadPlanarForce</para>
	/// <para>	,IfcStructuralLoadSingleDisplacement</para>
	/// <para>	,IfcStructuralLoadSingleForce</para>
	/// <para>	,IfcStructuralLoadTemperature))</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadOrResult);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralLoadStatic : IfcStructuralLoadOrResult
	{
		public IfcStructuralLoadStatic() : base()
		{
		}
		public IfcStructuralLoadStatic(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadTemperature
	/// <para>ENTITY IfcStructuralLoadTemperature</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>	DeltaTConstant : OPTIONAL IfcThermodynamicTemperatureMeasure;</para>
	/// <para>	DeltaTY : OPTIONAL IfcThermodynamicTemperatureMeasure;</para>
	/// <para>	DeltaTZ : OPTIONAL IfcThermodynamicTemperatureMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadTemperature : IfcStructuralLoadStatic
	{
		public IfcThermodynamicTemperatureMeasure? DeltaTConstant { get; set; }
		public IfcThermodynamicTemperatureMeasure? DeltaTY { get; set; }
		public IfcThermodynamicTemperatureMeasure? DeltaTZ { get; set; }
		public IfcStructuralLoadTemperature() : base()
		{
		}
		public IfcStructuralLoadTemperature(IfcLabel Name, IfcThermodynamicTemperatureMeasure DeltaTConstant, IfcThermodynamicTemperatureMeasure DeltaTY, IfcThermodynamicTemperatureMeasure DeltaTZ) : base (Name)
		{
			this.DeltaTConstant = DeltaTConstant;
			this.DeltaTY = DeltaTY;
			this.DeltaTZ = DeltaTZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralMember
	/// <para>ENTITY IfcStructuralMember</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralCurveMember</para>
	/// <para>	,IfcStructuralSurfaceMember))</para>
	/// <para> SUBTYPE OF (IfcStructuralItem);</para>
	/// <para> INVERSE</para>
	/// <para>	ConnectedBy : SET [0:?] OF IfcRelConnectsStructuralMember FOR RelatingStructuralMember;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralMember : IfcStructuralItem
	{
		public IfcStructuralMember() : base()
		{
		}
		public IfcStructuralMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPlanarAction
	/// <para>ENTITY IfcStructuralPlanarAction</para>
	/// <para> SUBTYPE OF (IfcStructuralSurfaceAction);</para>
	/// <para> WHERE</para>
	/// <para>	ConstPredefinedType : SELF\IfcStructuralSurfaceAction.PredefinedType = IfcStructuralSurfaceActivityTypeEnum.CONST;</para>
	/// <para>	SuitableLoadType : SIZEOF(['IFC4X3_ADD2.IFCSTRUCTURALLOADPLANARFORCE', 'IFC4X3_ADD2.IFCSTRUCTURALLOADTEMPERATURE'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPlanarAction : IfcStructuralSurfaceAction
	{
		public IfcStructuralPlanarAction() : base()
		{
		}
		public IfcStructuralPlanarAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPointAction
	/// <para>ENTITY IfcStructuralPointAction</para>
	/// <para> SUBTYPE OF (IfcStructuralAction);</para>
	/// <para> WHERE</para>
	/// <para>	SuitableLoadType : SIZEOF(['IFC4X3_ADD2.IFCSTRUCTURALLOADSINGLEFORCE', 'IFC4X3_ADD2.IFCSTRUCTURALLOADSINGLEDISPLACEMENT'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPointAction : IfcStructuralAction
	{
		public IfcStructuralPointAction() : base()
		{
		}
		public IfcStructuralPointAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPointConnection
	/// <para>ENTITY IfcStructuralPointConnection</para>
	/// <para> SUBTYPE OF (IfcStructuralConnection);</para>
	/// <para>	ConditionCoordinateSystem : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPointConnection : IfcStructuralConnection
	{
		public IfcAxis2Placement3D? ConditionCoordinateSystem { get; set; }
		public IfcStructuralPointConnection() : base()
		{
		}
		public IfcStructuralPointConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition, IfcAxis2Placement3D ConditionCoordinateSystem) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
		{
			this.ConditionCoordinateSystem = ConditionCoordinateSystem;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPointReaction
	/// <para>ENTITY IfcStructuralPointReaction</para>
	/// <para> SUBTYPE OF (IfcStructuralReaction);</para>
	/// <para> WHERE</para>
	/// <para>	SuitableLoadType : SIZEOF(['IFC4X3_ADD2.IFCSTRUCTURALLOADSINGLEFORCE', 'IFC4X3_ADD2.IFCSTRUCTURALLOADSINGLEDISPLACEMENT'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPointReaction : IfcStructuralReaction
	{
		public IfcStructuralPointReaction() : base()
		{
		}
		public IfcStructuralPointReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralReaction
	/// <para>ENTITY IfcStructuralReaction</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralCurveReaction</para>
	/// <para>	,IfcStructuralPointReaction</para>
	/// <para>	,IfcStructuralSurfaceReaction))</para>
	/// <para> SUBTYPE OF (IfcStructuralActivity);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralReaction : IfcStructuralActivity
	{
		public IfcStructuralReaction() : base()
		{
		}
		public IfcStructuralReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralResultGroup
	/// <para>ENTITY IfcStructuralResultGroup</para>
	/// <para> SUBTYPE OF (IfcGroup);</para>
	/// <para>	TheoryType : IfcAnalysisTheoryTypeEnum;</para>
	/// <para>	ResultForLoadGroup : OPTIONAL IfcStructuralLoadGroup;</para>
	/// <para>	IsLinear : IfcBoolean;</para>
	/// <para> INVERSE</para>
	/// <para>	ResultGroupFor : SET [0:1] OF IfcStructuralAnalysisModel FOR HasResults;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (TheoryType <> IfcAnalysisTheoryTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralResultGroup : IfcGroup
	{
		public IfcAnalysisTheoryTypeEnum TheoryType { get; set; }
		public IfcStructuralLoadGroup? ResultForLoadGroup { get; set; }
		public IfcBoolean IsLinear { get; set; }
		public IfcStructuralResultGroup() : base()
		{
			TheoryType = new IfcAnalysisTheoryTypeEnum();
			IsLinear = new IfcBoolean();
		}
		public IfcStructuralResultGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcAnalysisTheoryTypeEnum TheoryType, IfcStructuralLoadGroup ResultForLoadGroup, IfcBoolean IsLinear) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.TheoryType = TheoryType;
			this.ResultForLoadGroup = ResultForLoadGroup;
			this.IsLinear = IsLinear;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceAction
	/// <para>ENTITY IfcStructuralSurfaceAction</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralPlanarAction))</para>
	/// <para> SUBTYPE OF (IfcStructuralAction);</para>
	/// <para>	ProjectedOrTrue : OPTIONAL IfcProjectedOrTrueLengthEnum;</para>
	/// <para>	PredefinedType : IfcStructuralSurfaceActivityTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcStructuralSurfaceActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>	ProjectedIsGlobal : (NOT EXISTS(ProjectedOrTrue)) OR</para>
	/// <para>((ProjectedOrTrue <> PROJECTED_LENGTH) OR</para>
	/// <para> (SELF\IfcStructuralActivity.GlobalOrLocal = GLOBAL_COORDS));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceAction : IfcStructuralAction
	{
		public IfcProjectedOrTrueLengthEnum? ProjectedOrTrue { get; set; }
		public IfcStructuralSurfaceActivityTypeEnum PredefinedType { get; set; }
		public IfcStructuralSurfaceAction() : base()
		{
			PredefinedType = new IfcStructuralSurfaceActivityTypeEnum();
		}
		public IfcStructuralSurfaceAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
		{
			this.ProjectedOrTrue = ProjectedOrTrue;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceConnection
	/// <para>ENTITY IfcStructuralSurfaceConnection</para>
	/// <para> SUBTYPE OF (IfcStructuralConnection);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceConnection : IfcStructuralConnection
	{
		public IfcStructuralSurfaceConnection() : base()
		{
		}
		public IfcStructuralSurfaceConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceMember
	/// <para>ENTITY IfcStructuralSurfaceMember</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStructuralSurfaceMemberVarying))</para>
	/// <para> SUBTYPE OF (IfcStructuralMember);</para>
	/// <para>	PredefinedType : IfcStructuralSurfaceMemberTypeEnum;</para>
	/// <para>	Thickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcStructuralSurfaceMemberTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceMember : IfcStructuralMember
	{
		public IfcStructuralSurfaceMemberTypeEnum PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? Thickness { get; set; }
		public IfcStructuralSurfaceMember() : base()
		{
			PredefinedType = new IfcStructuralSurfaceMemberTypeEnum();
		}
		public IfcStructuralSurfaceMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralSurfaceMemberTypeEnum PredefinedType, IfcPositiveLengthMeasure Thickness) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.PredefinedType = PredefinedType;
			this.Thickness = Thickness;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceMemberVarying
	/// <para>ENTITY IfcStructuralSurfaceMemberVarying</para>
	/// <para> SUBTYPE OF (IfcStructuralSurfaceMember);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceMemberVarying : IfcStructuralSurfaceMember
	{
		public IfcStructuralSurfaceMemberVarying() : base()
		{
		}
		public IfcStructuralSurfaceMemberVarying(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralSurfaceMemberTypeEnum PredefinedType, IfcPositiveLengthMeasure Thickness) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceReaction
	/// <para>ENTITY IfcStructuralSurfaceReaction</para>
	/// <para> SUBTYPE OF (IfcStructuralReaction);</para>
	/// <para>	PredefinedType : IfcStructuralSurfaceActivityTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasPredefinedType : (PredefinedType <> IfcStructuralSurfaceActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceReaction : IfcStructuralReaction
	{
		public IfcStructuralSurfaceActivityTypeEnum PredefinedType { get; set; }
		public IfcStructuralSurfaceReaction() : base()
		{
			PredefinedType = new IfcStructuralSurfaceActivityTypeEnum();
		}
		public IfcStructuralSurfaceReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcStructuralSurfaceActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStyleModel
	/// <para>ENTITY IfcStyleModel</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcStyledRepresentation))</para>
	/// <para> SUBTYPE OF (IfcRepresentation);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStyleModel : IfcRepresentation
	{
		public IfcStyleModel() : base()
		{
		}
		public IfcStyleModel(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStyledItem
	/// <para>ENTITY IfcStyledItem</para>
	/// <para> SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>	Item : OPTIONAL IfcRepresentationItem;</para>
	/// <para>	Styles : SET [1:?] OF IfcPresentationStyle;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableItem : NOT('IFC4X3_ADD2.IFCSTYLEDITEM' IN TYPEOF(Item));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStyledItem : IfcRepresentationItem
	{
		public IfcRepresentationItem? Item { get; set; }
		public List<IfcPresentationStyle> Styles { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcStyledItem() : base()
		{
			Styles = new List<IfcPresentationStyle>();
		}
		public IfcStyledItem(IfcRepresentationItem Item, List<IfcPresentationStyle> Styles, IfcLabel Name) : base ()
		{
			this.Item = Item;
			this.Styles = Styles;
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcStyledRepresentation
	/// <para>ENTITY IfcStyledRepresentation</para>
	/// <para> SUBTYPE OF (IfcStyleModel);</para>
	/// <para> WHERE</para>
	/// <para>	OnlyStyledItems : SIZEOF(QUERY(temp <* SELF\IfcRepresentation.Items | </para>
	/// <para>  (NOT('IFC4X3_ADD2.IFCSTYLEDITEM' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStyledRepresentation : IfcStyleModel
	{
		public IfcStyledRepresentation() : base()
		{
		}
		public IfcStyledRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSubContractResource
	/// <para>ENTITY IfcSubContractResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSubContractResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcSubContractResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcSubContractResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSubContractResource : IfcConstructionResource
	{
		public IfcSubContractResourceTypeEnum? PredefinedType { get; set; }
		public IfcSubContractResource() : base()
		{
		}
		public IfcSubContractResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcSubContractResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSubContractResourceType
	/// <para>ENTITY IfcSubContractResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcSubContractResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSubContractResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSubContractResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSubContractResourceType : IfcConstructionResourceType
	{
		public IfcSubContractResourceTypeEnum PredefinedType { get; set; }
		public IfcSubContractResourceType() : base()
		{
			PredefinedType = new IfcSubContractResourceTypeEnum();
		}
		public IfcSubContractResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcSubContractResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSubedge
	/// <para>ENTITY IfcSubedge</para>
	/// <para> SUBTYPE OF (IfcEdge);</para>
	/// <para>	ParentEdge : IfcEdge;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSubedge : IfcEdge
	{
		public IfcEdge ParentEdge { get; set; }
		public IfcSubedge() : base()
		{
			ParentEdge = new IfcEdge();
		}
		public IfcSubedge(IfcVertex EdgeStart, IfcVertex EdgeEnd, IfcEdge ParentEdge) : base (EdgeStart, EdgeEnd)
		{
			this.ParentEdge = ParentEdge;
		}
	}
	/// <summary>
	/// ENTITY IfcSurface
	/// <para>ENTITY IfcSurface</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBoundedSurface</para>
	/// <para>	,IfcElementarySurface</para>
	/// <para>	,IfcSectionedSurface</para>
	/// <para>	,IfcSweptSurface))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSurface : IfcGeometricRepresentationItem, IfcGeometricSetSelect, IfcSurfaceOrFaceSurface
	{
		public IfcSurface() : base()
		{
		}
		public IfcSurface() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceCurve
	/// <para>ENTITY IfcSurfaceCurve</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcIntersectionCurve</para>
	/// <para>	,IfcSeamCurve))</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	Curve3D : IfcCurve;</para>
	/// <para>	AssociatedGeometry : LIST [1:2] OF IfcPcurve;</para>
	/// <para>	MasterRepresentation : IfcPreferredSurfaceCurveRepresentation;</para>
	/// <para> DERIVE</para>
	/// <para>	 BasisSurface : SET [1:2] OF IfcSurface := IfcGetBasisSurface(SELF);</para>
	/// <para> WHERE</para>
	/// <para>	CurveIs3D : Curve3D.Dim = 3;</para>
	/// <para>	CurveIsNotPcurve : NOT ('IFC4X3_ADD2.IFCPCURVE' IN TYPEOF(Curve3D));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceCurve : IfcCurve, IfcCurveOnSurface
	{
		public IfcCurve Curve3D { get; set; }
		public List<IfcPcurve> AssociatedGeometry { get; set; }
		public IfcPreferredSurfaceCurveRepresentation MasterRepresentation { get; set; }
		public IfcSurfaceCurve() : base()
		{
			Curve3D = new IfcCurve();
			AssociatedGeometry = new List<IfcPcurve>();
			MasterRepresentation = new IfcPreferredSurfaceCurveRepresentation();
		}
		public IfcSurfaceCurve(IfcCurve Curve3D, List<IfcPcurve> AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation MasterRepresentation) : base ()
		{
			this.Curve3D = Curve3D;
			this.AssociatedGeometry = AssociatedGeometry;
			this.MasterRepresentation = MasterRepresentation;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceCurveSweptAreaSolid
	/// <para>ENTITY IfcSurfaceCurveSweptAreaSolid</para>
	/// <para> SUBTYPE OF (IfcDirectrixCurveSweptAreaSolid);</para>
	/// <para>	ReferenceSurface : IfcSurface;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceCurveSweptAreaSolid : IfcDirectrixCurveSweptAreaSolid
	{
		public IfcSurface ReferenceSurface { get; set; }
		public IfcSurfaceCurveSweptAreaSolid() : base()
		{
			ReferenceSurface = new IfcSurface();
		}
		public IfcSurfaceCurveSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcCurve Directrix, IfcCurveMeasureSelect StartParam, IfcCurveMeasureSelect EndParam, IfcSurface ReferenceSurface) : base (SweptArea, Position, Directrix, StartParam, EndParam)
		{
			this.ReferenceSurface = ReferenceSurface;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceFeature
	/// <para>ENTITY IfcSurfaceFeature</para>
	/// <para> SUBTYPE OF (IfcFeatureElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSurfaceFeatureTypeEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	AdheresToElement : IfcRelAdheresToElement FOR RelatedSurfaceFeatures;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSurfaceFeatureTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSurfaceFeatureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceFeature : IfcFeatureElement
	{
		public IfcSurfaceFeatureTypeEnum? PredefinedType { get; set; }
		public IfcSurfaceFeature() : base()
		{
		}
		public IfcSurfaceFeature(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSurfaceFeatureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceOfLinearExtrusion
	/// <para>ENTITY IfcSurfaceOfLinearExtrusion</para>
	/// <para> SUBTYPE OF (IfcSweptSurface);</para>
	/// <para>	ExtrudedDirection : IfcDirection;</para>
	/// <para>	Depth : IfcLengthMeasure;</para>
	/// <para> DERIVE</para>
	/// <para>	 ExtrusionAxis : IfcVector := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector (ExtrudedDirection, Depth);</para>
	/// <para> WHERE</para>
	/// <para>	DepthGreaterZero : Depth > 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceOfLinearExtrusion : IfcSweptSurface
	{
		public IfcDirection ExtrudedDirection { get; set; }
		public IfcLengthMeasure Depth { get; set; }
		public IfcSurfaceOfLinearExtrusion() : base()
		{
			ExtrudedDirection = new IfcDirection();
			Depth = new IfcLengthMeasure();
		}
		public IfcSurfaceOfLinearExtrusion(IfcProfileDef SweptCurve, IfcAxis2Placement3D Position, IfcDirection ExtrudedDirection, IfcLengthMeasure Depth) : base (SweptCurve, Position)
		{
			this.ExtrudedDirection = ExtrudedDirection;
			this.Depth = Depth;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceOfRevolution
	/// <para>ENTITY IfcSurfaceOfRevolution</para>
	/// <para> SUBTYPE OF (IfcSweptSurface);</para>
	/// <para>	AxisPosition : IfcAxis1Placement;</para>
	/// <para> DERIVE</para>
	/// <para>	 AxisLine : IfcLine := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcCurve() || IfcLine(AxisPosition.Location, </para>
	/// <para>  IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector(AxisPosition.Z,1.0));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceOfRevolution : IfcSweptSurface
	{
		public IfcAxis1Placement AxisPosition { get; set; }
		public IfcSurfaceOfRevolution() : base()
		{
			AxisPosition = new IfcAxis1Placement();
		}
		public IfcSurfaceOfRevolution(IfcProfileDef SweptCurve, IfcAxis2Placement3D Position, IfcAxis1Placement AxisPosition) : base (SweptCurve, Position)
		{
			this.AxisPosition = AxisPosition;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceReinforcementArea
	/// <para>ENTITY IfcSurfaceReinforcementArea</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadOrResult);</para>
	/// <para>	SurfaceReinforcement1 : OPTIONAL LIST [2:3] OF IfcLengthMeasure;</para>
	/// <para>	SurfaceReinforcement2 : OPTIONAL LIST [2:3] OF IfcLengthMeasure;</para>
	/// <para>	ShearReinforcement : OPTIONAL IfcRatioMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	NonnegativeArea1 : (NOT EXISTS(SurfaceReinforcement1)) OR (</para>
	/// <para>    (SurfaceReinforcement1[1] >= 0.) AND</para>
	/// <para>    (SurfaceReinforcement1[2] >= 0.) AND</para>
	/// <para>    ((SIZEOF(SurfaceReinforcement1) = 1) OR (SurfaceReinforcement1[1] >= 0.))</para>
	/// <para>);</para>
	/// <para>	NonnegativeArea2 : (NOT EXISTS(SurfaceReinforcement2)) OR (</para>
	/// <para>    (SurfaceReinforcement2[1] >= 0.) AND</para>
	/// <para>    (SurfaceReinforcement2[2] >= 0.) AND</para>
	/// <para>    ((SIZEOF(SurfaceReinforcement2) = 1) OR (SurfaceReinforcement2[1] >= 0.))</para>
	/// <para>);</para>
	/// <para>	NonnegativeArea3 : (NOT EXISTS(ShearReinforcement)) OR (ShearReinforcement >= 0.);</para>
	/// <para>	SurfaceAndOrShearAreaSpecified : EXISTS(SurfaceReinforcement1) OR EXISTS(SurfaceReinforcement2) OR EXISTS(ShearReinforcement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceReinforcementArea : IfcStructuralLoadOrResult
	{
		public List<IfcLengthMeasure>? SurfaceReinforcement1 { get; set; }
		public List<IfcLengthMeasure>? SurfaceReinforcement2 { get; set; }
		public IfcRatioMeasure? ShearReinforcement { get; set; }
		public IfcSurfaceReinforcementArea() : base()
		{
		}
		public IfcSurfaceReinforcementArea(IfcLabel Name, List<IfcLengthMeasure> SurfaceReinforcement1, List<IfcLengthMeasure> SurfaceReinforcement2, IfcRatioMeasure ShearReinforcement) : base (Name)
		{
			this.SurfaceReinforcement1 = SurfaceReinforcement1;
			this.SurfaceReinforcement2 = SurfaceReinforcement2;
			this.ShearReinforcement = ShearReinforcement;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyle
	/// <para>ENTITY IfcSurfaceStyle</para>
	/// <para> SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>	Side : IfcSurfaceSide;</para>
	/// <para>	Styles : SET [1:5] OF IfcSurfaceStyleElementSelect;</para>
	/// <para> WHERE</para>
	/// <para>	MaxOneExtDefined : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>  'IFC4X3_ADD2.IFCEXTERNALLYDEFINEDSURFACESTYLE' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	MaxOneLighting : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>  'IFC4X3_ADD2.IFCSURFACESTYLELIGHTING' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	MaxOneRefraction : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>  'IFC4X3_ADD2.IFCSURFACESTYLEREFRACTION' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	MaxOneShading : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>  'IFC4X3_ADD2.IFCSURFACESTYLESHADING' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	MaxOneTextures : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>  'IFC4X3_ADD2.IFCSURFACESTYLEWITHTEXTURES' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyle : IfcPresentationStyle
	{
		public IfcSurfaceSide Side { get; set; }
		public List<IfcSurfaceStyleElementSelect> Styles { get; set; }
		public IfcSurfaceStyle() : base()
		{
			Side = new IfcSurfaceSide();
			Styles = new List<IfcSurfaceStyleElementSelect>();
		}
		public IfcSurfaceStyle(IfcLabel Name, IfcSurfaceSide Side, List<IfcSurfaceStyleElementSelect> Styles) : base (Name)
		{
			this.Side = Side;
			this.Styles = Styles;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleLighting
	/// <para>ENTITY IfcSurfaceStyleLighting</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	DiffuseTransmissionColour : IfcColourRgb;</para>
	/// <para>	DiffuseReflectionColour : IfcColourRgb;</para>
	/// <para>	TransmissionColour : IfcColourRgb;</para>
	/// <para>	ReflectanceColour : IfcColourRgb;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleLighting : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public IfcColourRgb DiffuseTransmissionColour { get; set; }
		public IfcColourRgb DiffuseReflectionColour { get; set; }
		public IfcColourRgb TransmissionColour { get; set; }
		public IfcColourRgb ReflectanceColour { get; set; }
		public IfcSurfaceStyleLighting() : base()
		{
			DiffuseTransmissionColour = new IfcColourRgb();
			DiffuseReflectionColour = new IfcColourRgb();
			TransmissionColour = new IfcColourRgb();
			ReflectanceColour = new IfcColourRgb();
		}
		public IfcSurfaceStyleLighting(IfcColourRgb DiffuseTransmissionColour, IfcColourRgb DiffuseReflectionColour, IfcColourRgb TransmissionColour, IfcColourRgb ReflectanceColour) : base ()
		{
			this.DiffuseTransmissionColour = DiffuseTransmissionColour;
			this.DiffuseReflectionColour = DiffuseReflectionColour;
			this.TransmissionColour = TransmissionColour;
			this.ReflectanceColour = ReflectanceColour;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleRefraction
	/// <para>ENTITY IfcSurfaceStyleRefraction</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	RefractionIndex : OPTIONAL IfcReal;</para>
	/// <para>	DispersionFactor : OPTIONAL IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleRefraction : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public IfcReal? RefractionIndex { get; set; }
		public IfcReal? DispersionFactor { get; set; }
		public IfcSurfaceStyleRefraction() : base()
		{
		}
		public IfcSurfaceStyleRefraction(IfcReal RefractionIndex, IfcReal DispersionFactor) : base ()
		{
			this.RefractionIndex = RefractionIndex;
			this.DispersionFactor = DispersionFactor;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleRendering
	/// <para>ENTITY IfcSurfaceStyleRendering</para>
	/// <para> SUBTYPE OF (IfcSurfaceStyleShading);</para>
	/// <para>	DiffuseColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>	TransmissionColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>	DiffuseTransmissionColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>	ReflectionColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>	SpecularColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>	SpecularHighlight : OPTIONAL IfcSpecularHighlightSelect;</para>
	/// <para>	ReflectanceMethod : IfcReflectanceMethodEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleRendering : IfcSurfaceStyleShading
	{
		public IfcColourOrFactor? DiffuseColour { get; set; }
		public IfcColourOrFactor? TransmissionColour { get; set; }
		public IfcColourOrFactor? DiffuseTransmissionColour { get; set; }
		public IfcColourOrFactor? ReflectionColour { get; set; }
		public IfcColourOrFactor? SpecularColour { get; set; }
		public IfcSpecularHighlightSelect? SpecularHighlight { get; set; }
		public IfcReflectanceMethodEnum ReflectanceMethod { get; set; }
		public IfcSurfaceStyleRendering() : base()
		{
			ReflectanceMethod = new IfcReflectanceMethodEnum();
		}
		public IfcSurfaceStyleRendering(IfcColourRgb SurfaceColour, IfcNormalisedRatioMeasure Transparency, IfcColourOrFactor DiffuseColour, IfcColourOrFactor TransmissionColour, IfcColourOrFactor DiffuseTransmissionColour, IfcColourOrFactor ReflectionColour, IfcColourOrFactor SpecularColour, IfcSpecularHighlightSelect SpecularHighlight, IfcReflectanceMethodEnum ReflectanceMethod) : base (SurfaceColour, Transparency)
		{
			this.DiffuseColour = DiffuseColour;
			this.TransmissionColour = TransmissionColour;
			this.DiffuseTransmissionColour = DiffuseTransmissionColour;
			this.ReflectionColour = ReflectionColour;
			this.SpecularColour = SpecularColour;
			this.SpecularHighlight = SpecularHighlight;
			this.ReflectanceMethod = ReflectanceMethod;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleShading
	/// <para>ENTITY IfcSurfaceStyleShading</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcSurfaceStyleRendering))</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	SurfaceColour : IfcColourRgb;</para>
	/// <para>	Transparency : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleShading : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public IfcColourRgb SurfaceColour { get; set; }
		public IfcNormalisedRatioMeasure? Transparency { get; set; }
		public IfcSurfaceStyleShading() : base()
		{
			SurfaceColour = new IfcColourRgb();
		}
		public IfcSurfaceStyleShading(IfcColourRgb SurfaceColour, IfcNormalisedRatioMeasure Transparency) : base ()
		{
			this.SurfaceColour = SurfaceColour;
			this.Transparency = Transparency;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleWithTextures
	/// <para>ENTITY IfcSurfaceStyleWithTextures</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Textures : LIST [1:?] OF IfcSurfaceTexture;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleWithTextures : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public List<IfcSurfaceTexture> Textures { get; set; }
		public IfcSurfaceStyleWithTextures() : base()
		{
			Textures = new List<IfcSurfaceTexture>();
		}
		public IfcSurfaceStyleWithTextures(List<IfcSurfaceTexture> Textures) : base ()
		{
			this.Textures = Textures;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceTexture
	/// <para>ENTITY IfcSurfaceTexture</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBlobTexture</para>
	/// <para>	,IfcImageTexture</para>
	/// <para>	,IfcPixelTexture))</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	RepeatS : IfcBoolean;</para>
	/// <para>	RepeatT : IfcBoolean;</para>
	/// <para>	Mode : OPTIONAL IfcIdentifier;</para>
	/// <para>	TextureTransform : OPTIONAL IfcCartesianTransformationOperator2D;</para>
	/// <para>	Parameter : OPTIONAL LIST [1:?] OF IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	IsMappedBy : SET [0:?] OF IfcTextureCoordinate FOR Maps;</para>
	/// <para>	UsedInStyles : SET [0:?] OF IfcSurfaceStyleWithTextures FOR Textures;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSurfaceTexture : IfcPresentationItem
	{
		public IfcBoolean RepeatS { get; set; }
		public IfcBoolean RepeatT { get; set; }
		public IfcIdentifier? Mode { get; set; }
		public IfcCartesianTransformationOperator2D? TextureTransform { get; set; }
		public List<IfcIdentifier>? Parameter { get; set; }
		public IfcSurfaceTexture() : base()
		{
			RepeatS = new IfcBoolean();
			RepeatT = new IfcBoolean();
		}
		public IfcSurfaceTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter) : base ()
		{
			this.RepeatS = RepeatS;
			this.RepeatT = RepeatT;
			this.Mode = Mode;
			this.TextureTransform = TextureTransform;
			this.Parameter = Parameter;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptAreaSolid
	/// <para>ENTITY IfcSweptAreaSolid</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcDirectrixCurveSweptAreaSolid</para>
	/// <para>	,IfcExtrudedAreaSolid</para>
	/// <para>	,IfcRevolvedAreaSolid))</para>
	/// <para> SUBTYPE OF (IfcSolidModel);</para>
	/// <para>	SweptArea : IfcProfileDef;</para>
	/// <para>	Position : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para> WHERE</para>
	/// <para>	SweptAreaType : SweptArea.ProfileType = IfcProfileTypeEnum.Area;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSweptAreaSolid : IfcSolidModel
	{
		public IfcProfileDef SweptArea { get; set; }
		public IfcAxis2Placement3D? Position { get; set; }
		public IfcSweptAreaSolid() : base()
		{
			SweptArea = new IfcProfileDef();
		}
		public IfcSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position) : base ()
		{
			this.SweptArea = SweptArea;
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptDiskSolid
	/// <para>ENTITY IfcSweptDiskSolid</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcSweptDiskSolidPolygonal))</para>
	/// <para> SUBTYPE OF (IfcSolidModel);</para>
	/// <para>	Directrix : IfcCurve;</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>	InnerRadius : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	StartParam : OPTIONAL IfcParameterValue;</para>
	/// <para>	EndParam : OPTIONAL IfcParameterValue;</para>
	/// <para> WHERE</para>
	/// <para>	DirectrixBounded : (EXISTS(StartParam) AND EXISTS(EndParam)) OR </para>
	/// <para>(SIZEOF(['IFC4X3_ADD2.IFCCONIC', 'IFC4X3_ADD2.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1);</para>
	/// <para>	DirectrixDim : Directrix.Dim = 3;</para>
	/// <para>	InnerRadiusSize : (NOT EXISTS(InnerRadius)) OR (Radius > InnerRadius);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSweptDiskSolid : IfcSolidModel
	{
		public IfcCurve Directrix { get; set; }
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcPositiveLengthMeasure? InnerRadius { get; set; }
		public IfcParameterValue? StartParam { get; set; }
		public IfcParameterValue? EndParam { get; set; }
		public IfcSweptDiskSolid() : base()
		{
			Directrix = new IfcCurve();
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcSweptDiskSolid(IfcCurve Directrix, IfcPositiveLengthMeasure Radius, IfcPositiveLengthMeasure InnerRadius, IfcParameterValue StartParam, IfcParameterValue EndParam) : base ()
		{
			this.Directrix = Directrix;
			this.Radius = Radius;
			this.InnerRadius = InnerRadius;
			this.StartParam = StartParam;
			this.EndParam = EndParam;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptDiskSolidPolygonal
	/// <para>ENTITY IfcSweptDiskSolidPolygonal</para>
	/// <para> SUBTYPE OF (IfcSweptDiskSolid);</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectRadii : NOT(EXISTS(FilletRadius)) OR (FilletRadius >= SELF\IfcSweptDiskSolid.Radius);</para>
	/// <para>	DirectrixIsPolyline : ('IFC4X3_ADD2.IFCPOLYLINE' IN TYPEOF(SELF\IfcSweptDiskSolid.Directrix)) OR</para>
	/// <para>(('IFC4X3_ADD2.IFCINDEXEDPOLYCURVE' IN TYPEOF(SELF\IfcSweptDiskSolid.Directrix)) AND NOT(EXISTS(SELF\IfcSweptDiskSolid.Directrix\IfcIndexedPolyCurve.Segments)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSweptDiskSolidPolygonal : IfcSweptDiskSolid
	{
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcSweptDiskSolidPolygonal() : base()
		{
		}
		public IfcSweptDiskSolidPolygonal(IfcCurve Directrix, IfcPositiveLengthMeasure Radius, IfcPositiveLengthMeasure InnerRadius, IfcParameterValue StartParam, IfcParameterValue EndParam, IfcNonNegativeLengthMeasure FilletRadius) : base (Directrix, Radius, InnerRadius, StartParam, EndParam)
		{
			this.FilletRadius = FilletRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptSurface
	/// <para>ENTITY IfcSweptSurface</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcSurfaceOfLinearExtrusion</para>
	/// <para>	,IfcSurfaceOfRevolution))</para>
	/// <para> SUBTYPE OF (IfcSurface);</para>
	/// <para>	SweptCurve : IfcProfileDef;</para>
	/// <para>	Position : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para> WHERE</para>
	/// <para>	SweptCurveType : SweptCurve.ProfileType = IfcProfileTypeEnum.Curve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSweptSurface : IfcSurface
	{
		public IfcProfileDef SweptCurve { get; set; }
		public IfcAxis2Placement3D? Position { get; set; }
		public IfcSweptSurface() : base()
		{
			SweptCurve = new IfcProfileDef();
		}
		public IfcSweptSurface(IfcProfileDef SweptCurve, IfcAxis2Placement3D Position) : base ()
		{
			this.SweptCurve = SweptCurve;
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcSwitchingDevice
	/// <para>ENTITY IfcSwitchingDevice</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSwitchingDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSwitchingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSwitchingDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSWITCHINGDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSwitchingDevice : IfcFlowController
	{
		public IfcSwitchingDeviceTypeEnum? PredefinedType { get; set; }
		public IfcSwitchingDevice() : base()
		{
		}
		public IfcSwitchingDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSwitchingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSwitchingDeviceType
	/// <para>ENTITY IfcSwitchingDeviceType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcSwitchingDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSwitchingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSwitchingDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSwitchingDeviceType : IfcFlowControllerType
	{
		public IfcSwitchingDeviceTypeEnum PredefinedType { get; set; }
		public IfcSwitchingDeviceType() : base()
		{
			PredefinedType = new IfcSwitchingDeviceTypeEnum();
		}
		public IfcSwitchingDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSwitchingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSystem
	/// <para>ENTITY IfcSystem</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcBuildingSystem</para>
	/// <para>	,IfcBuiltSystem</para>
	/// <para>	,IfcDistributionSystem</para>
	/// <para>	,IfcStructuralAnalysisModel</para>
	/// <para>	,IfcZone))</para>
	/// <para> SUBTYPE OF (IfcGroup);</para>
	/// <para> INVERSE</para>
	/// <para>	ServicesBuildings : SET [0:1] OF IfcRelServicesBuildings FOR RelatingSystem;</para>
	/// <para>	ServicesFacilities : SET [0:?] OF IfcRelReferencedInSpatialStructure FOR RelatedElements;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSystem : IfcGroup
	{
		public IfcSystem() : base()
		{
		}
		public IfcSystem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSystemFurnitureElement
	/// <para>ENTITY IfcSystemFurnitureElement</para>
	/// <para> SUBTYPE OF (IfcFurnishingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSystemFurnitureElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSystemFurnitureElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSystemFurnitureElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSYSTEMFURNITUREELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSystemFurnitureElement : IfcFurnishingElement
	{
		public IfcSystemFurnitureElementTypeEnum? PredefinedType { get; set; }
		public IfcSystemFurnitureElement() : base()
		{
		}
		public IfcSystemFurnitureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSystemFurnitureElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSystemFurnitureElementType
	/// <para>ENTITY IfcSystemFurnitureElementType</para>
	/// <para> SUBTYPE OF (IfcFurnishingElementType);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSystemFurnitureElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSystemFurnitureElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSystemFurnitureElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSystemFurnitureElementType : IfcFurnishingElementType
	{
		public IfcSystemFurnitureElementTypeEnum? PredefinedType { get; set; }
		public IfcSystemFurnitureElementType() : base()
		{
		}
		public IfcSystemFurnitureElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSystemFurnitureElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTShapeProfileDef
	/// <para>ENTITY IfcTShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	FlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	WebEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	WebSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>	FlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidFlangeThickness : FlangeThickness < Depth;</para>
	/// <para>	ValidWebThickness : WebThickness < FlangeWidth;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcPositiveLengthMeasure FlangeWidth { get; set; }
		public IfcPositiveLengthMeasure WebThickness { get; set; }
		public IfcPositiveLengthMeasure FlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? FlangeEdgeRadius { get; set; }
		public IfcNonNegativeLengthMeasure? WebEdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? WebSlope { get; set; }
		public IfcPlaneAngleMeasure? FlangeSlope { get; set; }
		public IfcTShapeProfileDef() : base()
		{
			Depth = new IfcPositiveLengthMeasure();
			FlangeWidth = new IfcPositiveLengthMeasure();
			WebThickness = new IfcPositiveLengthMeasure();
			FlangeThickness = new IfcPositiveLengthMeasure();
		}
		public IfcTShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure FlangeWidth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure FlangeEdgeRadius, IfcNonNegativeLengthMeasure WebEdgeRadius, IfcPlaneAngleMeasure WebSlope, IfcPlaneAngleMeasure FlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.FlangeWidth = FlangeWidth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.FlangeEdgeRadius = FlangeEdgeRadius;
			this.WebEdgeRadius = WebEdgeRadius;
			this.WebSlope = WebSlope;
			this.FlangeSlope = FlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcTable;
	/// <para>ENTITY IfcTable;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Rows : OPTIONAL LIST [1:?] OF IfcTableRow;</para>
	/// <para>	Columns : OPTIONAL LIST [1:?] OF IfcTableColumn;</para>
	/// <para> DERIVE</para>
	/// <para>	 NumberOfCellsInRow : IfcInteger := HIINDEX(Rows[1].RowCells);</para>
	/// <para>	 NumberOfHeadings : IfcInteger := SIZEOF(QUERY( Temp <* Rows | Temp.IsHeading));</para>
	/// <para>	 NumberOfDataRows : IfcInteger := SIZEOF(QUERY( Temp <* Rows | NOT(Temp.IsHeading)));</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SIZEOF(QUERY( Temp <* Rows | HIINDEX(Temp.RowCells) <> HIINDEX(Rows[1].RowCells))) = 0;</para>
	/// <para>	WR2 : { 0 <= NumberOfHeadings <= 1 };</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTableENTITY, IfcMetricValueSelect, IfcObjectReferenceSelect
	{
		public IfcLabel? Name { get; set; }
		public List<IfcTableRow>? Rows { get; set; }
		public List<IfcTableColumn>? Columns { get; set; }
		public IfcTable() : base()
		{
		}
		public IfcTable(IfcLabel Name, List<IfcTableRow> Rows, List<IfcTableColumn> Columns) : base ()
		{
			this.Name = Name;
			this.Rows = Rows;
			this.Columns = Columns;
		}
	}
	/// <summary>
	/// ENTITY IfcTableColumn;
	/// <para>ENTITY IfcTableColumn;</para>
	/// <para>	Identifier : OPTIONAL IfcIdentifier;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para>	ReferencePath : OPTIONAL IfcReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTableColumnENTITY
	{
		public IfcIdentifier? Identifier { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcUnit? Unit { get; set; }
		public IfcReference? ReferencePath { get; set; }
		public IfcTableColumn() : base()
		{
		}
		public IfcTableColumn(IfcIdentifier Identifier, IfcLabel Name, IfcText Description, IfcUnit Unit, IfcReference ReferencePath) : base ()
		{
			this.Identifier = Identifier;
			this.Name = Name;
			this.Description = Description;
			this.Unit = Unit;
			this.ReferencePath = ReferencePath;
		}
	}
	/// <summary>
	/// ENTITY IfcTableRow;
	/// <para>ENTITY IfcTableRow;</para>
	/// <para>	RowCells : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>	IsHeading : OPTIONAL IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTableRowENTITY
	{
		public List<IfcValue>? RowCells { get; set; }
		public IfcBoolean? IsHeading { get; set; }
		public IfcTableRow() : base()
		{
		}
		public IfcTableRow(List<IfcValue> RowCells, IfcBoolean IsHeading) : base ()
		{
			this.RowCells = RowCells;
			this.IsHeading = IsHeading;
		}
	}
	/// <summary>
	/// ENTITY IfcTank
	/// <para>ENTITY IfcTank</para>
	/// <para> SUBTYPE OF (IfcFlowStorageDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTankTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcTankTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTankTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCTANKTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTank : IfcFlowStorageDevice
	{
		public IfcTankTypeEnum? PredefinedType { get; set; }
		public IfcTank() : base()
		{
		}
		public IfcTank(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTankTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTankType
	/// <para>ENTITY IfcTankType</para>
	/// <para> SUBTYPE OF (IfcFlowStorageDeviceType);</para>
	/// <para>	PredefinedType : IfcTankTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTankTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTankTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTankType : IfcFlowStorageDeviceType
	{
		public IfcTankTypeEnum PredefinedType { get; set; }
		public IfcTankType() : base()
		{
			PredefinedType = new IfcTankTypeEnum();
		}
		public IfcTankType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTankTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTask
	/// <para>ENTITY IfcTask</para>
	/// <para> SUBTYPE OF (IfcProcess);</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	WorkMethod : OPTIONAL IfcLabel;</para>
	/// <para>	IsMilestone : IfcBoolean;</para>
	/// <para>	Priority : OPTIONAL IfcInteger;</para>
	/// <para>	TaskTime : OPTIONAL IfcTaskTime;</para>
	/// <para>	PredefinedType : OPTIONAL IfcTaskTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcTaskTypeEnum.USERDEFINED) OR ((PredefinedType = IfcTaskTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>	HasName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTask : IfcProcess
	{
		public IfcLabel? Status { get; set; }
		public IfcLabel? WorkMethod { get; set; }
		public IfcBoolean IsMilestone { get; set; }
		public IfcInteger? Priority { get; set; }
		public IfcTaskTime? TaskTime { get; set; }
		public IfcTaskTypeEnum? PredefinedType { get; set; }
		public IfcTask() : base()
		{
			IsMilestone = new IfcBoolean();
		}
		public IfcTask(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcLabel Status, IfcLabel WorkMethod, IfcBoolean IsMilestone, IfcInteger Priority, IfcTaskTime TaskTime, IfcTaskTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.Status = Status;
			this.WorkMethod = WorkMethod;
			this.IsMilestone = IsMilestone;
			this.Priority = Priority;
			this.TaskTime = TaskTime;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTaskTime
	/// <para>ENTITY IfcTaskTime</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcTaskTimeRecurring))</para>
	/// <para> SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>	DurationType : OPTIONAL IfcTaskDurationEnum;</para>
	/// <para>	ScheduleDuration : OPTIONAL IfcDuration;</para>
	/// <para>	ScheduleStart : OPTIONAL IfcDateTime;</para>
	/// <para>	ScheduleFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	EarlyStart : OPTIONAL IfcDateTime;</para>
	/// <para>	EarlyFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	LateStart : OPTIONAL IfcDateTime;</para>
	/// <para>	LateFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	FreeFloat : OPTIONAL IfcDuration;</para>
	/// <para>	TotalFloat : OPTIONAL IfcDuration;</para>
	/// <para>	IsCritical : OPTIONAL IfcBoolean;</para>
	/// <para>	StatusTime : OPTIONAL IfcDateTime;</para>
	/// <para>	ActualDuration : OPTIONAL IfcDuration;</para>
	/// <para>	ActualStart : OPTIONAL IfcDateTime;</para>
	/// <para>	ActualFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	RemainingTime : OPTIONAL IfcDuration;</para>
	/// <para>	Completion : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTaskTime : IfcSchedulingTime
	{
		public IfcTaskDurationEnum? DurationType { get; set; }
		public IfcDuration? ScheduleDuration { get; set; }
		public IfcDateTime? ScheduleStart { get; set; }
		public IfcDateTime? ScheduleFinish { get; set; }
		public IfcDateTime? EarlyStart { get; set; }
		public IfcDateTime? EarlyFinish { get; set; }
		public IfcDateTime? LateStart { get; set; }
		public IfcDateTime? LateFinish { get; set; }
		public IfcDuration? FreeFloat { get; set; }
		public IfcDuration? TotalFloat { get; set; }
		public IfcBoolean? IsCritical { get; set; }
		public IfcDateTime? StatusTime { get; set; }
		public IfcDuration? ActualDuration { get; set; }
		public IfcDateTime? ActualStart { get; set; }
		public IfcDateTime? ActualFinish { get; set; }
		public IfcDuration? RemainingTime { get; set; }
		public IfcPositiveRatioMeasure? Completion { get; set; }
		public IfcTaskTime() : base()
		{
		}
		public IfcTaskTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcTaskDurationEnum DurationType, IfcDuration ScheduleDuration, IfcDateTime ScheduleStart, IfcDateTime ScheduleFinish, IfcDateTime EarlyStart, IfcDateTime EarlyFinish, IfcDateTime LateStart, IfcDateTime LateFinish, IfcDuration FreeFloat, IfcDuration TotalFloat, IfcBoolean IsCritical, IfcDateTime StatusTime, IfcDuration ActualDuration, IfcDateTime ActualStart, IfcDateTime ActualFinish, IfcDuration RemainingTime, IfcPositiveRatioMeasure Completion) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.DurationType = DurationType;
			this.ScheduleDuration = ScheduleDuration;
			this.ScheduleStart = ScheduleStart;
			this.ScheduleFinish = ScheduleFinish;
			this.EarlyStart = EarlyStart;
			this.EarlyFinish = EarlyFinish;
			this.LateStart = LateStart;
			this.LateFinish = LateFinish;
			this.FreeFloat = FreeFloat;
			this.TotalFloat = TotalFloat;
			this.IsCritical = IsCritical;
			this.StatusTime = StatusTime;
			this.ActualDuration = ActualDuration;
			this.ActualStart = ActualStart;
			this.ActualFinish = ActualFinish;
			this.RemainingTime = RemainingTime;
			this.Completion = Completion;
		}
	}
	/// <summary>
	/// ENTITY IfcTaskTimeRecurring
	/// <para>ENTITY IfcTaskTimeRecurring</para>
	/// <para> SUBTYPE OF (IfcTaskTime);</para>
	/// <para>	Recurrence : IfcRecurrencePattern;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTaskTimeRecurring : IfcTaskTime
	{
		public IfcRecurrencePattern Recurrence { get; set; }
		public IfcTaskTimeRecurring() : base()
		{
			Recurrence = new IfcRecurrencePattern();
		}
		public IfcTaskTimeRecurring(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcTaskDurationEnum DurationType, IfcDuration ScheduleDuration, IfcDateTime ScheduleStart, IfcDateTime ScheduleFinish, IfcDateTime EarlyStart, IfcDateTime EarlyFinish, IfcDateTime LateStart, IfcDateTime LateFinish, IfcDuration FreeFloat, IfcDuration TotalFloat, IfcBoolean IsCritical, IfcDateTime StatusTime, IfcDuration ActualDuration, IfcDateTime ActualStart, IfcDateTime ActualFinish, IfcDuration RemainingTime, IfcPositiveRatioMeasure Completion, IfcRecurrencePattern Recurrence) : base (Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion)
		{
			this.Recurrence = Recurrence;
		}
	}
	/// <summary>
	/// ENTITY IfcTaskType
	/// <para>ENTITY IfcTaskType</para>
	/// <para> SUBTYPE OF (IfcTypeProcess);</para>
	/// <para>	PredefinedType : IfcTaskTypeEnum;</para>
	/// <para>	WorkMethod : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTaskTypeEnum.USERDEFINED) OR ((PredefinedType = IfcTaskTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTaskType : IfcTypeProcess
	{
		public IfcTaskTypeEnum PredefinedType { get; set; }
		public IfcLabel? WorkMethod { get; set; }
		public IfcTaskType() : base()
		{
			PredefinedType = new IfcTaskTypeEnum();
		}
		public IfcTaskType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType, IfcTaskTypeEnum PredefinedType, IfcLabel WorkMethod) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType)
		{
			this.PredefinedType = PredefinedType;
			this.WorkMethod = WorkMethod;
		}
	}
	/// <summary>
	/// ENTITY IfcTelecomAddress
	/// <para>ENTITY IfcTelecomAddress</para>
	/// <para> SUBTYPE OF (IfcAddress);</para>
	/// <para>	TelephoneNumbers : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	FacsimileNumbers : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	PagerNumber : OPTIONAL IfcLabel;</para>
	/// <para>	ElectronicMailAddresses : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	WWWHomePageURL : OPTIONAL IfcURIReference;</para>
	/// <para>	MessagingIDs : OPTIONAL LIST [1:?] OF IfcURIReference;</para>
	/// <para> WHERE</para>
	/// <para>	MinimumDataProvided : EXISTS (TelephoneNumbers) OR</para>
	/// <para>EXISTS (FacsimileNumbers) OR </para>
	/// <para>EXISTS (PagerNumber) OR</para>
	/// <para>EXISTS (ElectronicMailAddresses) OR </para>
	/// <para>EXISTS (WWWHomePageURL) OR</para>
	/// <para>EXISTS (MessagingIDs);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTelecomAddress : IfcAddress
	{
		public List<IfcLabel>? TelephoneNumbers { get; set; }
		public List<IfcLabel>? FacsimileNumbers { get; set; }
		public IfcLabel? PagerNumber { get; set; }
		public List<IfcLabel>? ElectronicMailAddresses { get; set; }
		public IfcURIReference? WWWHomePageURL { get; set; }
		public List<IfcURIReference>? MessagingIDs { get; set; }
		public IfcTelecomAddress() : base()
		{
		}
		public IfcTelecomAddress(IfcAddressTypeEnum Purpose, IfcText Description, IfcLabel UserDefinedPurpose, List<IfcLabel> TelephoneNumbers, List<IfcLabel> FacsimileNumbers, IfcLabel PagerNumber, List<IfcLabel> ElectronicMailAddresses, IfcURIReference WWWHomePageURL, List<IfcURIReference> MessagingIDs) : base (Purpose, Description, UserDefinedPurpose)
		{
			this.TelephoneNumbers = TelephoneNumbers;
			this.FacsimileNumbers = FacsimileNumbers;
			this.PagerNumber = PagerNumber;
			this.ElectronicMailAddresses = ElectronicMailAddresses;
			this.WWWHomePageURL = WWWHomePageURL;
			this.MessagingIDs = MessagingIDs;
		}
	}
	/// <summary>
	/// ENTITY IfcTendon
	/// <para>ENTITY IfcTendon</para>
	/// <para> SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTendonTypeEnum;</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	TensionForce : OPTIONAL IfcForceMeasure;</para>
	/// <para>	PreStress : OPTIONAL IfcPressureMeasure;</para>
	/// <para>	FrictionCoefficient : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	AnchorageSlip : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	MinCurvatureRadius : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcTendonTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTendonTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCTENDONTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendon : IfcReinforcingElement
	{
		public IfcTendonTypeEnum? PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcAreaMeasure? CrossSectionArea { get; set; }
		public IfcForceMeasure? TensionForce { get; set; }
		public IfcPressureMeasure? PreStress { get; set; }
		public IfcNormalisedRatioMeasure? FrictionCoefficient { get; set; }
		public IfcPositiveLengthMeasure? AnchorageSlip { get; set; }
		public IfcPositiveLengthMeasure? MinCurvatureRadius { get; set; }
		public IfcTendon() : base()
		{
		}
		public IfcTendon(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcTendonTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcForceMeasure TensionForce, IfcPressureMeasure PreStress, IfcNormalisedRatioMeasure FrictionCoefficient, IfcPositiveLengthMeasure AnchorageSlip, IfcPositiveLengthMeasure MinCurvatureRadius) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.TensionForce = TensionForce;
			this.PreStress = PreStress;
			this.FrictionCoefficient = FrictionCoefficient;
			this.AnchorageSlip = AnchorageSlip;
			this.MinCurvatureRadius = MinCurvatureRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonAnchor
	/// <para>ENTITY IfcTendonAnchor</para>
	/// <para> SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTendonAnchorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcTendonAnchorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTendonAnchorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCTENDONANCHORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonAnchor : IfcReinforcingElement
	{
		public IfcTendonAnchorTypeEnum? PredefinedType { get; set; }
		public IfcTendonAnchor() : base()
		{
		}
		public IfcTendonAnchor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcTendonAnchorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonAnchorType
	/// <para>ENTITY IfcTendonAnchorType</para>
	/// <para> SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>	PredefinedType : IfcTendonAnchorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTendonAnchorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTendonAnchorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonAnchorType : IfcReinforcingElementType
	{
		public IfcTendonAnchorTypeEnum PredefinedType { get; set; }
		public IfcTendonAnchorType() : base()
		{
			PredefinedType = new IfcTendonAnchorTypeEnum();
		}
		public IfcTendonAnchorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTendonAnchorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonConduit
	/// <para>ENTITY IfcTendonConduit</para>
	/// <para> SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTendonConduitTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcTendonConduitTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTendonConduitTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCTENDONCONDUITTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonConduit : IfcReinforcingElement
	{
		public IfcTendonConduitTypeEnum? PredefinedType { get; set; }
		public IfcTendonConduit() : base()
		{
		}
		public IfcTendonConduit(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcTendonConduitTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonConduitType
	/// <para>ENTITY IfcTendonConduitType</para>
	/// <para> SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>	PredefinedType : IfcTendonConduitTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTendonConduitTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTendonConduitTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonConduitType : IfcReinforcingElementType
	{
		public IfcTendonConduitTypeEnum PredefinedType { get; set; }
		public IfcTendonConduitType() : base()
		{
			PredefinedType = new IfcTendonConduitTypeEnum();
		}
		public IfcTendonConduitType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTendonConduitTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonType
	/// <para>ENTITY IfcTendonType</para>
	/// <para> SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>	PredefinedType : IfcTendonTypeEnum;</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	SheathDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTendonTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTendonTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonType : IfcReinforcingElementType
	{
		public IfcTendonTypeEnum PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcAreaMeasure? CrossSectionArea { get; set; }
		public IfcPositiveLengthMeasure? SheathDiameter { get; set; }
		public IfcTendonType() : base()
		{
			PredefinedType = new IfcTendonTypeEnum();
		}
		public IfcTendonType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTendonTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcPositiveLengthMeasure SheathDiameter) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.SheathDiameter = SheathDiameter;
		}
	}
	/// <summary>
	/// ENTITY IfcTessellatedFaceSet
	/// <para>ENTITY IfcTessellatedFaceSet</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcPolygonalFaceSet</para>
	/// <para>	,IfcTriangulatedFaceSet))</para>
	/// <para> SUBTYPE OF (IfcTessellatedItem);</para>
	/// <para>	Coordinates : IfcCartesianPointList3D;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := 3;</para>
	/// <para> INVERSE</para>
	/// <para>	HasColours : SET [0:1] OF IfcIndexedColourMap FOR MappedTo;</para>
	/// <para>	HasTextures : SET [0:?] OF IfcIndexedTextureMap FOR MappedTo;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTessellatedFaceSet : IfcTessellatedItem, IfcBooleanOperand
	{
		public IfcCartesianPointList3D Coordinates { get; set; }
		public IfcTessellatedFaceSet() : base()
		{
			Coordinates = new IfcCartesianPointList3D();
		}
		public IfcTessellatedFaceSet(IfcCartesianPointList3D Coordinates) : base ()
		{
			this.Coordinates = Coordinates;
		}
	}
	/// <summary>
	/// ENTITY IfcTessellatedItem
	/// <para>ENTITY IfcTessellatedItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcIndexedPolygonalFace</para>
	/// <para>	,IfcTessellatedFaceSet))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTessellatedItem : IfcGeometricRepresentationItem
	{
		public IfcTessellatedItem() : base()
		{
		}
		public IfcTessellatedItem() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTextLiteral
	/// <para>ENTITY IfcTextLiteral</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcTextLiteralWithExtent))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Literal : IfcPresentableText;</para>
	/// <para>	Placement : IfcAxis2Placement;</para>
	/// <para>	Path : IfcTextPath;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextLiteral : IfcGeometricRepresentationItem
	{
		public IfcPresentableText Literal { get; set; }
		public IfcAxis2Placement Placement { get; set; }
		public IfcTextPath Path { get; set; }
		public IfcTextLiteral() : base()
		{
			Literal = new IfcPresentableText();
			Placement = new IfcAxis2Placement();
			Path = new IfcTextPath();
		}
		public IfcTextLiteral(IfcPresentableText Literal, IfcAxis2Placement Placement, IfcTextPath Path) : base ()
		{
			this.Literal = Literal;
			this.Placement = Placement;
			this.Path = Path;
		}
	}
	/// <summary>
	/// ENTITY IfcTextLiteralWithExtent
	/// <para>ENTITY IfcTextLiteralWithExtent</para>
	/// <para> SUBTYPE OF (IfcTextLiteral);</para>
	/// <para>	Extent : IfcPlanarExtent;</para>
	/// <para>	BoxAlignment : IfcBoxAlignment;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : NOT('IFC4X3_ADD2.IFCPLANARBOX' IN TYPEOF(Extent));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextLiteralWithExtent : IfcTextLiteral
	{
		public IfcPlanarExtent Extent { get; set; }
		public IfcBoxAlignment BoxAlignment { get; set; }
		public IfcTextLiteralWithExtent() : base()
		{
			Extent = new IfcPlanarExtent();
			BoxAlignment = new IfcBoxAlignment();
		}
		public IfcTextLiteralWithExtent(IfcPresentableText Literal, IfcAxis2Placement Placement, IfcTextPath Path, IfcPlanarExtent Extent, IfcBoxAlignment BoxAlignment) : base (Literal, Placement, Path)
		{
			this.Extent = Extent;
			this.BoxAlignment = BoxAlignment;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyle
	/// <para>ENTITY IfcTextStyle</para>
	/// <para> SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>	TextCharacterAppearance : OPTIONAL IfcTextStyleForDefinedFont;</para>
	/// <para>	TextStyle : OPTIONAL IfcTextStyleTextModel;</para>
	/// <para>	TextFontStyle : IfcTextFontSelect;</para>
	/// <para>	ModelOrDraughting : OPTIONAL IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyle : IfcPresentationStyle
	{
		public IfcTextStyleForDefinedFont? TextCharacterAppearance { get; set; }
		public IfcTextStyleTextModel? TextStyle { get; set; }
		public IfcTextFontSelect TextFontStyle { get; set; }
		public IfcBoolean? ModelOrDraughting { get; set; }
		public IfcTextStyle() : base()
		{
			TextFontStyle = new IfcTextFontSelect();
		}
		public IfcTextStyle(IfcLabel Name, IfcTextStyleForDefinedFont TextCharacterAppearance, IfcTextStyleTextModel TextStyle, IfcTextFontSelect TextFontStyle, IfcBoolean ModelOrDraughting) : base (Name)
		{
			this.TextCharacterAppearance = TextCharacterAppearance;
			this.TextStyle = TextStyle;
			this.TextFontStyle = TextFontStyle;
			this.ModelOrDraughting = ModelOrDraughting;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyleFontModel
	/// <para>ENTITY IfcTextStyleFontModel</para>
	/// <para> SUBTYPE OF (IfcPreDefinedTextFont);</para>
	/// <para>	FontFamily : LIST [1:?] OF IfcTextFontName;</para>
	/// <para>	FontStyle : OPTIONAL IfcFontStyle;</para>
	/// <para>	FontVariant : OPTIONAL IfcFontVariant;</para>
	/// <para>	FontWeight : OPTIONAL IfcFontWeight;</para>
	/// <para>	FontSize : IfcSizeSelect;</para>
	/// <para> WHERE</para>
	/// <para>	MeasureOfFontSize : ('IFC4X3_ADD2.IFCLENGTHMEASURE' IN TYPEOF(SELF.FontSize)) AND</para>
	/// <para>(SELF.FontSize > 0.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyleFontModel : IfcPreDefinedTextFont
	{
		public List<IfcTextFontName> FontFamily { get; set; }
		public IfcFontStyle? FontStyle { get; set; }
		public IfcFontVariant? FontVariant { get; set; }
		public IfcFontWeight? FontWeight { get; set; }
		public IfcSizeSelect FontSize { get; set; }
		public IfcTextStyleFontModel() : base()
		{
			FontFamily = new List<IfcTextFontName>();
			FontSize = new IfcSizeSelect();
		}
		public IfcTextStyleFontModel(IfcLabel Name, List<IfcTextFontName> FontFamily, IfcFontStyle FontStyle, IfcFontVariant FontVariant, IfcFontWeight FontWeight, IfcSizeSelect FontSize) : base (Name)
		{
			this.FontFamily = FontFamily;
			this.FontStyle = FontStyle;
			this.FontVariant = FontVariant;
			this.FontWeight = FontWeight;
			this.FontSize = FontSize;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyleForDefinedFont
	/// <para>ENTITY IfcTextStyleForDefinedFont</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Colour : IfcColour;</para>
	/// <para>	BackgroundColour : OPTIONAL IfcColour;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyleForDefinedFont : IfcPresentationItem
	{
		public IfcColour Colour { get; set; }
		public IfcColour? BackgroundColour { get; set; }
		public IfcTextStyleForDefinedFont() : base()
		{
			Colour = new IfcColour();
		}
		public IfcTextStyleForDefinedFont(IfcColour Colour, IfcColour BackgroundColour) : base ()
		{
			this.Colour = Colour;
			this.BackgroundColour = BackgroundColour;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyleTextModel
	/// <para>ENTITY IfcTextStyleTextModel</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	TextIndent : OPTIONAL IfcSizeSelect;</para>
	/// <para>	TextAlign : OPTIONAL IfcTextAlignment;</para>
	/// <para>	TextDecoration : OPTIONAL IfcTextDecoration;</para>
	/// <para>	LetterSpacing : OPTIONAL IfcSizeSelect;</para>
	/// <para>	WordSpacing : OPTIONAL IfcSizeSelect;</para>
	/// <para>	TextTransform : OPTIONAL IfcTextTransformation;</para>
	/// <para>	LineHeight : OPTIONAL IfcSizeSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyleTextModel : IfcPresentationItem
	{
		public IfcSizeSelect? TextIndent { get; set; }
		public IfcTextAlignment? TextAlign { get; set; }
		public IfcTextDecoration? TextDecoration { get; set; }
		public IfcSizeSelect? LetterSpacing { get; set; }
		public IfcSizeSelect? WordSpacing { get; set; }
		public IfcTextTransformation? TextTransform { get; set; }
		public IfcSizeSelect? LineHeight { get; set; }
		public IfcTextStyleTextModel() : base()
		{
		}
		public IfcTextStyleTextModel(IfcSizeSelect TextIndent, IfcTextAlignment TextAlign, IfcTextDecoration TextDecoration, IfcSizeSelect LetterSpacing, IfcSizeSelect WordSpacing, IfcTextTransformation TextTransform, IfcSizeSelect LineHeight) : base ()
		{
			this.TextIndent = TextIndent;
			this.TextAlign = TextAlign;
			this.TextDecoration = TextDecoration;
			this.LetterSpacing = LetterSpacing;
			this.WordSpacing = WordSpacing;
			this.TextTransform = TextTransform;
			this.LineHeight = LineHeight;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureCoordinate
	/// <para>ENTITY IfcTextureCoordinate</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcIndexedTextureMap</para>
	/// <para>	,IfcTextureCoordinateGenerator</para>
	/// <para>	,IfcTextureMap))</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Maps : LIST [1:?] OF IfcSurfaceTexture;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTextureCoordinate : IfcPresentationItem
	{
		public List<IfcSurfaceTexture> Maps { get; set; }
		public IfcTextureCoordinate() : base()
		{
			Maps = new List<IfcSurfaceTexture>();
		}
		public IfcTextureCoordinate(List<IfcSurfaceTexture> Maps) : base ()
		{
			this.Maps = Maps;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureCoordinateGenerator
	/// <para>ENTITY IfcTextureCoordinateGenerator</para>
	/// <para> SUBTYPE OF (IfcTextureCoordinate);</para>
	/// <para>	Mode : IfcLabel;</para>
	/// <para>	Parameter : OPTIONAL LIST [1:?] OF IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureCoordinateGenerator : IfcTextureCoordinate
	{
		public IfcLabel Mode { get; set; }
		public List<IfcReal>? Parameter { get; set; }
		public IfcTextureCoordinateGenerator() : base()
		{
			Mode = new IfcLabel();
		}
		public IfcTextureCoordinateGenerator(List<IfcSurfaceTexture> Maps, IfcLabel Mode, List<IfcReal> Parameter) : base (Maps)
		{
			this.Mode = Mode;
			this.Parameter = Parameter;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureCoordinateIndices
	/// <para>ENTITY IfcTextureCoordinateIndices</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcTextureCoordinateIndicesWithVoids));</para>
	/// <para>	TexCoordIndex : LIST [3:?] OF IfcPositiveInteger;</para>
	/// <para>	TexCoordsOf : IfcIndexedPolygonalFace;</para>
	/// <para> INVERSE</para>
	/// <para>	ToTexMap : IfcIndexedPolygonalTextureMap FOR TexCoordIndices;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureCoordinateIndicesENTITY
	{
		public List<IfcPositiveInteger> TexCoordIndex { get; set; }
		public IfcIndexedPolygonalFace TexCoordsOf { get; set; }
		public IfcTextureCoordinateIndices() : base()
		{
			TexCoordIndex = new List<IfcPositiveInteger>();
			TexCoordsOf = new IfcIndexedPolygonalFace();
		}
		public IfcTextureCoordinateIndices(List<IfcPositiveInteger> TexCoordIndex, IfcIndexedPolygonalFace TexCoordsOf) : base ()
		{
			this.TexCoordIndex = TexCoordIndex;
			this.TexCoordsOf = TexCoordsOf;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureCoordinateIndicesWithVoids
	/// <para>ENTITY IfcTextureCoordinateIndicesWithVoids</para>
	/// <para> SUBTYPE OF (IfcTextureCoordinateIndices);</para>
	/// <para>	InnerTexCoordIndices : LIST [1:?] OF LIST [3:?] OF UNIQUE IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureCoordinateIndicesWithVoids : IfcTextureCoordinateIndices
	{
		public IfcTextureCoordinateIndicesWithVoids() : base()
		{
		}
		public IfcTextureCoordinateIndicesWithVoids(List<IfcPositiveInteger> TexCoordIndex, IfcIndexedPolygonalFace TexCoordsOf) : base (TexCoordIndex, TexCoordsOf)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTextureMap
	/// <para>ENTITY IfcTextureMap</para>
	/// <para> SUBTYPE OF (IfcTextureCoordinate);</para>
	/// <para>	Vertices : LIST [3:?] OF IfcTextureVertex;</para>
	/// <para>	MappedTo : IfcFace;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureMap : IfcTextureCoordinate
	{
		public List<IfcTextureVertex> Vertices { get; set; }
		public IfcFace MappedTo { get; set; }
		public IfcTextureMap() : base()
		{
			Vertices = new List<IfcTextureVertex>();
			MappedTo = new IfcFace();
		}
		public IfcTextureMap(List<IfcSurfaceTexture> Maps, List<IfcTextureVertex> Vertices, IfcFace MappedTo) : base (Maps)
		{
			this.Vertices = Vertices;
			this.MappedTo = MappedTo;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureVertex
	/// <para>ENTITY IfcTextureVertex</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Coordinates : LIST [2:2] OF IfcParameterValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureVertex : IfcPresentationItem
	{
		public List<IfcParameterValue> Coordinates { get; set; }
		public IfcTextureVertex() : base()
		{
			Coordinates = new List<IfcParameterValue>();
		}
		public IfcTextureVertex(List<IfcParameterValue> Coordinates) : base ()
		{
			this.Coordinates = Coordinates;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureVertexList
	/// <para>ENTITY IfcTextureVertexList</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	TexCoordsList : LIST [1:?] OF LIST [2:2] OF IfcParameterValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureVertexList : IfcPresentationItem
	{
		public List<List<IfcParameterValue >> TexCoordsList { get; set; }
		public IfcTextureVertexList() : base()
		{
			TexCoordsList = new List<List<IfcParameterValue >>();
		}
		public IfcTextureVertexList(List<List<IfcParameterValue >> TexCoordsList) : base ()
		{
			this.TexCoordsList = TexCoordsList;
		}
	}
	/// <summary>
	/// ENTITY IfcThirdOrderPolynomialSpiral
	/// <para>ENTITY IfcThirdOrderPolynomialSpiral</para>
	/// <para> SUBTYPE OF (IfcSpiral);</para>
	/// <para>	CubicTerm : IfcLengthMeasure;</para>
	/// <para>	QuadraticTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LinearTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ConstantTerm : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcThirdOrderPolynomialSpiral : IfcSpiral
	{
		public IfcLengthMeasure CubicTerm { get; set; }
		public IfcLengthMeasure? QuadraticTerm { get; set; }
		public IfcLengthMeasure? LinearTerm { get; set; }
		public IfcLengthMeasure? ConstantTerm { get; set; }
		public IfcThirdOrderPolynomialSpiral() : base()
		{
			CubicTerm = new IfcLengthMeasure();
		}
		public IfcThirdOrderPolynomialSpiral(IfcAxis2Placement Position, IfcLengthMeasure CubicTerm, IfcLengthMeasure QuadraticTerm, IfcLengthMeasure LinearTerm, IfcLengthMeasure ConstantTerm) : base (Position)
		{
			this.CubicTerm = CubicTerm;
			this.QuadraticTerm = QuadraticTerm;
			this.LinearTerm = LinearTerm;
			this.ConstantTerm = ConstantTerm;
		}
	}
	/// <summary>
	/// ENTITY IfcTimePeriod;
	/// <para>ENTITY IfcTimePeriod;</para>
	/// <para>	StartTime : IfcTime;</para>
	/// <para>	EndTime : IfcTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTimePeriodENTITY
	{
		public IfcTime StartTime { get; set; }
		public IfcTime EndTime { get; set; }
		public IfcTimePeriod() : base()
		{
			StartTime = new IfcTime();
			EndTime = new IfcTime();
		}
		public IfcTimePeriod(IfcTime StartTime, IfcTime EndTime) : base ()
		{
			this.StartTime = StartTime;
			this.EndTime = EndTime;
		}
	}
	/// <summary>
	/// ENTITY IfcTimeSeries
	/// <para>ENTITY IfcTimeSeries</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcIrregularTimeSeries</para>
	/// <para>	,IfcRegularTimeSeries));</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	StartTime : IfcDateTime;</para>
	/// <para>	EndTime : IfcDateTime;</para>
	/// <para>	TimeSeriesDataType : IfcTimeSeriesDataTypeEnum;</para>
	/// <para>	DataOrigin : IfcDataOriginEnum;</para>
	/// <para>	UserDefinedDataOrigin : OPTIONAL IfcLabel;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [1:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTimeSeriesENTITY, IfcMetricValueSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcDateTime StartTime { get; set; }
		public IfcDateTime EndTime { get; set; }
		public IfcTimeSeriesDataTypeEnum TimeSeriesDataType { get; set; }
		public IfcDataOriginEnum DataOrigin { get; set; }
		public IfcLabel? UserDefinedDataOrigin { get; set; }
		public IfcUnit? Unit { get; set; }
		public IfcTimeSeries() : base()
		{
			Name = new IfcLabel();
			StartTime = new IfcDateTime();
			EndTime = new IfcDateTime();
			TimeSeriesDataType = new IfcTimeSeriesDataTypeEnum();
			DataOrigin = new IfcDataOriginEnum();
		}
		public IfcTimeSeries(IfcLabel Name, IfcText Description, IfcDateTime StartTime, IfcDateTime EndTime, IfcTimeSeriesDataTypeEnum TimeSeriesDataType, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcUnit Unit) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.StartTime = StartTime;
			this.EndTime = EndTime;
			this.TimeSeriesDataType = TimeSeriesDataType;
			this.DataOrigin = DataOrigin;
			this.UserDefinedDataOrigin = UserDefinedDataOrigin;
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcTimeSeriesValue;
	/// <para>ENTITY IfcTimeSeriesValue;</para>
	/// <para>	ListValues : LIST [1:?] OF IfcValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTimeSeriesValueENTITY
	{
		public List<IfcValue> ListValues { get; set; }
		public IfcTimeSeriesValue() : base()
		{
			ListValues = new List<IfcValue>();
		}
		public IfcTimeSeriesValue(List<IfcValue> ListValues) : base ()
		{
			this.ListValues = ListValues;
		}
	}
	/// <summary>
	/// ENTITY IfcTopologicalRepresentationItem
	/// <para>ENTITY IfcTopologicalRepresentationItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcConnectedFaceSet</para>
	/// <para>	,IfcEdge</para>
	/// <para>	,IfcFace</para>
	/// <para>	,IfcFaceBound</para>
	/// <para>	,IfcLoop</para>
	/// <para>	,IfcPath</para>
	/// <para>	,IfcVertex))</para>
	/// <para> SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTopologicalRepresentationItem : IfcRepresentationItem
	{
		public IfcTopologicalRepresentationItem() : base()
		{
		}
		public IfcTopologicalRepresentationItem() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTopologyRepresentation
	/// <para>ENTITY IfcTopologyRepresentation</para>
	/// <para> SUBTYPE OF (IfcShapeModel);</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : SIZEOF(QUERY(temp <* SELF\IfcRepresentation.Items | </para>
	/// <para>  NOT('IFC4X3_ADD2.IFCTOPOLOGICALREPRESENTATIONITEM' IN TYPEOF(temp))</para>
	/// <para>)) = 0</para>
	/// <para></para>
	/// <para>;</para>
	/// <para>	WR22 : EXISTS(SELF\IfcRepresentation.RepresentationType);</para>
	/// <para>	WR23 : IfcTopologyRepresentationTypes(SELF\IfcRepresentation.RepresentationType, SELF\IfcRepresentation.Items);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTopologyRepresentation : IfcShapeModel
	{
		public IfcTopologyRepresentation() : base()
		{
		}
		public IfcTopologyRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcToroidalSurface
	/// <para>ENTITY IfcToroidalSurface</para>
	/// <para> SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>	MajorRadius : IfcPositiveLengthMeasure;</para>
	/// <para>	MinorRadius : IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	MajorLargerMinor : MinorRadius < MajorRadius;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcToroidalSurface : IfcElementarySurface
	{
		public IfcPositiveLengthMeasure MajorRadius { get; set; }
		public IfcPositiveLengthMeasure MinorRadius { get; set; }
		public IfcToroidalSurface() : base()
		{
			MajorRadius = new IfcPositiveLengthMeasure();
			MinorRadius = new IfcPositiveLengthMeasure();
		}
		public IfcToroidalSurface(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure MajorRadius, IfcPositiveLengthMeasure MinorRadius) : base (Position)
		{
			this.MajorRadius = MajorRadius;
			this.MinorRadius = MinorRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcTrackElement
	/// <para>ENTITY IfcTrackElement</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTrackElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcTrackElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTrackElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCTRACKELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTrackElement : IfcBuiltElement
	{
		public IfcTrackElementTypeEnum? PredefinedType { get; set; }
		public IfcTrackElement() : base()
		{
		}
		public IfcTrackElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTrackElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTrackElementType
	/// <para>ENTITY IfcTrackElementType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcTrackElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTrackElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTrackElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTrackElementType : IfcBuiltElementType
	{
		public IfcTrackElementTypeEnum PredefinedType { get; set; }
		public IfcTrackElementType() : base()
		{
			PredefinedType = new IfcTrackElementTypeEnum();
		}
		public IfcTrackElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTrackElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransformer
	/// <para>ENTITY IfcTransformer</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTransformerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcTransformerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTransformerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCTRANSFORMERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransformer : IfcEnergyConversionDevice
	{
		public IfcTransformerTypeEnum? PredefinedType { get; set; }
		public IfcTransformer() : base()
		{
		}
		public IfcTransformer(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTransformerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransformerType
	/// <para>ENTITY IfcTransformerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcTransformerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTransformerTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTransformerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransformerType : IfcEnergyConversionDeviceType
	{
		public IfcTransformerTypeEnum PredefinedType { get; set; }
		public IfcTransformerType() : base()
		{
			PredefinedType = new IfcTransformerTypeEnum();
		}
		public IfcTransformerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTransformerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransportElement
	/// <para>ENTITY IfcTransportElement</para>
	/// <para> SUBTYPE OF (IfcTransportationDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTransportElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcTransportElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTransportElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCTRANSPORTELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransportElement : IfcTransportationDevice
	{
		public IfcTransportElementTypeEnum? PredefinedType { get; set; }
		public IfcTransportElement() : base()
		{
		}
		public IfcTransportElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTransportElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransportElementType
	/// <para>ENTITY IfcTransportElementType</para>
	/// <para> SUBTYPE OF (IfcTransportationDeviceType);</para>
	/// <para>	PredefinedType : IfcTransportElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTransportElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTransportElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransportElementType : IfcTransportationDeviceType
	{
		public IfcTransportElementTypeEnum PredefinedType { get; set; }
		public IfcTransportElementType() : base()
		{
			PredefinedType = new IfcTransportElementTypeEnum();
		}
		public IfcTransportElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTransportElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransportationDevice
	/// <para>ENTITY IfcTransportationDevice</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcTransportElement</para>
	/// <para>	,IfcVehicle))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTransportationDevice : IfcElement
	{
		public IfcTransportationDevice() : base()
		{
		}
		public IfcTransportationDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTransportationDeviceType
	/// <para>ENTITY IfcTransportationDeviceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcTransportElementType</para>
	/// <para>	,IfcVehicleType))</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTransportationDeviceType : IfcElementType
	{
		public IfcTransportationDeviceType() : base()
		{
		}
		public IfcTransportationDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTrapeziumProfileDef
	/// <para>ENTITY IfcTrapeziumProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	BottomXDim : IfcPositiveLengthMeasure;</para>
	/// <para>	TopXDim : IfcPositiveLengthMeasure;</para>
	/// <para>	YDim : IfcPositiveLengthMeasure;</para>
	/// <para>	TopXOffset : IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTrapeziumProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure BottomXDim { get; set; }
		public IfcPositiveLengthMeasure TopXDim { get; set; }
		public IfcPositiveLengthMeasure YDim { get; set; }
		public IfcLengthMeasure TopXOffset { get; set; }
		public IfcTrapeziumProfileDef() : base()
		{
			BottomXDim = new IfcPositiveLengthMeasure();
			TopXDim = new IfcPositiveLengthMeasure();
			YDim = new IfcPositiveLengthMeasure();
			TopXOffset = new IfcLengthMeasure();
		}
		public IfcTrapeziumProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure BottomXDim, IfcPositiveLengthMeasure TopXDim, IfcPositiveLengthMeasure YDim, IfcLengthMeasure TopXOffset) : base (ProfileType, ProfileName, Position)
		{
			this.BottomXDim = BottomXDim;
			this.TopXDim = TopXDim;
			this.YDim = YDim;
			this.TopXOffset = TopXOffset;
		}
	}
	/// <summary>
	/// ENTITY IfcTriangulatedFaceSet
	/// <para>ENTITY IfcTriangulatedFaceSet</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcTriangulatedIrregularNetwork))</para>
	/// <para> SUBTYPE OF (IfcTessellatedFaceSet);</para>
	/// <para>	Normals : OPTIONAL LIST [1:?] OF LIST [3:3] OF IfcParameterValue;</para>
	/// <para>	Closed : OPTIONAL IfcBoolean;</para>
	/// <para>	CoordIndex : LIST [1:?] OF LIST [3:3] OF IfcPositiveInteger;</para>
	/// <para>	PnIndex : OPTIONAL LIST [1:?] OF IfcPositiveInteger;</para>
	/// <para> DERIVE</para>
	/// <para>	 NumberOfTriangles : IfcInteger := SIZEOF(CoordIndex);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTriangulatedFaceSet : IfcTessellatedFaceSet
	{
		public List<List<IfcParameterValue >>? Normals { get; set; }
		public IfcBoolean? Closed { get; set; }
		public List<List<IfcPositiveInteger >> CoordIndex { get; set; }
		public List<IfcPositiveInteger>? PnIndex { get; set; }
		public IfcTriangulatedFaceSet() : base()
		{
			CoordIndex = new List<List<IfcPositiveInteger >>();
		}
		public IfcTriangulatedFaceSet(IfcCartesianPointList3D Coordinates, List<List<IfcParameterValue >> Normals, IfcBoolean Closed, List<List<IfcPositiveInteger >> CoordIndex, List<IfcPositiveInteger> PnIndex) : base (Coordinates)
		{
			this.Normals = Normals;
			this.Closed = Closed;
			this.CoordIndex = CoordIndex;
			this.PnIndex = PnIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcTriangulatedIrregularNetwork
	/// <para>ENTITY IfcTriangulatedIrregularNetwork</para>
	/// <para> SUBTYPE OF (IfcTriangulatedFaceSet);</para>
	/// <para>	Flags : LIST [1:?] OF IfcInteger;</para>
	/// <para> WHERE</para>
	/// <para>	NotClosed : SELF\IfcTriangulatedFaceSet.Closed = FALSE;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTriangulatedIrregularNetwork : IfcTriangulatedFaceSet
	{
		public List<IfcInteger> Flags { get; set; }
		public IfcTriangulatedIrregularNetwork() : base()
		{
			Flags = new List<IfcInteger>();
		}
		public IfcTriangulatedIrregularNetwork(IfcCartesianPointList3D Coordinates, List<List<IfcParameterValue >> Normals, IfcBoolean Closed, List<List<IfcPositiveInteger >> CoordIndex, List<IfcPositiveInteger> PnIndex, List<IfcInteger> Flags) : base (Coordinates, Normals, Closed, CoordIndex, PnIndex)
		{
			this.Flags = Flags;
		}
	}
	/// <summary>
	/// ENTITY IfcTrimmedCurve
	/// <para>ENTITY IfcTrimmedCurve</para>
	/// <para> SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>	BasisCurve : IfcCurve;</para>
	/// <para>	Trim1 : SET [1:2] OF IfcTrimmingSelect;</para>
	/// <para>	Trim2 : SET [1:2] OF IfcTrimmingSelect;</para>
	/// <para>	SenseAgreement : IfcBoolean;</para>
	/// <para>	MasterRepresentation : IfcTrimmingPreference;</para>
	/// <para> WHERE</para>
	/// <para>	NoTrimOfBoundedCurves : NOT('IFC4X3_ADD2.IFCBOUNDEDCURVE' IN TYPEOF(BasisCurve));</para>
	/// <para>	Trim1ValuesConsistent : (HIINDEX(Trim1) = 1) OR (TYPEOF(Trim1[1]) <> TYPEOF(Trim1[2]));</para>
	/// <para>	Trim2ValuesConsistent : (HIINDEX(Trim2) = 1) OR (TYPEOF(Trim2[1]) <> TYPEOF(Trim2[2]));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTrimmedCurve : IfcBoundedCurve
	{
		public IfcCurve BasisCurve { get; set; }
		public List<IfcTrimmingSelect> Trim1 { get; set; }
		public List<IfcTrimmingSelect> Trim2 { get; set; }
		public IfcBoolean SenseAgreement { get; set; }
		public IfcTrimmingPreference MasterRepresentation { get; set; }
		public IfcTrimmedCurve() : base()
		{
			BasisCurve = new IfcCurve();
			Trim1 = new List<IfcTrimmingSelect>();
			Trim2 = new List<IfcTrimmingSelect>();
			SenseAgreement = new IfcBoolean();
			MasterRepresentation = new IfcTrimmingPreference();
		}
		public IfcTrimmedCurve(IfcCurve BasisCurve, List<IfcTrimmingSelect> Trim1, List<IfcTrimmingSelect> Trim2, IfcBoolean SenseAgreement, IfcTrimmingPreference MasterRepresentation) : base ()
		{
			this.BasisCurve = BasisCurve;
			this.Trim1 = Trim1;
			this.Trim2 = Trim2;
			this.SenseAgreement = SenseAgreement;
			this.MasterRepresentation = MasterRepresentation;
		}
	}
	/// <summary>
	/// ENTITY IfcTubeBundle
	/// <para>ENTITY IfcTubeBundle</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTubeBundleTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcTubeBundleTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTubeBundleTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCTUBEBUNDLETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTubeBundle : IfcEnergyConversionDevice
	{
		public IfcTubeBundleTypeEnum? PredefinedType { get; set; }
		public IfcTubeBundle() : base()
		{
		}
		public IfcTubeBundle(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTubeBundleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTubeBundleType
	/// <para>ENTITY IfcTubeBundleType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcTubeBundleTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTubeBundleTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTubeBundleTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTubeBundleType : IfcEnergyConversionDeviceType
	{
		public IfcTubeBundleTypeEnum PredefinedType { get; set; }
		public IfcTubeBundleType() : base()
		{
			PredefinedType = new IfcTubeBundleTypeEnum();
		}
		public IfcTubeBundleType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTubeBundleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTypeObject
	/// <para>ENTITY IfcTypeObject</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcTypeProcess</para>
	/// <para>	,IfcTypeProduct</para>
	/// <para>	,IfcTypeResource))</para>
	/// <para> SUBTYPE OF (IfcObjectDefinition);</para>
	/// <para>	ApplicableOccurrence : OPTIONAL IfcIdentifier;</para>
	/// <para>	HasPropertySets : OPTIONAL SET [1:?] OF IfcPropertySetDefinition;</para>
	/// <para> INVERSE</para>
	/// <para>	Types : SET [0:1] OF IfcRelDefinesByType FOR RelatingType;</para>
	/// <para> WHERE</para>
	/// <para>	NameRequired : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	UniquePropertySetNames : (NOT(EXISTS(HasPropertySets))) OR IfcUniquePropertySetNames(HasPropertySets);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTypeObject : IfcObjectDefinition
	{
		public IfcIdentifier? ApplicableOccurrence { get; set; }
		public List<IfcPropertySetDefinition>? HasPropertySets { get; set; }
		public IfcTypeObject() : base()
		{
		}
		public IfcTypeObject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ApplicableOccurrence = ApplicableOccurrence;
			this.HasPropertySets = HasPropertySets;
		}
	}
	/// <summary>
	/// ENTITY IfcTypeProcess
	/// <para>ENTITY IfcTypeProcess</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcEventType</para>
	/// <para>	,IfcProcedureType</para>
	/// <para>	,IfcTaskType))</para>
	/// <para> SUBTYPE OF (IfcTypeObject);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para>	ProcessType : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	OperatesOn : SET [0:?] OF IfcRelAssignsToProcess FOR RelatingProcess;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTypeProcess : IfcTypeObject, IfcProcessSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcLabel? ProcessType { get; set; }
		public IfcTypeProcess() : base()
		{
		}
		public IfcTypeProcess(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
			this.ProcessType = ProcessType;
		}
	}
	/// <summary>
	/// ENTITY IfcTypeProduct
	/// <para>ENTITY IfcTypeProduct</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcElementType</para>
	/// <para>	,IfcSpatialElementType))</para>
	/// <para> SUBTYPE OF (IfcTypeObject);</para>
	/// <para>	RepresentationMaps : OPTIONAL LIST [1:?] OF UNIQUE IfcRepresentationMap;</para>
	/// <para>	Tag : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ReferencedBy : SET [0:?] OF IfcRelAssignsToProduct FOR RelatingProduct;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableOccurrence : NOT(EXISTS(SELF\IfcTypeObject.Types[1])) OR</para>
	/// <para>(SIZEOF(QUERY(temp <* SELF\IfcTypeObject.Types[1].RelatedObjects |</para>
	/// <para>  NOT('IFC4X3_ADD2.IFCPRODUCT' IN TYPEOF(temp)))</para>
	/// <para>) = 0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTypeProduct : IfcTypeObject, IfcProductSelect
	{
		public IfcTypeProduct() : base()
		{
		}
		public IfcTypeProduct(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTypeResource
	/// <para>ENTITY IfcTypeResource</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcConstructionResourceType))</para>
	/// <para> SUBTYPE OF (IfcTypeObject);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para>	ResourceType : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ResourceOf : SET [0:?] OF IfcRelAssignsToResource FOR RelatingResource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTypeResource : IfcTypeObject, IfcResourceSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcLabel? ResourceType { get; set; }
		public IfcTypeResource() : base()
		{
		}
		public IfcTypeResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
			this.ResourceType = ResourceType;
		}
	}
	/// <summary>
	/// ENTITY IfcUShapeProfileDef
	/// <para>ENTITY IfcUShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	EdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	FlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidFlangeThickness : FlangeThickness < (Depth / 2.);</para>
	/// <para>	ValidWebThickness : WebThickness < FlangeWidth;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcPositiveLengthMeasure FlangeWidth { get; set; }
		public IfcPositiveLengthMeasure WebThickness { get; set; }
		public IfcPositiveLengthMeasure FlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? EdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? FlangeSlope { get; set; }
		public IfcUShapeProfileDef() : base()
		{
			Depth = new IfcPositiveLengthMeasure();
			FlangeWidth = new IfcPositiveLengthMeasure();
			WebThickness = new IfcPositiveLengthMeasure();
			FlangeThickness = new IfcPositiveLengthMeasure();
		}
		public IfcUShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure FlangeWidth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure EdgeRadius, IfcPlaneAngleMeasure FlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.FlangeWidth = FlangeWidth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.EdgeRadius = EdgeRadius;
			this.FlangeSlope = FlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitAssignment;
	/// <para>ENTITY IfcUnitAssignment;</para>
	/// <para>	Units : SET [1:?] OF IfcUnit;</para>
	/// <para> WHERE</para>
	/// <para>	WR01 : IfcCorrectUnitAssignment(Units);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitAssignmentENTITY
	{
		public List<IfcUnit> Units { get; set; }
		public IfcUnitAssignment() : base()
		{
			Units = new List<IfcUnit>();
		}
		public IfcUnitAssignment(List<IfcUnit> Units) : base ()
		{
			this.Units = Units;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryControlElement
	/// <para>ENTITY IfcUnitaryControlElement</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcUnitaryControlElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcUnitaryControlElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcUnitaryControlElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCUNITARYCONTROLELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryControlElement : IfcDistributionControlElement
	{
		public IfcUnitaryControlElementTypeEnum? PredefinedType { get; set; }
		public IfcUnitaryControlElement() : base()
		{
		}
		public IfcUnitaryControlElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcUnitaryControlElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryControlElementType
	/// <para>ENTITY IfcUnitaryControlElementType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcUnitaryControlElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcUnitaryControlElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcUnitaryControlElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryControlElementType : IfcDistributionControlElementType
	{
		public IfcUnitaryControlElementTypeEnum PredefinedType { get; set; }
		public IfcUnitaryControlElementType() : base()
		{
			PredefinedType = new IfcUnitaryControlElementTypeEnum();
		}
		public IfcUnitaryControlElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcUnitaryControlElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryEquipment
	/// <para>ENTITY IfcUnitaryEquipment</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcUnitaryEquipmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcUnitaryEquipmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcUnitaryEquipmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCUNITARYEQUIPMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryEquipment : IfcEnergyConversionDevice
	{
		public IfcUnitaryEquipmentTypeEnum? PredefinedType { get; set; }
		public IfcUnitaryEquipment() : base()
		{
		}
		public IfcUnitaryEquipment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcUnitaryEquipmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryEquipmentType
	/// <para>ENTITY IfcUnitaryEquipmentType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcUnitaryEquipmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcUnitaryEquipmentTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcUnitaryEquipmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryEquipmentType : IfcEnergyConversionDeviceType
	{
		public IfcUnitaryEquipmentTypeEnum PredefinedType { get; set; }
		public IfcUnitaryEquipmentType() : base()
		{
			PredefinedType = new IfcUnitaryEquipmentTypeEnum();
		}
		public IfcUnitaryEquipmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcUnitaryEquipmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcValve
	/// <para>ENTITY IfcValve</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcValveTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcValveTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcValveTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCVALVETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcValve : IfcFlowController
	{
		public IfcValveTypeEnum? PredefinedType { get; set; }
		public IfcValve() : base()
		{
		}
		public IfcValve(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcValveTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcValveType
	/// <para>ENTITY IfcValveType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcValveTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcValveTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcValveTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcValveType : IfcFlowControllerType
	{
		public IfcValveTypeEnum PredefinedType { get; set; }
		public IfcValveType() : base()
		{
			PredefinedType = new IfcValveTypeEnum();
		}
		public IfcValveType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcValveTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVector
	/// <para>ENTITY IfcVector</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Orientation : IfcDirection;</para>
	/// <para>	Magnitude : IfcLengthMeasure;</para>
	/// <para> DERIVE</para>
	/// <para>	 Dim : IfcDimensionCount := Orientation.Dim;</para>
	/// <para> WHERE</para>
	/// <para>	MagGreaterOrEqualZero : Magnitude >= 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVector : IfcGeometricRepresentationItem, IfcHatchLineDistanceSelect, IfcVectorOrDirection
	{
		public IfcDirection Orientation { get; set; }
		public IfcLengthMeasure Magnitude { get; set; }
		public IfcVector() : base()
		{
			Orientation = new IfcDirection();
			Magnitude = new IfcLengthMeasure();
		}
		public IfcVector(IfcDirection Orientation, IfcLengthMeasure Magnitude) : base ()
		{
			this.Orientation = Orientation;
			this.Magnitude = Magnitude;
		}
	}
	/// <summary>
	/// ENTITY IfcVehicle
	/// <para>ENTITY IfcVehicle</para>
	/// <para> SUBTYPE OF (IfcTransportationDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcVehicleTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcVehicleTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcVehicleTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCVEHICLETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVehicle : IfcTransportationDevice
	{
		public IfcVehicleTypeEnum? PredefinedType { get; set; }
		public IfcVehicle() : base()
		{
		}
		public IfcVehicle(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcVehicleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVehicleType
	/// <para>ENTITY IfcVehicleType</para>
	/// <para> SUBTYPE OF (IfcTransportationDeviceType);</para>
	/// <para>	PredefinedType : IfcVehicleTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcVehicleTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcVehicleTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVehicleType : IfcTransportationDeviceType
	{
		public IfcVehicleTypeEnum PredefinedType { get; set; }
		public IfcVehicleType() : base()
		{
			PredefinedType = new IfcVehicleTypeEnum();
		}
		public IfcVehicleType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcVehicleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVertex
	/// <para>ENTITY IfcVertex</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcVertexPoint))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVertex : IfcTopologicalRepresentationItem
	{
		public IfcVertex() : base()
		{
		}
		public IfcVertex() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcVertexLoop
	/// <para>ENTITY IfcVertexLoop</para>
	/// <para> SUBTYPE OF (IfcLoop);</para>
	/// <para>	LoopVertex : IfcVertex;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVertexLoop : IfcLoop
	{
		public IfcVertex LoopVertex { get; set; }
		public IfcVertexLoop() : base()
		{
			LoopVertex = new IfcVertex();
		}
		public IfcVertexLoop(IfcVertex LoopVertex) : base ()
		{
			this.LoopVertex = LoopVertex;
		}
	}
	/// <summary>
	/// ENTITY IfcVertexPoint
	/// <para>ENTITY IfcVertexPoint</para>
	/// <para> SUBTYPE OF (IfcVertex);</para>
	/// <para>	VertexGeometry : IfcPoint;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVertexPoint : IfcVertex, IfcPointOrVertexPoint
	{
		public IfcPoint VertexGeometry { get; set; }
		public IfcVertexPoint() : base()
		{
			VertexGeometry = new IfcPoint();
		}
		public IfcVertexPoint(IfcPoint VertexGeometry) : base ()
		{
			this.VertexGeometry = VertexGeometry;
		}
	}
	/// <summary>
	/// ENTITY IfcVibrationDamper
	/// <para>ENTITY IfcVibrationDamper</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcVibrationDamperTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcVibrationDamperTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcVibrationDamperTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCVIBRATIONDAMPERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVibrationDamper : IfcElementComponent
	{
		public IfcVibrationDamperTypeEnum? PredefinedType { get; set; }
		public IfcVibrationDamper() : base()
		{
		}
		public IfcVibrationDamper(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcVibrationDamperTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVibrationDamperType
	/// <para>ENTITY IfcVibrationDamperType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcVibrationDamperTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcVibrationDamperTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcVibrationDamperTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVibrationDamperType : IfcElementComponentType
	{
		public IfcVibrationDamperTypeEnum PredefinedType { get; set; }
		public IfcVibrationDamperType() : base()
		{
			PredefinedType = new IfcVibrationDamperTypeEnum();
		}
		public IfcVibrationDamperType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcVibrationDamperTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVibrationIsolator
	/// <para>ENTITY IfcVibrationIsolator</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcVibrationIsolatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcVibrationIsolatorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcVibrationIsolatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCVIBRATIONISOLATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVibrationIsolator : IfcElementComponent
	{
		public IfcVibrationIsolatorTypeEnum? PredefinedType { get; set; }
		public IfcVibrationIsolator() : base()
		{
		}
		public IfcVibrationIsolator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcVibrationIsolatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVibrationIsolatorType
	/// <para>ENTITY IfcVibrationIsolatorType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcVibrationIsolatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcVibrationIsolatorTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcVibrationIsolatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVibrationIsolatorType : IfcElementComponentType
	{
		public IfcVibrationIsolatorTypeEnum PredefinedType { get; set; }
		public IfcVibrationIsolatorType() : base()
		{
			PredefinedType = new IfcVibrationIsolatorTypeEnum();
		}
		public IfcVibrationIsolatorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcVibrationIsolatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVirtualElement
	/// <para>ENTITY IfcVirtualElement</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcVirtualElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcVirtualElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcVirtualElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVirtualElement : IfcElement
	{
		public IfcVirtualElementTypeEnum? PredefinedType { get; set; }
		public IfcVirtualElement() : base()
		{
		}
		public IfcVirtualElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcVirtualElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVirtualGridIntersection;
	/// <para>ENTITY IfcVirtualGridIntersection;</para>
	/// <para>	IntersectingAxes : LIST [2:2] OF UNIQUE IfcGridAxis;</para>
	/// <para>	OffsetDistances : LIST [2:3] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVirtualGridIntersectionENTITY, IfcGridPlacementDirectionSelect
	{
		public IfcVirtualGridIntersection() : base()
		{
		}
		public IfcVirtualGridIntersection() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcVoidingFeature
	/// <para>ENTITY IfcVoidingFeature</para>
	/// <para> SUBTYPE OF (IfcFeatureElementSubtraction);</para>
	/// <para>	PredefinedType : OPTIONAL IfcVoidingFeatureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcVoidingFeatureTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcVoidingFeatureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVoidingFeature : IfcFeatureElementSubtraction
	{
		public IfcVoidingFeatureTypeEnum? PredefinedType { get; set; }
		public IfcVoidingFeature() : base()
		{
		}
		public IfcVoidingFeature(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcVoidingFeatureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWall
	/// <para>ENTITY IfcWall</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcWallStandardCase))</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcWallTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcWallTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcWallTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCWALLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWall : IfcBuiltElement
	{
		public IfcWallTypeEnum? PredefinedType { get; set; }
		public IfcWall() : base()
		{
		}
		public IfcWall(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWallStandardCase
	/// <para>ENTITY IfcWallStandardCase</para>
	/// <para> SUBTYPE OF (IfcWall);</para>
	/// <para> WHERE</para>
	/// <para>	HasMaterialLayerSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4X3_ADD2.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>              ('IFC4X3_ADD2.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>              ('IFC4X3_ADD2.IFCMATERIALLAYERSETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>              )) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWallStandardCase : IfcWall
	{
		public IfcWallStandardCase() : base()
		{
		}
		public IfcWallStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcWallType
	/// <para>ENTITY IfcWallType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcWallTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcWallTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcWallTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWallType : IfcBuiltElementType
	{
		public IfcWallTypeEnum PredefinedType { get; set; }
		public IfcWallType() : base()
		{
			PredefinedType = new IfcWallTypeEnum();
		}
		public IfcWallType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWasteTerminal
	/// <para>ENTITY IfcWasteTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcWasteTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcWasteTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcWasteTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCWASTETERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWasteTerminal : IfcFlowTerminal
	{
		public IfcWasteTerminalTypeEnum? PredefinedType { get; set; }
		public IfcWasteTerminal() : base()
		{
		}
		public IfcWasteTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWasteTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWasteTerminalType
	/// <para>ENTITY IfcWasteTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcWasteTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcWasteTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcWasteTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWasteTerminalType : IfcFlowTerminalType
	{
		public IfcWasteTerminalTypeEnum PredefinedType { get; set; }
		public IfcWasteTerminalType() : base()
		{
			PredefinedType = new IfcWasteTerminalTypeEnum();
		}
		public IfcWasteTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcWasteTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWellKnownText;
	/// <para>ENTITY IfcWellKnownText;</para>
	/// <para>	WellKnownText : IfcWellKnownTextLiteral;</para>
	/// <para>	CoordinateReferenceSystem : IfcCoordinateReferenceSystem;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWellKnownTextENTITY
	{
		public IfcWellKnownTextLiteral WellKnownText { get; set; }
		public IfcCoordinateReferenceSystem CoordinateReferenceSystem { get; set; }
		public IfcWellKnownText() : base()
		{
			WellKnownText = new IfcWellKnownTextLiteral();
			CoordinateReferenceSystem = new IfcCoordinateReferenceSystem();
		}
		public IfcWellKnownText(IfcWellKnownTextLiteral WellKnownText, IfcCoordinateReferenceSystem CoordinateReferenceSystem) : base ()
		{
			this.WellKnownText = WellKnownText;
			this.CoordinateReferenceSystem = CoordinateReferenceSystem;
		}
	}
	/// <summary>
	/// ENTITY IfcWindow
	/// <para>ENTITY IfcWindow</para>
	/// <para> SUBTYPE OF (IfcBuiltElement);</para>
	/// <para>	OverallHeight : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	OverallWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcWindowTypeEnum;</para>
	/// <para>	PartitioningType : OPTIONAL IfcWindowTypePartitioningEnum;</para>
	/// <para>	UserDefinedPartitioningType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcWindowTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcWindowTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindow : IfcBuiltElement
	{
		public IfcPositiveLengthMeasure? OverallHeight { get; set; }
		public IfcPositiveLengthMeasure? OverallWidth { get; set; }
		public IfcWindowTypeEnum? PredefinedType { get; set; }
		public IfcWindowTypePartitioningEnum? PartitioningType { get; set; }
		public IfcLabel? UserDefinedPartitioningType { get; set; }
		public IfcWindow() : base()
		{
		}
		public IfcWindow(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure OverallHeight, IfcPositiveLengthMeasure OverallWidth, IfcWindowTypeEnum PredefinedType, IfcWindowTypePartitioningEnum PartitioningType, IfcLabel UserDefinedPartitioningType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.OverallHeight = OverallHeight;
			this.OverallWidth = OverallWidth;
			this.PredefinedType = PredefinedType;
			this.PartitioningType = PartitioningType;
			this.UserDefinedPartitioningType = UserDefinedPartitioningType;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowLiningProperties
	/// <para>ENTITY IfcWindowLiningProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	LiningDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LiningThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	TransomThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	MullionThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	FirstTransomOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	SecondTransomOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	FirstMullionOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	SecondMullionOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>	LiningOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LiningToPanelOffsetX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LiningToPanelOffsetY : OPTIONAL IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : NOT(EXISTS(LiningDepth) AND NOT(EXISTS(LiningThickness)));</para>
	/// <para>	WR32 : NOT(NOT(EXISTS(FirstTransomOffset)) AND EXISTS(SecondTransomOffset));</para>
	/// <para>	WR33 : NOT(NOT(EXISTS(FirstMullionOffset)) AND EXISTS(SecondMullionOffset));</para>
	/// <para>	WR34 : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) </para>
	/// <para>AND </para>
	/// <para>('IFC4X3_ADD2.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowLiningProperties : IfcPreDefinedPropertySet
	{
		public IfcPositiveLengthMeasure? LiningDepth { get; set; }
		public IfcNonNegativeLengthMeasure? LiningThickness { get; set; }
		public IfcNonNegativeLengthMeasure? TransomThickness { get; set; }
		public IfcNonNegativeLengthMeasure? MullionThickness { get; set; }
		public IfcNormalisedRatioMeasure? FirstTransomOffset { get; set; }
		public IfcNormalisedRatioMeasure? SecondTransomOffset { get; set; }
		public IfcNormalisedRatioMeasure? FirstMullionOffset { get; set; }
		public IfcNormalisedRatioMeasure? SecondMullionOffset { get; set; }
		public IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcLengthMeasure? LiningOffset { get; set; }
		public IfcLengthMeasure? LiningToPanelOffsetX { get; set; }
		public IfcLengthMeasure? LiningToPanelOffsetY { get; set; }
		public IfcWindowLiningProperties() : base()
		{
		}
		public IfcWindowLiningProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPositiveLengthMeasure LiningDepth, IfcNonNegativeLengthMeasure LiningThickness, IfcNonNegativeLengthMeasure TransomThickness, IfcNonNegativeLengthMeasure MullionThickness, IfcNormalisedRatioMeasure FirstTransomOffset, IfcNormalisedRatioMeasure SecondTransomOffset, IfcNormalisedRatioMeasure FirstMullionOffset, IfcNormalisedRatioMeasure SecondMullionOffset, IfcShapeAspect ShapeAspectStyle, IfcLengthMeasure LiningOffset, IfcLengthMeasure LiningToPanelOffsetX, IfcLengthMeasure LiningToPanelOffsetY) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.LiningDepth = LiningDepth;
			this.LiningThickness = LiningThickness;
			this.TransomThickness = TransomThickness;
			this.MullionThickness = MullionThickness;
			this.FirstTransomOffset = FirstTransomOffset;
			this.SecondTransomOffset = SecondTransomOffset;
			this.FirstMullionOffset = FirstMullionOffset;
			this.SecondMullionOffset = SecondMullionOffset;
			this.ShapeAspectStyle = ShapeAspectStyle;
			this.LiningOffset = LiningOffset;
			this.LiningToPanelOffsetX = LiningToPanelOffsetX;
			this.LiningToPanelOffsetY = LiningToPanelOffsetY;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowPanelProperties
	/// <para>ENTITY IfcWindowPanelProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	OperationType : IfcWindowPanelOperationEnum;</para>
	/// <para>	PanelPosition : IfcWindowPanelPositionEnum;</para>
	/// <para>	FrameDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	FrameThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableToType : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) </para>
	/// <para>AND </para>
	/// <para>('IFC4X3_ADD2.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowPanelProperties : IfcPreDefinedPropertySet
	{
		public IfcWindowPanelOperationEnum OperationType { get; set; }
		public IfcWindowPanelPositionEnum PanelPosition { get; set; }
		public IfcPositiveLengthMeasure? FrameDepth { get; set; }
		public IfcPositiveLengthMeasure? FrameThickness { get; set; }
		public IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcWindowPanelProperties() : base()
		{
			OperationType = new IfcWindowPanelOperationEnum();
			PanelPosition = new IfcWindowPanelPositionEnum();
		}
		public IfcWindowPanelProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcWindowPanelOperationEnum OperationType, IfcWindowPanelPositionEnum PanelPosition, IfcPositiveLengthMeasure FrameDepth, IfcPositiveLengthMeasure FrameThickness, IfcShapeAspect ShapeAspectStyle) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.OperationType = OperationType;
			this.PanelPosition = PanelPosition;
			this.FrameDepth = FrameDepth;
			this.FrameThickness = FrameThickness;
			this.ShapeAspectStyle = ShapeAspectStyle;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowType
	/// <para>ENTITY IfcWindowType</para>
	/// <para> SUBTYPE OF (IfcBuiltElementType);</para>
	/// <para>	PredefinedType : IfcWindowTypeEnum;</para>
	/// <para>	PartitioningType : IfcWindowTypePartitioningEnum;</para>
	/// <para>	ParameterTakesPrecedence : OPTIONAL IfcBoolean;</para>
	/// <para>	UserDefinedPartitioningType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcWindowTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcWindowTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowType : IfcBuiltElementType
	{
		public IfcWindowTypeEnum PredefinedType { get; set; }
		public IfcWindowTypePartitioningEnum PartitioningType { get; set; }
		public IfcBoolean? ParameterTakesPrecedence { get; set; }
		public IfcLabel? UserDefinedPartitioningType { get; set; }
		public IfcWindowType() : base()
		{
			PredefinedType = new IfcWindowTypeEnum();
			PartitioningType = new IfcWindowTypePartitioningEnum();
		}
		public IfcWindowType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcWindowTypeEnum PredefinedType, IfcWindowTypePartitioningEnum PartitioningType, IfcBoolean ParameterTakesPrecedence, IfcLabel UserDefinedPartitioningType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.PartitioningType = PartitioningType;
			this.ParameterTakesPrecedence = ParameterTakesPrecedence;
			this.UserDefinedPartitioningType = UserDefinedPartitioningType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkCalendar
	/// <para>ENTITY IfcWorkCalendar</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	WorkingTimes : OPTIONAL SET [1:?] OF IfcWorkTime;</para>
	/// <para>	ExceptionTimes : OPTIONAL SET [1:?] OF IfcWorkTime;</para>
	/// <para>	PredefinedType : OPTIONAL IfcWorkCalendarTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcWorkCalendarTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWorkCalendarTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkCalendar : IfcControl
	{
		public List<IfcWorkTime>? WorkingTimes { get; set; }
		public List<IfcWorkTime>? ExceptionTimes { get; set; }
		public IfcWorkCalendarTypeEnum? PredefinedType { get; set; }
		public IfcWorkCalendar() : base()
		{
		}
		public IfcWorkCalendar(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, List<IfcWorkTime> WorkingTimes, List<IfcWorkTime> ExceptionTimes, IfcWorkCalendarTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.WorkingTimes = WorkingTimes;
			this.ExceptionTimes = ExceptionTimes;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkControl
	/// <para>ENTITY IfcWorkControl</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>	(IfcWorkPlan</para>
	/// <para>	,IfcWorkSchedule))</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	CreationDate : IfcDateTime;</para>
	/// <para>	Creators : OPTIONAL SET [1:?] OF IfcPerson;</para>
	/// <para>	Purpose : OPTIONAL IfcLabel;</para>
	/// <para>	Duration : OPTIONAL IfcDuration;</para>
	/// <para>	TotalFloat : OPTIONAL IfcDuration;</para>
	/// <para>	StartTime : IfcDateTime;</para>
	/// <para>	FinishTime : OPTIONAL IfcDateTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcWorkControl : IfcControl
	{
		public IfcDateTime CreationDate { get; set; }
		public List<IfcPerson>? Creators { get; set; }
		public IfcLabel? Purpose { get; set; }
		public IfcDuration? Duration { get; set; }
		public IfcDuration? TotalFloat { get; set; }
		public IfcDateTime StartTime { get; set; }
		public IfcDateTime? FinishTime { get; set; }
		public IfcWorkControl() : base()
		{
			CreationDate = new IfcDateTime();
			StartTime = new IfcDateTime();
		}
		public IfcWorkControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcDateTime CreationDate, List<IfcPerson> Creators, IfcLabel Purpose, IfcDuration Duration, IfcDuration TotalFloat, IfcDateTime StartTime, IfcDateTime FinishTime) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.CreationDate = CreationDate;
			this.Creators = Creators;
			this.Purpose = Purpose;
			this.Duration = Duration;
			this.TotalFloat = TotalFloat;
			this.StartTime = StartTime;
			this.FinishTime = FinishTime;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkPlan
	/// <para>ENTITY IfcWorkPlan</para>
	/// <para> SUBTYPE OF (IfcWorkControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcWorkPlanTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcWorkPlanTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWorkPlanTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkPlan : IfcWorkControl
	{
		public IfcWorkPlanTypeEnum? PredefinedType { get; set; }
		public IfcWorkPlan() : base()
		{
		}
		public IfcWorkPlan(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcDateTime CreationDate, List<IfcPerson> Creators, IfcLabel Purpose, IfcDuration Duration, IfcDuration TotalFloat, IfcDateTime StartTime, IfcDateTime FinishTime, IfcWorkPlanTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkSchedule
	/// <para>ENTITY IfcWorkSchedule</para>
	/// <para> SUBTYPE OF (IfcWorkControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcWorkScheduleTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcWorkScheduleTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWorkScheduleTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkSchedule : IfcWorkControl
	{
		public IfcWorkScheduleTypeEnum? PredefinedType { get; set; }
		public IfcWorkSchedule() : base()
		{
		}
		public IfcWorkSchedule(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcDateTime CreationDate, List<IfcPerson> Creators, IfcLabel Purpose, IfcDuration Duration, IfcDuration TotalFloat, IfcDateTime StartTime, IfcDateTime FinishTime, IfcWorkScheduleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkTime
	/// <para>ENTITY IfcWorkTime</para>
	/// <para> SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>	RecurrencePattern : OPTIONAL IfcRecurrencePattern;</para>
	/// <para>	StartDate : OPTIONAL IfcDate;</para>
	/// <para>	FinishDate : OPTIONAL IfcDate;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkTime : IfcSchedulingTime
	{
		public IfcRecurrencePattern? RecurrencePattern { get; set; }
		public IfcDate? StartDate { get; set; }
		public IfcDate? FinishDate { get; set; }
		public IfcWorkTime() : base()
		{
		}
		public IfcWorkTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcRecurrencePattern RecurrencePattern, IfcDate StartDate, IfcDate FinishDate) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.RecurrencePattern = RecurrencePattern;
			this.StartDate = StartDate;
			this.FinishDate = FinishDate;
		}
	}
	/// <summary>
	/// ENTITY IfcZShapeProfileDef
	/// <para>ENTITY IfcZShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	EdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidFlangeThickness : FlangeThickness < (Depth / 2.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcZShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcPositiveLengthMeasure FlangeWidth { get; set; }
		public IfcPositiveLengthMeasure WebThickness { get; set; }
		public IfcPositiveLengthMeasure FlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? EdgeRadius { get; set; }
		public IfcZShapeProfileDef() : base()
		{
			Depth = new IfcPositiveLengthMeasure();
			FlangeWidth = new IfcPositiveLengthMeasure();
			WebThickness = new IfcPositiveLengthMeasure();
			FlangeThickness = new IfcPositiveLengthMeasure();
		}
		public IfcZShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure FlangeWidth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure EdgeRadius) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.FlangeWidth = FlangeWidth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.EdgeRadius = EdgeRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcZone
	/// <para>ENTITY IfcZone</para>
	/// <para> SUBTYPE OF (IfcSystem);</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : (SIZEOF(SELF\IfcGroup.IsGroupedBy) = 0) OR</para>
	/// <para> (SIZEOF (QUERY (temp <* SELF\IfcGroup.IsGroupedBy[1].RelatedObjects |  </para>
	/// <para>  NOT(('IFC4X3_ADD2.IFCZONE' IN TYPEOF(temp)) OR </para>
	/// <para>  ('IFC4X3_ADD2.IFCSPACE' IN TYPEOF(temp)) OR</para>
	/// <para>  ('IFC4X3_ADD2.IFCSPATIALZONE' IN TYPEOF(temp))</para>
	/// <para> ))) = 0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcZone : IfcSystem
	{
		public IfcLabel? LongName { get; set; }
		public IfcZone() : base()
		{
		}
		public IfcZone(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.LongName = LongName;
		}
	}
