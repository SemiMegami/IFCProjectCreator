using System;
using System.Collections.Generic;
namespace IFC.IFC4;
{
	/// <summary>
	/// TYPE IfcAbsorbedDoseMeasure = REAL;
	/// <para>TYPE IfcAbsorbedDoseMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAbsorbedDoseMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcAbsorbedDoseMeasure() { }
		IfcAbsorbedDoseMeasure(double value) { Value = value; }
		public static implicit operator IfcAbsorbedDoseMeasure(double value) { return new IfcAbsorbedDoseMeasure(double);}
		public static implicit operator double(IfcAbsorbedDoseMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAccelerationMeasure = REAL;
	/// <para>TYPE IfcAccelerationMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAccelerationMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcAccelerationMeasure() { }
		IfcAccelerationMeasure(double value) { Value = value; }
		public static implicit operator IfcAccelerationMeasure(double value) { return new IfcAccelerationMeasure(double);}
		public static implicit operator double(IfcAccelerationMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAmountOfSubstanceMeasure = REAL;
	/// <para>TYPE IfcAmountOfSubstanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAmountOfSubstanceMeasure : REAL, IfcMeasureValue
	{
		IfcAmountOfSubstanceMeasure() { }
		IfcAmountOfSubstanceMeasure(double value) { Value = value; }
		public static implicit operator IfcAmountOfSubstanceMeasure(double value) { return new IfcAmountOfSubstanceMeasure(double);}
		public static implicit operator double(IfcAmountOfSubstanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAngularVelocityMeasure = REAL;
	/// <para>TYPE IfcAngularVelocityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAngularVelocityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcAngularVelocityMeasure() { }
		IfcAngularVelocityMeasure(double value) { Value = value; }
		public static implicit operator IfcAngularVelocityMeasure(double value) { return new IfcAngularVelocityMeasure(double);}
		public static implicit operator double(IfcAngularVelocityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAreaDensityMeasure = REAL;
	/// <para>TYPE IfcAreaDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAreaDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcAreaDensityMeasure() { }
		IfcAreaDensityMeasure(double value) { Value = value; }
		public static implicit operator IfcAreaDensityMeasure(double value) { return new IfcAreaDensityMeasure(double);}
		public static implicit operator double(IfcAreaDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAreaMeasure = REAL;
	/// <para>TYPE IfcAreaMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAreaMeasure : REAL, IfcMeasureValue
	{
		IfcAreaMeasure() { }
		IfcAreaMeasure(double value) { Value = value; }
		public static implicit operator IfcAreaMeasure(double value) { return new IfcAreaMeasure(double);}
		public static implicit operator double(IfcAreaMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBinary = BINARY;
	/// <para>TYPE IfcBinary = BINARY;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBinary : BINARY, IfcSimpleValue
	{
		IfcBinary() { }
		IfcBinary(int value) { Value = value; }
		public static implicit operator IfcBinary(int value) { return new IfcBinary(int);}
		public static implicit operator int(IfcBinary value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBoolean = BOOLEAN;
	/// <para>TYPE IfcBoolean = BOOLEAN;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBoolean : BOOLEAN, IfcModulusOfRotationalSubgradeReactionSelect, IfcModulusOfSubgradeReactionSelect, IfcModulusOfTranslationalSubgradeReactionSelect, IfcRotationalStiffnessSelect, IfcSimpleValue, IfcTranslationalStiffnessSelect, IfcWarpingStiffnessSelect
	{
		IfcBoolean() { }
		IfcBoolean(bool value) { Value = value; }
		public static implicit operator IfcBoolean(bool value) { return new IfcBoolean(bool);}
		public static implicit operator bool(IfcBoolean value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBoxAlignment = IfcLabel;
	/// <para>TYPE IfcBoxAlignment = IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF IN ['top-left', 'top-middle', 'top-right', 'middle-left', 'center', 'middle-right', 'bottom-left', 'bottom-middle', 'bottom-right'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBoxAlignment : IfcLabel
	{
		IfcBoxAlignment() { }
		IfcBoxAlignment(string value) { Value = value; }
		public static implicit operator IfcBoxAlignment(string value) { return new IfcBoxAlignment(string);}
		public static implicit operator string(IfcBoxAlignment value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCardinalPointReference = INTEGER;
	/// <para>TYPE IfcCardinalPointReference = INTEGER;</para>
	/// <para> WHERE</para>
	/// <para>	GreaterThanZero : SELF > 0;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCardinalPointReference : INTEGER
	{
		IfcCardinalPointReference() { }
		IfcCardinalPointReference(int value) { Value = value; }
		public static implicit operator IfcCardinalPointReference(int value) { return new IfcCardinalPointReference(int);}
		public static implicit operator int(IfcCardinalPointReference value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcContextDependentMeasure = REAL;
	/// <para>TYPE IfcContextDependentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcContextDependentMeasure : REAL, IfcMeasureValue
	{
		IfcContextDependentMeasure() { }
		IfcContextDependentMeasure(double value) { Value = value; }
		public static implicit operator IfcContextDependentMeasure(double value) { return new IfcContextDependentMeasure(double);}
		public static implicit operator double(IfcContextDependentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCountMeasure = NUMBER;
	/// <para>TYPE IfcCountMeasure = NUMBER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCountMeasure : NUMBER, IfcMeasureValue
	{
		IfcCountMeasure() { }
		IfcCountMeasure(double value) { Value = value; }
		public static implicit operator IfcCountMeasure(double value) { return new IfcCountMeasure(double);}
		public static implicit operator double(IfcCountMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCurvatureMeasure = REAL;
	/// <para>TYPE IfcCurvatureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCurvatureMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcCurvatureMeasure() { }
		IfcCurvatureMeasure(double value) { Value = value; }
		public static implicit operator IfcCurvatureMeasure(double value) { return new IfcCurvatureMeasure(double);}
		public static implicit operator double(IfcCurvatureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDate = STRING;
	/// <para>TYPE IfcDate = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDate : STRING, IfcSimpleValue
	{
		IfcDate() { }
		IfcDate(string value) { Value = value; }
		public static implicit operator IfcDate(string value) { return new IfcDate(string);}
		public static implicit operator string(IfcDate value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDateTime = STRING;
	/// <para>TYPE IfcDateTime = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDateTime : STRING, IfcSimpleValue
	{
		IfcDateTime() { }
		IfcDateTime(string value) { Value = value; }
		public static implicit operator IfcDateTime(string value) { return new IfcDateTime(string);}
		public static implicit operator string(IfcDateTime value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDayInMonthNumber = INTEGER;
	/// <para>TYPE IfcDayInMonthNumber = INTEGER;</para>
	/// <para> WHERE</para>
	/// <para>	ValidRange : {1 <= SELF <= 31};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDayInMonthNumber : INTEGER
	{
		IfcDayInMonthNumber() { }
		IfcDayInMonthNumber(int value) { Value = value; }
		public static implicit operator IfcDayInMonthNumber(int value) { return new IfcDayInMonthNumber(int);}
		public static implicit operator int(IfcDayInMonthNumber value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDayInWeekNumber = INTEGER;
	/// <para>TYPE IfcDayInWeekNumber = INTEGER;</para>
	/// <para> WHERE</para>
	/// <para>	ValidRange : {1 <= SELF <= 7};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDayInWeekNumber : INTEGER
	{
		IfcDayInWeekNumber() { }
		IfcDayInWeekNumber(int value) { Value = value; }
		public static implicit operator IfcDayInWeekNumber(int value) { return new IfcDayInWeekNumber(int);}
		public static implicit operator int(IfcDayInWeekNumber value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDescriptiveMeasure = STRING;
	/// <para>TYPE IfcDescriptiveMeasure = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDescriptiveMeasure : STRING, IfcMeasureValue, IfcSizeSelect
	{
		IfcDescriptiveMeasure() { }
		IfcDescriptiveMeasure(string value) { Value = value; }
		public static implicit operator IfcDescriptiveMeasure(string value) { return new IfcDescriptiveMeasure(string);}
		public static implicit operator string(IfcDescriptiveMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDimensionCount = INTEGER;
	/// <para>TYPE IfcDimensionCount = INTEGER;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : { 0 < SELF <= 3 };</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDimensionCount : INTEGER
	{
		IfcDimensionCount() { }
		IfcDimensionCount(int value) { Value = value; }
		public static implicit operator IfcDimensionCount(int value) { return new IfcDimensionCount(int);}
		public static implicit operator int(IfcDimensionCount value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoseEquivalentMeasure = REAL;
	/// <para>TYPE IfcDoseEquivalentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoseEquivalentMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcDoseEquivalentMeasure() { }
		IfcDoseEquivalentMeasure(double value) { Value = value; }
		public static implicit operator IfcDoseEquivalentMeasure(double value) { return new IfcDoseEquivalentMeasure(double);}
		public static implicit operator double(IfcDoseEquivalentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDuration = STRING;
	/// <para>TYPE IfcDuration = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDuration : STRING, IfcSimpleValue, IfcTimeOrRatioSelect
	{
		IfcDuration() { }
		IfcDuration(string value) { Value = value; }
		public static implicit operator IfcDuration(string value) { return new IfcDuration(string);}
		public static implicit operator string(IfcDuration value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDynamicViscosityMeasure = REAL;
	/// <para>TYPE IfcDynamicViscosityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDynamicViscosityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcDynamicViscosityMeasure() { }
		IfcDynamicViscosityMeasure(double value) { Value = value; }
		public static implicit operator IfcDynamicViscosityMeasure(double value) { return new IfcDynamicViscosityMeasure(double);}
		public static implicit operator double(IfcDynamicViscosityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricCapacitanceMeasure = REAL;
	/// <para>TYPE IfcElectricCapacitanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricCapacitanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcElectricCapacitanceMeasure() { }
		IfcElectricCapacitanceMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricCapacitanceMeasure(double value) { return new IfcElectricCapacitanceMeasure(double);}
		public static implicit operator double(IfcElectricCapacitanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricChargeMeasure = REAL;
	/// <para>TYPE IfcElectricChargeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricChargeMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcElectricChargeMeasure() { }
		IfcElectricChargeMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricChargeMeasure(double value) { return new IfcElectricChargeMeasure(double);}
		public static implicit operator double(IfcElectricChargeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricConductanceMeasure = REAL;
	/// <para>TYPE IfcElectricConductanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricConductanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcElectricConductanceMeasure() { }
		IfcElectricConductanceMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricConductanceMeasure(double value) { return new IfcElectricConductanceMeasure(double);}
		public static implicit operator double(IfcElectricConductanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricCurrentMeasure = REAL;
	/// <para>TYPE IfcElectricCurrentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricCurrentMeasure : REAL, IfcMeasureValue
	{
		IfcElectricCurrentMeasure() { }
		IfcElectricCurrentMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricCurrentMeasure(double value) { return new IfcElectricCurrentMeasure(double);}
		public static implicit operator double(IfcElectricCurrentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricResistanceMeasure = REAL;
	/// <para>TYPE IfcElectricResistanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricResistanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcElectricResistanceMeasure() { }
		IfcElectricResistanceMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricResistanceMeasure(double value) { return new IfcElectricResistanceMeasure(double);}
		public static implicit operator double(IfcElectricResistanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricVoltageMeasure = REAL;
	/// <para>TYPE IfcElectricVoltageMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricVoltageMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcElectricVoltageMeasure() { }
		IfcElectricVoltageMeasure(double value) { Value = value; }
		public static implicit operator IfcElectricVoltageMeasure(double value) { return new IfcElectricVoltageMeasure(double);}
		public static implicit operator double(IfcElectricVoltageMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEnergyMeasure = REAL;
	/// <para>TYPE IfcEnergyMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEnergyMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcEnergyMeasure() { }
		IfcEnergyMeasure(double value) { Value = value; }
		public static implicit operator IfcEnergyMeasure(double value) { return new IfcEnergyMeasure(double);}
		public static implicit operator double(IfcEnergyMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFontStyle = STRING;
	/// <para>TYPE IfcFontStyle = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF IN ['normal','italic','oblique'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFontStyle : STRING
	{
		IfcFontStyle() { }
		IfcFontStyle(string value) { Value = value; }
		public static implicit operator IfcFontStyle(string value) { return new IfcFontStyle(string);}
		public static implicit operator string(IfcFontStyle value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFontVariant = STRING;
	/// <para>TYPE IfcFontVariant = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF IN ['normal','small-caps'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFontVariant : STRING
	{
		IfcFontVariant() { }
		IfcFontVariant(string value) { Value = value; }
		public static implicit operator IfcFontVariant(string value) { return new IfcFontVariant(string);}
		public static implicit operator string(IfcFontVariant value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFontWeight = STRING;
	/// <para>TYPE IfcFontWeight = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF IN ['normal','small-caps','100','200','300','400','500','600','700','800','900'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFontWeight : STRING
	{
		IfcFontWeight() { }
		IfcFontWeight(string value) { Value = value; }
		public static implicit operator IfcFontWeight(string value) { return new IfcFontWeight(string);}
		public static implicit operator string(IfcFontWeight value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcForceMeasure = REAL;
	/// <para>TYPE IfcForceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcForceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcForceMeasure() { }
		IfcForceMeasure(double value) { Value = value; }
		public static implicit operator IfcForceMeasure(double value) { return new IfcForceMeasure(double);}
		public static implicit operator double(IfcForceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFrequencyMeasure = REAL;
	/// <para>TYPE IfcFrequencyMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFrequencyMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcFrequencyMeasure() { }
		IfcFrequencyMeasure(double value) { Value = value; }
		public static implicit operator IfcFrequencyMeasure(double value) { return new IfcFrequencyMeasure(double);}
		public static implicit operator double(IfcFrequencyMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGloballyUniqueId = STRING(22) FIXED;
	/// <para>TYPE IfcGloballyUniqueId = STRING(22) FIXED;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGloballyUniqueId : STRING
	{
		IfcGloballyUniqueId() { }
		IfcGloballyUniqueId(string value) { Value = value; }
		public static implicit operator IfcGloballyUniqueId(string value) { return new IfcGloballyUniqueId(string);}
		public static implicit operator string(IfcGloballyUniqueId value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcHeatFluxDensityMeasure = REAL;
	/// <para>TYPE IfcHeatFluxDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcHeatFluxDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcHeatFluxDensityMeasure() { }
		IfcHeatFluxDensityMeasure(double value) { Value = value; }
		public static implicit operator IfcHeatFluxDensityMeasure(double value) { return new IfcHeatFluxDensityMeasure(double);}
		public static implicit operator double(IfcHeatFluxDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcHeatingValueMeasure = REAL;
	/// <para>TYPE IfcHeatingValueMeasure = REAL;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcHeatingValueMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcHeatingValueMeasure() { }
		IfcHeatingValueMeasure(double value) { Value = value; }
		public static implicit operator IfcHeatingValueMeasure(double value) { return new IfcHeatingValueMeasure(double);}
		public static implicit operator double(IfcHeatingValueMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIdentifier = STRING(255);
	/// <para>TYPE IfcIdentifier = STRING(255);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIdentifier : STRING, IfcSimpleValue
	{
		IfcIdentifier() { }
		IfcIdentifier(string value) { Value = value; }
		public static implicit operator IfcIdentifier(string value) { return new IfcIdentifier(string);}
		public static implicit operator string(IfcIdentifier value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIlluminanceMeasure = REAL;
	/// <para>TYPE IfcIlluminanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIlluminanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcIlluminanceMeasure() { }
		IfcIlluminanceMeasure(double value) { Value = value; }
		public static implicit operator IfcIlluminanceMeasure(double value) { return new IfcIlluminanceMeasure(double);}
		public static implicit operator double(IfcIlluminanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInductanceMeasure = REAL;
	/// <para>TYPE IfcInductanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInductanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcInductanceMeasure() { }
		IfcInductanceMeasure(double value) { Value = value; }
		public static implicit operator IfcInductanceMeasure(double value) { return new IfcInductanceMeasure(double);}
		public static implicit operator double(IfcInductanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInteger = INTEGER;
	/// <para>TYPE IfcInteger = INTEGER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInteger : INTEGER, IfcSimpleValue
	{
		IfcInteger() { }
		IfcInteger(int value) { Value = value; }
		public static implicit operator IfcInteger(int value) { return new IfcInteger(int);}
		public static implicit operator int(IfcInteger value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIntegerCountRateMeasure = INTEGER;
	/// <para>TYPE IfcIntegerCountRateMeasure = INTEGER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIntegerCountRateMeasure : INTEGER, IfcDerivedMeasureValue
	{
		IfcIntegerCountRateMeasure() { }
		IfcIntegerCountRateMeasure(int value) { Value = value; }
		public static implicit operator IfcIntegerCountRateMeasure(int value) { return new IfcIntegerCountRateMeasure(int);}
		public static implicit operator int(IfcIntegerCountRateMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIonConcentrationMeasure = REAL;
	/// <para>TYPE IfcIonConcentrationMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIonConcentrationMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcIonConcentrationMeasure() { }
		IfcIonConcentrationMeasure(double value) { Value = value; }
		public static implicit operator IfcIonConcentrationMeasure(double value) { return new IfcIonConcentrationMeasure(double);}
		public static implicit operator double(IfcIonConcentrationMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIsothermalMoistureCapacityMeasure = REAL;
	/// <para>TYPE IfcIsothermalMoistureCapacityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIsothermalMoistureCapacityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcIsothermalMoistureCapacityMeasure() { }
		IfcIsothermalMoistureCapacityMeasure(double value) { Value = value; }
		public static implicit operator IfcIsothermalMoistureCapacityMeasure(double value) { return new IfcIsothermalMoistureCapacityMeasure(double);}
		public static implicit operator double(IfcIsothermalMoistureCapacityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcKinematicViscosityMeasure = REAL;
	/// <para>TYPE IfcKinematicViscosityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcKinematicViscosityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcKinematicViscosityMeasure() { }
		IfcKinematicViscosityMeasure(double value) { Value = value; }
		public static implicit operator IfcKinematicViscosityMeasure(double value) { return new IfcKinematicViscosityMeasure(double);}
		public static implicit operator double(IfcKinematicViscosityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLabel = STRING(255);
	/// <para>TYPE IfcLabel = STRING(255);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLabel : STRING, IfcSimpleValue
	{
		IfcLabel() { }
		IfcLabel(string value) { Value = value; }
		public static implicit operator IfcLabel(string value) { return new IfcLabel(string);}
		public static implicit operator string(IfcLabel value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLanguageId = IfcIdentifier;
	/// <para>TYPE IfcLanguageId = IfcIdentifier;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLanguageId : IfcIdentifier
	{
		IfcLanguageId() { }
		IfcLanguageId(string value) { Value = value; }
		public static implicit operator IfcLanguageId(string value) { return new IfcLanguageId(string);}
		public static implicit operator string(IfcLanguageId value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLengthMeasure = REAL;
	/// <para>TYPE IfcLengthMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLengthMeasure : REAL, IfcBendingParameterSelect, IfcMeasureValue, IfcSizeSelect
	{
		IfcLengthMeasure() { }
		IfcLengthMeasure(double value) { Value = value; }
		public static implicit operator IfcLengthMeasure(double value) { return new IfcLengthMeasure(double);}
		public static implicit operator double(IfcLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearForceMeasure = REAL;
	/// <para>TYPE IfcLinearForceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearForceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcLinearForceMeasure() { }
		IfcLinearForceMeasure(double value) { Value = value; }
		public static implicit operator IfcLinearForceMeasure(double value) { return new IfcLinearForceMeasure(double);}
		public static implicit operator double(IfcLinearForceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearMomentMeasure = REAL;
	/// <para>TYPE IfcLinearMomentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearMomentMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcLinearMomentMeasure() { }
		IfcLinearMomentMeasure(double value) { Value = value; }
		public static implicit operator IfcLinearMomentMeasure(double value) { return new IfcLinearMomentMeasure(double);}
		public static implicit operator double(IfcLinearMomentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearStiffnessMeasure = REAL;
	/// <para>TYPE IfcLinearStiffnessMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearStiffnessMeasure : REAL, IfcDerivedMeasureValue, IfcTranslationalStiffnessSelect
	{
		IfcLinearStiffnessMeasure() { }
		IfcLinearStiffnessMeasure(double value) { Value = value; }
		public static implicit operator IfcLinearStiffnessMeasure(double value) { return new IfcLinearStiffnessMeasure(double);}
		public static implicit operator double(IfcLinearStiffnessMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearVelocityMeasure = REAL;
	/// <para>TYPE IfcLinearVelocityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearVelocityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcLinearVelocityMeasure() { }
		IfcLinearVelocityMeasure(double value) { Value = value; }
		public static implicit operator IfcLinearVelocityMeasure(double value) { return new IfcLinearVelocityMeasure(double);}
		public static implicit operator double(IfcLinearVelocityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLogical = LOGICAL;
	/// <para>TYPE IfcLogical = LOGICAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLogical : LOGICAL, IfcSimpleValue
	{
		IfcLogical() { }
		IfcLogical(bool value) { Value = value; }
		public static implicit operator IfcLogical(bool value) { return new IfcLogical(bool);}
		public static implicit operator bool(IfcLogical value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLuminousFluxMeasure = REAL;
	/// <para>TYPE IfcLuminousFluxMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLuminousFluxMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcLuminousFluxMeasure() { }
		IfcLuminousFluxMeasure(double value) { Value = value; }
		public static implicit operator IfcLuminousFluxMeasure(double value) { return new IfcLuminousFluxMeasure(double);}
		public static implicit operator double(IfcLuminousFluxMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLuminousIntensityDistributionMeasure = REAL;
	/// <para>TYPE IfcLuminousIntensityDistributionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLuminousIntensityDistributionMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcLuminousIntensityDistributionMeasure() { }
		IfcLuminousIntensityDistributionMeasure(double value) { Value = value; }
		public static implicit operator IfcLuminousIntensityDistributionMeasure(double value) { return new IfcLuminousIntensityDistributionMeasure(double);}
		public static implicit operator double(IfcLuminousIntensityDistributionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLuminousIntensityMeasure = REAL;
	/// <para>TYPE IfcLuminousIntensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLuminousIntensityMeasure : REAL, IfcMeasureValue
	{
		IfcLuminousIntensityMeasure() { }
		IfcLuminousIntensityMeasure(double value) { Value = value; }
		public static implicit operator IfcLuminousIntensityMeasure(double value) { return new IfcLuminousIntensityMeasure(double);}
		public static implicit operator double(IfcLuminousIntensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMagneticFluxDensityMeasure = REAL;
	/// <para>TYPE IfcMagneticFluxDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMagneticFluxDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMagneticFluxDensityMeasure() { }
		IfcMagneticFluxDensityMeasure(double value) { Value = value; }
		public static implicit operator IfcMagneticFluxDensityMeasure(double value) { return new IfcMagneticFluxDensityMeasure(double);}
		public static implicit operator double(IfcMagneticFluxDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMagneticFluxMeasure = REAL;
	/// <para>TYPE IfcMagneticFluxMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMagneticFluxMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMagneticFluxMeasure() { }
		IfcMagneticFluxMeasure(double value) { Value = value; }
		public static implicit operator IfcMagneticFluxMeasure(double value) { return new IfcMagneticFluxMeasure(double);}
		public static implicit operator double(IfcMagneticFluxMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassDensityMeasure = REAL;
	/// <para>TYPE IfcMassDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMassDensityMeasure() { }
		IfcMassDensityMeasure(double value) { Value = value; }
		public static implicit operator IfcMassDensityMeasure(double value) { return new IfcMassDensityMeasure(double);}
		public static implicit operator double(IfcMassDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassFlowRateMeasure = REAL;
	/// <para>TYPE IfcMassFlowRateMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassFlowRateMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMassFlowRateMeasure() { }
		IfcMassFlowRateMeasure(double value) { Value = value; }
		public static implicit operator IfcMassFlowRateMeasure(double value) { return new IfcMassFlowRateMeasure(double);}
		public static implicit operator double(IfcMassFlowRateMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassMeasure = REAL;
	/// <para>TYPE IfcMassMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassMeasure : REAL, IfcMeasureValue
	{
		IfcMassMeasure() { }
		IfcMassMeasure(double value) { Value = value; }
		public static implicit operator IfcMassMeasure(double value) { return new IfcMassMeasure(double);}
		public static implicit operator double(IfcMassMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassPerLengthMeasure = REAL;
	/// <para>TYPE IfcMassPerLengthMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassPerLengthMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMassPerLengthMeasure() { }
		IfcMassPerLengthMeasure(double value) { Value = value; }
		public static implicit operator IfcMassPerLengthMeasure(double value) { return new IfcMassPerLengthMeasure(double);}
		public static implicit operator double(IfcMassPerLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfElasticityMeasure = REAL;
	/// <para>TYPE IfcModulusOfElasticityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfElasticityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcModulusOfElasticityMeasure() { }
		IfcModulusOfElasticityMeasure(double value) { Value = value; }
		public static implicit operator IfcModulusOfElasticityMeasure(double value) { return new IfcModulusOfElasticityMeasure(double);}
		public static implicit operator double(IfcModulusOfElasticityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfLinearSubgradeReactionMeasure = REAL;
	/// <para>TYPE IfcModulusOfLinearSubgradeReactionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfLinearSubgradeReactionMeasure : REAL, IfcDerivedMeasureValue, IfcModulusOfTranslationalSubgradeReactionSelect
	{
		IfcModulusOfLinearSubgradeReactionMeasure() { }
		IfcModulusOfLinearSubgradeReactionMeasure(double value) { Value = value; }
		public static implicit operator IfcModulusOfLinearSubgradeReactionMeasure(double value) { return new IfcModulusOfLinearSubgradeReactionMeasure(double);}
		public static implicit operator double(IfcModulusOfLinearSubgradeReactionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfRotationalSubgradeReactionMeasure = REAL;
	/// <para>TYPE IfcModulusOfRotationalSubgradeReactionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfRotationalSubgradeReactionMeasure : REAL, IfcDerivedMeasureValue, IfcModulusOfRotationalSubgradeReactionSelect
	{
		IfcModulusOfRotationalSubgradeReactionMeasure() { }
		IfcModulusOfRotationalSubgradeReactionMeasure(double value) { Value = value; }
		public static implicit operator IfcModulusOfRotationalSubgradeReactionMeasure(double value) { return new IfcModulusOfRotationalSubgradeReactionMeasure(double);}
		public static implicit operator double(IfcModulusOfRotationalSubgradeReactionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfSubgradeReactionMeasure = REAL;
	/// <para>TYPE IfcModulusOfSubgradeReactionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfSubgradeReactionMeasure : REAL, IfcDerivedMeasureValue, IfcModulusOfSubgradeReactionSelect
	{
		IfcModulusOfSubgradeReactionMeasure() { }
		IfcModulusOfSubgradeReactionMeasure(double value) { Value = value; }
		public static implicit operator IfcModulusOfSubgradeReactionMeasure(double value) { return new IfcModulusOfSubgradeReactionMeasure(double);}
		public static implicit operator double(IfcModulusOfSubgradeReactionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMoistureDiffusivityMeasure = REAL;
	/// <para>TYPE IfcMoistureDiffusivityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMoistureDiffusivityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMoistureDiffusivityMeasure() { }
		IfcMoistureDiffusivityMeasure(double value) { Value = value; }
		public static implicit operator IfcMoistureDiffusivityMeasure(double value) { return new IfcMoistureDiffusivityMeasure(double);}
		public static implicit operator double(IfcMoistureDiffusivityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMolecularWeightMeasure = REAL;
	/// <para>TYPE IfcMolecularWeightMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMolecularWeightMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMolecularWeightMeasure() { }
		IfcMolecularWeightMeasure(double value) { Value = value; }
		public static implicit operator IfcMolecularWeightMeasure(double value) { return new IfcMolecularWeightMeasure(double);}
		public static implicit operator double(IfcMolecularWeightMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMomentOfInertiaMeasure = REAL;
	/// <para>TYPE IfcMomentOfInertiaMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMomentOfInertiaMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMomentOfInertiaMeasure() { }
		IfcMomentOfInertiaMeasure(double value) { Value = value; }
		public static implicit operator IfcMomentOfInertiaMeasure(double value) { return new IfcMomentOfInertiaMeasure(double);}
		public static implicit operator double(IfcMomentOfInertiaMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMonetaryMeasure = REAL;
	/// <para>TYPE IfcMonetaryMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMonetaryMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcMonetaryMeasure() { }
		IfcMonetaryMeasure(double value) { Value = value; }
		public static implicit operator IfcMonetaryMeasure(double value) { return new IfcMonetaryMeasure(double);}
		public static implicit operator double(IfcMonetaryMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMonthInYearNumber = INTEGER;
	/// <para>TYPE IfcMonthInYearNumber = INTEGER;</para>
	/// <para> WHERE</para>
	/// <para>	ValidRange : {1 <= SELF <= 12};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMonthInYearNumber : INTEGER
	{
		IfcMonthInYearNumber() { }
		IfcMonthInYearNumber(int value) { Value = value; }
		public static implicit operator IfcMonthInYearNumber(int value) { return new IfcMonthInYearNumber(int);}
		public static implicit operator int(IfcMonthInYearNumber value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNonNegativeLengthMeasure = IfcLengthMeasure;
	/// <para>TYPE IfcNonNegativeLengthMeasure = IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	NotNegative : SELF >= 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNonNegativeLengthMeasure : IfcLengthMeasure, IfcMeasureValue
	{
		IfcNonNegativeLengthMeasure() { }
		IfcNonNegativeLengthMeasure(double value) { Value = value; }
		public static implicit operator IfcNonNegativeLengthMeasure(double value) { return new IfcNonNegativeLengthMeasure(double);}
		public static implicit operator double(IfcNonNegativeLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNormalisedRatioMeasure = IfcRatioMeasure;
	/// <para>TYPE IfcNormalisedRatioMeasure = IfcRatioMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : {0.0 <= SELF <= 1.0};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNormalisedRatioMeasure : IfcRatioMeasure, IfcColourOrFactor, IfcMeasureValue, IfcSizeSelect
	{
		IfcNormalisedRatioMeasure() { }
		IfcNormalisedRatioMeasure(double value) { Value = value; }
		public static implicit operator IfcNormalisedRatioMeasure(double value) { return new IfcNormalisedRatioMeasure(double);}
		public static implicit operator double(IfcNormalisedRatioMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNumericMeasure = NUMBER;
	/// <para>TYPE IfcNumericMeasure = NUMBER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNumericMeasure : NUMBER, IfcMeasureValue
	{
		IfcNumericMeasure() { }
		IfcNumericMeasure(double value) { Value = value; }
		public static implicit operator IfcNumericMeasure(double value) { return new IfcNumericMeasure(double);}
		public static implicit operator double(IfcNumericMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPHMeasure = REAL;
	/// <para>TYPE IfcPHMeasure = REAL;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : {0.0 <= SELF <= 14.0};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPHMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcPHMeasure() { }
		IfcPHMeasure(double value) { Value = value; }
		public static implicit operator IfcPHMeasure(double value) { return new IfcPHMeasure(double);}
		public static implicit operator double(IfcPHMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcParameterValue = REAL;
	/// <para>TYPE IfcParameterValue = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcParameterValue : REAL, IfcMeasureValue, IfcTrimmingSelect
	{
		IfcParameterValue() { }
		IfcParameterValue(double value) { Value = value; }
		public static implicit operator IfcParameterValue(double value) { return new IfcParameterValue(double);}
		public static implicit operator double(IfcParameterValue value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPlanarForceMeasure = REAL;
	/// <para>TYPE IfcPlanarForceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPlanarForceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcPlanarForceMeasure() { }
		IfcPlanarForceMeasure(double value) { Value = value; }
		public static implicit operator IfcPlanarForceMeasure(double value) { return new IfcPlanarForceMeasure(double);}
		public static implicit operator double(IfcPlanarForceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPlaneAngleMeasure = REAL;
	/// <para>TYPE IfcPlaneAngleMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPlaneAngleMeasure : REAL, IfcBendingParameterSelect, IfcMeasureValue
	{
		IfcPlaneAngleMeasure() { }
		IfcPlaneAngleMeasure(double value) { Value = value; }
		public static implicit operator IfcPlaneAngleMeasure(double value) { return new IfcPlaneAngleMeasure(double);}
		public static implicit operator double(IfcPlaneAngleMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositiveInteger = IfcInteger;
	/// <para>TYPE IfcPositiveInteger = IfcInteger;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF > 0;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositiveInteger : IfcInteger, IfcSimpleValue
	{
		IfcPositiveInteger() { }
		IfcPositiveInteger(int value) { Value = value; }
		public static implicit operator IfcPositiveInteger(int value) { return new IfcPositiveInteger(int);}
		public static implicit operator int(IfcPositiveInteger value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositiveLengthMeasure = IfcLengthMeasure;
	/// <para>TYPE IfcPositiveLengthMeasure = IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositiveLengthMeasure : IfcLengthMeasure, IfcHatchLineDistanceSelect, IfcMeasureValue, IfcSizeSelect
	{
		IfcPositiveLengthMeasure() { }
		IfcPositiveLengthMeasure(double value) { Value = value; }
		public static implicit operator IfcPositiveLengthMeasure(double value) { return new IfcPositiveLengthMeasure(double);}
		public static implicit operator double(IfcPositiveLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositivePlaneAngleMeasure = IfcPlaneAngleMeasure;
	/// <para>TYPE IfcPositivePlaneAngleMeasure = IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositivePlaneAngleMeasure : IfcPlaneAngleMeasure, IfcMeasureValue
	{
		IfcPositivePlaneAngleMeasure() { }
		IfcPositivePlaneAngleMeasure(double value) { Value = value; }
		public static implicit operator IfcPositivePlaneAngleMeasure(double value) { return new IfcPositivePlaneAngleMeasure(double);}
		public static implicit operator double(IfcPositivePlaneAngleMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositiveRatioMeasure = IfcRatioMeasure;
	/// <para>TYPE IfcPositiveRatioMeasure = IfcRatioMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositiveRatioMeasure : IfcRatioMeasure, IfcMeasureValue, IfcSizeSelect
	{
		IfcPositiveRatioMeasure() { }
		IfcPositiveRatioMeasure(double value) { Value = value; }
		public static implicit operator IfcPositiveRatioMeasure(double value) { return new IfcPositiveRatioMeasure(double);}
		public static implicit operator double(IfcPositiveRatioMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPowerMeasure = REAL;
	/// <para>TYPE IfcPowerMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPowerMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcPowerMeasure() { }
		IfcPowerMeasure(double value) { Value = value; }
		public static implicit operator IfcPowerMeasure(double value) { return new IfcPowerMeasure(double);}
		public static implicit operator double(IfcPowerMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPresentableText = STRING;
	/// <para>TYPE IfcPresentableText = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPresentableText : STRING
	{
		IfcPresentableText() { }
		IfcPresentableText(string value) { Value = value; }
		public static implicit operator IfcPresentableText(string value) { return new IfcPresentableText(string);}
		public static implicit operator string(IfcPresentableText value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPressureMeasure = REAL;
	/// <para>TYPE IfcPressureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPressureMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcPressureMeasure() { }
		IfcPressureMeasure(double value) { Value = value; }
		public static implicit operator IfcPressureMeasure(double value) { return new IfcPressureMeasure(double);}
		public static implicit operator double(IfcPressureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRadioActivityMeasure = REAL;
	/// <para>TYPE IfcRadioActivityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRadioActivityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcRadioActivityMeasure() { }
		IfcRadioActivityMeasure(double value) { Value = value; }
		public static implicit operator IfcRadioActivityMeasure(double value) { return new IfcRadioActivityMeasure(double);}
		public static implicit operator double(IfcRadioActivityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRatioMeasure = REAL;
	/// <para>TYPE IfcRatioMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRatioMeasure : REAL, IfcMeasureValue, IfcSizeSelect, IfcTimeOrRatioSelect
	{
		IfcRatioMeasure() { }
		IfcRatioMeasure(double value) { Value = value; }
		public static implicit operator IfcRatioMeasure(double value) { return new IfcRatioMeasure(double);}
		public static implicit operator double(IfcRatioMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReal = REAL;
	/// <para>TYPE IfcReal = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReal : REAL, IfcSimpleValue
	{
		IfcReal() { }
		IfcReal(double value) { Value = value; }
		public static implicit operator IfcReal(double value) { return new IfcReal(double);}
		public static implicit operator double(IfcReal value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRotationalFrequencyMeasure = REAL;
	/// <para>TYPE IfcRotationalFrequencyMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRotationalFrequencyMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcRotationalFrequencyMeasure() { }
		IfcRotationalFrequencyMeasure(double value) { Value = value; }
		public static implicit operator IfcRotationalFrequencyMeasure(double value) { return new IfcRotationalFrequencyMeasure(double);}
		public static implicit operator double(IfcRotationalFrequencyMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRotationalMassMeasure = REAL;
	/// <para>TYPE IfcRotationalMassMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRotationalMassMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcRotationalMassMeasure() { }
		IfcRotationalMassMeasure(double value) { Value = value; }
		public static implicit operator IfcRotationalMassMeasure(double value) { return new IfcRotationalMassMeasure(double);}
		public static implicit operator double(IfcRotationalMassMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRotationalStiffnessMeasure = REAL;
	/// <para>TYPE IfcRotationalStiffnessMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRotationalStiffnessMeasure : REAL, IfcDerivedMeasureValue, IfcRotationalStiffnessSelect
	{
		IfcRotationalStiffnessMeasure() { }
		IfcRotationalStiffnessMeasure(double value) { Value = value; }
		public static implicit operator IfcRotationalStiffnessMeasure(double value) { return new IfcRotationalStiffnessMeasure(double);}
		public static implicit operator double(IfcRotationalStiffnessMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSectionModulusMeasure = REAL;
	/// <para>TYPE IfcSectionModulusMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSectionModulusMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSectionModulusMeasure() { }
		IfcSectionModulusMeasure(double value) { Value = value; }
		public static implicit operator IfcSectionModulusMeasure(double value) { return new IfcSectionModulusMeasure(double);}
		public static implicit operator double(IfcSectionModulusMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSectionalAreaIntegralMeasure = REAL;
	/// <para>TYPE IfcSectionalAreaIntegralMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSectionalAreaIntegralMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSectionalAreaIntegralMeasure() { }
		IfcSectionalAreaIntegralMeasure(double value) { Value = value; }
		public static implicit operator IfcSectionalAreaIntegralMeasure(double value) { return new IfcSectionalAreaIntegralMeasure(double);}
		public static implicit operator double(IfcSectionalAreaIntegralMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcShearModulusMeasure = REAL;
	/// <para>TYPE IfcShearModulusMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcShearModulusMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcShearModulusMeasure() { }
		IfcShearModulusMeasure(double value) { Value = value; }
		public static implicit operator IfcShearModulusMeasure(double value) { return new IfcShearModulusMeasure(double);}
		public static implicit operator double(IfcShearModulusMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSolidAngleMeasure = REAL;
	/// <para>TYPE IfcSolidAngleMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSolidAngleMeasure : REAL, IfcMeasureValue
	{
		IfcSolidAngleMeasure() { }
		IfcSolidAngleMeasure(double value) { Value = value; }
		public static implicit operator IfcSolidAngleMeasure(double value) { return new IfcSolidAngleMeasure(double);}
		public static implicit operator double(IfcSolidAngleMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPowerLevelMeasure = REAL;
	/// <para>TYPE IfcSoundPowerLevelMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPowerLevelMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSoundPowerLevelMeasure() { }
		IfcSoundPowerLevelMeasure(double value) { Value = value; }
		public static implicit operator IfcSoundPowerLevelMeasure(double value) { return new IfcSoundPowerLevelMeasure(double);}
		public static implicit operator double(IfcSoundPowerLevelMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPowerMeasure = REAL;
	/// <para>TYPE IfcSoundPowerMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPowerMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSoundPowerMeasure() { }
		IfcSoundPowerMeasure(double value) { Value = value; }
		public static implicit operator IfcSoundPowerMeasure(double value) { return new IfcSoundPowerMeasure(double);}
		public static implicit operator double(IfcSoundPowerMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPressureLevelMeasure = REAL;
	/// <para>TYPE IfcSoundPressureLevelMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPressureLevelMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSoundPressureLevelMeasure() { }
		IfcSoundPressureLevelMeasure(double value) { Value = value; }
		public static implicit operator IfcSoundPressureLevelMeasure(double value) { return new IfcSoundPressureLevelMeasure(double);}
		public static implicit operator double(IfcSoundPressureLevelMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPressureMeasure = REAL;
	/// <para>TYPE IfcSoundPressureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPressureMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSoundPressureMeasure() { }
		IfcSoundPressureMeasure(double value) { Value = value; }
		public static implicit operator IfcSoundPressureMeasure(double value) { return new IfcSoundPressureMeasure(double);}
		public static implicit operator double(IfcSoundPressureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpecificHeatCapacityMeasure = REAL;
	/// <para>TYPE IfcSpecificHeatCapacityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpecificHeatCapacityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcSpecificHeatCapacityMeasure() { }
		IfcSpecificHeatCapacityMeasure(double value) { Value = value; }
		public static implicit operator IfcSpecificHeatCapacityMeasure(double value) { return new IfcSpecificHeatCapacityMeasure(double);}
		public static implicit operator double(IfcSpecificHeatCapacityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpecularExponent = REAL;
	/// <para>TYPE IfcSpecularExponent = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpecularExponent : REAL, IfcSpecularHighlightSelect
	{
		IfcSpecularExponent() { }
		IfcSpecularExponent(double value) { Value = value; }
		public static implicit operator IfcSpecularExponent(double value) { return new IfcSpecularExponent(double);}
		public static implicit operator double(IfcSpecularExponent value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpecularRoughness = REAL;
	/// <para>TYPE IfcSpecularRoughness = REAL;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : {0.0 <= SELF <= 1.0};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpecularRoughness : REAL, IfcSpecularHighlightSelect
	{
		IfcSpecularRoughness() { }
		IfcSpecularRoughness(double value) { Value = value; }
		public static implicit operator IfcSpecularRoughness(double value) { return new IfcSpecularRoughness(double);}
		public static implicit operator double(IfcSpecularRoughness value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTemperatureGradientMeasure = REAL;
	/// <para>TYPE IfcTemperatureGradientMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTemperatureGradientMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcTemperatureGradientMeasure() { }
		IfcTemperatureGradientMeasure(double value) { Value = value; }
		public static implicit operator IfcTemperatureGradientMeasure(double value) { return new IfcTemperatureGradientMeasure(double);}
		public static implicit operator double(IfcTemperatureGradientMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTemperatureRateOfChangeMeasure = REAL;
	/// <para>TYPE IfcTemperatureRateOfChangeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTemperatureRateOfChangeMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcTemperatureRateOfChangeMeasure() { }
		IfcTemperatureRateOfChangeMeasure(double value) { Value = value; }
		public static implicit operator IfcTemperatureRateOfChangeMeasure(double value) { return new IfcTemperatureRateOfChangeMeasure(double);}
		public static implicit operator double(IfcTemperatureRateOfChangeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcText = STRING;
	/// <para>TYPE IfcText = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcText : STRING, IfcSimpleValue
	{
		IfcText() { }
		IfcText(string value) { Value = value; }
		public static implicit operator IfcText(string value) { return new IfcText(string);}
		public static implicit operator string(IfcText value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextAlignment = STRING;
	/// <para>TYPE IfcTextAlignment = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF IN ['left', 'right', 'center', 'justify'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextAlignment : STRING
	{
		IfcTextAlignment() { }
		IfcTextAlignment(string value) { Value = value; }
		public static implicit operator IfcTextAlignment(string value) { return new IfcTextAlignment(string);}
		public static implicit operator string(IfcTextAlignment value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextDecoration = STRING;
	/// <para>TYPE IfcTextDecoration = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF IN ['none', 'underline', 'overline', 'line-through', 'blink'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextDecoration : STRING
	{
		IfcTextDecoration() { }
		IfcTextDecoration(string value) { Value = value; }
		public static implicit operator IfcTextDecoration(string value) { return new IfcTextDecoration(string);}
		public static implicit operator string(IfcTextDecoration value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextFontName = STRING;
	/// <para>TYPE IfcTextFontName = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextFontName : STRING
	{
		IfcTextFontName() { }
		IfcTextFontName(string value) { Value = value; }
		public static implicit operator IfcTextFontName(string value) { return new IfcTextFontName(string);}
		public static implicit operator string(IfcTextFontName value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextTransformation = STRING;
	/// <para>TYPE IfcTextTransformation = STRING;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF IN ['capitalize', 'uppercase', 'lowercase', 'none'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextTransformation : STRING
	{
		IfcTextTransformation() { }
		IfcTextTransformation(string value) { Value = value; }
		public static implicit operator IfcTextTransformation(string value) { return new IfcTextTransformation(string);}
		public static implicit operator string(IfcTextTransformation value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalAdmittanceMeasure = REAL;
	/// <para>TYPE IfcThermalAdmittanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalAdmittanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcThermalAdmittanceMeasure() { }
		IfcThermalAdmittanceMeasure(double value) { Value = value; }
		public static implicit operator IfcThermalAdmittanceMeasure(double value) { return new IfcThermalAdmittanceMeasure(double);}
		public static implicit operator double(IfcThermalAdmittanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalConductivityMeasure = REAL;
	/// <para>TYPE IfcThermalConductivityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalConductivityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcThermalConductivityMeasure() { }
		IfcThermalConductivityMeasure(double value) { Value = value; }
		public static implicit operator IfcThermalConductivityMeasure(double value) { return new IfcThermalConductivityMeasure(double);}
		public static implicit operator double(IfcThermalConductivityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalExpansionCoefficientMeasure = REAL;
	/// <para>TYPE IfcThermalExpansionCoefficientMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalExpansionCoefficientMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcThermalExpansionCoefficientMeasure() { }
		IfcThermalExpansionCoefficientMeasure(double value) { Value = value; }
		public static implicit operator IfcThermalExpansionCoefficientMeasure(double value) { return new IfcThermalExpansionCoefficientMeasure(double);}
		public static implicit operator double(IfcThermalExpansionCoefficientMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalResistanceMeasure = REAL;
	/// <para>TYPE IfcThermalResistanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalResistanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcThermalResistanceMeasure() { }
		IfcThermalResistanceMeasure(double value) { Value = value; }
		public static implicit operator IfcThermalResistanceMeasure(double value) { return new IfcThermalResistanceMeasure(double);}
		public static implicit operator double(IfcThermalResistanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalTransmittanceMeasure = REAL;
	/// <para>TYPE IfcThermalTransmittanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalTransmittanceMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcThermalTransmittanceMeasure() { }
		IfcThermalTransmittanceMeasure(double value) { Value = value; }
		public static implicit operator IfcThermalTransmittanceMeasure(double value) { return new IfcThermalTransmittanceMeasure(double);}
		public static implicit operator double(IfcThermalTransmittanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermodynamicTemperatureMeasure = REAL;
	/// <para>TYPE IfcThermodynamicTemperatureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermodynamicTemperatureMeasure : REAL, IfcMeasureValue
	{
		IfcThermodynamicTemperatureMeasure() { }
		IfcThermodynamicTemperatureMeasure(double value) { Value = value; }
		public static implicit operator IfcThermodynamicTemperatureMeasure(double value) { return new IfcThermodynamicTemperatureMeasure(double);}
		public static implicit operator double(IfcThermodynamicTemperatureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTime = STRING;
	/// <para>TYPE IfcTime = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTime : STRING, IfcSimpleValue
	{
		IfcTime() { }
		IfcTime(string value) { Value = value; }
		public static implicit operator IfcTime(string value) { return new IfcTime(string);}
		public static implicit operator string(IfcTime value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTimeMeasure = REAL;
	/// <para>TYPE IfcTimeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTimeMeasure : REAL, IfcMeasureValue
	{
		IfcTimeMeasure() { }
		IfcTimeMeasure(double value) { Value = value; }
		public static implicit operator IfcTimeMeasure(double value) { return new IfcTimeMeasure(double);}
		public static implicit operator double(IfcTimeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTimeStamp = INTEGER;
	/// <para>TYPE IfcTimeStamp = INTEGER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTimeStamp : INTEGER, IfcSimpleValue
	{
		IfcTimeStamp() { }
		IfcTimeStamp(int value) { Value = value; }
		public static implicit operator IfcTimeStamp(int value) { return new IfcTimeStamp(int);}
		public static implicit operator int(IfcTimeStamp value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTorqueMeasure = REAL;
	/// <para>TYPE IfcTorqueMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTorqueMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcTorqueMeasure() { }
		IfcTorqueMeasure(double value) { Value = value; }
		public static implicit operator IfcTorqueMeasure(double value) { return new IfcTorqueMeasure(double);}
		public static implicit operator double(IfcTorqueMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcURIReference = STRING;
	/// <para>TYPE IfcURIReference = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcURIReference : STRING
	{
		IfcURIReference() { }
		IfcURIReference(string value) { Value = value; }
		public static implicit operator IfcURIReference(string value) { return new IfcURIReference(string);}
		public static implicit operator string(IfcURIReference value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVaporPermeabilityMeasure = REAL;
	/// <para>TYPE IfcVaporPermeabilityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVaporPermeabilityMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcVaporPermeabilityMeasure() { }
		IfcVaporPermeabilityMeasure(double value) { Value = value; }
		public static implicit operator IfcVaporPermeabilityMeasure(double value) { return new IfcVaporPermeabilityMeasure(double);}
		public static implicit operator double(IfcVaporPermeabilityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVolumeMeasure = REAL;
	/// <para>TYPE IfcVolumeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVolumeMeasure : REAL, IfcMeasureValue
	{
		IfcVolumeMeasure() { }
		IfcVolumeMeasure(double value) { Value = value; }
		public static implicit operator IfcVolumeMeasure(double value) { return new IfcVolumeMeasure(double);}
		public static implicit operator double(IfcVolumeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVolumetricFlowRateMeasure = REAL;
	/// <para>TYPE IfcVolumetricFlowRateMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVolumetricFlowRateMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcVolumetricFlowRateMeasure() { }
		IfcVolumetricFlowRateMeasure(double value) { Value = value; }
		public static implicit operator IfcVolumetricFlowRateMeasure(double value) { return new IfcVolumetricFlowRateMeasure(double);}
		public static implicit operator double(IfcVolumetricFlowRateMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWarpingConstantMeasure = REAL;
	/// <para>TYPE IfcWarpingConstantMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWarpingConstantMeasure : REAL, IfcDerivedMeasureValue
	{
		IfcWarpingConstantMeasure() { }
		IfcWarpingConstantMeasure(double value) { Value = value; }
		public static implicit operator IfcWarpingConstantMeasure(double value) { return new IfcWarpingConstantMeasure(double);}
		public static implicit operator double(IfcWarpingConstantMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWarpingMomentMeasure = REAL;
	/// <para>TYPE IfcWarpingMomentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWarpingMomentMeasure : REAL, IfcDerivedMeasureValue, IfcWarpingStiffnessSelect
	{
		IfcWarpingMomentMeasure() { }
		IfcWarpingMomentMeasure(double value) { Value = value; }
		public static implicit operator IfcWarpingMomentMeasure(double value) { return new IfcWarpingMomentMeasure(double);}
		public static implicit operator double(IfcWarpingMomentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcActionRequestTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcActionRequestTypeEnum = ENUMERATION OF</para>
	/// <para>	(EMAIL</para>
	/// <para>	,FAX</para>
	/// <para>	,PHONE</para>
	/// <para>	,POST</para>
	/// <para>	,VERBAL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcActionRequestTypeEnum
	{
		public static string EMAIL { get {return "EMAIL";} }
		public static string FAX { get {return "FAX";} }
		public static string PHONE { get {return "PHONE";} }
		public static string POST { get {return "POST";} }
		public static string VERBAL { get {return "VERBAL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcActionRequestTypeEnum(string value) { return new IfcActionRequestTypeEnum(string);}
		public static implicit operator string(IfcActionRequestTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcActionSourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcActionSourceTypeEnum = ENUMERATION OF</para>
	/// <para>	(DEAD_LOAD_G</para>
	/// <para>	,COMPLETION_G1</para>
	/// <para>	,LIVE_LOAD_Q</para>
	/// <para>	,SNOW_S</para>
	/// <para>	,WIND_W</para>
	/// <para>	,PRESTRESSING_P</para>
	/// <para>	,SETTLEMENT_U</para>
	/// <para>	,TEMPERATURE_T</para>
	/// <para>	,EARTHQUAKE_E</para>
	/// <para>	,FIRE</para>
	/// <para>	,IMPULSE</para>
	/// <para>	,IMPACT</para>
	/// <para>	,TRANSPORT</para>
	/// <para>	,ERECTION</para>
	/// <para>	,PROPPING</para>
	/// <para>	,SYSTEM_IMPERFECTION</para>
	/// <para>	,SHRINKAGE</para>
	/// <para>	,CREEP</para>
	/// <para>	,LACK_OF_FIT</para>
	/// <para>	,BUOYANCY</para>
	/// <para>	,ICE</para>
	/// <para>	,CURRENT</para>
	/// <para>	,WAVE</para>
	/// <para>	,RAIN</para>
	/// <para>	,BRAKES</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcActionSourceTypeEnum
	{
		public static string DEAD_LOAD_G { get {return "DEAD_LOAD_G";} }
		public static string COMPLETION_G1 { get {return "COMPLETION_G1";} }
		public static string LIVE_LOAD_Q { get {return "LIVE_LOAD_Q";} }
		public static string SNOW_S { get {return "SNOW_S";} }
		public static string WIND_W { get {return "WIND_W";} }
		public static string PRESTRESSING_P { get {return "PRESTRESSING_P";} }
		public static string SETTLEMENT_U { get {return "SETTLEMENT_U";} }
		public static string TEMPERATURE_T { get {return "TEMPERATURE_T";} }
		public static string EARTHQUAKE_E { get {return "EARTHQUAKE_E";} }
		public static string FIRE { get {return "FIRE";} }
		public static string IMPULSE { get {return "IMPULSE";} }
		public static string IMPACT { get {return "IMPACT";} }
		public static string TRANSPORT { get {return "TRANSPORT";} }
		public static string ERECTION { get {return "ERECTION";} }
		public static string PROPPING { get {return "PROPPING";} }
		public static string SYSTEM_IMPERFECTION { get {return "SYSTEM_IMPERFECTION";} }
		public static string SHRINKAGE { get {return "SHRINKAGE";} }
		public static string CREEP { get {return "CREEP";} }
		public static string LACK_OF_FIT { get {return "LACK_OF_FIT";} }
		public static string BUOYANCY { get {return "BUOYANCY";} }
		public static string ICE { get {return "ICE";} }
		public static string CURRENT { get {return "CURRENT";} }
		public static string WAVE { get {return "WAVE";} }
		public static string RAIN { get {return "RAIN";} }
		public static string BRAKES { get {return "BRAKES";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcActionSourceTypeEnum(string value) { return new IfcActionSourceTypeEnum(string);}
		public static implicit operator string(IfcActionSourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcActionTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcActionTypeEnum = ENUMERATION OF</para>
	/// <para>	(PERMANENT_G</para>
	/// <para>	,VARIABLE_Q</para>
	/// <para>	,EXTRAORDINARY_A</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcActionTypeEnum
	{
		public static string PERMANENT_G { get {return "PERMANENT_G";} }
		public static string VARIABLE_Q { get {return "VARIABLE_Q";} }
		public static string EXTRAORDINARY_A { get {return "EXTRAORDINARY_A";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcActionTypeEnum(string value) { return new IfcActionTypeEnum(string);}
		public static implicit operator string(IfcActionTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcActuatorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcActuatorTypeEnum = ENUMERATION OF</para>
	/// <para>	(ELECTRICACTUATOR</para>
	/// <para>	,HANDOPERATEDACTUATOR</para>
	/// <para>	,HYDRAULICACTUATOR</para>
	/// <para>	,PNEUMATICACTUATOR</para>
	/// <para>	,THERMOSTATICACTUATOR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcActuatorTypeEnum
	{
		public static string ELECTRICACTUATOR { get {return "ELECTRICACTUATOR";} }
		public static string HANDOPERATEDACTUATOR { get {return "HANDOPERATEDACTUATOR";} }
		public static string HYDRAULICACTUATOR { get {return "HYDRAULICACTUATOR";} }
		public static string PNEUMATICACTUATOR { get {return "PNEUMATICACTUATOR";} }
		public static string THERMOSTATICACTUATOR { get {return "THERMOSTATICACTUATOR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcActuatorTypeEnum(string value) { return new IfcActuatorTypeEnum(string);}
		public static implicit operator string(IfcActuatorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAddressTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAddressTypeEnum = ENUMERATION OF</para>
	/// <para>	(OFFICE</para>
	/// <para>	,SITE</para>
	/// <para>	,HOME</para>
	/// <para>	,DISTRIBUTIONPOINT</para>
	/// <para>	,USERDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAddressTypeEnum
	{
		public static string OFFICE { get {return "OFFICE";} }
		public static string SITE { get {return "SITE";} }
		public static string HOME { get {return "HOME";} }
		public static string DISTRIBUTIONPOINT { get {return "DISTRIBUTIONPOINT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static implicit operator IfcAddressTypeEnum(string value) { return new IfcAddressTypeEnum(string);}
		public static implicit operator string(IfcAddressTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAirTerminalBoxTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAirTerminalBoxTypeEnum = ENUMERATION OF</para>
	/// <para>	(CONSTANTFLOW</para>
	/// <para>	,VARIABLEFLOWPRESSUREDEPENDANT</para>
	/// <para>	,VARIABLEFLOWPRESSUREINDEPENDANT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAirTerminalBoxTypeEnum
	{
		public static string CONSTANTFLOW { get {return "CONSTANTFLOW";} }
		public static string VARIABLEFLOWPRESSUREDEPENDANT { get {return "VARIABLEFLOWPRESSUREDEPENDANT";} }
		public static string VARIABLEFLOWPRESSUREINDEPENDANT { get {return "VARIABLEFLOWPRESSUREINDEPENDANT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcAirTerminalBoxTypeEnum(string value) { return new IfcAirTerminalBoxTypeEnum(string);}
		public static implicit operator string(IfcAirTerminalBoxTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAirTerminalTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAirTerminalTypeEnum = ENUMERATION OF</para>
	/// <para>	(DIFFUSER</para>
	/// <para>	,GRILLE</para>
	/// <para>	,LOUVRE</para>
	/// <para>	,REGISTER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAirTerminalTypeEnum
	{
		public static string DIFFUSER { get {return "DIFFUSER";} }
		public static string GRILLE { get {return "GRILLE";} }
		public static string LOUVRE { get {return "LOUVRE";} }
		public static string REGISTER { get {return "REGISTER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcAirTerminalTypeEnum(string value) { return new IfcAirTerminalTypeEnum(string);}
		public static implicit operator string(IfcAirTerminalTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAirToAirHeatRecoveryTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAirToAirHeatRecoveryTypeEnum = ENUMERATION OF</para>
	/// <para>	(FIXEDPLATECOUNTERFLOWEXCHANGER</para>
	/// <para>	,FIXEDPLATECROSSFLOWEXCHANGER</para>
	/// <para>	,FIXEDPLATEPARALLELFLOWEXCHANGER</para>
	/// <para>	,ROTARYWHEEL</para>
	/// <para>	,RUNAROUNDCOILLOOP</para>
	/// <para>	,HEATPIPE</para>
	/// <para>	,TWINTOWERENTHALPYRECOVERYLOOPS</para>
	/// <para>	,THERMOSIPHONSEALEDTUBEHEATEXCHANGERS</para>
	/// <para>	,THERMOSIPHONCOILTYPEHEATEXCHANGERS</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAirToAirHeatRecoveryTypeEnum
	{
		public static string FIXEDPLATECOUNTERFLOWEXCHANGER { get {return "FIXEDPLATECOUNTERFLOWEXCHANGER";} }
		public static string FIXEDPLATECROSSFLOWEXCHANGER { get {return "FIXEDPLATECROSSFLOWEXCHANGER";} }
		public static string FIXEDPLATEPARALLELFLOWEXCHANGER { get {return "FIXEDPLATEPARALLELFLOWEXCHANGER";} }
		public static string ROTARYWHEEL { get {return "ROTARYWHEEL";} }
		public static string RUNAROUNDCOILLOOP { get {return "RUNAROUNDCOILLOOP";} }
		public static string HEATPIPE { get {return "HEATPIPE";} }
		public static string TWINTOWERENTHALPYRECOVERYLOOPS { get {return "TWINTOWERENTHALPYRECOVERYLOOPS";} }
		public static string THERMOSIPHONSEALEDTUBEHEATEXCHANGERS { get {return "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS";} }
		public static string THERMOSIPHONCOILTYPEHEATEXCHANGERS { get {return "THERMOSIPHONCOILTYPEHEATEXCHANGERS";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcAirToAirHeatRecoveryTypeEnum(string value) { return new IfcAirToAirHeatRecoveryTypeEnum(string);}
		public static implicit operator string(IfcAirToAirHeatRecoveryTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAlarmTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAlarmTypeEnum = ENUMERATION OF</para>
	/// <para>	(BELL</para>
	/// <para>	,BREAKGLASSBUTTON</para>
	/// <para>	,LIGHT</para>
	/// <para>	,MANUALPULLBOX</para>
	/// <para>	,SIREN</para>
	/// <para>	,WHISTLE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAlarmTypeEnum
	{
		public static string BELL { get {return "BELL";} }
		public static string BREAKGLASSBUTTON { get {return "BREAKGLASSBUTTON";} }
		public static string LIGHT { get {return "LIGHT";} }
		public static string MANUALPULLBOX { get {return "MANUALPULLBOX";} }
		public static string SIREN { get {return "SIREN";} }
		public static string WHISTLE { get {return "WHISTLE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcAlarmTypeEnum(string value) { return new IfcAlarmTypeEnum(string);}
		public static implicit operator string(IfcAlarmTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAnalysisModelTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAnalysisModelTypeEnum = ENUMERATION OF</para>
	/// <para>	(IN_PLANE_LOADING_2D</para>
	/// <para>	,OUT_PLANE_LOADING_2D</para>
	/// <para>	,LOADING_3D</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAnalysisModelTypeEnum
	{
		public static string IN_PLANE_LOADING_2D { get {return "IN_PLANE_LOADING_2D";} }
		public static string OUT_PLANE_LOADING_2D { get {return "OUT_PLANE_LOADING_2D";} }
		public static string LOADING_3D { get {return "LOADING_3D";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcAnalysisModelTypeEnum(string value) { return new IfcAnalysisModelTypeEnum(string);}
		public static implicit operator string(IfcAnalysisModelTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAnalysisTheoryTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAnalysisTheoryTypeEnum = ENUMERATION OF</para>
	/// <para>	(FIRST_ORDER_THEORY</para>
	/// <para>	,SECOND_ORDER_THEORY</para>
	/// <para>	,THIRD_ORDER_THEORY</para>
	/// <para>	,FULL_NONLINEAR_THEORY</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAnalysisTheoryTypeEnum
	{
		public static string FIRST_ORDER_THEORY { get {return "FIRST_ORDER_THEORY";} }
		public static string SECOND_ORDER_THEORY { get {return "SECOND_ORDER_THEORY";} }
		public static string THIRD_ORDER_THEORY { get {return "THIRD_ORDER_THEORY";} }
		public static string FULL_NONLINEAR_THEORY { get {return "FULL_NONLINEAR_THEORY";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcAnalysisTheoryTypeEnum(string value) { return new IfcAnalysisTheoryTypeEnum(string);}
		public static implicit operator string(IfcAnalysisTheoryTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcArithmeticOperatorEnum = ENUMERATION OF
	/// <para>TYPE IfcArithmeticOperatorEnum = ENUMERATION OF</para>
	/// <para>	(ADD</para>
	/// <para>	,DIVIDE</para>
	/// <para>	,MULTIPLY</para>
	/// <para>	,SUBTRACT);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcArithmeticOperatorEnum
	{
		public static string ADD { get {return "ADD";} }
		public static string DIVIDE { get {return "DIVIDE";} }
		public static string MULTIPLY { get {return "MULTIPLY";} }
		public static string SUBTRACT { get {return "SUBTRACT";} }
		public static implicit operator IfcArithmeticOperatorEnum(string value) { return new IfcArithmeticOperatorEnum(string);}
		public static implicit operator string(IfcArithmeticOperatorEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAssemblyPlaceEnum = ENUMERATION OF
	/// <para>TYPE IfcAssemblyPlaceEnum = ENUMERATION OF</para>
	/// <para>	(SITE</para>
	/// <para>	,FACTORY</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAssemblyPlaceEnum
	{
		public static string SITE { get {return "SITE";} }
		public static string FACTORY { get {return "FACTORY";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcAssemblyPlaceEnum(string value) { return new IfcAssemblyPlaceEnum(string);}
		public static implicit operator string(IfcAssemblyPlaceEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAudioVisualApplianceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAudioVisualApplianceTypeEnum = ENUMERATION OF</para>
	/// <para>	(AMPLIFIER</para>
	/// <para>	,CAMERA</para>
	/// <para>	,DISPLAY</para>
	/// <para>	,MICROPHONE</para>
	/// <para>	,PLAYER</para>
	/// <para>	,PROJECTOR</para>
	/// <para>	,RECEIVER</para>
	/// <para>	,SPEAKER</para>
	/// <para>	,SWITCHER</para>
	/// <para>	,TELEPHONE</para>
	/// <para>	,TUNER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAudioVisualApplianceTypeEnum
	{
		public static string AMPLIFIER { get {return "AMPLIFIER";} }
		public static string CAMERA { get {return "CAMERA";} }
		public static string DISPLAY { get {return "DISPLAY";} }
		public static string MICROPHONE { get {return "MICROPHONE";} }
		public static string PLAYER { get {return "PLAYER";} }
		public static string PROJECTOR { get {return "PROJECTOR";} }
		public static string RECEIVER { get {return "RECEIVER";} }
		public static string SPEAKER { get {return "SPEAKER";} }
		public static string SWITCHER { get {return "SWITCHER";} }
		public static string TELEPHONE { get {return "TELEPHONE";} }
		public static string TUNER { get {return "TUNER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcAudioVisualApplianceTypeEnum(string value) { return new IfcAudioVisualApplianceTypeEnum(string);}
		public static implicit operator string(IfcAudioVisualApplianceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBSplineCurveForm = ENUMERATION OF
	/// <para>TYPE IfcBSplineCurveForm = ENUMERATION OF</para>
	/// <para>	(POLYLINE_FORM</para>
	/// <para>	,CIRCULAR_ARC</para>
	/// <para>	,ELLIPTIC_ARC</para>
	/// <para>	,PARABOLIC_ARC</para>
	/// <para>	,HYPERBOLIC_ARC</para>
	/// <para>	,UNSPECIFIED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBSplineCurveForm
	{
		public static string POLYLINE_FORM { get {return "POLYLINE_FORM";} }
		public static string CIRCULAR_ARC { get {return "CIRCULAR_ARC";} }
		public static string ELLIPTIC_ARC { get {return "ELLIPTIC_ARC";} }
		public static string PARABOLIC_ARC { get {return "PARABOLIC_ARC";} }
		public static string HYPERBOLIC_ARC { get {return "HYPERBOLIC_ARC";} }
		public static string UNSPECIFIED { get {return "UNSPECIFIED";} }
		public static implicit operator IfcBSplineCurveForm(string value) { return new IfcBSplineCurveForm(string);}
		public static implicit operator string(IfcBSplineCurveForm value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBSplineSurfaceForm = ENUMERATION OF
	/// <para>TYPE IfcBSplineSurfaceForm = ENUMERATION OF</para>
	/// <para>	(PLANE_SURF</para>
	/// <para>	,CYLINDRICAL_SURF</para>
	/// <para>	,CONICAL_SURF</para>
	/// <para>	,SPHERICAL_SURF</para>
	/// <para>	,TOROIDAL_SURF</para>
	/// <para>	,SURF_OF_REVOLUTION</para>
	/// <para>	,RULED_SURF</para>
	/// <para>	,GENERALISED_CONE</para>
	/// <para>	,QUADRIC_SURF</para>
	/// <para>	,SURF_OF_LINEAR_EXTRUSION</para>
	/// <para>	,UNSPECIFIED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBSplineSurfaceForm
	{
		public static string PLANE_SURF { get {return "PLANE_SURF";} }
		public static string CYLINDRICAL_SURF { get {return "CYLINDRICAL_SURF";} }
		public static string CONICAL_SURF { get {return "CONICAL_SURF";} }
		public static string SPHERICAL_SURF { get {return "SPHERICAL_SURF";} }
		public static string TOROIDAL_SURF { get {return "TOROIDAL_SURF";} }
		public static string SURF_OF_REVOLUTION { get {return "SURF_OF_REVOLUTION";} }
		public static string RULED_SURF { get {return "RULED_SURF";} }
		public static string GENERALISED_CONE { get {return "GENERALISED_CONE";} }
		public static string QUADRIC_SURF { get {return "QUADRIC_SURF";} }
		public static string SURF_OF_LINEAR_EXTRUSION { get {return "SURF_OF_LINEAR_EXTRUSION";} }
		public static string UNSPECIFIED { get {return "UNSPECIFIED";} }
		public static implicit operator IfcBSplineSurfaceForm(string value) { return new IfcBSplineSurfaceForm(string);}
		public static implicit operator string(IfcBSplineSurfaceForm value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBeamTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBeamTypeEnum = ENUMERATION OF</para>
	/// <para>	(BEAM</para>
	/// <para>	,JOIST</para>
	/// <para>	,HOLLOWCORE</para>
	/// <para>	,LINTEL</para>
	/// <para>	,SPANDREL</para>
	/// <para>	,T_BEAM</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBeamTypeEnum
	{
		public static string BEAM { get {return "BEAM";} }
		public static string JOIST { get {return "JOIST";} }
		public static string HOLLOWCORE { get {return "HOLLOWCORE";} }
		public static string LINTEL { get {return "LINTEL";} }
		public static string SPANDREL { get {return "SPANDREL";} }
		public static string T_BEAM { get {return "T_BEAM";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcBeamTypeEnum(string value) { return new IfcBeamTypeEnum(string);}
		public static implicit operator string(IfcBeamTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBenchmarkEnum = ENUMERATION OF
	/// <para>TYPE IfcBenchmarkEnum = ENUMERATION OF</para>
	/// <para>	(GREATERTHAN</para>
	/// <para>	,GREATERTHANOREQUALTO</para>
	/// <para>	,LESSTHAN</para>
	/// <para>	,LESSTHANOREQUALTO</para>
	/// <para>	,EQUALTO</para>
	/// <para>	,NOTEQUALTO</para>
	/// <para>	,INCLUDES</para>
	/// <para>	,NOTINCLUDES</para>
	/// <para>	,INCLUDEDIN</para>
	/// <para>	,NOTINCLUDEDIN);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBenchmarkEnum
	{
		public static string GREATERTHAN { get {return "GREATERTHAN";} }
		public static string GREATERTHANOREQUALTO { get {return "GREATERTHANOREQUALTO";} }
		public static string LESSTHAN { get {return "LESSTHAN";} }
		public static string LESSTHANOREQUALTO { get {return "LESSTHANOREQUALTO";} }
		public static string EQUALTO { get {return "EQUALTO";} }
		public static string NOTEQUALTO { get {return "NOTEQUALTO";} }
		public static string INCLUDES { get {return "INCLUDES";} }
		public static string NOTINCLUDES { get {return "NOTINCLUDES";} }
		public static string INCLUDEDIN { get {return "INCLUDEDIN";} }
		public static string NOTINCLUDEDIN { get {return "NOTINCLUDEDIN";} }
		public static implicit operator IfcBenchmarkEnum(string value) { return new IfcBenchmarkEnum(string);}
		public static implicit operator string(IfcBenchmarkEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBoilerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBoilerTypeEnum = ENUMERATION OF</para>
	/// <para>	(WATER</para>
	/// <para>	,STEAM</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBoilerTypeEnum
	{
		public static string WATER { get {return "WATER";} }
		public static string STEAM { get {return "STEAM";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcBoilerTypeEnum(string value) { return new IfcBoilerTypeEnum(string);}
		public static implicit operator string(IfcBoilerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBooleanOperator = ENUMERATION OF
	/// <para>TYPE IfcBooleanOperator = ENUMERATION OF</para>
	/// <para>	(UNION</para>
	/// <para>	,INTERSECTION</para>
	/// <para>	,DIFFERENCE);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBooleanOperator
	{
		public static string UNION { get {return "UNION";} }
		public static string INTERSECTION { get {return "INTERSECTION";} }
		public static string DIFFERENCE { get {return "DIFFERENCE";} }
		public static implicit operator IfcBooleanOperator(string value) { return new IfcBooleanOperator(string);}
		public static implicit operator string(IfcBooleanOperator value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBuildingElementPartTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBuildingElementPartTypeEnum = ENUMERATION OF</para>
	/// <para>	(INSULATION</para>
	/// <para>	,PRECASTPANEL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBuildingElementPartTypeEnum
	{
		public static string INSULATION { get {return "INSULATION";} }
		public static string PRECASTPANEL { get {return "PRECASTPANEL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcBuildingElementPartTypeEnum(string value) { return new IfcBuildingElementPartTypeEnum(string);}
		public static implicit operator string(IfcBuildingElementPartTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBuildingElementProxyTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBuildingElementProxyTypeEnum = ENUMERATION OF</para>
	/// <para>	(COMPLEX</para>
	/// <para>	,ELEMENT</para>
	/// <para>	,PARTIAL</para>
	/// <para>	,PROVISIONFORVOID</para>
	/// <para>	,PROVISIONFORSPACE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBuildingElementProxyTypeEnum
	{
		public static string COMPLEX { get {return "COMPLEX";} }
		public static string ELEMENT { get {return "ELEMENT";} }
		public static string PARTIAL { get {return "PARTIAL";} }
		public static string PROVISIONFORVOID { get {return "PROVISIONFORVOID";} }
		public static string PROVISIONFORSPACE { get {return "PROVISIONFORSPACE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcBuildingElementProxyTypeEnum(string value) { return new IfcBuildingElementProxyTypeEnum(string);}
		public static implicit operator string(IfcBuildingElementProxyTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBuildingSystemTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBuildingSystemTypeEnum = ENUMERATION OF</para>
	/// <para>	(FENESTRATION</para>
	/// <para>	,FOUNDATION</para>
	/// <para>	,LOADBEARING</para>
	/// <para>	,OUTERSHELL</para>
	/// <para>	,SHADING</para>
	/// <para>	,TRANSPORT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBuildingSystemTypeEnum
	{
		public static string FENESTRATION { get {return "FENESTRATION";} }
		public static string FOUNDATION { get {return "FOUNDATION";} }
		public static string LOADBEARING { get {return "LOADBEARING";} }
		public static string OUTERSHELL { get {return "OUTERSHELL";} }
		public static string SHADING { get {return "SHADING";} }
		public static string TRANSPORT { get {return "TRANSPORT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcBuildingSystemTypeEnum(string value) { return new IfcBuildingSystemTypeEnum(string);}
		public static implicit operator string(IfcBuildingSystemTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBurnerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBurnerTypeEnum = ENUMERATION OF</para>
	/// <para>	(USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBurnerTypeEnum
	{
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcBurnerTypeEnum(string value) { return new IfcBurnerTypeEnum(string);}
		public static implicit operator string(IfcBurnerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCableCarrierFittingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCableCarrierFittingTypeEnum = ENUMERATION OF</para>
	/// <para>	(BEND</para>
	/// <para>	,CROSS</para>
	/// <para>	,REDUCER</para>
	/// <para>	,TEE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCableCarrierFittingTypeEnum
	{
		public static string BEND { get {return "BEND";} }
		public static string CROSS { get {return "CROSS";} }
		public static string REDUCER { get {return "REDUCER";} }
		public static string TEE { get {return "TEE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCableCarrierFittingTypeEnum(string value) { return new IfcCableCarrierFittingTypeEnum(string);}
		public static implicit operator string(IfcCableCarrierFittingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCableCarrierSegmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCableCarrierSegmentTypeEnum = ENUMERATION OF</para>
	/// <para>	(CABLELADDERSEGMENT</para>
	/// <para>	,CABLETRAYSEGMENT</para>
	/// <para>	,CABLETRUNKINGSEGMENT</para>
	/// <para>	,CONDUITSEGMENT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCableCarrierSegmentTypeEnum
	{
		public static string CABLELADDERSEGMENT { get {return "CABLELADDERSEGMENT";} }
		public static string CABLETRAYSEGMENT { get {return "CABLETRAYSEGMENT";} }
		public static string CABLETRUNKINGSEGMENT { get {return "CABLETRUNKINGSEGMENT";} }
		public static string CONDUITSEGMENT { get {return "CONDUITSEGMENT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCableCarrierSegmentTypeEnum(string value) { return new IfcCableCarrierSegmentTypeEnum(string);}
		public static implicit operator string(IfcCableCarrierSegmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCableFittingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCableFittingTypeEnum = ENUMERATION OF</para>
	/// <para>	(CONNECTOR</para>
	/// <para>	,ENTRY</para>
	/// <para>	,EXIT</para>
	/// <para>	,JUNCTION</para>
	/// <para>	,TRANSITION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCableFittingTypeEnum
	{
		public static string CONNECTOR { get {return "CONNECTOR";} }
		public static string ENTRY { get {return "ENTRY";} }
		public static string EXIT { get {return "EXIT";} }
		public static string JUNCTION { get {return "JUNCTION";} }
		public static string TRANSITION { get {return "TRANSITION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCableFittingTypeEnum(string value) { return new IfcCableFittingTypeEnum(string);}
		public static implicit operator string(IfcCableFittingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCableSegmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCableSegmentTypeEnum = ENUMERATION OF</para>
	/// <para>	(BUSBARSEGMENT</para>
	/// <para>	,CABLESEGMENT</para>
	/// <para>	,CONDUCTORSEGMENT</para>
	/// <para>	,CORESEGMENT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCableSegmentTypeEnum
	{
		public static string BUSBARSEGMENT { get {return "BUSBARSEGMENT";} }
		public static string CABLESEGMENT { get {return "CABLESEGMENT";} }
		public static string CONDUCTORSEGMENT { get {return "CONDUCTORSEGMENT";} }
		public static string CORESEGMENT { get {return "CORESEGMENT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCableSegmentTypeEnum(string value) { return new IfcCableSegmentTypeEnum(string);}
		public static implicit operator string(IfcCableSegmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcChangeActionEnum = ENUMERATION OF
	/// <para>TYPE IfcChangeActionEnum = ENUMERATION OF</para>
	/// <para>	(NOCHANGE</para>
	/// <para>	,MODIFIED</para>
	/// <para>	,ADDED</para>
	/// <para>	,DELETED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcChangeActionEnum
	{
		public static string NOCHANGE { get {return "NOCHANGE";} }
		public static string MODIFIED { get {return "MODIFIED";} }
		public static string ADDED { get {return "ADDED";} }
		public static string DELETED { get {return "DELETED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcChangeActionEnum(string value) { return new IfcChangeActionEnum(string);}
		public static implicit operator string(IfcChangeActionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcChillerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcChillerTypeEnum = ENUMERATION OF</para>
	/// <para>	(AIRCOOLED</para>
	/// <para>	,WATERCOOLED</para>
	/// <para>	,HEATRECOVERY</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcChillerTypeEnum
	{
		public static string AIRCOOLED { get {return "AIRCOOLED";} }
		public static string WATERCOOLED { get {return "WATERCOOLED";} }
		public static string HEATRECOVERY { get {return "HEATRECOVERY";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcChillerTypeEnum(string value) { return new IfcChillerTypeEnum(string);}
		public static implicit operator string(IfcChillerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcChimneyTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcChimneyTypeEnum = ENUMERATION OF</para>
	/// <para>	(USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcChimneyTypeEnum
	{
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcChimneyTypeEnum(string value) { return new IfcChimneyTypeEnum(string);}
		public static implicit operator string(IfcChimneyTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCoilTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCoilTypeEnum = ENUMERATION OF</para>
	/// <para>	(DXCOOLINGCOIL</para>
	/// <para>	,ELECTRICHEATINGCOIL</para>
	/// <para>	,GASHEATINGCOIL</para>
	/// <para>	,HYDRONICCOIL</para>
	/// <para>	,STEAMHEATINGCOIL</para>
	/// <para>	,WATERCOOLINGCOIL</para>
	/// <para>	,WATERHEATINGCOIL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCoilTypeEnum
	{
		public static string DXCOOLINGCOIL { get {return "DXCOOLINGCOIL";} }
		public static string ELECTRICHEATINGCOIL { get {return "ELECTRICHEATINGCOIL";} }
		public static string GASHEATINGCOIL { get {return "GASHEATINGCOIL";} }
		public static string HYDRONICCOIL { get {return "HYDRONICCOIL";} }
		public static string STEAMHEATINGCOIL { get {return "STEAMHEATINGCOIL";} }
		public static string WATERCOOLINGCOIL { get {return "WATERCOOLINGCOIL";} }
		public static string WATERHEATINGCOIL { get {return "WATERHEATINGCOIL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCoilTypeEnum(string value) { return new IfcCoilTypeEnum(string);}
		public static implicit operator string(IfcCoilTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcColumnTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcColumnTypeEnum = ENUMERATION OF</para>
	/// <para>	(COLUMN</para>
	/// <para>	,PILASTER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcColumnTypeEnum
	{
		public static string COLUMN { get {return "COLUMN";} }
		public static string PILASTER { get {return "PILASTER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcColumnTypeEnum(string value) { return new IfcColumnTypeEnum(string);}
		public static implicit operator string(IfcColumnTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCommunicationsApplianceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCommunicationsApplianceTypeEnum = ENUMERATION OF</para>
	/// <para>	(ANTENNA</para>
	/// <para>	,COMPUTER</para>
	/// <para>	,FAX</para>
	/// <para>	,GATEWAY</para>
	/// <para>	,MODEM</para>
	/// <para>	,NETWORKAPPLIANCE</para>
	/// <para>	,NETWORKBRIDGE</para>
	/// <para>	,NETWORKHUB</para>
	/// <para>	,PRINTER</para>
	/// <para>	,REPEATER</para>
	/// <para>	,ROUTER</para>
	/// <para>	,SCANNER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCommunicationsApplianceTypeEnum
	{
		public static string ANTENNA { get {return "ANTENNA";} }
		public static string COMPUTER { get {return "COMPUTER";} }
		public static string FAX { get {return "FAX";} }
		public static string GATEWAY { get {return "GATEWAY";} }
		public static string MODEM { get {return "MODEM";} }
		public static string NETWORKAPPLIANCE { get {return "NETWORKAPPLIANCE";} }
		public static string NETWORKBRIDGE { get {return "NETWORKBRIDGE";} }
		public static string NETWORKHUB { get {return "NETWORKHUB";} }
		public static string PRINTER { get {return "PRINTER";} }
		public static string REPEATER { get {return "REPEATER";} }
		public static string ROUTER { get {return "ROUTER";} }
		public static string SCANNER { get {return "SCANNER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCommunicationsApplianceTypeEnum(string value) { return new IfcCommunicationsApplianceTypeEnum(string);}
		public static implicit operator string(IfcCommunicationsApplianceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcComplexPropertyTemplateTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcComplexPropertyTemplateTypeEnum = ENUMERATION OF</para>
	/// <para>	(P_COMPLEX</para>
	/// <para>	,Q_COMPLEX);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcComplexPropertyTemplateTypeEnum
	{
		public static string P_COMPLEX { get {return "P_COMPLEX";} }
		public static string Q_COMPLEX { get {return "Q_COMPLEX";} }
		public static implicit operator IfcComplexPropertyTemplateTypeEnum(string value) { return new IfcComplexPropertyTemplateTypeEnum(string);}
		public static implicit operator string(IfcComplexPropertyTemplateTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCompressorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCompressorTypeEnum = ENUMERATION OF</para>
	/// <para>	(DYNAMIC</para>
	/// <para>	,RECIPROCATING</para>
	/// <para>	,ROTARY</para>
	/// <para>	,SCROLL</para>
	/// <para>	,TROCHOIDAL</para>
	/// <para>	,SINGLESTAGE</para>
	/// <para>	,BOOSTER</para>
	/// <para>	,OPENTYPE</para>
	/// <para>	,HERMETIC</para>
	/// <para>	,SEMIHERMETIC</para>
	/// <para>	,WELDEDSHELLHERMETIC</para>
	/// <para>	,ROLLINGPISTON</para>
	/// <para>	,ROTARYVANE</para>
	/// <para>	,SINGLESCREW</para>
	/// <para>	,TWINSCREW</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCompressorTypeEnum
	{
		public static string DYNAMIC { get {return "DYNAMIC";} }
		public static string RECIPROCATING { get {return "RECIPROCATING";} }
		public static string ROTARY { get {return "ROTARY";} }
		public static string SCROLL { get {return "SCROLL";} }
		public static string TROCHOIDAL { get {return "TROCHOIDAL";} }
		public static string SINGLESTAGE { get {return "SINGLESTAGE";} }
		public static string BOOSTER { get {return "BOOSTER";} }
		public static string OPENTYPE { get {return "OPENTYPE";} }
		public static string HERMETIC { get {return "HERMETIC";} }
		public static string SEMIHERMETIC { get {return "SEMIHERMETIC";} }
		public static string WELDEDSHELLHERMETIC { get {return "WELDEDSHELLHERMETIC";} }
		public static string ROLLINGPISTON { get {return "ROLLINGPISTON";} }
		public static string ROTARYVANE { get {return "ROTARYVANE";} }
		public static string SINGLESCREW { get {return "SINGLESCREW";} }
		public static string TWINSCREW { get {return "TWINSCREW";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCompressorTypeEnum(string value) { return new IfcCompressorTypeEnum(string);}
		public static implicit operator string(IfcCompressorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCondenserTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCondenserTypeEnum = ENUMERATION OF</para>
	/// <para>	(AIRCOOLED</para>
	/// <para>	,EVAPORATIVECOOLED</para>
	/// <para>	,WATERCOOLED</para>
	/// <para>	,WATERCOOLEDBRAZEDPLATE</para>
	/// <para>	,WATERCOOLEDSHELLCOIL</para>
	/// <para>	,WATERCOOLEDSHELLTUBE</para>
	/// <para>	,WATERCOOLEDTUBEINTUBE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCondenserTypeEnum
	{
		public static string AIRCOOLED { get {return "AIRCOOLED";} }
		public static string EVAPORATIVECOOLED { get {return "EVAPORATIVECOOLED";} }
		public static string WATERCOOLED { get {return "WATERCOOLED";} }
		public static string WATERCOOLEDBRAZEDPLATE { get {return "WATERCOOLEDBRAZEDPLATE";} }
		public static string WATERCOOLEDSHELLCOIL { get {return "WATERCOOLEDSHELLCOIL";} }
		public static string WATERCOOLEDSHELLTUBE { get {return "WATERCOOLEDSHELLTUBE";} }
		public static string WATERCOOLEDTUBEINTUBE { get {return "WATERCOOLEDTUBEINTUBE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCondenserTypeEnum(string value) { return new IfcCondenserTypeEnum(string);}
		public static implicit operator string(IfcCondenserTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcConnectionTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcConnectionTypeEnum = ENUMERATION OF</para>
	/// <para>	(ATPATH</para>
	/// <para>	,ATSTART</para>
	/// <para>	,ATEND</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcConnectionTypeEnum
	{
		public static string ATPATH { get {return "ATPATH";} }
		public static string ATSTART { get {return "ATSTART";} }
		public static string ATEND { get {return "ATEND";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcConnectionTypeEnum(string value) { return new IfcConnectionTypeEnum(string);}
		public static implicit operator string(IfcConnectionTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcConstraintEnum = ENUMERATION OF
	/// <para>TYPE IfcConstraintEnum = ENUMERATION OF</para>
	/// <para>	(HARD</para>
	/// <para>	,SOFT</para>
	/// <para>	,ADVISORY</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcConstraintEnum
	{
		public static string HARD { get {return "HARD";} }
		public static string SOFT { get {return "SOFT";} }
		public static string ADVISORY { get {return "ADVISORY";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcConstraintEnum(string value) { return new IfcConstraintEnum(string);}
		public static implicit operator string(IfcConstraintEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcConstructionEquipmentResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcConstructionEquipmentResourceTypeEnum = ENUMERATION OF</para>
	/// <para>	(DEMOLISHING</para>
	/// <para>	,EARTHMOVING</para>
	/// <para>	,ERECTING</para>
	/// <para>	,HEATING</para>
	/// <para>	,LIGHTING</para>
	/// <para>	,PAVING</para>
	/// <para>	,PUMPING</para>
	/// <para>	,TRANSPORTING</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcConstructionEquipmentResourceTypeEnum
	{
		public static string DEMOLISHING { get {return "DEMOLISHING";} }
		public static string EARTHMOVING { get {return "EARTHMOVING";} }
		public static string ERECTING { get {return "ERECTING";} }
		public static string HEATING { get {return "HEATING";} }
		public static string LIGHTING { get {return "LIGHTING";} }
		public static string PAVING { get {return "PAVING";} }
		public static string PUMPING { get {return "PUMPING";} }
		public static string TRANSPORTING { get {return "TRANSPORTING";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcConstructionEquipmentResourceTypeEnum(string value) { return new IfcConstructionEquipmentResourceTypeEnum(string);}
		public static implicit operator string(IfcConstructionEquipmentResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcConstructionMaterialResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcConstructionMaterialResourceTypeEnum = ENUMERATION OF</para>
	/// <para>	(AGGREGATES</para>
	/// <para>	,CONCRETE</para>
	/// <para>	,DRYWALL</para>
	/// <para>	,FUEL</para>
	/// <para>	,GYPSUM</para>
	/// <para>	,MASONRY</para>
	/// <para>	,METAL</para>
	/// <para>	,PLASTIC</para>
	/// <para>	,WOOD</para>
	/// <para>	,NOTDEFINED</para>
	/// <para>	,USERDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcConstructionMaterialResourceTypeEnum
	{
		public static string AGGREGATES { get {return "AGGREGATES";} }
		public static string CONCRETE { get {return "CONCRETE";} }
		public static string DRYWALL { get {return "DRYWALL";} }
		public static string FUEL { get {return "FUEL";} }
		public static string GYPSUM { get {return "GYPSUM";} }
		public static string MASONRY { get {return "MASONRY";} }
		public static string METAL { get {return "METAL";} }
		public static string PLASTIC { get {return "PLASTIC";} }
		public static string WOOD { get {return "WOOD";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static implicit operator IfcConstructionMaterialResourceTypeEnum(string value) { return new IfcConstructionMaterialResourceTypeEnum(string);}
		public static implicit operator string(IfcConstructionMaterialResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcConstructionProductResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcConstructionProductResourceTypeEnum = ENUMERATION OF</para>
	/// <para>	(ASSEMBLY</para>
	/// <para>	,FORMWORK</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcConstructionProductResourceTypeEnum
	{
		public static string ASSEMBLY { get {return "ASSEMBLY";} }
		public static string FORMWORK { get {return "FORMWORK";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcConstructionProductResourceTypeEnum(string value) { return new IfcConstructionProductResourceTypeEnum(string);}
		public static implicit operator string(IfcConstructionProductResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcControllerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcControllerTypeEnum = ENUMERATION OF</para>
	/// <para>	(FLOATING</para>
	/// <para>	,PROGRAMMABLE</para>
	/// <para>	,PROPORTIONAL</para>
	/// <para>	,MULTIPOSITION</para>
	/// <para>	,TWOPOSITION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcControllerTypeEnum
	{
		public static string FLOATING { get {return "FLOATING";} }
		public static string PROGRAMMABLE { get {return "PROGRAMMABLE";} }
		public static string PROPORTIONAL { get {return "PROPORTIONAL";} }
		public static string MULTIPOSITION { get {return "MULTIPOSITION";} }
		public static string TWOPOSITION { get {return "TWOPOSITION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcControllerTypeEnum(string value) { return new IfcControllerTypeEnum(string);}
		public static implicit operator string(IfcControllerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCooledBeamTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCooledBeamTypeEnum = ENUMERATION OF</para>
	/// <para>	(ACTIVE</para>
	/// <para>	,PASSIVE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCooledBeamTypeEnum
	{
		public static string ACTIVE { get {return "ACTIVE";} }
		public static string PASSIVE { get {return "PASSIVE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCooledBeamTypeEnum(string value) { return new IfcCooledBeamTypeEnum(string);}
		public static implicit operator string(IfcCooledBeamTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCoolingTowerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCoolingTowerTypeEnum = ENUMERATION OF</para>
	/// <para>	(NATURALDRAFT</para>
	/// <para>	,MECHANICALINDUCEDDRAFT</para>
	/// <para>	,MECHANICALFORCEDDRAFT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCoolingTowerTypeEnum
	{
		public static string NATURALDRAFT { get {return "NATURALDRAFT";} }
		public static string MECHANICALINDUCEDDRAFT { get {return "MECHANICALINDUCEDDRAFT";} }
		public static string MECHANICALFORCEDDRAFT { get {return "MECHANICALFORCEDDRAFT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCoolingTowerTypeEnum(string value) { return new IfcCoolingTowerTypeEnum(string);}
		public static implicit operator string(IfcCoolingTowerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCostItemTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCostItemTypeEnum = ENUMERATION OF</para>
	/// <para>	(USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCostItemTypeEnum
	{
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCostItemTypeEnum(string value) { return new IfcCostItemTypeEnum(string);}
		public static implicit operator string(IfcCostItemTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCostScheduleTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCostScheduleTypeEnum = ENUMERATION OF</para>
	/// <para>	(BUDGET</para>
	/// <para>	,COSTPLAN</para>
	/// <para>	,ESTIMATE</para>
	/// <para>	,TENDER</para>
	/// <para>	,PRICEDBILLOFQUANTITIES</para>
	/// <para>	,UNPRICEDBILLOFQUANTITIES</para>
	/// <para>	,SCHEDULEOFRATES</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCostScheduleTypeEnum
	{
		public static string BUDGET { get {return "BUDGET";} }
		public static string COSTPLAN { get {return "COSTPLAN";} }
		public static string ESTIMATE { get {return "ESTIMATE";} }
		public static string TENDER { get {return "TENDER";} }
		public static string PRICEDBILLOFQUANTITIES { get {return "PRICEDBILLOFQUANTITIES";} }
		public static string UNPRICEDBILLOFQUANTITIES { get {return "UNPRICEDBILLOFQUANTITIES";} }
		public static string SCHEDULEOFRATES { get {return "SCHEDULEOFRATES";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCostScheduleTypeEnum(string value) { return new IfcCostScheduleTypeEnum(string);}
		public static implicit operator string(IfcCostScheduleTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCoveringTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCoveringTypeEnum = ENUMERATION OF</para>
	/// <para>	(CEILING</para>
	/// <para>	,FLOORING</para>
	/// <para>	,CLADDING</para>
	/// <para>	,ROOFING</para>
	/// <para>	,MOLDING</para>
	/// <para>	,SKIRTINGBOARD</para>
	/// <para>	,INSULATION</para>
	/// <para>	,MEMBRANE</para>
	/// <para>	,SLEEVING</para>
	/// <para>	,WRAPPING</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCoveringTypeEnum
	{
		public static string CEILING { get {return "CEILING";} }
		public static string FLOORING { get {return "FLOORING";} }
		public static string CLADDING { get {return "CLADDING";} }
		public static string ROOFING { get {return "ROOFING";} }
		public static string MOLDING { get {return "MOLDING";} }
		public static string SKIRTINGBOARD { get {return "SKIRTINGBOARD";} }
		public static string INSULATION { get {return "INSULATION";} }
		public static string MEMBRANE { get {return "MEMBRANE";} }
		public static string SLEEVING { get {return "SLEEVING";} }
		public static string WRAPPING { get {return "WRAPPING";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCoveringTypeEnum(string value) { return new IfcCoveringTypeEnum(string);}
		public static implicit operator string(IfcCoveringTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCrewResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCrewResourceTypeEnum = ENUMERATION OF</para>
	/// <para>	(OFFICE</para>
	/// <para>	,SITE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCrewResourceTypeEnum
	{
		public static string OFFICE { get {return "OFFICE";} }
		public static string SITE { get {return "SITE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCrewResourceTypeEnum(string value) { return new IfcCrewResourceTypeEnum(string);}
		public static implicit operator string(IfcCrewResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCurtainWallTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCurtainWallTypeEnum = ENUMERATION OF</para>
	/// <para>	(USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCurtainWallTypeEnum
	{
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCurtainWallTypeEnum(string value) { return new IfcCurtainWallTypeEnum(string);}
		public static implicit operator string(IfcCurtainWallTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCurveInterpolationEnum = ENUMERATION OF
	/// <para>TYPE IfcCurveInterpolationEnum = ENUMERATION OF</para>
	/// <para>	(LINEAR</para>
	/// <para>	,LOG_LINEAR</para>
	/// <para>	,LOG_LOG</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCurveInterpolationEnum
	{
		public static string LINEAR { get {return "LINEAR";} }
		public static string LOG_LINEAR { get {return "LOG_LINEAR";} }
		public static string LOG_LOG { get {return "LOG_LOG";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcCurveInterpolationEnum(string value) { return new IfcCurveInterpolationEnum(string);}
		public static implicit operator string(IfcCurveInterpolationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDamperTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDamperTypeEnum = ENUMERATION OF</para>
	/// <para>	(BACKDRAFTDAMPER</para>
	/// <para>	,BALANCINGDAMPER</para>
	/// <para>	,BLASTDAMPER</para>
	/// <para>	,CONTROLDAMPER</para>
	/// <para>	,FIREDAMPER</para>
	/// <para>	,FIRESMOKEDAMPER</para>
	/// <para>	,FUMEHOODEXHAUST</para>
	/// <para>	,GRAVITYDAMPER</para>
	/// <para>	,GRAVITYRELIEFDAMPER</para>
	/// <para>	,RELIEFDAMPER</para>
	/// <para>	,SMOKEDAMPER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDamperTypeEnum
	{
		public static string BACKDRAFTDAMPER { get {return "BACKDRAFTDAMPER";} }
		public static string BALANCINGDAMPER { get {return "BALANCINGDAMPER";} }
		public static string BLASTDAMPER { get {return "BLASTDAMPER";} }
		public static string CONTROLDAMPER { get {return "CONTROLDAMPER";} }
		public static string FIREDAMPER { get {return "FIREDAMPER";} }
		public static string FIRESMOKEDAMPER { get {return "FIRESMOKEDAMPER";} }
		public static string FUMEHOODEXHAUST { get {return "FUMEHOODEXHAUST";} }
		public static string GRAVITYDAMPER { get {return "GRAVITYDAMPER";} }
		public static string GRAVITYRELIEFDAMPER { get {return "GRAVITYRELIEFDAMPER";} }
		public static string RELIEFDAMPER { get {return "RELIEFDAMPER";} }
		public static string SMOKEDAMPER { get {return "SMOKEDAMPER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDamperTypeEnum(string value) { return new IfcDamperTypeEnum(string);}
		public static implicit operator string(IfcDamperTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDataOriginEnum = ENUMERATION OF
	/// <para>TYPE IfcDataOriginEnum = ENUMERATION OF</para>
	/// <para>	(MEASURED</para>
	/// <para>	,PREDICTED</para>
	/// <para>	,SIMULATED</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDataOriginEnum
	{
		public static string MEASURED { get {return "MEASURED";} }
		public static string PREDICTED { get {return "PREDICTED";} }
		public static string SIMULATED { get {return "SIMULATED";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDataOriginEnum(string value) { return new IfcDataOriginEnum(string);}
		public static implicit operator string(IfcDataOriginEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDerivedUnitEnum = ENUMERATION OF
	/// <para>TYPE IfcDerivedUnitEnum = ENUMERATION OF</para>
	/// <para>	(ANGULARVELOCITYUNIT</para>
	/// <para>	,AREADENSITYUNIT</para>
	/// <para>	,COMPOUNDPLANEANGLEUNIT</para>
	/// <para>	,DYNAMICVISCOSITYUNIT</para>
	/// <para>	,HEATFLUXDENSITYUNIT</para>
	/// <para>	,INTEGERCOUNTRATEUNIT</para>
	/// <para>	,ISOTHERMALMOISTURECAPACITYUNIT</para>
	/// <para>	,KINEMATICVISCOSITYUNIT</para>
	/// <para>	,LINEARVELOCITYUNIT</para>
	/// <para>	,MASSDENSITYUNIT</para>
	/// <para>	,MASSFLOWRATEUNIT</para>
	/// <para>	,MOISTUREDIFFUSIVITYUNIT</para>
	/// <para>	,MOLECULARWEIGHTUNIT</para>
	/// <para>	,SPECIFICHEATCAPACITYUNIT</para>
	/// <para>	,THERMALADMITTANCEUNIT</para>
	/// <para>	,THERMALCONDUCTANCEUNIT</para>
	/// <para>	,THERMALRESISTANCEUNIT</para>
	/// <para>	,THERMALTRANSMITTANCEUNIT</para>
	/// <para>	,VAPORPERMEABILITYUNIT</para>
	/// <para>	,VOLUMETRICFLOWRATEUNIT</para>
	/// <para>	,ROTATIONALFREQUENCYUNIT</para>
	/// <para>	,TORQUEUNIT</para>
	/// <para>	,MOMENTOFINERTIAUNIT</para>
	/// <para>	,LINEARMOMENTUNIT</para>
	/// <para>	,LINEARFORCEUNIT</para>
	/// <para>	,PLANARFORCEUNIT</para>
	/// <para>	,MODULUSOFELASTICITYUNIT</para>
	/// <para>	,SHEARMODULUSUNIT</para>
	/// <para>	,LINEARSTIFFNESSUNIT</para>
	/// <para>	,ROTATIONALSTIFFNESSUNIT</para>
	/// <para>	,MODULUSOFSUBGRADEREACTIONUNIT</para>
	/// <para>	,ACCELERATIONUNIT</para>
	/// <para>	,CURVATUREUNIT</para>
	/// <para>	,HEATINGVALUEUNIT</para>
	/// <para>	,IONCONCENTRATIONUNIT</para>
	/// <para>	,LUMINOUSINTENSITYDISTRIBUTIONUNIT</para>
	/// <para>	,MASSPERLENGTHUNIT</para>
	/// <para>	,MODULUSOFLINEARSUBGRADEREACTIONUNIT</para>
	/// <para>	,MODULUSOFROTATIONALSUBGRADEREACTIONUNIT</para>
	/// <para>	,PHUNIT</para>
	/// <para>	,ROTATIONALMASSUNIT</para>
	/// <para>	,SECTIONAREAINTEGRALUNIT</para>
	/// <para>	,SECTIONMODULUSUNIT</para>
	/// <para>	,SOUNDPOWERLEVELUNIT</para>
	/// <para>	,SOUNDPOWERUNIT</para>
	/// <para>	,SOUNDPRESSURELEVELUNIT</para>
	/// <para>	,SOUNDPRESSUREUNIT</para>
	/// <para>	,TEMPERATUREGRADIENTUNIT</para>
	/// <para>	,TEMPERATURERATEOFCHANGEUNIT</para>
	/// <para>	,THERMALEXPANSIONCOEFFICIENTUNIT</para>
	/// <para>	,WARPINGCONSTANTUNIT</para>
	/// <para>	,WARPINGMOMENTUNIT</para>
	/// <para>	,USERDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDerivedUnitEnum
	{
		public static string ANGULARVELOCITYUNIT { get {return "ANGULARVELOCITYUNIT";} }
		public static string AREADENSITYUNIT { get {return "AREADENSITYUNIT";} }
		public static string COMPOUNDPLANEANGLEUNIT { get {return "COMPOUNDPLANEANGLEUNIT";} }
		public static string DYNAMICVISCOSITYUNIT { get {return "DYNAMICVISCOSITYUNIT";} }
		public static string HEATFLUXDENSITYUNIT { get {return "HEATFLUXDENSITYUNIT";} }
		public static string INTEGERCOUNTRATEUNIT { get {return "INTEGERCOUNTRATEUNIT";} }
		public static string ISOTHERMALMOISTURECAPACITYUNIT { get {return "ISOTHERMALMOISTURECAPACITYUNIT";} }
		public static string KINEMATICVISCOSITYUNIT { get {return "KINEMATICVISCOSITYUNIT";} }
		public static string LINEARVELOCITYUNIT { get {return "LINEARVELOCITYUNIT";} }
		public static string MASSDENSITYUNIT { get {return "MASSDENSITYUNIT";} }
		public static string MASSFLOWRATEUNIT { get {return "MASSFLOWRATEUNIT";} }
		public static string MOISTUREDIFFUSIVITYUNIT { get {return "MOISTUREDIFFUSIVITYUNIT";} }
		public static string MOLECULARWEIGHTUNIT { get {return "MOLECULARWEIGHTUNIT";} }
		public static string SPECIFICHEATCAPACITYUNIT { get {return "SPECIFICHEATCAPACITYUNIT";} }
		public static string THERMALADMITTANCEUNIT { get {return "THERMALADMITTANCEUNIT";} }
		public static string THERMALCONDUCTANCEUNIT { get {return "THERMALCONDUCTANCEUNIT";} }
		public static string THERMALRESISTANCEUNIT { get {return "THERMALRESISTANCEUNIT";} }
		public static string THERMALTRANSMITTANCEUNIT { get {return "THERMALTRANSMITTANCEUNIT";} }
		public static string VAPORPERMEABILITYUNIT { get {return "VAPORPERMEABILITYUNIT";} }
		public static string VOLUMETRICFLOWRATEUNIT { get {return "VOLUMETRICFLOWRATEUNIT";} }
		public static string ROTATIONALFREQUENCYUNIT { get {return "ROTATIONALFREQUENCYUNIT";} }
		public static string TORQUEUNIT { get {return "TORQUEUNIT";} }
		public static string MOMENTOFINERTIAUNIT { get {return "MOMENTOFINERTIAUNIT";} }
		public static string LINEARMOMENTUNIT { get {return "LINEARMOMENTUNIT";} }
		public static string LINEARFORCEUNIT { get {return "LINEARFORCEUNIT";} }
		public static string PLANARFORCEUNIT { get {return "PLANARFORCEUNIT";} }
		public static string MODULUSOFELASTICITYUNIT { get {return "MODULUSOFELASTICITYUNIT";} }
		public static string SHEARMODULUSUNIT { get {return "SHEARMODULUSUNIT";} }
		public static string LINEARSTIFFNESSUNIT { get {return "LINEARSTIFFNESSUNIT";} }
		public static string ROTATIONALSTIFFNESSUNIT { get {return "ROTATIONALSTIFFNESSUNIT";} }
		public static string MODULUSOFSUBGRADEREACTIONUNIT { get {return "MODULUSOFSUBGRADEREACTIONUNIT";} }
		public static string ACCELERATIONUNIT { get {return "ACCELERATIONUNIT";} }
		public static string CURVATUREUNIT { get {return "CURVATUREUNIT";} }
		public static string HEATINGVALUEUNIT { get {return "HEATINGVALUEUNIT";} }
		public static string IONCONCENTRATIONUNIT { get {return "IONCONCENTRATIONUNIT";} }
		public static string LUMINOUSINTENSITYDISTRIBUTIONUNIT { get {return "LUMINOUSINTENSITYDISTRIBUTIONUNIT";} }
		public static string MASSPERLENGTHUNIT { get {return "MASSPERLENGTHUNIT";} }
		public static string MODULUSOFLINEARSUBGRADEREACTIONUNIT { get {return "MODULUSOFLINEARSUBGRADEREACTIONUNIT";} }
		public static string MODULUSOFROTATIONALSUBGRADEREACTIONUNIT { get {return "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT";} }
		public static string PHUNIT { get {return "PHUNIT";} }
		public static string ROTATIONALMASSUNIT { get {return "ROTATIONALMASSUNIT";} }
		public static string SECTIONAREAINTEGRALUNIT { get {return "SECTIONAREAINTEGRALUNIT";} }
		public static string SECTIONMODULUSUNIT { get {return "SECTIONMODULUSUNIT";} }
		public static string SOUNDPOWERLEVELUNIT { get {return "SOUNDPOWERLEVELUNIT";} }
		public static string SOUNDPOWERUNIT { get {return "SOUNDPOWERUNIT";} }
		public static string SOUNDPRESSURELEVELUNIT { get {return "SOUNDPRESSURELEVELUNIT";} }
		public static string SOUNDPRESSUREUNIT { get {return "SOUNDPRESSUREUNIT";} }
		public static string TEMPERATUREGRADIENTUNIT { get {return "TEMPERATUREGRADIENTUNIT";} }
		public static string TEMPERATURERATEOFCHANGEUNIT { get {return "TEMPERATURERATEOFCHANGEUNIT";} }
		public static string THERMALEXPANSIONCOEFFICIENTUNIT { get {return "THERMALEXPANSIONCOEFFICIENTUNIT";} }
		public static string WARPINGCONSTANTUNIT { get {return "WARPINGCONSTANTUNIT";} }
		public static string WARPINGMOMENTUNIT { get {return "WARPINGMOMENTUNIT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static implicit operator IfcDerivedUnitEnum(string value) { return new IfcDerivedUnitEnum(string);}
		public static implicit operator string(IfcDerivedUnitEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDirectionSenseEnum = ENUMERATION OF
	/// <para>TYPE IfcDirectionSenseEnum = ENUMERATION OF</para>
	/// <para>	(POSITIVE</para>
	/// <para>	,NEGATIVE);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDirectionSenseEnum
	{
		public static string POSITIVE { get {return "POSITIVE";} }
		public static string NEGATIVE { get {return "NEGATIVE";} }
		public static implicit operator IfcDirectionSenseEnum(string value) { return new IfcDirectionSenseEnum(string);}
		public static implicit operator string(IfcDirectionSenseEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDiscreteAccessoryTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDiscreteAccessoryTypeEnum = ENUMERATION OF</para>
	/// <para>	(ANCHORPLATE</para>
	/// <para>	,BRACKET</para>
	/// <para>	,SHOE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDiscreteAccessoryTypeEnum
	{
		public static string ANCHORPLATE { get {return "ANCHORPLATE";} }
		public static string BRACKET { get {return "BRACKET";} }
		public static string SHOE { get {return "SHOE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDiscreteAccessoryTypeEnum(string value) { return new IfcDiscreteAccessoryTypeEnum(string);}
		public static implicit operator string(IfcDiscreteAccessoryTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDistributionChamberElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDistributionChamberElementTypeEnum = ENUMERATION OF</para>
	/// <para>	(FORMEDDUCT</para>
	/// <para>	,INSPECTIONCHAMBER</para>
	/// <para>	,INSPECTIONPIT</para>
	/// <para>	,MANHOLE</para>
	/// <para>	,METERCHAMBER</para>
	/// <para>	,SUMP</para>
	/// <para>	,TRENCH</para>
	/// <para>	,VALVECHAMBER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDistributionChamberElementTypeEnum
	{
		public static string FORMEDDUCT { get {return "FORMEDDUCT";} }
		public static string INSPECTIONCHAMBER { get {return "INSPECTIONCHAMBER";} }
		public static string INSPECTIONPIT { get {return "INSPECTIONPIT";} }
		public static string MANHOLE { get {return "MANHOLE";} }
		public static string METERCHAMBER { get {return "METERCHAMBER";} }
		public static string SUMP { get {return "SUMP";} }
		public static string TRENCH { get {return "TRENCH";} }
		public static string VALVECHAMBER { get {return "VALVECHAMBER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDistributionChamberElementTypeEnum(string value) { return new IfcDistributionChamberElementTypeEnum(string);}
		public static implicit operator string(IfcDistributionChamberElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDistributionPortTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDistributionPortTypeEnum = ENUMERATION OF</para>
	/// <para>	(CABLE</para>
	/// <para>	,CABLECARRIER</para>
	/// <para>	,DUCT</para>
	/// <para>	,PIPE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDistributionPortTypeEnum
	{
		public static string CABLE { get {return "CABLE";} }
		public static string CABLECARRIER { get {return "CABLECARRIER";} }
		public static string DUCT { get {return "DUCT";} }
		public static string PIPE { get {return "PIPE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDistributionPortTypeEnum(string value) { return new IfcDistributionPortTypeEnum(string);}
		public static implicit operator string(IfcDistributionPortTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDistributionSystemEnum = ENUMERATION OF
	/// <para>TYPE IfcDistributionSystemEnum = ENUMERATION OF</para>
	/// <para>	(AIRCONDITIONING</para>
	/// <para>	,AUDIOVISUAL</para>
	/// <para>	,CHEMICAL</para>
	/// <para>	,CHILLEDWATER</para>
	/// <para>	,COMMUNICATION</para>
	/// <para>	,COMPRESSEDAIR</para>
	/// <para>	,CONDENSERWATER</para>
	/// <para>	,CONTROL</para>
	/// <para>	,CONVEYING</para>
	/// <para>	,DATA</para>
	/// <para>	,DISPOSAL</para>
	/// <para>	,DOMESTICCOLDWATER</para>
	/// <para>	,DOMESTICHOTWATER</para>
	/// <para>	,DRAINAGE</para>
	/// <para>	,EARTHING</para>
	/// <para>	,ELECTRICAL</para>
	/// <para>	,ELECTROACOUSTIC</para>
	/// <para>	,EXHAUST</para>
	/// <para>	,FIREPROTECTION</para>
	/// <para>	,FUEL</para>
	/// <para>	,GAS</para>
	/// <para>	,HAZARDOUS</para>
	/// <para>	,HEATING</para>
	/// <para>	,LIGHTING</para>
	/// <para>	,LIGHTNINGPROTECTION</para>
	/// <para>	,MUNICIPALSOLIDWASTE</para>
	/// <para>	,OIL</para>
	/// <para>	,OPERATIONAL</para>
	/// <para>	,POWERGENERATION</para>
	/// <para>	,RAINWATER</para>
	/// <para>	,REFRIGERATION</para>
	/// <para>	,SECURITY</para>
	/// <para>	,SEWAGE</para>
	/// <para>	,SIGNAL</para>
	/// <para>	,STORMWATER</para>
	/// <para>	,TELEPHONE</para>
	/// <para>	,TV</para>
	/// <para>	,VACUUM</para>
	/// <para>	,VENT</para>
	/// <para>	,VENTILATION</para>
	/// <para>	,WASTEWATER</para>
	/// <para>	,WATERSUPPLY</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDistributionSystemEnum
	{
		public static string AIRCONDITIONING { get {return "AIRCONDITIONING";} }
		public static string AUDIOVISUAL { get {return "AUDIOVISUAL";} }
		public static string CHEMICAL { get {return "CHEMICAL";} }
		public static string CHILLEDWATER { get {return "CHILLEDWATER";} }
		public static string COMMUNICATION { get {return "COMMUNICATION";} }
		public static string COMPRESSEDAIR { get {return "COMPRESSEDAIR";} }
		public static string CONDENSERWATER { get {return "CONDENSERWATER";} }
		public static string CONTROL { get {return "CONTROL";} }
		public static string CONVEYING { get {return "CONVEYING";} }
		public static string DATA { get {return "DATA";} }
		public static string DISPOSAL { get {return "DISPOSAL";} }
		public static string DOMESTICCOLDWATER { get {return "DOMESTICCOLDWATER";} }
		public static string DOMESTICHOTWATER { get {return "DOMESTICHOTWATER";} }
		public static string DRAINAGE { get {return "DRAINAGE";} }
		public static string EARTHING { get {return "EARTHING";} }
		public static string ELECTRICAL { get {return "ELECTRICAL";} }
		public static string ELECTROACOUSTIC { get {return "ELECTROACOUSTIC";} }
		public static string EXHAUST { get {return "EXHAUST";} }
		public static string FIREPROTECTION { get {return "FIREPROTECTION";} }
		public static string FUEL { get {return "FUEL";} }
		public static string GAS { get {return "GAS";} }
		public static string HAZARDOUS { get {return "HAZARDOUS";} }
		public static string HEATING { get {return "HEATING";} }
		public static string LIGHTING { get {return "LIGHTING";} }
		public static string LIGHTNINGPROTECTION { get {return "LIGHTNINGPROTECTION";} }
		public static string MUNICIPALSOLIDWASTE { get {return "MUNICIPALSOLIDWASTE";} }
		public static string OIL { get {return "OIL";} }
		public static string OPERATIONAL { get {return "OPERATIONAL";} }
		public static string POWERGENERATION { get {return "POWERGENERATION";} }
		public static string RAINWATER { get {return "RAINWATER";} }
		public static string REFRIGERATION { get {return "REFRIGERATION";} }
		public static string SECURITY { get {return "SECURITY";} }
		public static string SEWAGE { get {return "SEWAGE";} }
		public static string SIGNAL { get {return "SIGNAL";} }
		public static string STORMWATER { get {return "STORMWATER";} }
		public static string TELEPHONE { get {return "TELEPHONE";} }
		public static string TV { get {return "TV";} }
		public static string VACUUM { get {return "VACUUM";} }
		public static string VENT { get {return "VENT";} }
		public static string VENTILATION { get {return "VENTILATION";} }
		public static string WASTEWATER { get {return "WASTEWATER";} }
		public static string WATERSUPPLY { get {return "WATERSUPPLY";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDistributionSystemEnum(string value) { return new IfcDistributionSystemEnum(string);}
		public static implicit operator string(IfcDistributionSystemEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDocumentConfidentialityEnum = ENUMERATION OF
	/// <para>TYPE IfcDocumentConfidentialityEnum = ENUMERATION OF</para>
	/// <para>	(PUBLIC</para>
	/// <para>	,RESTRICTED</para>
	/// <para>	,CONFIDENTIAL</para>
	/// <para>	,PERSONAL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDocumentConfidentialityEnum
	{
		public static string PUBLIC { get {return "PUBLIC";} }
		public static string RESTRICTED { get {return "RESTRICTED";} }
		public static string CONFIDENTIAL { get {return "CONFIDENTIAL";} }
		public static string PERSONAL { get {return "PERSONAL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDocumentConfidentialityEnum(string value) { return new IfcDocumentConfidentialityEnum(string);}
		public static implicit operator string(IfcDocumentConfidentialityEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDocumentStatusEnum = ENUMERATION OF
	/// <para>TYPE IfcDocumentStatusEnum = ENUMERATION OF</para>
	/// <para>	(DRAFT</para>
	/// <para>	,FINALDRAFT</para>
	/// <para>	,FINAL</para>
	/// <para>	,REVISION</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDocumentStatusEnum
	{
		public static string DRAFT { get {return "DRAFT";} }
		public static string FINALDRAFT { get {return "FINALDRAFT";} }
		public static string FINAL { get {return "FINAL";} }
		public static string REVISION { get {return "REVISION";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDocumentStatusEnum(string value) { return new IfcDocumentStatusEnum(string);}
		public static implicit operator string(IfcDocumentStatusEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorPanelOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorPanelOperationEnum = ENUMERATION OF</para>
	/// <para>	(SWINGING</para>
	/// <para>	,DOUBLE_ACTING</para>
	/// <para>	,SLIDING</para>
	/// <para>	,FOLDING</para>
	/// <para>	,REVOLVING</para>
	/// <para>	,ROLLINGUP</para>
	/// <para>	,FIXEDPANEL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorPanelOperationEnum
	{
		public static string SWINGING { get {return "SWINGING";} }
		public static string DOUBLE_ACTING { get {return "DOUBLE_ACTING";} }
		public static string SLIDING { get {return "SLIDING";} }
		public static string FOLDING { get {return "FOLDING";} }
		public static string REVOLVING { get {return "REVOLVING";} }
		public static string ROLLINGUP { get {return "ROLLINGUP";} }
		public static string FIXEDPANEL { get {return "FIXEDPANEL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDoorPanelOperationEnum(string value) { return new IfcDoorPanelOperationEnum(string);}
		public static implicit operator string(IfcDoorPanelOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorPanelPositionEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorPanelPositionEnum = ENUMERATION OF</para>
	/// <para>	(LEFT</para>
	/// <para>	,MIDDLE</para>
	/// <para>	,RIGHT</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorPanelPositionEnum
	{
		public static string LEFT { get {return "LEFT";} }
		public static string MIDDLE { get {return "MIDDLE";} }
		public static string RIGHT { get {return "RIGHT";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDoorPanelPositionEnum(string value) { return new IfcDoorPanelPositionEnum(string);}
		public static implicit operator string(IfcDoorPanelPositionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorStyleConstructionEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorStyleConstructionEnum = ENUMERATION OF</para>
	/// <para>	(ALUMINIUM</para>
	/// <para>	,HIGH_GRADE_STEEL</para>
	/// <para>	,STEEL</para>
	/// <para>	,WOOD</para>
	/// <para>	,ALUMINIUM_WOOD</para>
	/// <para>	,ALUMINIUM_PLASTIC</para>
	/// <para>	,PLASTIC</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorStyleConstructionEnum
	{
		public static string ALUMINIUM { get {return "ALUMINIUM";} }
		public static string HIGH_GRADE_STEEL { get {return "HIGH_GRADE_STEEL";} }
		public static string STEEL { get {return "STEEL";} }
		public static string WOOD { get {return "WOOD";} }
		public static string ALUMINIUM_WOOD { get {return "ALUMINIUM_WOOD";} }
		public static string ALUMINIUM_PLASTIC { get {return "ALUMINIUM_PLASTIC";} }
		public static string PLASTIC { get {return "PLASTIC";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDoorStyleConstructionEnum(string value) { return new IfcDoorStyleConstructionEnum(string);}
		public static implicit operator string(IfcDoorStyleConstructionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorStyleOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorStyleOperationEnum = ENUMERATION OF</para>
	/// <para>	(SINGLE_SWING_LEFT</para>
	/// <para>	,SINGLE_SWING_RIGHT</para>
	/// <para>	,DOUBLE_DOOR_SINGLE_SWING</para>
	/// <para>	,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT</para>
	/// <para>	,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT</para>
	/// <para>	,DOUBLE_SWING_LEFT</para>
	/// <para>	,DOUBLE_SWING_RIGHT</para>
	/// <para>	,DOUBLE_DOOR_DOUBLE_SWING</para>
	/// <para>	,SLIDING_TO_LEFT</para>
	/// <para>	,SLIDING_TO_RIGHT</para>
	/// <para>	,DOUBLE_DOOR_SLIDING</para>
	/// <para>	,FOLDING_TO_LEFT</para>
	/// <para>	,FOLDING_TO_RIGHT</para>
	/// <para>	,DOUBLE_DOOR_FOLDING</para>
	/// <para>	,REVOLVING</para>
	/// <para>	,ROLLINGUP</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorStyleOperationEnum
	{
		public static string SINGLE_SWING_LEFT { get {return "SINGLE_SWING_LEFT";} }
		public static string SINGLE_SWING_RIGHT { get {return "SINGLE_SWING_RIGHT";} }
		public static string DOUBLE_DOOR_SINGLE_SWING { get {return "DOUBLE_DOOR_SINGLE_SWING";} }
		public static string DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT { get {return "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT";} }
		public static string DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT { get {return "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT";} }
		public static string DOUBLE_SWING_LEFT { get {return "DOUBLE_SWING_LEFT";} }
		public static string DOUBLE_SWING_RIGHT { get {return "DOUBLE_SWING_RIGHT";} }
		public static string DOUBLE_DOOR_DOUBLE_SWING { get {return "DOUBLE_DOOR_DOUBLE_SWING";} }
		public static string SLIDING_TO_LEFT { get {return "SLIDING_TO_LEFT";} }
		public static string SLIDING_TO_RIGHT { get {return "SLIDING_TO_RIGHT";} }
		public static string DOUBLE_DOOR_SLIDING { get {return "DOUBLE_DOOR_SLIDING";} }
		public static string FOLDING_TO_LEFT { get {return "FOLDING_TO_LEFT";} }
		public static string FOLDING_TO_RIGHT { get {return "FOLDING_TO_RIGHT";} }
		public static string DOUBLE_DOOR_FOLDING { get {return "DOUBLE_DOOR_FOLDING";} }
		public static string REVOLVING { get {return "REVOLVING";} }
		public static string ROLLINGUP { get {return "ROLLINGUP";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDoorStyleOperationEnum(string value) { return new IfcDoorStyleOperationEnum(string);}
		public static implicit operator string(IfcDoorStyleOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorTypeEnum = ENUMERATION OF</para>
	/// <para>	(DOOR</para>
	/// <para>	,GATE</para>
	/// <para>	,TRAPDOOR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorTypeEnum
	{
		public static string DOOR { get {return "DOOR";} }
		public static string GATE { get {return "GATE";} }
		public static string TRAPDOOR { get {return "TRAPDOOR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDoorTypeEnum(string value) { return new IfcDoorTypeEnum(string);}
		public static implicit operator string(IfcDoorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorTypeOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorTypeOperationEnum = ENUMERATION OF</para>
	/// <para>	(SINGLE_SWING_LEFT</para>
	/// <para>	,SINGLE_SWING_RIGHT</para>
	/// <para>	,DOUBLE_DOOR_SINGLE_SWING</para>
	/// <para>	,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT</para>
	/// <para>	,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT</para>
	/// <para>	,DOUBLE_SWING_LEFT</para>
	/// <para>	,DOUBLE_SWING_RIGHT</para>
	/// <para>	,DOUBLE_DOOR_DOUBLE_SWING</para>
	/// <para>	,SLIDING_TO_LEFT</para>
	/// <para>	,SLIDING_TO_RIGHT</para>
	/// <para>	,DOUBLE_DOOR_SLIDING</para>
	/// <para>	,FOLDING_TO_LEFT</para>
	/// <para>	,FOLDING_TO_RIGHT</para>
	/// <para>	,DOUBLE_DOOR_FOLDING</para>
	/// <para>	,REVOLVING</para>
	/// <para>	,ROLLINGUP</para>
	/// <para>	,SWING_FIXED_LEFT</para>
	/// <para>	,SWING_FIXED_RIGHT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorTypeOperationEnum
	{
		public static string SINGLE_SWING_LEFT { get {return "SINGLE_SWING_LEFT";} }
		public static string SINGLE_SWING_RIGHT { get {return "SINGLE_SWING_RIGHT";} }
		public static string DOUBLE_DOOR_SINGLE_SWING { get {return "DOUBLE_DOOR_SINGLE_SWING";} }
		public static string DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT { get {return "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT";} }
		public static string DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT { get {return "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT";} }
		public static string DOUBLE_SWING_LEFT { get {return "DOUBLE_SWING_LEFT";} }
		public static string DOUBLE_SWING_RIGHT { get {return "DOUBLE_SWING_RIGHT";} }
		public static string DOUBLE_DOOR_DOUBLE_SWING { get {return "DOUBLE_DOOR_DOUBLE_SWING";} }
		public static string SLIDING_TO_LEFT { get {return "SLIDING_TO_LEFT";} }
		public static string SLIDING_TO_RIGHT { get {return "SLIDING_TO_RIGHT";} }
		public static string DOUBLE_DOOR_SLIDING { get {return "DOUBLE_DOOR_SLIDING";} }
		public static string FOLDING_TO_LEFT { get {return "FOLDING_TO_LEFT";} }
		public static string FOLDING_TO_RIGHT { get {return "FOLDING_TO_RIGHT";} }
		public static string DOUBLE_DOOR_FOLDING { get {return "DOUBLE_DOOR_FOLDING";} }
		public static string REVOLVING { get {return "REVOLVING";} }
		public static string ROLLINGUP { get {return "ROLLINGUP";} }
		public static string SWING_FIXED_LEFT { get {return "SWING_FIXED_LEFT";} }
		public static string SWING_FIXED_RIGHT { get {return "SWING_FIXED_RIGHT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDoorTypeOperationEnum(string value) { return new IfcDoorTypeOperationEnum(string);}
		public static implicit operator string(IfcDoorTypeOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDuctFittingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDuctFittingTypeEnum = ENUMERATION OF</para>
	/// <para>	(BEND</para>
	/// <para>	,CONNECTOR</para>
	/// <para>	,ENTRY</para>
	/// <para>	,EXIT</para>
	/// <para>	,JUNCTION</para>
	/// <para>	,OBSTRUCTION</para>
	/// <para>	,TRANSITION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDuctFittingTypeEnum
	{
		public static string BEND { get {return "BEND";} }
		public static string CONNECTOR { get {return "CONNECTOR";} }
		public static string ENTRY { get {return "ENTRY";} }
		public static string EXIT { get {return "EXIT";} }
		public static string JUNCTION { get {return "JUNCTION";} }
		public static string OBSTRUCTION { get {return "OBSTRUCTION";} }
		public static string TRANSITION { get {return "TRANSITION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDuctFittingTypeEnum(string value) { return new IfcDuctFittingTypeEnum(string);}
		public static implicit operator string(IfcDuctFittingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDuctSegmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDuctSegmentTypeEnum = ENUMERATION OF</para>
	/// <para>	(RIGIDSEGMENT</para>
	/// <para>	,FLEXIBLESEGMENT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDuctSegmentTypeEnum
	{
		public static string RIGIDSEGMENT { get {return "RIGIDSEGMENT";} }
		public static string FLEXIBLESEGMENT { get {return "FLEXIBLESEGMENT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDuctSegmentTypeEnum(string value) { return new IfcDuctSegmentTypeEnum(string);}
		public static implicit operator string(IfcDuctSegmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDuctSilencerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDuctSilencerTypeEnum = ENUMERATION OF</para>
	/// <para>	(FLATOVAL</para>
	/// <para>	,RECTANGULAR</para>
	/// <para>	,ROUND</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDuctSilencerTypeEnum
	{
		public static string FLATOVAL { get {return "FLATOVAL";} }
		public static string RECTANGULAR { get {return "RECTANGULAR";} }
		public static string ROUND { get {return "ROUND";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcDuctSilencerTypeEnum(string value) { return new IfcDuctSilencerTypeEnum(string);}
		public static implicit operator string(IfcDuctSilencerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricApplianceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricApplianceTypeEnum = ENUMERATION OF</para>
	/// <para>	(DISHWASHER</para>
	/// <para>	,ELECTRICCOOKER</para>
	/// <para>	,FREESTANDINGELECTRICHEATER</para>
	/// <para>	,FREESTANDINGFAN</para>
	/// <para>	,FREESTANDINGWATERHEATER</para>
	/// <para>	,FREESTANDINGWATERCOOLER</para>
	/// <para>	,FREEZER</para>
	/// <para>	,FRIDGE_FREEZER</para>
	/// <para>	,HANDDRYER</para>
	/// <para>	,KITCHENMACHINE</para>
	/// <para>	,MICROWAVE</para>
	/// <para>	,PHOTOCOPIER</para>
	/// <para>	,REFRIGERATOR</para>
	/// <para>	,TUMBLEDRYER</para>
	/// <para>	,VENDINGMACHINE</para>
	/// <para>	,WASHINGMACHINE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricApplianceTypeEnum
	{
		public static string DISHWASHER { get {return "DISHWASHER";} }
		public static string ELECTRICCOOKER { get {return "ELECTRICCOOKER";} }
		public static string FREESTANDINGELECTRICHEATER { get {return "FREESTANDINGELECTRICHEATER";} }
		public static string FREESTANDINGFAN { get {return "FREESTANDINGFAN";} }
		public static string FREESTANDINGWATERHEATER { get {return "FREESTANDINGWATERHEATER";} }
		public static string FREESTANDINGWATERCOOLER { get {return "FREESTANDINGWATERCOOLER";} }
		public static string FREEZER { get {return "FREEZER";} }
		public static string FRIDGE_FREEZER { get {return "FRIDGE_FREEZER";} }
		public static string HANDDRYER { get {return "HANDDRYER";} }
		public static string KITCHENMACHINE { get {return "KITCHENMACHINE";} }
		public static string MICROWAVE { get {return "MICROWAVE";} }
		public static string PHOTOCOPIER { get {return "PHOTOCOPIER";} }
		public static string REFRIGERATOR { get {return "REFRIGERATOR";} }
		public static string TUMBLEDRYER { get {return "TUMBLEDRYER";} }
		public static string VENDINGMACHINE { get {return "VENDINGMACHINE";} }
		public static string WASHINGMACHINE { get {return "WASHINGMACHINE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcElectricApplianceTypeEnum(string value) { return new IfcElectricApplianceTypeEnum(string);}
		public static implicit operator string(IfcElectricApplianceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricDistributionBoardTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricDistributionBoardTypeEnum = ENUMERATION OF</para>
	/// <para>	(CONSUMERUNIT</para>
	/// <para>	,DISTRIBUTIONBOARD</para>
	/// <para>	,MOTORCONTROLCENTRE</para>
	/// <para>	,SWITCHBOARD</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricDistributionBoardTypeEnum
	{
		public static string CONSUMERUNIT { get {return "CONSUMERUNIT";} }
		public static string DISTRIBUTIONBOARD { get {return "DISTRIBUTIONBOARD";} }
		public static string MOTORCONTROLCENTRE { get {return "MOTORCONTROLCENTRE";} }
		public static string SWITCHBOARD { get {return "SWITCHBOARD";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcElectricDistributionBoardTypeEnum(string value) { return new IfcElectricDistributionBoardTypeEnum(string);}
		public static implicit operator string(IfcElectricDistributionBoardTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricFlowStorageDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricFlowStorageDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>	(BATTERY</para>
	/// <para>	,CAPACITORBANK</para>
	/// <para>	,HARMONICFILTER</para>
	/// <para>	,INDUCTORBANK</para>
	/// <para>	,UPS</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricFlowStorageDeviceTypeEnum
	{
		public static string BATTERY { get {return "BATTERY";} }
		public static string CAPACITORBANK { get {return "CAPACITORBANK";} }
		public static string HARMONICFILTER { get {return "HARMONICFILTER";} }
		public static string INDUCTORBANK { get {return "INDUCTORBANK";} }
		public static string UPS { get {return "UPS";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcElectricFlowStorageDeviceTypeEnum(string value) { return new IfcElectricFlowStorageDeviceTypeEnum(string);}
		public static implicit operator string(IfcElectricFlowStorageDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricGeneratorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricGeneratorTypeEnum = ENUMERATION OF</para>
	/// <para>	(CHP</para>
	/// <para>	,ENGINEGENERATOR</para>
	/// <para>	,STANDALONE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricGeneratorTypeEnum
	{
		public static string CHP { get {return "CHP";} }
		public static string ENGINEGENERATOR { get {return "ENGINEGENERATOR";} }
		public static string STANDALONE { get {return "STANDALONE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcElectricGeneratorTypeEnum(string value) { return new IfcElectricGeneratorTypeEnum(string);}
		public static implicit operator string(IfcElectricGeneratorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricMotorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricMotorTypeEnum = ENUMERATION OF</para>
	/// <para>	(DC</para>
	/// <para>	,INDUCTION</para>
	/// <para>	,POLYPHASE</para>
	/// <para>	,RELUCTANCESYNCHRONOUS</para>
	/// <para>	,SYNCHRONOUS</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricMotorTypeEnum
	{
		public static string DC { get {return "DC";} }
		public static string INDUCTION { get {return "INDUCTION";} }
		public static string POLYPHASE { get {return "POLYPHASE";} }
		public static string RELUCTANCESYNCHRONOUS { get {return "RELUCTANCESYNCHRONOUS";} }
		public static string SYNCHRONOUS { get {return "SYNCHRONOUS";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcElectricMotorTypeEnum(string value) { return new IfcElectricMotorTypeEnum(string);}
		public static implicit operator string(IfcElectricMotorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricTimeControlTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricTimeControlTypeEnum = ENUMERATION OF</para>
	/// <para>	(TIMECLOCK</para>
	/// <para>	,TIMEDELAY</para>
	/// <para>	,RELAY</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricTimeControlTypeEnum
	{
		public static string TIMECLOCK { get {return "TIMECLOCK";} }
		public static string TIMEDELAY { get {return "TIMEDELAY";} }
		public static string RELAY { get {return "RELAY";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcElectricTimeControlTypeEnum(string value) { return new IfcElectricTimeControlTypeEnum(string);}
		public static implicit operator string(IfcElectricTimeControlTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElementAssemblyTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElementAssemblyTypeEnum = ENUMERATION OF</para>
	/// <para>	(ACCESSORY_ASSEMBLY</para>
	/// <para>	,ARCH</para>
	/// <para>	,BEAM_GRID</para>
	/// <para>	,BRACED_FRAME</para>
	/// <para>	,GIRDER</para>
	/// <para>	,REINFORCEMENT_UNIT</para>
	/// <para>	,RIGID_FRAME</para>
	/// <para>	,SLAB_FIELD</para>
	/// <para>	,TRUSS</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElementAssemblyTypeEnum
	{
		public static string ACCESSORY_ASSEMBLY { get {return "ACCESSORY_ASSEMBLY";} }
		public static string ARCH { get {return "ARCH";} }
		public static string BEAM_GRID { get {return "BEAM_GRID";} }
		public static string BRACED_FRAME { get {return "BRACED_FRAME";} }
		public static string GIRDER { get {return "GIRDER";} }
		public static string REINFORCEMENT_UNIT { get {return "REINFORCEMENT_UNIT";} }
		public static string RIGID_FRAME { get {return "RIGID_FRAME";} }
		public static string SLAB_FIELD { get {return "SLAB_FIELD";} }
		public static string TRUSS { get {return "TRUSS";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcElementAssemblyTypeEnum(string value) { return new IfcElementAssemblyTypeEnum(string);}
		public static implicit operator string(IfcElementAssemblyTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElementCompositionEnum = ENUMERATION OF
	/// <para>TYPE IfcElementCompositionEnum = ENUMERATION OF</para>
	/// <para>	(COMPLEX</para>
	/// <para>	,ELEMENT</para>
	/// <para>	,PARTIAL);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElementCompositionEnum
	{
		public static string COMPLEX { get {return "COMPLEX";} }
		public static string ELEMENT { get {return "ELEMENT";} }
		public static string PARTIAL { get {return "PARTIAL";} }
		public static implicit operator IfcElementCompositionEnum(string value) { return new IfcElementCompositionEnum(string);}
		public static implicit operator string(IfcElementCompositionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEngineTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcEngineTypeEnum = ENUMERATION OF</para>
	/// <para>	(EXTERNALCOMBUSTION</para>
	/// <para>	,INTERNALCOMBUSTION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEngineTypeEnum
	{
		public static string EXTERNALCOMBUSTION { get {return "EXTERNALCOMBUSTION";} }
		public static string INTERNALCOMBUSTION { get {return "INTERNALCOMBUSTION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcEngineTypeEnum(string value) { return new IfcEngineTypeEnum(string);}
		public static implicit operator string(IfcEngineTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEvaporativeCoolerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcEvaporativeCoolerTypeEnum = ENUMERATION OF</para>
	/// <para>	(DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER</para>
	/// <para>	,DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER</para>
	/// <para>	,DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER</para>
	/// <para>	,DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER</para>
	/// <para>	,DIRECTEVAPORATIVEAIRWASHER</para>
	/// <para>	,INDIRECTEVAPORATIVEPACKAGEAIRCOOLER</para>
	/// <para>	,INDIRECTEVAPORATIVEWETCOIL</para>
	/// <para>	,INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER</para>
	/// <para>	,INDIRECTDIRECTCOMBINATION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEvaporativeCoolerTypeEnum
	{
		public static string DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER { get {return "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER";} }
		public static string DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER { get {return "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER";} }
		public static string DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER { get {return "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER";} }
		public static string DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER { get {return "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER";} }
		public static string DIRECTEVAPORATIVEAIRWASHER { get {return "DIRECTEVAPORATIVEAIRWASHER";} }
		public static string INDIRECTEVAPORATIVEPACKAGEAIRCOOLER { get {return "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER";} }
		public static string INDIRECTEVAPORATIVEWETCOIL { get {return "INDIRECTEVAPORATIVEWETCOIL";} }
		public static string INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER { get {return "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER";} }
		public static string INDIRECTDIRECTCOMBINATION { get {return "INDIRECTDIRECTCOMBINATION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcEvaporativeCoolerTypeEnum(string value) { return new IfcEvaporativeCoolerTypeEnum(string);}
		public static implicit operator string(IfcEvaporativeCoolerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEvaporatorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcEvaporatorTypeEnum = ENUMERATION OF</para>
	/// <para>	(DIRECTEXPANSION</para>
	/// <para>	,DIRECTEXPANSIONSHELLANDTUBE</para>
	/// <para>	,DIRECTEXPANSIONTUBEINTUBE</para>
	/// <para>	,DIRECTEXPANSIONBRAZEDPLATE</para>
	/// <para>	,FLOODEDSHELLANDTUBE</para>
	/// <para>	,SHELLANDCOIL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEvaporatorTypeEnum
	{
		public static string DIRECTEXPANSION { get {return "DIRECTEXPANSION";} }
		public static string DIRECTEXPANSIONSHELLANDTUBE { get {return "DIRECTEXPANSIONSHELLANDTUBE";} }
		public static string DIRECTEXPANSIONTUBEINTUBE { get {return "DIRECTEXPANSIONTUBEINTUBE";} }
		public static string DIRECTEXPANSIONBRAZEDPLATE { get {return "DIRECTEXPANSIONBRAZEDPLATE";} }
		public static string FLOODEDSHELLANDTUBE { get {return "FLOODEDSHELLANDTUBE";} }
		public static string SHELLANDCOIL { get {return "SHELLANDCOIL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcEvaporatorTypeEnum(string value) { return new IfcEvaporatorTypeEnum(string);}
		public static implicit operator string(IfcEvaporatorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEventTriggerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcEventTriggerTypeEnum = ENUMERATION OF</para>
	/// <para>	(EVENTRULE</para>
	/// <para>	,EVENTMESSAGE</para>
	/// <para>	,EVENTTIME</para>
	/// <para>	,EVENTCOMPLEX</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEventTriggerTypeEnum
	{
		public static string EVENTRULE { get {return "EVENTRULE";} }
		public static string EVENTMESSAGE { get {return "EVENTMESSAGE";} }
		public static string EVENTTIME { get {return "EVENTTIME";} }
		public static string EVENTCOMPLEX { get {return "EVENTCOMPLEX";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcEventTriggerTypeEnum(string value) { return new IfcEventTriggerTypeEnum(string);}
		public static implicit operator string(IfcEventTriggerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEventTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcEventTypeEnum = ENUMERATION OF</para>
	/// <para>	(STARTEVENT</para>
	/// <para>	,ENDEVENT</para>
	/// <para>	,INTERMEDIATEEVENT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEventTypeEnum
	{
		public static string STARTEVENT { get {return "STARTEVENT";} }
		public static string ENDEVENT { get {return "ENDEVENT";} }
		public static string INTERMEDIATEEVENT { get {return "INTERMEDIATEEVENT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcEventTypeEnum(string value) { return new IfcEventTypeEnum(string);}
		public static implicit operator string(IfcEventTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcExternalSpatialElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcExternalSpatialElementTypeEnum = ENUMERATION OF</para>
	/// <para>	(EXTERNAL</para>
	/// <para>	,EXTERNAL_EARTH</para>
	/// <para>	,EXTERNAL_WATER</para>
	/// <para>	,EXTERNAL_FIRE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcExternalSpatialElementTypeEnum
	{
		public static string EXTERNAL { get {return "EXTERNAL";} }
		public static string EXTERNAL_EARTH { get {return "EXTERNAL_EARTH";} }
		public static string EXTERNAL_WATER { get {return "EXTERNAL_WATER";} }
		public static string EXTERNAL_FIRE { get {return "EXTERNAL_FIRE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcExternalSpatialElementTypeEnum(string value) { return new IfcExternalSpatialElementTypeEnum(string);}
		public static implicit operator string(IfcExternalSpatialElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFanTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFanTypeEnum = ENUMERATION OF</para>
	/// <para>	(CENTRIFUGALFORWARDCURVED</para>
	/// <para>	,CENTRIFUGALRADIAL</para>
	/// <para>	,CENTRIFUGALBACKWARDINCLINEDCURVED</para>
	/// <para>	,CENTRIFUGALAIRFOIL</para>
	/// <para>	,TUBEAXIAL</para>
	/// <para>	,VANEAXIAL</para>
	/// <para>	,PROPELLORAXIAL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFanTypeEnum
	{
		public static string CENTRIFUGALFORWARDCURVED { get {return "CENTRIFUGALFORWARDCURVED";} }
		public static string CENTRIFUGALRADIAL { get {return "CENTRIFUGALRADIAL";} }
		public static string CENTRIFUGALBACKWARDINCLINEDCURVED { get {return "CENTRIFUGALBACKWARDINCLINEDCURVED";} }
		public static string CENTRIFUGALAIRFOIL { get {return "CENTRIFUGALAIRFOIL";} }
		public static string TUBEAXIAL { get {return "TUBEAXIAL";} }
		public static string VANEAXIAL { get {return "VANEAXIAL";} }
		public static string PROPELLORAXIAL { get {return "PROPELLORAXIAL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcFanTypeEnum(string value) { return new IfcFanTypeEnum(string);}
		public static implicit operator string(IfcFanTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFastenerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFastenerTypeEnum = ENUMERATION OF</para>
	/// <para>	(GLUE</para>
	/// <para>	,MORTAR</para>
	/// <para>	,WELD</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFastenerTypeEnum
	{
		public static string GLUE { get {return "GLUE";} }
		public static string MORTAR { get {return "MORTAR";} }
		public static string WELD { get {return "WELD";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcFastenerTypeEnum(string value) { return new IfcFastenerTypeEnum(string);}
		public static implicit operator string(IfcFastenerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFilterTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFilterTypeEnum = ENUMERATION OF</para>
	/// <para>	(AIRPARTICLEFILTER</para>
	/// <para>	,COMPRESSEDAIRFILTER</para>
	/// <para>	,ODORFILTER</para>
	/// <para>	,OILFILTER</para>
	/// <para>	,STRAINER</para>
	/// <para>	,WATERFILTER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFilterTypeEnum
	{
		public static string AIRPARTICLEFILTER { get {return "AIRPARTICLEFILTER";} }
		public static string COMPRESSEDAIRFILTER { get {return "COMPRESSEDAIRFILTER";} }
		public static string ODORFILTER { get {return "ODORFILTER";} }
		public static string OILFILTER { get {return "OILFILTER";} }
		public static string STRAINER { get {return "STRAINER";} }
		public static string WATERFILTER { get {return "WATERFILTER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcFilterTypeEnum(string value) { return new IfcFilterTypeEnum(string);}
		public static implicit operator string(IfcFilterTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFireSuppressionTerminalTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFireSuppressionTerminalTypeEnum = ENUMERATION OF</para>
	/// <para>	(BREECHINGINLET</para>
	/// <para>	,FIREHYDRANT</para>
	/// <para>	,HOSEREEL</para>
	/// <para>	,SPRINKLER</para>
	/// <para>	,SPRINKLERDEFLECTOR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFireSuppressionTerminalTypeEnum
	{
		public static string BREECHINGINLET { get {return "BREECHINGINLET";} }
		public static string FIREHYDRANT { get {return "FIREHYDRANT";} }
		public static string HOSEREEL { get {return "HOSEREEL";} }
		public static string SPRINKLER { get {return "SPRINKLER";} }
		public static string SPRINKLERDEFLECTOR { get {return "SPRINKLERDEFLECTOR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcFireSuppressionTerminalTypeEnum(string value) { return new IfcFireSuppressionTerminalTypeEnum(string);}
		public static implicit operator string(IfcFireSuppressionTerminalTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFlowDirectionEnum = ENUMERATION OF
	/// <para>TYPE IfcFlowDirectionEnum = ENUMERATION OF</para>
	/// <para>	(SOURCE</para>
	/// <para>	,SINK</para>
	/// <para>	,SOURCEANDSINK</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFlowDirectionEnum
	{
		public static string SOURCE { get {return "SOURCE";} }
		public static string SINK { get {return "SINK";} }
		public static string SOURCEANDSINK { get {return "SOURCEANDSINK";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcFlowDirectionEnum(string value) { return new IfcFlowDirectionEnum(string);}
		public static implicit operator string(IfcFlowDirectionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFlowInstrumentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFlowInstrumentTypeEnum = ENUMERATION OF</para>
	/// <para>	(PRESSUREGAUGE</para>
	/// <para>	,THERMOMETER</para>
	/// <para>	,AMMETER</para>
	/// <para>	,FREQUENCYMETER</para>
	/// <para>	,POWERFACTORMETER</para>
	/// <para>	,PHASEANGLEMETER</para>
	/// <para>	,VOLTMETER_PEAK</para>
	/// <para>	,VOLTMETER_RMS</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFlowInstrumentTypeEnum
	{
		public static string PRESSUREGAUGE { get {return "PRESSUREGAUGE";} }
		public static string THERMOMETER { get {return "THERMOMETER";} }
		public static string AMMETER { get {return "AMMETER";} }
		public static string FREQUENCYMETER { get {return "FREQUENCYMETER";} }
		public static string POWERFACTORMETER { get {return "POWERFACTORMETER";} }
		public static string PHASEANGLEMETER { get {return "PHASEANGLEMETER";} }
		public static string VOLTMETER_PEAK { get {return "VOLTMETER_PEAK";} }
		public static string VOLTMETER_RMS { get {return "VOLTMETER_RMS";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcFlowInstrumentTypeEnum(string value) { return new IfcFlowInstrumentTypeEnum(string);}
		public static implicit operator string(IfcFlowInstrumentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFlowMeterTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFlowMeterTypeEnum = ENUMERATION OF</para>
	/// <para>	(ENERGYMETER</para>
	/// <para>	,GASMETER</para>
	/// <para>	,OILMETER</para>
	/// <para>	,WATERMETER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFlowMeterTypeEnum
	{
		public static string ENERGYMETER { get {return "ENERGYMETER";} }
		public static string GASMETER { get {return "GASMETER";} }
		public static string OILMETER { get {return "OILMETER";} }
		public static string WATERMETER { get {return "WATERMETER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcFlowMeterTypeEnum(string value) { return new IfcFlowMeterTypeEnum(string);}
		public static implicit operator string(IfcFlowMeterTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFootingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFootingTypeEnum = ENUMERATION OF</para>
	/// <para>	(CAISSON_FOUNDATION</para>
	/// <para>	,FOOTING_BEAM</para>
	/// <para>	,PAD_FOOTING</para>
	/// <para>	,PILE_CAP</para>
	/// <para>	,STRIP_FOOTING</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFootingTypeEnum
	{
		public static string CAISSON_FOUNDATION { get {return "CAISSON_FOUNDATION";} }
		public static string FOOTING_BEAM { get {return "FOOTING_BEAM";} }
		public static string PAD_FOOTING { get {return "PAD_FOOTING";} }
		public static string PILE_CAP { get {return "PILE_CAP";} }
		public static string STRIP_FOOTING { get {return "STRIP_FOOTING";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcFootingTypeEnum(string value) { return new IfcFootingTypeEnum(string);}
		public static implicit operator string(IfcFootingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFurnitureTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFurnitureTypeEnum = ENUMERATION OF</para>
	/// <para>	(CHAIR</para>
	/// <para>	,TABLE</para>
	/// <para>	,DESK</para>
	/// <para>	,BED</para>
	/// <para>	,FILECABINET</para>
	/// <para>	,SHELF</para>
	/// <para>	,SOFA</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFurnitureTypeEnum
	{
		public static string CHAIR { get {return "CHAIR";} }
		public static string TABLE { get {return "TABLE";} }
		public static string DESK { get {return "DESK";} }
		public static string BED { get {return "BED";} }
		public static string FILECABINET { get {return "FILECABINET";} }
		public static string SHELF { get {return "SHELF";} }
		public static string SOFA { get {return "SOFA";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcFurnitureTypeEnum(string value) { return new IfcFurnitureTypeEnum(string);}
		public static implicit operator string(IfcFurnitureTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGeographicElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcGeographicElementTypeEnum = ENUMERATION OF</para>
	/// <para>	(TERRAIN</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGeographicElementTypeEnum
	{
		public static string TERRAIN { get {return "TERRAIN";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcGeographicElementTypeEnum(string value) { return new IfcGeographicElementTypeEnum(string);}
		public static implicit operator string(IfcGeographicElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGeometricProjectionEnum = ENUMERATION OF
	/// <para>TYPE IfcGeometricProjectionEnum = ENUMERATION OF</para>
	/// <para>	(GRAPH_VIEW</para>
	/// <para>	,SKETCH_VIEW</para>
	/// <para>	,MODEL_VIEW</para>
	/// <para>	,PLAN_VIEW</para>
	/// <para>	,REFLECTED_PLAN_VIEW</para>
	/// <para>	,SECTION_VIEW</para>
	/// <para>	,ELEVATION_VIEW</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGeometricProjectionEnum
	{
		public static string GRAPH_VIEW { get {return "GRAPH_VIEW";} }
		public static string SKETCH_VIEW { get {return "SKETCH_VIEW";} }
		public static string MODEL_VIEW { get {return "MODEL_VIEW";} }
		public static string PLAN_VIEW { get {return "PLAN_VIEW";} }
		public static string REFLECTED_PLAN_VIEW { get {return "REFLECTED_PLAN_VIEW";} }
		public static string SECTION_VIEW { get {return "SECTION_VIEW";} }
		public static string ELEVATION_VIEW { get {return "ELEVATION_VIEW";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcGeometricProjectionEnum(string value) { return new IfcGeometricProjectionEnum(string);}
		public static implicit operator string(IfcGeometricProjectionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGlobalOrLocalEnum = ENUMERATION OF
	/// <para>TYPE IfcGlobalOrLocalEnum = ENUMERATION OF</para>
	/// <para>	(GLOBAL_COORDS</para>
	/// <para>	,LOCAL_COORDS);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGlobalOrLocalEnum
	{
		public static string GLOBAL_COORDS { get {return "GLOBAL_COORDS";} }
		public static string LOCAL_COORDS { get {return "LOCAL_COORDS";} }
		public static implicit operator IfcGlobalOrLocalEnum(string value) { return new IfcGlobalOrLocalEnum(string);}
		public static implicit operator string(IfcGlobalOrLocalEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGridTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcGridTypeEnum = ENUMERATION OF</para>
	/// <para>	(RECTANGULAR</para>
	/// <para>	,RADIAL</para>
	/// <para>	,TRIANGULAR</para>
	/// <para>	,IRREGULAR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGridTypeEnum
	{
		public static string RECTANGULAR { get {return "RECTANGULAR";} }
		public static string RADIAL { get {return "RADIAL";} }
		public static string TRIANGULAR { get {return "TRIANGULAR";} }
		public static string IRREGULAR { get {return "IRREGULAR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcGridTypeEnum(string value) { return new IfcGridTypeEnum(string);}
		public static implicit operator string(IfcGridTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcHeatExchangerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcHeatExchangerTypeEnum = ENUMERATION OF</para>
	/// <para>	(PLATE</para>
	/// <para>	,SHELLANDTUBE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcHeatExchangerTypeEnum
	{
		public static string PLATE { get {return "PLATE";} }
		public static string SHELLANDTUBE { get {return "SHELLANDTUBE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcHeatExchangerTypeEnum(string value) { return new IfcHeatExchangerTypeEnum(string);}
		public static implicit operator string(IfcHeatExchangerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcHumidifierTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcHumidifierTypeEnum = ENUMERATION OF</para>
	/// <para>	(STEAMINJECTION</para>
	/// <para>	,ADIABATICAIRWASHER</para>
	/// <para>	,ADIABATICPAN</para>
	/// <para>	,ADIABATICWETTEDELEMENT</para>
	/// <para>	,ADIABATICATOMIZING</para>
	/// <para>	,ADIABATICULTRASONIC</para>
	/// <para>	,ADIABATICRIGIDMEDIA</para>
	/// <para>	,ADIABATICCOMPRESSEDAIRNOZZLE</para>
	/// <para>	,ASSISTEDELECTRIC</para>
	/// <para>	,ASSISTEDNATURALGAS</para>
	/// <para>	,ASSISTEDPROPANE</para>
	/// <para>	,ASSISTEDBUTANE</para>
	/// <para>	,ASSISTEDSTEAM</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcHumidifierTypeEnum
	{
		public static string STEAMINJECTION { get {return "STEAMINJECTION";} }
		public static string ADIABATICAIRWASHER { get {return "ADIABATICAIRWASHER";} }
		public static string ADIABATICPAN { get {return "ADIABATICPAN";} }
		public static string ADIABATICWETTEDELEMENT { get {return "ADIABATICWETTEDELEMENT";} }
		public static string ADIABATICATOMIZING { get {return "ADIABATICATOMIZING";} }
		public static string ADIABATICULTRASONIC { get {return "ADIABATICULTRASONIC";} }
		public static string ADIABATICRIGIDMEDIA { get {return "ADIABATICRIGIDMEDIA";} }
		public static string ADIABATICCOMPRESSEDAIRNOZZLE { get {return "ADIABATICCOMPRESSEDAIRNOZZLE";} }
		public static string ASSISTEDELECTRIC { get {return "ASSISTEDELECTRIC";} }
		public static string ASSISTEDNATURALGAS { get {return "ASSISTEDNATURALGAS";} }
		public static string ASSISTEDPROPANE { get {return "ASSISTEDPROPANE";} }
		public static string ASSISTEDBUTANE { get {return "ASSISTEDBUTANE";} }
		public static string ASSISTEDSTEAM { get {return "ASSISTEDSTEAM";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcHumidifierTypeEnum(string value) { return new IfcHumidifierTypeEnum(string);}
		public static implicit operator string(IfcHumidifierTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInterceptorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcInterceptorTypeEnum = ENUMERATION OF</para>
	/// <para>	(CYCLONIC</para>
	/// <para>	,GREASE</para>
	/// <para>	,OIL</para>
	/// <para>	,PETROL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInterceptorTypeEnum
	{
		public static string CYCLONIC { get {return "CYCLONIC";} }
		public static string GREASE { get {return "GREASE";} }
		public static string OIL { get {return "OIL";} }
		public static string PETROL { get {return "PETROL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcInterceptorTypeEnum(string value) { return new IfcInterceptorTypeEnum(string);}
		public static implicit operator string(IfcInterceptorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInternalOrExternalEnum = ENUMERATION OF
	/// <para>TYPE IfcInternalOrExternalEnum = ENUMERATION OF</para>
	/// <para>	(INTERNAL</para>
	/// <para>	,EXTERNAL</para>
	/// <para>	,EXTERNAL_EARTH</para>
	/// <para>	,EXTERNAL_WATER</para>
	/// <para>	,EXTERNAL_FIRE</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInternalOrExternalEnum
	{
		public static string INTERNAL { get {return "INTERNAL";} }
		public static string EXTERNAL { get {return "EXTERNAL";} }
		public static string EXTERNAL_EARTH { get {return "EXTERNAL_EARTH";} }
		public static string EXTERNAL_WATER { get {return "EXTERNAL_WATER";} }
		public static string EXTERNAL_FIRE { get {return "EXTERNAL_FIRE";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcInternalOrExternalEnum(string value) { return new IfcInternalOrExternalEnum(string);}
		public static implicit operator string(IfcInternalOrExternalEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInventoryTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcInventoryTypeEnum = ENUMERATION OF</para>
	/// <para>	(ASSETINVENTORY</para>
	/// <para>	,SPACEINVENTORY</para>
	/// <para>	,FURNITUREINVENTORY</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInventoryTypeEnum
	{
		public static string ASSETINVENTORY { get {return "ASSETINVENTORY";} }
		public static string SPACEINVENTORY { get {return "SPACEINVENTORY";} }
		public static string FURNITUREINVENTORY { get {return "FURNITUREINVENTORY";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcInventoryTypeEnum(string value) { return new IfcInventoryTypeEnum(string);}
		public static implicit operator string(IfcInventoryTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcJunctionBoxTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcJunctionBoxTypeEnum = ENUMERATION OF</para>
	/// <para>	(DATA</para>
	/// <para>	,POWER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcJunctionBoxTypeEnum
	{
		public static string DATA { get {return "DATA";} }
		public static string POWER { get {return "POWER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcJunctionBoxTypeEnum(string value) { return new IfcJunctionBoxTypeEnum(string);}
		public static implicit operator string(IfcJunctionBoxTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcKnotType = ENUMERATION OF
	/// <para>TYPE IfcKnotType = ENUMERATION OF</para>
	/// <para>	(UNIFORM_KNOTS</para>
	/// <para>	,QUASI_UNIFORM_KNOTS</para>
	/// <para>	,PIECEWISE_BEZIER_KNOTS</para>
	/// <para>	,UNSPECIFIED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcKnotType
	{
		public static string UNIFORM_KNOTS { get {return "UNIFORM_KNOTS";} }
		public static string QUASI_UNIFORM_KNOTS { get {return "QUASI_UNIFORM_KNOTS";} }
		public static string PIECEWISE_BEZIER_KNOTS { get {return "PIECEWISE_BEZIER_KNOTS";} }
		public static string UNSPECIFIED { get {return "UNSPECIFIED";} }
		public static implicit operator IfcKnotType(string value) { return new IfcKnotType(string);}
		public static implicit operator string(IfcKnotType value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLaborResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcLaborResourceTypeEnum = ENUMERATION OF</para>
	/// <para>	(ADMINISTRATION</para>
	/// <para>	,CARPENTRY</para>
	/// <para>	,CLEANING</para>
	/// <para>	,CONCRETE</para>
	/// <para>	,DRYWALL</para>
	/// <para>	,ELECTRIC</para>
	/// <para>	,FINISHING</para>
	/// <para>	,FLOORING</para>
	/// <para>	,GENERAL</para>
	/// <para>	,HVAC</para>
	/// <para>	,LANDSCAPING</para>
	/// <para>	,MASONRY</para>
	/// <para>	,PAINTING</para>
	/// <para>	,PAVING</para>
	/// <para>	,PLUMBING</para>
	/// <para>	,ROOFING</para>
	/// <para>	,SITEGRADING</para>
	/// <para>	,STEELWORK</para>
	/// <para>	,SURVEYING</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLaborResourceTypeEnum
	{
		public static string ADMINISTRATION { get {return "ADMINISTRATION";} }
		public static string CARPENTRY { get {return "CARPENTRY";} }
		public static string CLEANING { get {return "CLEANING";} }
		public static string CONCRETE { get {return "CONCRETE";} }
		public static string DRYWALL { get {return "DRYWALL";} }
		public static string ELECTRIC { get {return "ELECTRIC";} }
		public static string FINISHING { get {return "FINISHING";} }
		public static string FLOORING { get {return "FLOORING";} }
		public static string GENERAL { get {return "GENERAL";} }
		public static string HVAC { get {return "HVAC";} }
		public static string LANDSCAPING { get {return "LANDSCAPING";} }
		public static string MASONRY { get {return "MASONRY";} }
		public static string PAINTING { get {return "PAINTING";} }
		public static string PAVING { get {return "PAVING";} }
		public static string PLUMBING { get {return "PLUMBING";} }
		public static string ROOFING { get {return "ROOFING";} }
		public static string SITEGRADING { get {return "SITEGRADING";} }
		public static string STEELWORK { get {return "STEELWORK";} }
		public static string SURVEYING { get {return "SURVEYING";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcLaborResourceTypeEnum(string value) { return new IfcLaborResourceTypeEnum(string);}
		public static implicit operator string(IfcLaborResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLampTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcLampTypeEnum = ENUMERATION OF</para>
	/// <para>	(COMPACTFLUORESCENT</para>
	/// <para>	,FLUORESCENT</para>
	/// <para>	,HALOGEN</para>
	/// <para>	,HIGHPRESSUREMERCURY</para>
	/// <para>	,HIGHPRESSURESODIUM</para>
	/// <para>	,LED</para>
	/// <para>	,METALHALIDE</para>
	/// <para>	,OLED</para>
	/// <para>	,TUNGSTENFILAMENT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLampTypeEnum
	{
		public static string COMPACTFLUORESCENT { get {return "COMPACTFLUORESCENT";} }
		public static string FLUORESCENT { get {return "FLUORESCENT";} }
		public static string HALOGEN { get {return "HALOGEN";} }
		public static string HIGHPRESSUREMERCURY { get {return "HIGHPRESSUREMERCURY";} }
		public static string HIGHPRESSURESODIUM { get {return "HIGHPRESSURESODIUM";} }
		public static string LED { get {return "LED";} }
		public static string METALHALIDE { get {return "METALHALIDE";} }
		public static string OLED { get {return "OLED";} }
		public static string TUNGSTENFILAMENT { get {return "TUNGSTENFILAMENT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcLampTypeEnum(string value) { return new IfcLampTypeEnum(string);}
		public static implicit operator string(IfcLampTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLayerSetDirectionEnum = ENUMERATION OF
	/// <para>TYPE IfcLayerSetDirectionEnum = ENUMERATION OF</para>
	/// <para>	(AXIS1</para>
	/// <para>	,AXIS2</para>
	/// <para>	,AXIS3);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLayerSetDirectionEnum
	{
		public static string AXIS1 { get {return "AXIS1";} }
		public static string AXIS2 { get {return "AXIS2";} }
		public static string AXIS3 { get {return "AXIS3";} }
		public static implicit operator IfcLayerSetDirectionEnum(string value) { return new IfcLayerSetDirectionEnum(string);}
		public static implicit operator string(IfcLayerSetDirectionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLightDistributionCurveEnum = ENUMERATION OF
	/// <para>TYPE IfcLightDistributionCurveEnum = ENUMERATION OF</para>
	/// <para>	(TYPE_A</para>
	/// <para>	,TYPE_B</para>
	/// <para>	,TYPE_C</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLightDistributionCurveEnum
	{
		public static string TYPE_A { get {return "TYPE_A";} }
		public static string TYPE_B { get {return "TYPE_B";} }
		public static string TYPE_C { get {return "TYPE_C";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcLightDistributionCurveEnum(string value) { return new IfcLightDistributionCurveEnum(string);}
		public static implicit operator string(IfcLightDistributionCurveEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLightEmissionSourceEnum = ENUMERATION OF
	/// <para>TYPE IfcLightEmissionSourceEnum = ENUMERATION OF</para>
	/// <para>	(COMPACTFLUORESCENT</para>
	/// <para>	,FLUORESCENT</para>
	/// <para>	,HIGHPRESSUREMERCURY</para>
	/// <para>	,HIGHPRESSURESODIUM</para>
	/// <para>	,LIGHTEMITTINGDIODE</para>
	/// <para>	,LOWPRESSURESODIUM</para>
	/// <para>	,LOWVOLTAGEHALOGEN</para>
	/// <para>	,MAINVOLTAGEHALOGEN</para>
	/// <para>	,METALHALIDE</para>
	/// <para>	,TUNGSTENFILAMENT</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLightEmissionSourceEnum
	{
		public static string COMPACTFLUORESCENT { get {return "COMPACTFLUORESCENT";} }
		public static string FLUORESCENT { get {return "FLUORESCENT";} }
		public static string HIGHPRESSUREMERCURY { get {return "HIGHPRESSUREMERCURY";} }
		public static string HIGHPRESSURESODIUM { get {return "HIGHPRESSURESODIUM";} }
		public static string LIGHTEMITTINGDIODE { get {return "LIGHTEMITTINGDIODE";} }
		public static string LOWPRESSURESODIUM { get {return "LOWPRESSURESODIUM";} }
		public static string LOWVOLTAGEHALOGEN { get {return "LOWVOLTAGEHALOGEN";} }
		public static string MAINVOLTAGEHALOGEN { get {return "MAINVOLTAGEHALOGEN";} }
		public static string METALHALIDE { get {return "METALHALIDE";} }
		public static string TUNGSTENFILAMENT { get {return "TUNGSTENFILAMENT";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcLightEmissionSourceEnum(string value) { return new IfcLightEmissionSourceEnum(string);}
		public static implicit operator string(IfcLightEmissionSourceEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLightFixtureTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcLightFixtureTypeEnum = ENUMERATION OF</para>
	/// <para>	(POINTSOURCE</para>
	/// <para>	,DIRECTIONSOURCE</para>
	/// <para>	,SECURITYLIGHTING</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLightFixtureTypeEnum
	{
		public static string POINTSOURCE { get {return "POINTSOURCE";} }
		public static string DIRECTIONSOURCE { get {return "DIRECTIONSOURCE";} }
		public static string SECURITYLIGHTING { get {return "SECURITYLIGHTING";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcLightFixtureTypeEnum(string value) { return new IfcLightFixtureTypeEnum(string);}
		public static implicit operator string(IfcLightFixtureTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLoadGroupTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcLoadGroupTypeEnum = ENUMERATION OF</para>
	/// <para>	(LOAD_GROUP</para>
	/// <para>	,LOAD_CASE</para>
	/// <para>	,LOAD_COMBINATION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLoadGroupTypeEnum
	{
		public static string LOAD_GROUP { get {return "LOAD_GROUP";} }
		public static string LOAD_CASE { get {return "LOAD_CASE";} }
		public static string LOAD_COMBINATION { get {return "LOAD_COMBINATION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcLoadGroupTypeEnum(string value) { return new IfcLoadGroupTypeEnum(string);}
		public static implicit operator string(IfcLoadGroupTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLogicalOperatorEnum = ENUMERATION OF
	/// <para>TYPE IfcLogicalOperatorEnum = ENUMERATION OF</para>
	/// <para>	(LOGICALAND</para>
	/// <para>	,LOGICALOR</para>
	/// <para>	,LOGICALXOR</para>
	/// <para>	,LOGICALNOTAND</para>
	/// <para>	,LOGICALNOTOR);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLogicalOperatorEnum
	{
		public static string LOGICALAND { get {return "LOGICALAND";} }
		public static string LOGICALOR { get {return "LOGICALOR";} }
		public static string LOGICALXOR { get {return "LOGICALXOR";} }
		public static string LOGICALNOTAND { get {return "LOGICALNOTAND";} }
		public static string LOGICALNOTOR { get {return "LOGICALNOTOR";} }
		public static implicit operator IfcLogicalOperatorEnum(string value) { return new IfcLogicalOperatorEnum(string);}
		public static implicit operator string(IfcLogicalOperatorEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMechanicalFastenerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcMechanicalFastenerTypeEnum = ENUMERATION OF</para>
	/// <para>	(ANCHORBOLT</para>
	/// <para>	,BOLT</para>
	/// <para>	,DOWEL</para>
	/// <para>	,NAIL</para>
	/// <para>	,NAILPLATE</para>
	/// <para>	,RIVET</para>
	/// <para>	,SCREW</para>
	/// <para>	,SHEARCONNECTOR</para>
	/// <para>	,STAPLE</para>
	/// <para>	,STUDSHEARCONNECTOR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMechanicalFastenerTypeEnum
	{
		public static string ANCHORBOLT { get {return "ANCHORBOLT";} }
		public static string BOLT { get {return "BOLT";} }
		public static string DOWEL { get {return "DOWEL";} }
		public static string NAIL { get {return "NAIL";} }
		public static string NAILPLATE { get {return "NAILPLATE";} }
		public static string RIVET { get {return "RIVET";} }
		public static string SCREW { get {return "SCREW";} }
		public static string SHEARCONNECTOR { get {return "SHEARCONNECTOR";} }
		public static string STAPLE { get {return "STAPLE";} }
		public static string STUDSHEARCONNECTOR { get {return "STUDSHEARCONNECTOR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcMechanicalFastenerTypeEnum(string value) { return new IfcMechanicalFastenerTypeEnum(string);}
		public static implicit operator string(IfcMechanicalFastenerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMedicalDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcMedicalDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>	(AIRSTATION</para>
	/// <para>	,FEEDAIRUNIT</para>
	/// <para>	,OXYGENGENERATOR</para>
	/// <para>	,OXYGENPLANT</para>
	/// <para>	,VACUUMSTATION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMedicalDeviceTypeEnum
	{
		public static string AIRSTATION { get {return "AIRSTATION";} }
		public static string FEEDAIRUNIT { get {return "FEEDAIRUNIT";} }
		public static string OXYGENGENERATOR { get {return "OXYGENGENERATOR";} }
		public static string OXYGENPLANT { get {return "OXYGENPLANT";} }
		public static string VACUUMSTATION { get {return "VACUUMSTATION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcMedicalDeviceTypeEnum(string value) { return new IfcMedicalDeviceTypeEnum(string);}
		public static implicit operator string(IfcMedicalDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMemberTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcMemberTypeEnum = ENUMERATION OF</para>
	/// <para>	(BRACE</para>
	/// <para>	,CHORD</para>
	/// <para>	,COLLAR</para>
	/// <para>	,MEMBER</para>
	/// <para>	,MULLION</para>
	/// <para>	,PLATE</para>
	/// <para>	,POST</para>
	/// <para>	,PURLIN</para>
	/// <para>	,RAFTER</para>
	/// <para>	,STRINGER</para>
	/// <para>	,STRUT</para>
	/// <para>	,STUD</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMemberTypeEnum
	{
		public static string BRACE { get {return "BRACE";} }
		public static string CHORD { get {return "CHORD";} }
		public static string COLLAR { get {return "COLLAR";} }
		public static string MEMBER { get {return "MEMBER";} }
		public static string MULLION { get {return "MULLION";} }
		public static string PLATE { get {return "PLATE";} }
		public static string POST { get {return "POST";} }
		public static string PURLIN { get {return "PURLIN";} }
		public static string RAFTER { get {return "RAFTER";} }
		public static string STRINGER { get {return "STRINGER";} }
		public static string STRUT { get {return "STRUT";} }
		public static string STUD { get {return "STUD";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcMemberTypeEnum(string value) { return new IfcMemberTypeEnum(string);}
		public static implicit operator string(IfcMemberTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMotorConnectionTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcMotorConnectionTypeEnum = ENUMERATION OF</para>
	/// <para>	(BELTDRIVE</para>
	/// <para>	,COUPLING</para>
	/// <para>	,DIRECTDRIVE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMotorConnectionTypeEnum
	{
		public static string BELTDRIVE { get {return "BELTDRIVE";} }
		public static string COUPLING { get {return "COUPLING";} }
		public static string DIRECTDRIVE { get {return "DIRECTDRIVE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcMotorConnectionTypeEnum(string value) { return new IfcMotorConnectionTypeEnum(string);}
		public static implicit operator string(IfcMotorConnectionTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNullStyle = ENUMERATION OF
	/// <para>TYPE IfcNullStyle = ENUMERATION OF</para>
	/// <para>	(NULL);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNullStyle, IfcPresentationStyleSelect
	{
		public static string NULL { get {return "NULL";} }
		public static implicit operator IfcNullStyle(string value) { return new IfcNullStyle(string);}
		public static implicit operator string(IfcNullStyle value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcObjectTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcObjectTypeEnum = ENUMERATION OF</para>
	/// <para>	(PRODUCT</para>
	/// <para>	,PROCESS</para>
	/// <para>	,CONTROL</para>
	/// <para>	,RESOURCE</para>
	/// <para>	,ACTOR</para>
	/// <para>	,GROUP</para>
	/// <para>	,PROJECT</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcObjectTypeEnum
	{
		public static string PRODUCT { get {return "PRODUCT";} }
		public static string PROCESS { get {return "PROCESS";} }
		public static string CONTROL { get {return "CONTROL";} }
		public static string RESOURCE { get {return "RESOURCE";} }
		public static string ACTOR { get {return "ACTOR";} }
		public static string GROUP { get {return "GROUP";} }
		public static string PROJECT { get {return "PROJECT";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcObjectTypeEnum(string value) { return new IfcObjectTypeEnum(string);}
		public static implicit operator string(IfcObjectTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcObjectiveEnum = ENUMERATION OF
	/// <para>TYPE IfcObjectiveEnum = ENUMERATION OF</para>
	/// <para>	(CODECOMPLIANCE</para>
	/// <para>	,CODEWAIVER</para>
	/// <para>	,DESIGNINTENT</para>
	/// <para>	,EXTERNAL</para>
	/// <para>	,HEALTHANDSAFETY</para>
	/// <para>	,MERGECONFLICT</para>
	/// <para>	,MODELVIEW</para>
	/// <para>	,PARAMETER</para>
	/// <para>	,REQUIREMENT</para>
	/// <para>	,SPECIFICATION</para>
	/// <para>	,TRIGGERCONDITION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcObjectiveEnum
	{
		public static string CODECOMPLIANCE { get {return "CODECOMPLIANCE";} }
		public static string CODEWAIVER { get {return "CODEWAIVER";} }
		public static string DESIGNINTENT { get {return "DESIGNINTENT";} }
		public static string EXTERNAL { get {return "EXTERNAL";} }
		public static string HEALTHANDSAFETY { get {return "HEALTHANDSAFETY";} }
		public static string MERGECONFLICT { get {return "MERGECONFLICT";} }
		public static string MODELVIEW { get {return "MODELVIEW";} }
		public static string PARAMETER { get {return "PARAMETER";} }
		public static string REQUIREMENT { get {return "REQUIREMENT";} }
		public static string SPECIFICATION { get {return "SPECIFICATION";} }
		public static string TRIGGERCONDITION { get {return "TRIGGERCONDITION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcObjectiveEnum(string value) { return new IfcObjectiveEnum(string);}
		public static implicit operator string(IfcObjectiveEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcOccupantTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcOccupantTypeEnum = ENUMERATION OF</para>
	/// <para>	(ASSIGNEE</para>
	/// <para>	,ASSIGNOR</para>
	/// <para>	,LESSEE</para>
	/// <para>	,LESSOR</para>
	/// <para>	,LETTINGAGENT</para>
	/// <para>	,OWNER</para>
	/// <para>	,TENANT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcOccupantTypeEnum
	{
		public static string ASSIGNEE { get {return "ASSIGNEE";} }
		public static string ASSIGNOR { get {return "ASSIGNOR";} }
		public static string LESSEE { get {return "LESSEE";} }
		public static string LESSOR { get {return "LESSOR";} }
		public static string LETTINGAGENT { get {return "LETTINGAGENT";} }
		public static string OWNER { get {return "OWNER";} }
		public static string TENANT { get {return "TENANT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcOccupantTypeEnum(string value) { return new IfcOccupantTypeEnum(string);}
		public static implicit operator string(IfcOccupantTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcOpeningElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcOpeningElementTypeEnum = ENUMERATION OF</para>
	/// <para>	(OPENING</para>
	/// <para>	,RECESS</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcOpeningElementTypeEnum
	{
		public static string OPENING { get {return "OPENING";} }
		public static string RECESS { get {return "RECESS";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcOpeningElementTypeEnum(string value) { return new IfcOpeningElementTypeEnum(string);}
		public static implicit operator string(IfcOpeningElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcOutletTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcOutletTypeEnum = ENUMERATION OF</para>
	/// <para>	(AUDIOVISUALOUTLET</para>
	/// <para>	,COMMUNICATIONSOUTLET</para>
	/// <para>	,POWEROUTLET</para>
	/// <para>	,DATAOUTLET</para>
	/// <para>	,TELEPHONEOUTLET</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcOutletTypeEnum
	{
		public static string AUDIOVISUALOUTLET { get {return "AUDIOVISUALOUTLET";} }
		public static string COMMUNICATIONSOUTLET { get {return "COMMUNICATIONSOUTLET";} }
		public static string POWEROUTLET { get {return "POWEROUTLET";} }
		public static string DATAOUTLET { get {return "DATAOUTLET";} }
		public static string TELEPHONEOUTLET { get {return "TELEPHONEOUTLET";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcOutletTypeEnum(string value) { return new IfcOutletTypeEnum(string);}
		public static implicit operator string(IfcOutletTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPerformanceHistoryTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPerformanceHistoryTypeEnum = ENUMERATION OF</para>
	/// <para>	(USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPerformanceHistoryTypeEnum
	{
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPerformanceHistoryTypeEnum(string value) { return new IfcPerformanceHistoryTypeEnum(string);}
		public static implicit operator string(IfcPerformanceHistoryTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPermeableCoveringOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcPermeableCoveringOperationEnum = ENUMERATION OF</para>
	/// <para>	(GRILL</para>
	/// <para>	,LOUVER</para>
	/// <para>	,SCREEN</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPermeableCoveringOperationEnum
	{
		public static string GRILL { get {return "GRILL";} }
		public static string LOUVER { get {return "LOUVER";} }
		public static string SCREEN { get {return "SCREEN";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPermeableCoveringOperationEnum(string value) { return new IfcPermeableCoveringOperationEnum(string);}
		public static implicit operator string(IfcPermeableCoveringOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPermitTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPermitTypeEnum = ENUMERATION OF</para>
	/// <para>	(ACCESS</para>
	/// <para>	,BUILDING</para>
	/// <para>	,WORK</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPermitTypeEnum
	{
		public static string ACCESS { get {return "ACCESS";} }
		public static string BUILDING { get {return "BUILDING";} }
		public static string WORK { get {return "WORK";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPermitTypeEnum(string value) { return new IfcPermitTypeEnum(string);}
		public static implicit operator string(IfcPermitTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPhysicalOrVirtualEnum = ENUMERATION OF
	/// <para>TYPE IfcPhysicalOrVirtualEnum = ENUMERATION OF</para>
	/// <para>	(PHYSICAL</para>
	/// <para>	,VIRTUAL</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPhysicalOrVirtualEnum
	{
		public static string PHYSICAL { get {return "PHYSICAL";} }
		public static string VIRTUAL { get {return "VIRTUAL";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPhysicalOrVirtualEnum(string value) { return new IfcPhysicalOrVirtualEnum(string);}
		public static implicit operator string(IfcPhysicalOrVirtualEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPileConstructionEnum = ENUMERATION OF
	/// <para>TYPE IfcPileConstructionEnum = ENUMERATION OF</para>
	/// <para>	(CAST_IN_PLACE</para>
	/// <para>	,COMPOSITE</para>
	/// <para>	,PRECAST_CONCRETE</para>
	/// <para>	,PREFAB_STEEL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPileConstructionEnum
	{
		public static string CAST_IN_PLACE { get {return "CAST_IN_PLACE";} }
		public static string COMPOSITE { get {return "COMPOSITE";} }
		public static string PRECAST_CONCRETE { get {return "PRECAST_CONCRETE";} }
		public static string PREFAB_STEEL { get {return "PREFAB_STEEL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPileConstructionEnum(string value) { return new IfcPileConstructionEnum(string);}
		public static implicit operator string(IfcPileConstructionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPileTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPileTypeEnum = ENUMERATION OF</para>
	/// <para>	(BORED</para>
	/// <para>	,DRIVEN</para>
	/// <para>	,JETGROUTING</para>
	/// <para>	,COHESION</para>
	/// <para>	,FRICTION</para>
	/// <para>	,SUPPORT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPileTypeEnum
	{
		public static string BORED { get {return "BORED";} }
		public static string DRIVEN { get {return "DRIVEN";} }
		public static string JETGROUTING { get {return "JETGROUTING";} }
		public static string COHESION { get {return "COHESION";} }
		public static string FRICTION { get {return "FRICTION";} }
		public static string SUPPORT { get {return "SUPPORT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPileTypeEnum(string value) { return new IfcPileTypeEnum(string);}
		public static implicit operator string(IfcPileTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPipeFittingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPipeFittingTypeEnum = ENUMERATION OF</para>
	/// <para>	(BEND</para>
	/// <para>	,CONNECTOR</para>
	/// <para>	,ENTRY</para>
	/// <para>	,EXIT</para>
	/// <para>	,JUNCTION</para>
	/// <para>	,OBSTRUCTION</para>
	/// <para>	,TRANSITION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPipeFittingTypeEnum
	{
		public static string BEND { get {return "BEND";} }
		public static string CONNECTOR { get {return "CONNECTOR";} }
		public static string ENTRY { get {return "ENTRY";} }
		public static string EXIT { get {return "EXIT";} }
		public static string JUNCTION { get {return "JUNCTION";} }
		public static string OBSTRUCTION { get {return "OBSTRUCTION";} }
		public static string TRANSITION { get {return "TRANSITION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPipeFittingTypeEnum(string value) { return new IfcPipeFittingTypeEnum(string);}
		public static implicit operator string(IfcPipeFittingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPipeSegmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPipeSegmentTypeEnum = ENUMERATION OF</para>
	/// <para>	(CULVERT</para>
	/// <para>	,FLEXIBLESEGMENT</para>
	/// <para>	,RIGIDSEGMENT</para>
	/// <para>	,GUTTER</para>
	/// <para>	,SPOOL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPipeSegmentTypeEnum
	{
		public static string CULVERT { get {return "CULVERT";} }
		public static string FLEXIBLESEGMENT { get {return "FLEXIBLESEGMENT";} }
		public static string RIGIDSEGMENT { get {return "RIGIDSEGMENT";} }
		public static string GUTTER { get {return "GUTTER";} }
		public static string SPOOL { get {return "SPOOL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPipeSegmentTypeEnum(string value) { return new IfcPipeSegmentTypeEnum(string);}
		public static implicit operator string(IfcPipeSegmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPlateTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPlateTypeEnum = ENUMERATION OF</para>
	/// <para>	(CURTAIN_PANEL</para>
	/// <para>	,SHEET</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPlateTypeEnum
	{
		public static string CURTAIN_PANEL { get {return "CURTAIN_PANEL";} }
		public static string SHEET { get {return "SHEET";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPlateTypeEnum(string value) { return new IfcPlateTypeEnum(string);}
		public static implicit operator string(IfcPlateTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPreferredSurfaceCurveRepresentation = ENUMERATION OF
	/// <para>TYPE IfcPreferredSurfaceCurveRepresentation = ENUMERATION OF</para>
	/// <para>	(CURVE3D</para>
	/// <para>	,PCURVE_S1</para>
	/// <para>	,PCURVE_S2);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPreferredSurfaceCurveRepresentation
	{
		public static string CURVE3D { get {return "CURVE3D";} }
		public static string PCURVE_S1 { get {return "PCURVE_S1";} }
		public static string PCURVE_S2 { get {return "PCURVE_S2";} }
		public static implicit operator IfcPreferredSurfaceCurveRepresentation(string value) { return new IfcPreferredSurfaceCurveRepresentation(string);}
		public static implicit operator string(IfcPreferredSurfaceCurveRepresentation value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProcedureTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProcedureTypeEnum = ENUMERATION OF</para>
	/// <para>	(ADVICE_CAUTION</para>
	/// <para>	,ADVICE_NOTE</para>
	/// <para>	,ADVICE_WARNING</para>
	/// <para>	,CALIBRATION</para>
	/// <para>	,DIAGNOSTIC</para>
	/// <para>	,SHUTDOWN</para>
	/// <para>	,STARTUP</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProcedureTypeEnum
	{
		public static string ADVICE_CAUTION { get {return "ADVICE_CAUTION";} }
		public static string ADVICE_NOTE { get {return "ADVICE_NOTE";} }
		public static string ADVICE_WARNING { get {return "ADVICE_WARNING";} }
		public static string CALIBRATION { get {return "CALIBRATION";} }
		public static string DIAGNOSTIC { get {return "DIAGNOSTIC";} }
		public static string SHUTDOWN { get {return "SHUTDOWN";} }
		public static string STARTUP { get {return "STARTUP";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcProcedureTypeEnum(string value) { return new IfcProcedureTypeEnum(string);}
		public static implicit operator string(IfcProcedureTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProfileTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProfileTypeEnum = ENUMERATION OF</para>
	/// <para>	(CURVE</para>
	/// <para>	,AREA);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProfileTypeEnum
	{
		public static string CURVE { get {return "CURVE";} }
		public static string AREA { get {return "AREA";} }
		public static implicit operator IfcProfileTypeEnum(string value) { return new IfcProfileTypeEnum(string);}
		public static implicit operator string(IfcProfileTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProjectOrderTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProjectOrderTypeEnum = ENUMERATION OF</para>
	/// <para>	(CHANGEORDER</para>
	/// <para>	,MAINTENANCEWORKORDER</para>
	/// <para>	,MOVEORDER</para>
	/// <para>	,PURCHASEORDER</para>
	/// <para>	,WORKORDER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProjectOrderTypeEnum
	{
		public static string CHANGEORDER { get {return "CHANGEORDER";} }
		public static string MAINTENANCEWORKORDER { get {return "MAINTENANCEWORKORDER";} }
		public static string MOVEORDER { get {return "MOVEORDER";} }
		public static string PURCHASEORDER { get {return "PURCHASEORDER";} }
		public static string WORKORDER { get {return "WORKORDER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcProjectOrderTypeEnum(string value) { return new IfcProjectOrderTypeEnum(string);}
		public static implicit operator string(IfcProjectOrderTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProjectedOrTrueLengthEnum = ENUMERATION OF
	/// <para>TYPE IfcProjectedOrTrueLengthEnum = ENUMERATION OF</para>
	/// <para>	(PROJECTED_LENGTH</para>
	/// <para>	,TRUE_LENGTH);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProjectedOrTrueLengthEnum
	{
		public static string PROJECTED_LENGTH { get {return "PROJECTED_LENGTH";} }
		public static string TRUE_LENGTH { get {return "TRUE_LENGTH";} }
		public static implicit operator IfcProjectedOrTrueLengthEnum(string value) { return new IfcProjectedOrTrueLengthEnum(string);}
		public static implicit operator string(IfcProjectedOrTrueLengthEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProjectionElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProjectionElementTypeEnum = ENUMERATION OF</para>
	/// <para>	(USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProjectionElementTypeEnum
	{
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcProjectionElementTypeEnum(string value) { return new IfcProjectionElementTypeEnum(string);}
		public static implicit operator string(IfcProjectionElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPropertySetTemplateTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPropertySetTemplateTypeEnum = ENUMERATION OF</para>
	/// <para>	(PSET_TYPEDRIVENONLY</para>
	/// <para>	,PSET_TYPEDRIVENOVERRIDE</para>
	/// <para>	,PSET_OCCURRENCEDRIVEN</para>
	/// <para>	,PSET_PERFORMANCEDRIVEN</para>
	/// <para>	,QTO_TYPEDRIVENONLY</para>
	/// <para>	,QTO_TYPEDRIVENOVERRIDE</para>
	/// <para>	,QTO_OCCURRENCEDRIVEN</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPropertySetTemplateTypeEnum
	{
		public static string PSET_TYPEDRIVENONLY { get {return "PSET_TYPEDRIVENONLY";} }
		public static string PSET_TYPEDRIVENOVERRIDE { get {return "PSET_TYPEDRIVENOVERRIDE";} }
		public static string PSET_OCCURRENCEDRIVEN { get {return "PSET_OCCURRENCEDRIVEN";} }
		public static string PSET_PERFORMANCEDRIVEN { get {return "PSET_PERFORMANCEDRIVEN";} }
		public static string QTO_TYPEDRIVENONLY { get {return "QTO_TYPEDRIVENONLY";} }
		public static string QTO_TYPEDRIVENOVERRIDE { get {return "QTO_TYPEDRIVENOVERRIDE";} }
		public static string QTO_OCCURRENCEDRIVEN { get {return "QTO_OCCURRENCEDRIVEN";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPropertySetTemplateTypeEnum(string value) { return new IfcPropertySetTemplateTypeEnum(string);}
		public static implicit operator string(IfcPropertySetTemplateTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProtectiveDeviceTrippingUnitTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProtectiveDeviceTrippingUnitTypeEnum = ENUMERATION OF</para>
	/// <para>	(ELECTRONIC</para>
	/// <para>	,ELECTROMAGNETIC</para>
	/// <para>	,RESIDUALCURRENT</para>
	/// <para>	,THERMAL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProtectiveDeviceTrippingUnitTypeEnum
	{
		public static string ELECTRONIC { get {return "ELECTRONIC";} }
		public static string ELECTROMAGNETIC { get {return "ELECTROMAGNETIC";} }
		public static string RESIDUALCURRENT { get {return "RESIDUALCURRENT";} }
		public static string THERMAL { get {return "THERMAL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcProtectiveDeviceTrippingUnitTypeEnum(string value) { return new IfcProtectiveDeviceTrippingUnitTypeEnum(string);}
		public static implicit operator string(IfcProtectiveDeviceTrippingUnitTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProtectiveDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProtectiveDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>	(CIRCUITBREAKER</para>
	/// <para>	,EARTHLEAKAGECIRCUITBREAKER</para>
	/// <para>	,EARTHINGSWITCH</para>
	/// <para>	,FUSEDISCONNECTOR</para>
	/// <para>	,RESIDUALCURRENTCIRCUITBREAKER</para>
	/// <para>	,RESIDUALCURRENTSWITCH</para>
	/// <para>	,VARISTOR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProtectiveDeviceTypeEnum
	{
		public static string CIRCUITBREAKER { get {return "CIRCUITBREAKER";} }
		public static string EARTHLEAKAGECIRCUITBREAKER { get {return "EARTHLEAKAGECIRCUITBREAKER";} }
		public static string EARTHINGSWITCH { get {return "EARTHINGSWITCH";} }
		public static string FUSEDISCONNECTOR { get {return "FUSEDISCONNECTOR";} }
		public static string RESIDUALCURRENTCIRCUITBREAKER { get {return "RESIDUALCURRENTCIRCUITBREAKER";} }
		public static string RESIDUALCURRENTSWITCH { get {return "RESIDUALCURRENTSWITCH";} }
		public static string VARISTOR { get {return "VARISTOR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcProtectiveDeviceTypeEnum(string value) { return new IfcProtectiveDeviceTypeEnum(string);}
		public static implicit operator string(IfcProtectiveDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPumpTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPumpTypeEnum = ENUMERATION OF</para>
	/// <para>	(CIRCULATOR</para>
	/// <para>	,ENDSUCTION</para>
	/// <para>	,SPLITCASE</para>
	/// <para>	,SUBMERSIBLEPUMP</para>
	/// <para>	,SUMPPUMP</para>
	/// <para>	,VERTICALINLINE</para>
	/// <para>	,VERTICALTURBINE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPumpTypeEnum
	{
		public static string CIRCULATOR { get {return "CIRCULATOR";} }
		public static string ENDSUCTION { get {return "ENDSUCTION";} }
		public static string SPLITCASE { get {return "SPLITCASE";} }
		public static string SUBMERSIBLEPUMP { get {return "SUBMERSIBLEPUMP";} }
		public static string SUMPPUMP { get {return "SUMPPUMP";} }
		public static string VERTICALINLINE { get {return "VERTICALINLINE";} }
		public static string VERTICALTURBINE { get {return "VERTICALTURBINE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcPumpTypeEnum(string value) { return new IfcPumpTypeEnum(string);}
		public static implicit operator string(IfcPumpTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRailingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcRailingTypeEnum = ENUMERATION OF</para>
	/// <para>	(HANDRAIL</para>
	/// <para>	,GUARDRAIL</para>
	/// <para>	,BALUSTRADE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRailingTypeEnum
	{
		public static string HANDRAIL { get {return "HANDRAIL";} }
		public static string GUARDRAIL { get {return "GUARDRAIL";} }
		public static string BALUSTRADE { get {return "BALUSTRADE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcRailingTypeEnum(string value) { return new IfcRailingTypeEnum(string);}
		public static implicit operator string(IfcRailingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRampFlightTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcRampFlightTypeEnum = ENUMERATION OF</para>
	/// <para>	(STRAIGHT</para>
	/// <para>	,SPIRAL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRampFlightTypeEnum
	{
		public static string STRAIGHT { get {return "STRAIGHT";} }
		public static string SPIRAL { get {return "SPIRAL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcRampFlightTypeEnum(string value) { return new IfcRampFlightTypeEnum(string);}
		public static implicit operator string(IfcRampFlightTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRampTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcRampTypeEnum = ENUMERATION OF</para>
	/// <para>	(STRAIGHT_RUN_RAMP</para>
	/// <para>	,TWO_STRAIGHT_RUN_RAMP</para>
	/// <para>	,QUARTER_TURN_RAMP</para>
	/// <para>	,TWO_QUARTER_TURN_RAMP</para>
	/// <para>	,HALF_TURN_RAMP</para>
	/// <para>	,SPIRAL_RAMP</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRampTypeEnum
	{
		public static string STRAIGHT_RUN_RAMP { get {return "STRAIGHT_RUN_RAMP";} }
		public static string TWO_STRAIGHT_RUN_RAMP { get {return "TWO_STRAIGHT_RUN_RAMP";} }
		public static string QUARTER_TURN_RAMP { get {return "QUARTER_TURN_RAMP";} }
		public static string TWO_QUARTER_TURN_RAMP { get {return "TWO_QUARTER_TURN_RAMP";} }
		public static string HALF_TURN_RAMP { get {return "HALF_TURN_RAMP";} }
		public static string SPIRAL_RAMP { get {return "SPIRAL_RAMP";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcRampTypeEnum(string value) { return new IfcRampTypeEnum(string);}
		public static implicit operator string(IfcRampTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRecurrenceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcRecurrenceTypeEnum = ENUMERATION OF</para>
	/// <para>	(DAILY</para>
	/// <para>	,WEEKLY</para>
	/// <para>	,MONTHLY_BY_DAY_OF_MONTH</para>
	/// <para>	,MONTHLY_BY_POSITION</para>
	/// <para>	,BY_DAY_COUNT</para>
	/// <para>	,BY_WEEKDAY_COUNT</para>
	/// <para>	,YEARLY_BY_DAY_OF_MONTH</para>
	/// <para>	,YEARLY_BY_POSITION);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRecurrenceTypeEnum
	{
		public static string DAILY { get {return "DAILY";} }
		public static string WEEKLY { get {return "WEEKLY";} }
		public static string MONTHLY_BY_DAY_OF_MONTH { get {return "MONTHLY_BY_DAY_OF_MONTH";} }
		public static string MONTHLY_BY_POSITION { get {return "MONTHLY_BY_POSITION";} }
		public static string BY_DAY_COUNT { get {return "BY_DAY_COUNT";} }
		public static string BY_WEEKDAY_COUNT { get {return "BY_WEEKDAY_COUNT";} }
		public static string YEARLY_BY_DAY_OF_MONTH { get {return "YEARLY_BY_DAY_OF_MONTH";} }
		public static string YEARLY_BY_POSITION { get {return "YEARLY_BY_POSITION";} }
		public static implicit operator IfcRecurrenceTypeEnum(string value) { return new IfcRecurrenceTypeEnum(string);}
		public static implicit operator string(IfcRecurrenceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReflectanceMethodEnum = ENUMERATION OF
	/// <para>TYPE IfcReflectanceMethodEnum = ENUMERATION OF</para>
	/// <para>	(BLINN</para>
	/// <para>	,FLAT</para>
	/// <para>	,GLASS</para>
	/// <para>	,MATT</para>
	/// <para>	,METAL</para>
	/// <para>	,MIRROR</para>
	/// <para>	,PHONG</para>
	/// <para>	,PLASTIC</para>
	/// <para>	,STRAUSS</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReflectanceMethodEnum
	{
		public static string BLINN { get {return "BLINN";} }
		public static string FLAT { get {return "FLAT";} }
		public static string GLASS { get {return "GLASS";} }
		public static string MATT { get {return "MATT";} }
		public static string METAL { get {return "METAL";} }
		public static string MIRROR { get {return "MIRROR";} }
		public static string PHONG { get {return "PHONG";} }
		public static string PLASTIC { get {return "PLASTIC";} }
		public static string STRAUSS { get {return "STRAUSS";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcReflectanceMethodEnum(string value) { return new IfcReflectanceMethodEnum(string);}
		public static implicit operator string(IfcReflectanceMethodEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReinforcingBarRoleEnum = ENUMERATION OF
	/// <para>TYPE IfcReinforcingBarRoleEnum = ENUMERATION OF</para>
	/// <para>	(MAIN</para>
	/// <para>	,SHEAR</para>
	/// <para>	,LIGATURE</para>
	/// <para>	,STUD</para>
	/// <para>	,PUNCHING</para>
	/// <para>	,EDGE</para>
	/// <para>	,RING</para>
	/// <para>	,ANCHORING</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReinforcingBarRoleEnum
	{
		public static string MAIN { get {return "MAIN";} }
		public static string SHEAR { get {return "SHEAR";} }
		public static string LIGATURE { get {return "LIGATURE";} }
		public static string STUD { get {return "STUD";} }
		public static string PUNCHING { get {return "PUNCHING";} }
		public static string EDGE { get {return "EDGE";} }
		public static string RING { get {return "RING";} }
		public static string ANCHORING { get {return "ANCHORING";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcReinforcingBarRoleEnum(string value) { return new IfcReinforcingBarRoleEnum(string);}
		public static implicit operator string(IfcReinforcingBarRoleEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReinforcingBarSurfaceEnum = ENUMERATION OF
	/// <para>TYPE IfcReinforcingBarSurfaceEnum = ENUMERATION OF</para>
	/// <para>	(PLAIN</para>
	/// <para>	,TEXTURED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReinforcingBarSurfaceEnum
	{
		public static string PLAIN { get {return "PLAIN";} }
		public static string TEXTURED { get {return "TEXTURED";} }
		public static implicit operator IfcReinforcingBarSurfaceEnum(string value) { return new IfcReinforcingBarSurfaceEnum(string);}
		public static implicit operator string(IfcReinforcingBarSurfaceEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReinforcingBarTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcReinforcingBarTypeEnum = ENUMERATION OF</para>
	/// <para>	(ANCHORING</para>
	/// <para>	,EDGE</para>
	/// <para>	,LIGATURE</para>
	/// <para>	,MAIN</para>
	/// <para>	,PUNCHING</para>
	/// <para>	,RING</para>
	/// <para>	,SHEAR</para>
	/// <para>	,STUD</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReinforcingBarTypeEnum
	{
		public static string ANCHORING { get {return "ANCHORING";} }
		public static string EDGE { get {return "EDGE";} }
		public static string LIGATURE { get {return "LIGATURE";} }
		public static string MAIN { get {return "MAIN";} }
		public static string PUNCHING { get {return "PUNCHING";} }
		public static string RING { get {return "RING";} }
		public static string SHEAR { get {return "SHEAR";} }
		public static string STUD { get {return "STUD";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcReinforcingBarTypeEnum(string value) { return new IfcReinforcingBarTypeEnum(string);}
		public static implicit operator string(IfcReinforcingBarTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReinforcingMeshTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcReinforcingMeshTypeEnum = ENUMERATION OF</para>
	/// <para>	(USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReinforcingMeshTypeEnum
	{
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcReinforcingMeshTypeEnum(string value) { return new IfcReinforcingMeshTypeEnum(string);}
		public static implicit operator string(IfcReinforcingMeshTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRoleEnum = ENUMERATION OF
	/// <para>TYPE IfcRoleEnum = ENUMERATION OF</para>
	/// <para>	(SUPPLIER</para>
	/// <para>	,MANUFACTURER</para>
	/// <para>	,CONTRACTOR</para>
	/// <para>	,SUBCONTRACTOR</para>
	/// <para>	,ARCHITECT</para>
	/// <para>	,STRUCTURALENGINEER</para>
	/// <para>	,COSTENGINEER</para>
	/// <para>	,CLIENT</para>
	/// <para>	,BUILDINGOWNER</para>
	/// <para>	,BUILDINGOPERATOR</para>
	/// <para>	,MECHANICALENGINEER</para>
	/// <para>	,ELECTRICALENGINEER</para>
	/// <para>	,PROJECTMANAGER</para>
	/// <para>	,FACILITIESMANAGER</para>
	/// <para>	,CIVILENGINEER</para>
	/// <para>	,COMMISSIONINGENGINEER</para>
	/// <para>	,ENGINEER</para>
	/// <para>	,OWNER</para>
	/// <para>	,CONSULTANT</para>
	/// <para>	,CONSTRUCTIONMANAGER</para>
	/// <para>	,FIELDCONSTRUCTIONMANAGER</para>
	/// <para>	,RESELLER</para>
	/// <para>	,USERDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRoleEnum
	{
		public static string SUPPLIER { get {return "SUPPLIER";} }
		public static string MANUFACTURER { get {return "MANUFACTURER";} }
		public static string CONTRACTOR { get {return "CONTRACTOR";} }
		public static string SUBCONTRACTOR { get {return "SUBCONTRACTOR";} }
		public static string ARCHITECT { get {return "ARCHITECT";} }
		public static string STRUCTURALENGINEER { get {return "STRUCTURALENGINEER";} }
		public static string COSTENGINEER { get {return "COSTENGINEER";} }
		public static string CLIENT { get {return "CLIENT";} }
		public static string BUILDINGOWNER { get {return "BUILDINGOWNER";} }
		public static string BUILDINGOPERATOR { get {return "BUILDINGOPERATOR";} }
		public static string MECHANICALENGINEER { get {return "MECHANICALENGINEER";} }
		public static string ELECTRICALENGINEER { get {return "ELECTRICALENGINEER";} }
		public static string PROJECTMANAGER { get {return "PROJECTMANAGER";} }
		public static string FACILITIESMANAGER { get {return "FACILITIESMANAGER";} }
		public static string CIVILENGINEER { get {return "CIVILENGINEER";} }
		public static string COMMISSIONINGENGINEER { get {return "COMMISSIONINGENGINEER";} }
		public static string ENGINEER { get {return "ENGINEER";} }
		public static string OWNER { get {return "OWNER";} }
		public static string CONSULTANT { get {return "CONSULTANT";} }
		public static string CONSTRUCTIONMANAGER { get {return "CONSTRUCTIONMANAGER";} }
		public static string FIELDCONSTRUCTIONMANAGER { get {return "FIELDCONSTRUCTIONMANAGER";} }
		public static string RESELLER { get {return "RESELLER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static implicit operator IfcRoleEnum(string value) { return new IfcRoleEnum(string);}
		public static implicit operator string(IfcRoleEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRoofTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcRoofTypeEnum = ENUMERATION OF</para>
	/// <para>	(FLAT_ROOF</para>
	/// <para>	,SHED_ROOF</para>
	/// <para>	,GABLE_ROOF</para>
	/// <para>	,HIP_ROOF</para>
	/// <para>	,HIPPED_GABLE_ROOF</para>
	/// <para>	,GAMBREL_ROOF</para>
	/// <para>	,MANSARD_ROOF</para>
	/// <para>	,BARREL_ROOF</para>
	/// <para>	,RAINBOW_ROOF</para>
	/// <para>	,BUTTERFLY_ROOF</para>
	/// <para>	,PAVILION_ROOF</para>
	/// <para>	,DOME_ROOF</para>
	/// <para>	,FREEFORM</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRoofTypeEnum
	{
		public static string FLAT_ROOF { get {return "FLAT_ROOF";} }
		public static string SHED_ROOF { get {return "SHED_ROOF";} }
		public static string GABLE_ROOF { get {return "GABLE_ROOF";} }
		public static string HIP_ROOF { get {return "HIP_ROOF";} }
		public static string HIPPED_GABLE_ROOF { get {return "HIPPED_GABLE_ROOF";} }
		public static string GAMBREL_ROOF { get {return "GAMBREL_ROOF";} }
		public static string MANSARD_ROOF { get {return "MANSARD_ROOF";} }
		public static string BARREL_ROOF { get {return "BARREL_ROOF";} }
		public static string RAINBOW_ROOF { get {return "RAINBOW_ROOF";} }
		public static string BUTTERFLY_ROOF { get {return "BUTTERFLY_ROOF";} }
		public static string PAVILION_ROOF { get {return "PAVILION_ROOF";} }
		public static string DOME_ROOF { get {return "DOME_ROOF";} }
		public static string FREEFORM { get {return "FREEFORM";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcRoofTypeEnum(string value) { return new IfcRoofTypeEnum(string);}
		public static implicit operator string(IfcRoofTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSIPrefix = ENUMERATION OF
	/// <para>TYPE IfcSIPrefix = ENUMERATION OF</para>
	/// <para>	(EXA</para>
	/// <para>	,PETA</para>
	/// <para>	,TERA</para>
	/// <para>	,GIGA</para>
	/// <para>	,MEGA</para>
	/// <para>	,KILO</para>
	/// <para>	,HECTO</para>
	/// <para>	,DECA</para>
	/// <para>	,DECI</para>
	/// <para>	,CENTI</para>
	/// <para>	,MILLI</para>
	/// <para>	,MICRO</para>
	/// <para>	,NANO</para>
	/// <para>	,PICO</para>
	/// <para>	,FEMTO</para>
	/// <para>	,ATTO);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSIPrefix
	{
		public static string EXA { get {return "EXA";} }
		public static string PETA { get {return "PETA";} }
		public static string TERA { get {return "TERA";} }
		public static string GIGA { get {return "GIGA";} }
		public static string MEGA { get {return "MEGA";} }
		public static string KILO { get {return "KILO";} }
		public static string HECTO { get {return "HECTO";} }
		public static string DECA { get {return "DECA";} }
		public static string DECI { get {return "DECI";} }
		public static string CENTI { get {return "CENTI";} }
		public static string MILLI { get {return "MILLI";} }
		public static string MICRO { get {return "MICRO";} }
		public static string NANO { get {return "NANO";} }
		public static string PICO { get {return "PICO";} }
		public static string FEMTO { get {return "FEMTO";} }
		public static string ATTO { get {return "ATTO";} }
		public static implicit operator IfcSIPrefix(string value) { return new IfcSIPrefix(string);}
		public static implicit operator string(IfcSIPrefix value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSIUnitName = ENUMERATION OF
	/// <para>TYPE IfcSIUnitName = ENUMERATION OF</para>
	/// <para>	(AMPERE</para>
	/// <para>	,BECQUEREL</para>
	/// <para>	,CANDELA</para>
	/// <para>	,COULOMB</para>
	/// <para>	,CUBIC_METRE</para>
	/// <para>	,DEGREE_CELSIUS</para>
	/// <para>	,FARAD</para>
	/// <para>	,GRAM</para>
	/// <para>	,GRAY</para>
	/// <para>	,HENRY</para>
	/// <para>	,HERTZ</para>
	/// <para>	,JOULE</para>
	/// <para>	,KELVIN</para>
	/// <para>	,LUMEN</para>
	/// <para>	,LUX</para>
	/// <para>	,METRE</para>
	/// <para>	,MOLE</para>
	/// <para>	,NEWTON</para>
	/// <para>	,OHM</para>
	/// <para>	,PASCAL</para>
	/// <para>	,RADIAN</para>
	/// <para>	,SECOND</para>
	/// <para>	,SIEMENS</para>
	/// <para>	,SIEVERT</para>
	/// <para>	,SQUARE_METRE</para>
	/// <para>	,STERADIAN</para>
	/// <para>	,TESLA</para>
	/// <para>	,VOLT</para>
	/// <para>	,WATT</para>
	/// <para>	,WEBER);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSIUnitName
	{
		public static string AMPERE { get {return "AMPERE";} }
		public static string BECQUEREL { get {return "BECQUEREL";} }
		public static string CANDELA { get {return "CANDELA";} }
		public static string COULOMB { get {return "COULOMB";} }
		public static string CUBIC_METRE { get {return "CUBIC_METRE";} }
		public static string DEGREE_CELSIUS { get {return "DEGREE_CELSIUS";} }
		public static string FARAD { get {return "FARAD";} }
		public static string GRAM { get {return "GRAM";} }
		public static string GRAY { get {return "GRAY";} }
		public static string HENRY { get {return "HENRY";} }
		public static string HERTZ { get {return "HERTZ";} }
		public static string JOULE { get {return "JOULE";} }
		public static string KELVIN { get {return "KELVIN";} }
		public static string LUMEN { get {return "LUMEN";} }
		public static string LUX { get {return "LUX";} }
		public static string METRE { get {return "METRE";} }
		public static string MOLE { get {return "MOLE";} }
		public static string NEWTON { get {return "NEWTON";} }
		public static string OHM { get {return "OHM";} }
		public static string PASCAL { get {return "PASCAL";} }
		public static string RADIAN { get {return "RADIAN";} }
		public static string SECOND { get {return "SECOND";} }
		public static string SIEMENS { get {return "SIEMENS";} }
		public static string SIEVERT { get {return "SIEVERT";} }
		public static string SQUARE_METRE { get {return "SQUARE_METRE";} }
		public static string STERADIAN { get {return "STERADIAN";} }
		public static string TESLA { get {return "TESLA";} }
		public static string VOLT { get {return "VOLT";} }
		public static string WATT { get {return "WATT";} }
		public static string WEBER { get {return "WEBER";} }
		public static implicit operator IfcSIUnitName(string value) { return new IfcSIUnitName(string);}
		public static implicit operator string(IfcSIUnitName value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSanitaryTerminalTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSanitaryTerminalTypeEnum = ENUMERATION OF</para>
	/// <para>	(BATH</para>
	/// <para>	,BIDET</para>
	/// <para>	,CISTERN</para>
	/// <para>	,SHOWER</para>
	/// <para>	,SINK</para>
	/// <para>	,SANITARYFOUNTAIN</para>
	/// <para>	,TOILETPAN</para>
	/// <para>	,URINAL</para>
	/// <para>	,WASHHANDBASIN</para>
	/// <para>	,WCSEAT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSanitaryTerminalTypeEnum
	{
		public static string BATH { get {return "BATH";} }
		public static string BIDET { get {return "BIDET";} }
		public static string CISTERN { get {return "CISTERN";} }
		public static string SHOWER { get {return "SHOWER";} }
		public static string SINK { get {return "SINK";} }
		public static string SANITARYFOUNTAIN { get {return "SANITARYFOUNTAIN";} }
		public static string TOILETPAN { get {return "TOILETPAN";} }
		public static string URINAL { get {return "URINAL";} }
		public static string WASHHANDBASIN { get {return "WASHHANDBASIN";} }
		public static string WCSEAT { get {return "WCSEAT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSanitaryTerminalTypeEnum(string value) { return new IfcSanitaryTerminalTypeEnum(string);}
		public static implicit operator string(IfcSanitaryTerminalTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSectionTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSectionTypeEnum = ENUMERATION OF</para>
	/// <para>	(UNIFORM</para>
	/// <para>	,TAPERED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSectionTypeEnum
	{
		public static string UNIFORM { get {return "UNIFORM";} }
		public static string TAPERED { get {return "TAPERED";} }
		public static implicit operator IfcSectionTypeEnum(string value) { return new IfcSectionTypeEnum(string);}
		public static implicit operator string(IfcSectionTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSensorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSensorTypeEnum = ENUMERATION OF</para>
	/// <para>	(COSENSOR</para>
	/// <para>	,CO2SENSOR</para>
	/// <para>	,CONDUCTANCESENSOR</para>
	/// <para>	,CONTACTSENSOR</para>
	/// <para>	,FIRESENSOR</para>
	/// <para>	,FLOWSENSOR</para>
	/// <para>	,FROSTSENSOR</para>
	/// <para>	,GASSENSOR</para>
	/// <para>	,HEATSENSOR</para>
	/// <para>	,HUMIDITYSENSOR</para>
	/// <para>	,IDENTIFIERSENSOR</para>
	/// <para>	,IONCONCENTRATIONSENSOR</para>
	/// <para>	,LEVELSENSOR</para>
	/// <para>	,LIGHTSENSOR</para>
	/// <para>	,MOISTURESENSOR</para>
	/// <para>	,MOVEMENTSENSOR</para>
	/// <para>	,PHSENSOR</para>
	/// <para>	,PRESSURESENSOR</para>
	/// <para>	,RADIATIONSENSOR</para>
	/// <para>	,RADIOACTIVITYSENSOR</para>
	/// <para>	,SMOKESENSOR</para>
	/// <para>	,SOUNDSENSOR</para>
	/// <para>	,TEMPERATURESENSOR</para>
	/// <para>	,WINDSENSOR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSensorTypeEnum
	{
		public static string COSENSOR { get {return "COSENSOR";} }
		public static string CO2SENSOR { get {return "CO2SENSOR";} }
		public static string CONDUCTANCESENSOR { get {return "CONDUCTANCESENSOR";} }
		public static string CONTACTSENSOR { get {return "CONTACTSENSOR";} }
		public static string FIRESENSOR { get {return "FIRESENSOR";} }
		public static string FLOWSENSOR { get {return "FLOWSENSOR";} }
		public static string FROSTSENSOR { get {return "FROSTSENSOR";} }
		public static string GASSENSOR { get {return "GASSENSOR";} }
		public static string HEATSENSOR { get {return "HEATSENSOR";} }
		public static string HUMIDITYSENSOR { get {return "HUMIDITYSENSOR";} }
		public static string IDENTIFIERSENSOR { get {return "IDENTIFIERSENSOR";} }
		public static string IONCONCENTRATIONSENSOR { get {return "IONCONCENTRATIONSENSOR";} }
		public static string LEVELSENSOR { get {return "LEVELSENSOR";} }
		public static string LIGHTSENSOR { get {return "LIGHTSENSOR";} }
		public static string MOISTURESENSOR { get {return "MOISTURESENSOR";} }
		public static string MOVEMENTSENSOR { get {return "MOVEMENTSENSOR";} }
		public static string PHSENSOR { get {return "PHSENSOR";} }
		public static string PRESSURESENSOR { get {return "PRESSURESENSOR";} }
		public static string RADIATIONSENSOR { get {return "RADIATIONSENSOR";} }
		public static string RADIOACTIVITYSENSOR { get {return "RADIOACTIVITYSENSOR";} }
		public static string SMOKESENSOR { get {return "SMOKESENSOR";} }
		public static string SOUNDSENSOR { get {return "SOUNDSENSOR";} }
		public static string TEMPERATURESENSOR { get {return "TEMPERATURESENSOR";} }
		public static string WINDSENSOR { get {return "WINDSENSOR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSensorTypeEnum(string value) { return new IfcSensorTypeEnum(string);}
		public static implicit operator string(IfcSensorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSequenceEnum = ENUMERATION OF
	/// <para>TYPE IfcSequenceEnum = ENUMERATION OF</para>
	/// <para>	(START_START</para>
	/// <para>	,START_FINISH</para>
	/// <para>	,FINISH_START</para>
	/// <para>	,FINISH_FINISH</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSequenceEnum
	{
		public static string START_START { get {return "START_START";} }
		public static string START_FINISH { get {return "START_FINISH";} }
		public static string FINISH_START { get {return "FINISH_START";} }
		public static string FINISH_FINISH { get {return "FINISH_FINISH";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSequenceEnum(string value) { return new IfcSequenceEnum(string);}
		public static implicit operator string(IfcSequenceEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcShadingDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcShadingDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>	(JALOUSIE</para>
	/// <para>	,SHUTTER</para>
	/// <para>	,AWNING</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcShadingDeviceTypeEnum
	{
		public static string JALOUSIE { get {return "JALOUSIE";} }
		public static string SHUTTER { get {return "SHUTTER";} }
		public static string AWNING { get {return "AWNING";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcShadingDeviceTypeEnum(string value) { return new IfcShadingDeviceTypeEnum(string);}
		public static implicit operator string(IfcShadingDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSimplePropertyTemplateTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSimplePropertyTemplateTypeEnum = ENUMERATION OF</para>
	/// <para>	(P_SINGLEVALUE</para>
	/// <para>	,P_ENUMERATEDVALUE</para>
	/// <para>	,P_BOUNDEDVALUE</para>
	/// <para>	,P_LISTVALUE</para>
	/// <para>	,P_TABLEVALUE</para>
	/// <para>	,P_REFERENCEVALUE</para>
	/// <para>	,Q_LENGTH</para>
	/// <para>	,Q_AREA</para>
	/// <para>	,Q_VOLUME</para>
	/// <para>	,Q_COUNT</para>
	/// <para>	,Q_WEIGHT</para>
	/// <para>	,Q_TIME);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSimplePropertyTemplateTypeEnum
	{
		public static string P_SINGLEVALUE { get {return "P_SINGLEVALUE";} }
		public static string P_ENUMERATEDVALUE { get {return "P_ENUMERATEDVALUE";} }
		public static string P_BOUNDEDVALUE { get {return "P_BOUNDEDVALUE";} }
		public static string P_LISTVALUE { get {return "P_LISTVALUE";} }
		public static string P_TABLEVALUE { get {return "P_TABLEVALUE";} }
		public static string P_REFERENCEVALUE { get {return "P_REFERENCEVALUE";} }
		public static string Q_LENGTH { get {return "Q_LENGTH";} }
		public static string Q_AREA { get {return "Q_AREA";} }
		public static string Q_VOLUME { get {return "Q_VOLUME";} }
		public static string Q_COUNT { get {return "Q_COUNT";} }
		public static string Q_WEIGHT { get {return "Q_WEIGHT";} }
		public static string Q_TIME { get {return "Q_TIME";} }
		public static implicit operator IfcSimplePropertyTemplateTypeEnum(string value) { return new IfcSimplePropertyTemplateTypeEnum(string);}
		public static implicit operator string(IfcSimplePropertyTemplateTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSlabTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSlabTypeEnum = ENUMERATION OF</para>
	/// <para>	(FLOOR</para>
	/// <para>	,ROOF</para>
	/// <para>	,LANDING</para>
	/// <para>	,BASESLAB</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSlabTypeEnum
	{
		public static string FLOOR { get {return "FLOOR";} }
		public static string ROOF { get {return "ROOF";} }
		public static string LANDING { get {return "LANDING";} }
		public static string BASESLAB { get {return "BASESLAB";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSlabTypeEnum(string value) { return new IfcSlabTypeEnum(string);}
		public static implicit operator string(IfcSlabTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSolarDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSolarDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>	(SOLARCOLLECTOR</para>
	/// <para>	,SOLARPANEL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSolarDeviceTypeEnum
	{
		public static string SOLARCOLLECTOR { get {return "SOLARCOLLECTOR";} }
		public static string SOLARPANEL { get {return "SOLARPANEL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSolarDeviceTypeEnum(string value) { return new IfcSolarDeviceTypeEnum(string);}
		public static implicit operator string(IfcSolarDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpaceHeaterTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSpaceHeaterTypeEnum = ENUMERATION OF</para>
	/// <para>	(CONVECTOR</para>
	/// <para>	,RADIATOR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpaceHeaterTypeEnum
	{
		public static string CONVECTOR { get {return "CONVECTOR";} }
		public static string RADIATOR { get {return "RADIATOR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSpaceHeaterTypeEnum(string value) { return new IfcSpaceHeaterTypeEnum(string);}
		public static implicit operator string(IfcSpaceHeaterTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpaceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSpaceTypeEnum = ENUMERATION OF</para>
	/// <para>	(SPACE</para>
	/// <para>	,PARKING</para>
	/// <para>	,GFA</para>
	/// <para>	,INTERNAL</para>
	/// <para>	,EXTERNAL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpaceTypeEnum
	{
		public static string SPACE { get {return "SPACE";} }
		public static string PARKING { get {return "PARKING";} }
		public static string GFA { get {return "GFA";} }
		public static string INTERNAL { get {return "INTERNAL";} }
		public static string EXTERNAL { get {return "EXTERNAL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSpaceTypeEnum(string value) { return new IfcSpaceTypeEnum(string);}
		public static implicit operator string(IfcSpaceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpatialZoneTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSpatialZoneTypeEnum = ENUMERATION OF</para>
	/// <para>	(CONSTRUCTION</para>
	/// <para>	,FIRESAFETY</para>
	/// <para>	,LIGHTING</para>
	/// <para>	,OCCUPANCY</para>
	/// <para>	,SECURITY</para>
	/// <para>	,THERMAL</para>
	/// <para>	,TRANSPORT</para>
	/// <para>	,VENTILATION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpatialZoneTypeEnum
	{
		public static string CONSTRUCTION { get {return "CONSTRUCTION";} }
		public static string FIRESAFETY { get {return "FIRESAFETY";} }
		public static string LIGHTING { get {return "LIGHTING";} }
		public static string OCCUPANCY { get {return "OCCUPANCY";} }
		public static string SECURITY { get {return "SECURITY";} }
		public static string THERMAL { get {return "THERMAL";} }
		public static string TRANSPORT { get {return "TRANSPORT";} }
		public static string VENTILATION { get {return "VENTILATION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSpatialZoneTypeEnum(string value) { return new IfcSpatialZoneTypeEnum(string);}
		public static implicit operator string(IfcSpatialZoneTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStackTerminalTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStackTerminalTypeEnum = ENUMERATION OF</para>
	/// <para>	(BIRDCAGE</para>
	/// <para>	,COWL</para>
	/// <para>	,RAINWATERHOPPER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStackTerminalTypeEnum
	{
		public static string BIRDCAGE { get {return "BIRDCAGE";} }
		public static string COWL { get {return "COWL";} }
		public static string RAINWATERHOPPER { get {return "RAINWATERHOPPER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcStackTerminalTypeEnum(string value) { return new IfcStackTerminalTypeEnum(string);}
		public static implicit operator string(IfcStackTerminalTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStairFlightTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStairFlightTypeEnum = ENUMERATION OF</para>
	/// <para>	(STRAIGHT</para>
	/// <para>	,WINDER</para>
	/// <para>	,SPIRAL</para>
	/// <para>	,CURVED</para>
	/// <para>	,FREEFORM</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStairFlightTypeEnum
	{
		public static string STRAIGHT { get {return "STRAIGHT";} }
		public static string WINDER { get {return "WINDER";} }
		public static string SPIRAL { get {return "SPIRAL";} }
		public static string CURVED { get {return "CURVED";} }
		public static string FREEFORM { get {return "FREEFORM";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcStairFlightTypeEnum(string value) { return new IfcStairFlightTypeEnum(string);}
		public static implicit operator string(IfcStairFlightTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStairTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStairTypeEnum = ENUMERATION OF</para>
	/// <para>	(STRAIGHT_RUN_STAIR</para>
	/// <para>	,TWO_STRAIGHT_RUN_STAIR</para>
	/// <para>	,QUARTER_WINDING_STAIR</para>
	/// <para>	,QUARTER_TURN_STAIR</para>
	/// <para>	,HALF_WINDING_STAIR</para>
	/// <para>	,HALF_TURN_STAIR</para>
	/// <para>	,TWO_QUARTER_WINDING_STAIR</para>
	/// <para>	,TWO_QUARTER_TURN_STAIR</para>
	/// <para>	,THREE_QUARTER_WINDING_STAIR</para>
	/// <para>	,THREE_QUARTER_TURN_STAIR</para>
	/// <para>	,SPIRAL_STAIR</para>
	/// <para>	,DOUBLE_RETURN_STAIR</para>
	/// <para>	,CURVED_RUN_STAIR</para>
	/// <para>	,TWO_CURVED_RUN_STAIR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStairTypeEnum
	{
		public static string STRAIGHT_RUN_STAIR { get {return "STRAIGHT_RUN_STAIR";} }
		public static string TWO_STRAIGHT_RUN_STAIR { get {return "TWO_STRAIGHT_RUN_STAIR";} }
		public static string QUARTER_WINDING_STAIR { get {return "QUARTER_WINDING_STAIR";} }
		public static string QUARTER_TURN_STAIR { get {return "QUARTER_TURN_STAIR";} }
		public static string HALF_WINDING_STAIR { get {return "HALF_WINDING_STAIR";} }
		public static string HALF_TURN_STAIR { get {return "HALF_TURN_STAIR";} }
		public static string TWO_QUARTER_WINDING_STAIR { get {return "TWO_QUARTER_WINDING_STAIR";} }
		public static string TWO_QUARTER_TURN_STAIR { get {return "TWO_QUARTER_TURN_STAIR";} }
		public static string THREE_QUARTER_WINDING_STAIR { get {return "THREE_QUARTER_WINDING_STAIR";} }
		public static string THREE_QUARTER_TURN_STAIR { get {return "THREE_QUARTER_TURN_STAIR";} }
		public static string SPIRAL_STAIR { get {return "SPIRAL_STAIR";} }
		public static string DOUBLE_RETURN_STAIR { get {return "DOUBLE_RETURN_STAIR";} }
		public static string CURVED_RUN_STAIR { get {return "CURVED_RUN_STAIR";} }
		public static string TWO_CURVED_RUN_STAIR { get {return "TWO_CURVED_RUN_STAIR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcStairTypeEnum(string value) { return new IfcStairTypeEnum(string);}
		public static implicit operator string(IfcStairTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStateEnum = ENUMERATION OF
	/// <para>TYPE IfcStateEnum = ENUMERATION OF</para>
	/// <para>	(READWRITE</para>
	/// <para>	,READONLY</para>
	/// <para>	,LOCKED</para>
	/// <para>	,READWRITELOCKED</para>
	/// <para>	,READONLYLOCKED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStateEnum
	{
		public static string READWRITE { get {return "READWRITE";} }
		public static string READONLY { get {return "READONLY";} }
		public static string LOCKED { get {return "LOCKED";} }
		public static string READWRITELOCKED { get {return "READWRITELOCKED";} }
		public static string READONLYLOCKED { get {return "READONLYLOCKED";} }
		public static implicit operator IfcStateEnum(string value) { return new IfcStateEnum(string);}
		public static implicit operator string(IfcStateEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStructuralCurveActivityTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStructuralCurveActivityTypeEnum = ENUMERATION OF</para>
	/// <para>	(CONST</para>
	/// <para>	,LINEAR</para>
	/// <para>	,POLYGONAL</para>
	/// <para>	,EQUIDISTANT</para>
	/// <para>	,SINUS</para>
	/// <para>	,PARABOLA</para>
	/// <para>	,DISCRETE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStructuralCurveActivityTypeEnum
	{
		public static string CONST { get {return "CONST";} }
		public static string LINEAR { get {return "LINEAR";} }
		public static string POLYGONAL { get {return "POLYGONAL";} }
		public static string EQUIDISTANT { get {return "EQUIDISTANT";} }
		public static string SINUS { get {return "SINUS";} }
		public static string PARABOLA { get {return "PARABOLA";} }
		public static string DISCRETE { get {return "DISCRETE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcStructuralCurveActivityTypeEnum(string value) { return new IfcStructuralCurveActivityTypeEnum(string);}
		public static implicit operator string(IfcStructuralCurveActivityTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStructuralCurveMemberTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStructuralCurveMemberTypeEnum = ENUMERATION OF</para>
	/// <para>	(RIGID_JOINED_MEMBER</para>
	/// <para>	,PIN_JOINED_MEMBER</para>
	/// <para>	,CABLE</para>
	/// <para>	,TENSION_MEMBER</para>
	/// <para>	,COMPRESSION_MEMBER</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStructuralCurveMemberTypeEnum
	{
		public static string RIGID_JOINED_MEMBER { get {return "RIGID_JOINED_MEMBER";} }
		public static string PIN_JOINED_MEMBER { get {return "PIN_JOINED_MEMBER";} }
		public static string CABLE { get {return "CABLE";} }
		public static string TENSION_MEMBER { get {return "TENSION_MEMBER";} }
		public static string COMPRESSION_MEMBER { get {return "COMPRESSION_MEMBER";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcStructuralCurveMemberTypeEnum(string value) { return new IfcStructuralCurveMemberTypeEnum(string);}
		public static implicit operator string(IfcStructuralCurveMemberTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStructuralSurfaceActivityTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStructuralSurfaceActivityTypeEnum = ENUMERATION OF</para>
	/// <para>	(CONST</para>
	/// <para>	,BILINEAR</para>
	/// <para>	,DISCRETE</para>
	/// <para>	,ISOCONTOUR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStructuralSurfaceActivityTypeEnum
	{
		public static string CONST { get {return "CONST";} }
		public static string BILINEAR { get {return "BILINEAR";} }
		public static string DISCRETE { get {return "DISCRETE";} }
		public static string ISOCONTOUR { get {return "ISOCONTOUR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcStructuralSurfaceActivityTypeEnum(string value) { return new IfcStructuralSurfaceActivityTypeEnum(string);}
		public static implicit operator string(IfcStructuralSurfaceActivityTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStructuralSurfaceMemberTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStructuralSurfaceMemberTypeEnum = ENUMERATION OF</para>
	/// <para>	(BENDING_ELEMENT</para>
	/// <para>	,MEMBRANE_ELEMENT</para>
	/// <para>	,SHELL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStructuralSurfaceMemberTypeEnum
	{
		public static string BENDING_ELEMENT { get {return "BENDING_ELEMENT";} }
		public static string MEMBRANE_ELEMENT { get {return "MEMBRANE_ELEMENT";} }
		public static string SHELL { get {return "SHELL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcStructuralSurfaceMemberTypeEnum(string value) { return new IfcStructuralSurfaceMemberTypeEnum(string);}
		public static implicit operator string(IfcStructuralSurfaceMemberTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSubContractResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSubContractResourceTypeEnum = ENUMERATION OF</para>
	/// <para>	(PURCHASE</para>
	/// <para>	,WORK</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSubContractResourceTypeEnum
	{
		public static string PURCHASE { get {return "PURCHASE";} }
		public static string WORK { get {return "WORK";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSubContractResourceTypeEnum(string value) { return new IfcSubContractResourceTypeEnum(string);}
		public static implicit operator string(IfcSubContractResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSurfaceFeatureTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSurfaceFeatureTypeEnum = ENUMERATION OF</para>
	/// <para>	(MARK</para>
	/// <para>	,TAG</para>
	/// <para>	,TREATMENT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSurfaceFeatureTypeEnum
	{
		public static string MARK { get {return "MARK";} }
		public static string TAG { get {return "TAG";} }
		public static string TREATMENT { get {return "TREATMENT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSurfaceFeatureTypeEnum(string value) { return new IfcSurfaceFeatureTypeEnum(string);}
		public static implicit operator string(IfcSurfaceFeatureTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSurfaceSide = ENUMERATION OF
	/// <para>TYPE IfcSurfaceSide = ENUMERATION OF</para>
	/// <para>	(POSITIVE</para>
	/// <para>	,NEGATIVE</para>
	/// <para>	,BOTH);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSurfaceSide
	{
		public static string POSITIVE { get {return "POSITIVE";} }
		public static string NEGATIVE { get {return "NEGATIVE";} }
		public static string BOTH { get {return "BOTH";} }
		public static implicit operator IfcSurfaceSide(string value) { return new IfcSurfaceSide(string);}
		public static implicit operator string(IfcSurfaceSide value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSwitchingDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSwitchingDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>	(CONTACTOR</para>
	/// <para>	,DIMMERSWITCH</para>
	/// <para>	,EMERGENCYSTOP</para>
	/// <para>	,KEYPAD</para>
	/// <para>	,MOMENTARYSWITCH</para>
	/// <para>	,SELECTORSWITCH</para>
	/// <para>	,STARTER</para>
	/// <para>	,SWITCHDISCONNECTOR</para>
	/// <para>	,TOGGLESWITCH</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSwitchingDeviceTypeEnum
	{
		public static string CONTACTOR { get {return "CONTACTOR";} }
		public static string DIMMERSWITCH { get {return "DIMMERSWITCH";} }
		public static string EMERGENCYSTOP { get {return "EMERGENCYSTOP";} }
		public static string KEYPAD { get {return "KEYPAD";} }
		public static string MOMENTARYSWITCH { get {return "MOMENTARYSWITCH";} }
		public static string SELECTORSWITCH { get {return "SELECTORSWITCH";} }
		public static string STARTER { get {return "STARTER";} }
		public static string SWITCHDISCONNECTOR { get {return "SWITCHDISCONNECTOR";} }
		public static string TOGGLESWITCH { get {return "TOGGLESWITCH";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSwitchingDeviceTypeEnum(string value) { return new IfcSwitchingDeviceTypeEnum(string);}
		public static implicit operator string(IfcSwitchingDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSystemFurnitureElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSystemFurnitureElementTypeEnum = ENUMERATION OF</para>
	/// <para>	(PANEL</para>
	/// <para>	,WORKSURFACE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSystemFurnitureElementTypeEnum
	{
		public static string PANEL { get {return "PANEL";} }
		public static string WORKSURFACE { get {return "WORKSURFACE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcSystemFurnitureElementTypeEnum(string value) { return new IfcSystemFurnitureElementTypeEnum(string);}
		public static implicit operator string(IfcSystemFurnitureElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTankTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTankTypeEnum = ENUMERATION OF</para>
	/// <para>	(BASIN</para>
	/// <para>	,BREAKPRESSURE</para>
	/// <para>	,EXPANSION</para>
	/// <para>	,FEEDANDEXPANSION</para>
	/// <para>	,PRESSUREVESSEL</para>
	/// <para>	,STORAGE</para>
	/// <para>	,VESSEL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTankTypeEnum
	{
		public static string BASIN { get {return "BASIN";} }
		public static string BREAKPRESSURE { get {return "BREAKPRESSURE";} }
		public static string EXPANSION { get {return "EXPANSION";} }
		public static string FEEDANDEXPANSION { get {return "FEEDANDEXPANSION";} }
		public static string PRESSUREVESSEL { get {return "PRESSUREVESSEL";} }
		public static string STORAGE { get {return "STORAGE";} }
		public static string VESSEL { get {return "VESSEL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcTankTypeEnum(string value) { return new IfcTankTypeEnum(string);}
		public static implicit operator string(IfcTankTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTaskDurationEnum = ENUMERATION OF
	/// <para>TYPE IfcTaskDurationEnum = ENUMERATION OF</para>
	/// <para>	(ELAPSEDTIME</para>
	/// <para>	,WORKTIME</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTaskDurationEnum
	{
		public static string ELAPSEDTIME { get {return "ELAPSEDTIME";} }
		public static string WORKTIME { get {return "WORKTIME";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcTaskDurationEnum(string value) { return new IfcTaskDurationEnum(string);}
		public static implicit operator string(IfcTaskDurationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTaskTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTaskTypeEnum = ENUMERATION OF</para>
	/// <para>	(ATTENDANCE</para>
	/// <para>	,CONSTRUCTION</para>
	/// <para>	,DEMOLITION</para>
	/// <para>	,DISMANTLE</para>
	/// <para>	,DISPOSAL</para>
	/// <para>	,INSTALLATION</para>
	/// <para>	,LOGISTIC</para>
	/// <para>	,MAINTENANCE</para>
	/// <para>	,MOVE</para>
	/// <para>	,OPERATION</para>
	/// <para>	,REMOVAL</para>
	/// <para>	,RENOVATION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTaskTypeEnum
	{
		public static string ATTENDANCE { get {return "ATTENDANCE";} }
		public static string CONSTRUCTION { get {return "CONSTRUCTION";} }
		public static string DEMOLITION { get {return "DEMOLITION";} }
		public static string DISMANTLE { get {return "DISMANTLE";} }
		public static string DISPOSAL { get {return "DISPOSAL";} }
		public static string INSTALLATION { get {return "INSTALLATION";} }
		public static string LOGISTIC { get {return "LOGISTIC";} }
		public static string MAINTENANCE { get {return "MAINTENANCE";} }
		public static string MOVE { get {return "MOVE";} }
		public static string OPERATION { get {return "OPERATION";} }
		public static string REMOVAL { get {return "REMOVAL";} }
		public static string RENOVATION { get {return "RENOVATION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcTaskTypeEnum(string value) { return new IfcTaskTypeEnum(string);}
		public static implicit operator string(IfcTaskTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTendonAnchorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTendonAnchorTypeEnum = ENUMERATION OF</para>
	/// <para>	(COUPLER</para>
	/// <para>	,FIXED_END</para>
	/// <para>	,TENSIONING_END</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTendonAnchorTypeEnum
	{
		public static string COUPLER { get {return "COUPLER";} }
		public static string FIXED_END { get {return "FIXED_END";} }
		public static string TENSIONING_END { get {return "TENSIONING_END";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcTendonAnchorTypeEnum(string value) { return new IfcTendonAnchorTypeEnum(string);}
		public static implicit operator string(IfcTendonAnchorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTendonTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTendonTypeEnum = ENUMERATION OF</para>
	/// <para>	(BAR</para>
	/// <para>	,COATED</para>
	/// <para>	,STRAND</para>
	/// <para>	,WIRE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTendonTypeEnum
	{
		public static string BAR { get {return "BAR";} }
		public static string COATED { get {return "COATED";} }
		public static string STRAND { get {return "STRAND";} }
		public static string WIRE { get {return "WIRE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcTendonTypeEnum(string value) { return new IfcTendonTypeEnum(string);}
		public static implicit operator string(IfcTendonTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextPath = ENUMERATION OF
	/// <para>TYPE IfcTextPath = ENUMERATION OF</para>
	/// <para>	(LEFT</para>
	/// <para>	,RIGHT</para>
	/// <para>	,UP</para>
	/// <para>	,DOWN);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextPath
	{
		public static string LEFT { get {return "LEFT";} }
		public static string RIGHT { get {return "RIGHT";} }
		public static string UP { get {return "UP";} }
		public static string DOWN { get {return "DOWN";} }
		public static implicit operator IfcTextPath(string value) { return new IfcTextPath(string);}
		public static implicit operator string(IfcTextPath value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTimeSeriesDataTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTimeSeriesDataTypeEnum = ENUMERATION OF</para>
	/// <para>	(CONTINUOUS</para>
	/// <para>	,DISCRETE</para>
	/// <para>	,DISCRETEBINARY</para>
	/// <para>	,PIECEWISEBINARY</para>
	/// <para>	,PIECEWISECONSTANT</para>
	/// <para>	,PIECEWISECONTINUOUS</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTimeSeriesDataTypeEnum
	{
		public static string CONTINUOUS { get {return "CONTINUOUS";} }
		public static string DISCRETE { get {return "DISCRETE";} }
		public static string DISCRETEBINARY { get {return "DISCRETEBINARY";} }
		public static string PIECEWISEBINARY { get {return "PIECEWISEBINARY";} }
		public static string PIECEWISECONSTANT { get {return "PIECEWISECONSTANT";} }
		public static string PIECEWISECONTINUOUS { get {return "PIECEWISECONTINUOUS";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcTimeSeriesDataTypeEnum(string value) { return new IfcTimeSeriesDataTypeEnum(string);}
		public static implicit operator string(IfcTimeSeriesDataTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTransformerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTransformerTypeEnum = ENUMERATION OF</para>
	/// <para>	(CURRENT</para>
	/// <para>	,FREQUENCY</para>
	/// <para>	,INVERTER</para>
	/// <para>	,RECTIFIER</para>
	/// <para>	,VOLTAGE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTransformerTypeEnum
	{
		public static string CURRENT { get {return "CURRENT";} }
		public static string FREQUENCY { get {return "FREQUENCY";} }
		public static string INVERTER { get {return "INVERTER";} }
		public static string RECTIFIER { get {return "RECTIFIER";} }
		public static string VOLTAGE { get {return "VOLTAGE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcTransformerTypeEnum(string value) { return new IfcTransformerTypeEnum(string);}
		public static implicit operator string(IfcTransformerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTransitionCode = ENUMERATION OF
	/// <para>TYPE IfcTransitionCode = ENUMERATION OF</para>
	/// <para>	(DISCONTINUOUS</para>
	/// <para>	,CONTINUOUS</para>
	/// <para>	,CONTSAMEGRADIENT</para>
	/// <para>	,CONTSAMEGRADIENTSAMECURVATURE);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTransitionCode
	{
		public static string DISCONTINUOUS { get {return "DISCONTINUOUS";} }
		public static string CONTINUOUS { get {return "CONTINUOUS";} }
		public static string CONTSAMEGRADIENT { get {return "CONTSAMEGRADIENT";} }
		public static string CONTSAMEGRADIENTSAMECURVATURE { get {return "CONTSAMEGRADIENTSAMECURVATURE";} }
		public static implicit operator IfcTransitionCode(string value) { return new IfcTransitionCode(string);}
		public static implicit operator string(IfcTransitionCode value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTransportElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTransportElementTypeEnum = ENUMERATION OF</para>
	/// <para>	(ELEVATOR</para>
	/// <para>	,ESCALATOR</para>
	/// <para>	,MOVINGWALKWAY</para>
	/// <para>	,CRANEWAY</para>
	/// <para>	,LIFTINGGEAR</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTransportElementTypeEnum
	{
		public static string ELEVATOR { get {return "ELEVATOR";} }
		public static string ESCALATOR { get {return "ESCALATOR";} }
		public static string MOVINGWALKWAY { get {return "MOVINGWALKWAY";} }
		public static string CRANEWAY { get {return "CRANEWAY";} }
		public static string LIFTINGGEAR { get {return "LIFTINGGEAR";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcTransportElementTypeEnum(string value) { return new IfcTransportElementTypeEnum(string);}
		public static implicit operator string(IfcTransportElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTrimmingPreference = ENUMERATION OF
	/// <para>TYPE IfcTrimmingPreference = ENUMERATION OF</para>
	/// <para>	(CARTESIAN</para>
	/// <para>	,PARAMETER</para>
	/// <para>	,UNSPECIFIED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTrimmingPreference
	{
		public static string CARTESIAN { get {return "CARTESIAN";} }
		public static string PARAMETER { get {return "PARAMETER";} }
		public static string UNSPECIFIED { get {return "UNSPECIFIED";} }
		public static implicit operator IfcTrimmingPreference(string value) { return new IfcTrimmingPreference(string);}
		public static implicit operator string(IfcTrimmingPreference value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTubeBundleTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTubeBundleTypeEnum = ENUMERATION OF</para>
	/// <para>	(FINNED</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTubeBundleTypeEnum
	{
		public static string FINNED { get {return "FINNED";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcTubeBundleTypeEnum(string value) { return new IfcTubeBundleTypeEnum(string);}
		public static implicit operator string(IfcTubeBundleTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcUnitEnum = ENUMERATION OF
	/// <para>TYPE IfcUnitEnum = ENUMERATION OF</para>
	/// <para>	(ABSORBEDDOSEUNIT</para>
	/// <para>	,AMOUNTOFSUBSTANCEUNIT</para>
	/// <para>	,AREAUNIT</para>
	/// <para>	,DOSEEQUIVALENTUNIT</para>
	/// <para>	,ELECTRICCAPACITANCEUNIT</para>
	/// <para>	,ELECTRICCHARGEUNIT</para>
	/// <para>	,ELECTRICCONDUCTANCEUNIT</para>
	/// <para>	,ELECTRICCURRENTUNIT</para>
	/// <para>	,ELECTRICRESISTANCEUNIT</para>
	/// <para>	,ELECTRICVOLTAGEUNIT</para>
	/// <para>	,ENERGYUNIT</para>
	/// <para>	,FORCEUNIT</para>
	/// <para>	,FREQUENCYUNIT</para>
	/// <para>	,ILLUMINANCEUNIT</para>
	/// <para>	,INDUCTANCEUNIT</para>
	/// <para>	,LENGTHUNIT</para>
	/// <para>	,LUMINOUSFLUXUNIT</para>
	/// <para>	,LUMINOUSINTENSITYUNIT</para>
	/// <para>	,MAGNETICFLUXDENSITYUNIT</para>
	/// <para>	,MAGNETICFLUXUNIT</para>
	/// <para>	,MASSUNIT</para>
	/// <para>	,PLANEANGLEUNIT</para>
	/// <para>	,POWERUNIT</para>
	/// <para>	,PRESSUREUNIT</para>
	/// <para>	,RADIOACTIVITYUNIT</para>
	/// <para>	,SOLIDANGLEUNIT</para>
	/// <para>	,THERMODYNAMICTEMPERATUREUNIT</para>
	/// <para>	,TIMEUNIT</para>
	/// <para>	,VOLUMEUNIT</para>
	/// <para>	,USERDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcUnitEnum
	{
		public static string ABSORBEDDOSEUNIT { get {return "ABSORBEDDOSEUNIT";} }
		public static string AMOUNTOFSUBSTANCEUNIT { get {return "AMOUNTOFSUBSTANCEUNIT";} }
		public static string AREAUNIT { get {return "AREAUNIT";} }
		public static string DOSEEQUIVALENTUNIT { get {return "DOSEEQUIVALENTUNIT";} }
		public static string ELECTRICCAPACITANCEUNIT { get {return "ELECTRICCAPACITANCEUNIT";} }
		public static string ELECTRICCHARGEUNIT { get {return "ELECTRICCHARGEUNIT";} }
		public static string ELECTRICCONDUCTANCEUNIT { get {return "ELECTRICCONDUCTANCEUNIT";} }
		public static string ELECTRICCURRENTUNIT { get {return "ELECTRICCURRENTUNIT";} }
		public static string ELECTRICRESISTANCEUNIT { get {return "ELECTRICRESISTANCEUNIT";} }
		public static string ELECTRICVOLTAGEUNIT { get {return "ELECTRICVOLTAGEUNIT";} }
		public static string ENERGYUNIT { get {return "ENERGYUNIT";} }
		public static string FORCEUNIT { get {return "FORCEUNIT";} }
		public static string FREQUENCYUNIT { get {return "FREQUENCYUNIT";} }
		public static string ILLUMINANCEUNIT { get {return "ILLUMINANCEUNIT";} }
		public static string INDUCTANCEUNIT { get {return "INDUCTANCEUNIT";} }
		public static string LENGTHUNIT { get {return "LENGTHUNIT";} }
		public static string LUMINOUSFLUXUNIT { get {return "LUMINOUSFLUXUNIT";} }
		public static string LUMINOUSINTENSITYUNIT { get {return "LUMINOUSINTENSITYUNIT";} }
		public static string MAGNETICFLUXDENSITYUNIT { get {return "MAGNETICFLUXDENSITYUNIT";} }
		public static string MAGNETICFLUXUNIT { get {return "MAGNETICFLUXUNIT";} }
		public static string MASSUNIT { get {return "MASSUNIT";} }
		public static string PLANEANGLEUNIT { get {return "PLANEANGLEUNIT";} }
		public static string POWERUNIT { get {return "POWERUNIT";} }
		public static string PRESSUREUNIT { get {return "PRESSUREUNIT";} }
		public static string RADIOACTIVITYUNIT { get {return "RADIOACTIVITYUNIT";} }
		public static string SOLIDANGLEUNIT { get {return "SOLIDANGLEUNIT";} }
		public static string THERMODYNAMICTEMPERATUREUNIT { get {return "THERMODYNAMICTEMPERATUREUNIT";} }
		public static string TIMEUNIT { get {return "TIMEUNIT";} }
		public static string VOLUMEUNIT { get {return "VOLUMEUNIT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static implicit operator IfcUnitEnum(string value) { return new IfcUnitEnum(string);}
		public static implicit operator string(IfcUnitEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcUnitaryControlElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcUnitaryControlElementTypeEnum = ENUMERATION OF</para>
	/// <para>	(ALARMPANEL</para>
	/// <para>	,CONTROLPANEL</para>
	/// <para>	,GASDETECTIONPANEL</para>
	/// <para>	,INDICATORPANEL</para>
	/// <para>	,MIMICPANEL</para>
	/// <para>	,HUMIDISTAT</para>
	/// <para>	,THERMOSTAT</para>
	/// <para>	,WEATHERSTATION</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcUnitaryControlElementTypeEnum
	{
		public static string ALARMPANEL { get {return "ALARMPANEL";} }
		public static string CONTROLPANEL { get {return "CONTROLPANEL";} }
		public static string GASDETECTIONPANEL { get {return "GASDETECTIONPANEL";} }
		public static string INDICATORPANEL { get {return "INDICATORPANEL";} }
		public static string MIMICPANEL { get {return "MIMICPANEL";} }
		public static string HUMIDISTAT { get {return "HUMIDISTAT";} }
		public static string THERMOSTAT { get {return "THERMOSTAT";} }
		public static string WEATHERSTATION { get {return "WEATHERSTATION";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcUnitaryControlElementTypeEnum(string value) { return new IfcUnitaryControlElementTypeEnum(string);}
		public static implicit operator string(IfcUnitaryControlElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcUnitaryEquipmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcUnitaryEquipmentTypeEnum = ENUMERATION OF</para>
	/// <para>	(AIRHANDLER</para>
	/// <para>	,AIRCONDITIONINGUNIT</para>
	/// <para>	,DEHUMIDIFIER</para>
	/// <para>	,SPLITSYSTEM</para>
	/// <para>	,ROOFTOPUNIT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcUnitaryEquipmentTypeEnum
	{
		public static string AIRHANDLER { get {return "AIRHANDLER";} }
		public static string AIRCONDITIONINGUNIT { get {return "AIRCONDITIONINGUNIT";} }
		public static string DEHUMIDIFIER { get {return "DEHUMIDIFIER";} }
		public static string SPLITSYSTEM { get {return "SPLITSYSTEM";} }
		public static string ROOFTOPUNIT { get {return "ROOFTOPUNIT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcUnitaryEquipmentTypeEnum(string value) { return new IfcUnitaryEquipmentTypeEnum(string);}
		public static implicit operator string(IfcUnitaryEquipmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcValveTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcValveTypeEnum = ENUMERATION OF</para>
	/// <para>	(AIRRELEASE</para>
	/// <para>	,ANTIVACUUM</para>
	/// <para>	,CHANGEOVER</para>
	/// <para>	,CHECK</para>
	/// <para>	,COMMISSIONING</para>
	/// <para>	,DIVERTING</para>
	/// <para>	,DRAWOFFCOCK</para>
	/// <para>	,DOUBLECHECK</para>
	/// <para>	,DOUBLEREGULATING</para>
	/// <para>	,FAUCET</para>
	/// <para>	,FLUSHING</para>
	/// <para>	,GASCOCK</para>
	/// <para>	,GASTAP</para>
	/// <para>	,ISOLATING</para>
	/// <para>	,MIXING</para>
	/// <para>	,PRESSUREREDUCING</para>
	/// <para>	,PRESSURERELIEF</para>
	/// <para>	,REGULATING</para>
	/// <para>	,SAFETYCUTOFF</para>
	/// <para>	,STEAMTRAP</para>
	/// <para>	,STOPCOCK</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcValveTypeEnum
	{
		public static string AIRRELEASE { get {return "AIRRELEASE";} }
		public static string ANTIVACUUM { get {return "ANTIVACUUM";} }
		public static string CHANGEOVER { get {return "CHANGEOVER";} }
		public static string CHECK { get {return "CHECK";} }
		public static string COMMISSIONING { get {return "COMMISSIONING";} }
		public static string DIVERTING { get {return "DIVERTING";} }
		public static string DRAWOFFCOCK { get {return "DRAWOFFCOCK";} }
		public static string DOUBLECHECK { get {return "DOUBLECHECK";} }
		public static string DOUBLEREGULATING { get {return "DOUBLEREGULATING";} }
		public static string FAUCET { get {return "FAUCET";} }
		public static string FLUSHING { get {return "FLUSHING";} }
		public static string GASCOCK { get {return "GASCOCK";} }
		public static string GASTAP { get {return "GASTAP";} }
		public static string ISOLATING { get {return "ISOLATING";} }
		public static string MIXING { get {return "MIXING";} }
		public static string PRESSUREREDUCING { get {return "PRESSUREREDUCING";} }
		public static string PRESSURERELIEF { get {return "PRESSURERELIEF";} }
		public static string REGULATING { get {return "REGULATING";} }
		public static string SAFETYCUTOFF { get {return "SAFETYCUTOFF";} }
		public static string STEAMTRAP { get {return "STEAMTRAP";} }
		public static string STOPCOCK { get {return "STOPCOCK";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcValveTypeEnum(string value) { return new IfcValveTypeEnum(string);}
		public static implicit operator string(IfcValveTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVibrationIsolatorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcVibrationIsolatorTypeEnum = ENUMERATION OF</para>
	/// <para>	(COMPRESSION</para>
	/// <para>	,SPRING</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVibrationIsolatorTypeEnum
	{
		public static string COMPRESSION { get {return "COMPRESSION";} }
		public static string SPRING { get {return "SPRING";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcVibrationIsolatorTypeEnum(string value) { return new IfcVibrationIsolatorTypeEnum(string);}
		public static implicit operator string(IfcVibrationIsolatorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVoidingFeatureTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcVoidingFeatureTypeEnum = ENUMERATION OF</para>
	/// <para>	(CUTOUT</para>
	/// <para>	,NOTCH</para>
	/// <para>	,HOLE</para>
	/// <para>	,MITER</para>
	/// <para>	,CHAMFER</para>
	/// <para>	,EDGE</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVoidingFeatureTypeEnum
	{
		public static string CUTOUT { get {return "CUTOUT";} }
		public static string NOTCH { get {return "NOTCH";} }
		public static string HOLE { get {return "HOLE";} }
		public static string MITER { get {return "MITER";} }
		public static string CHAMFER { get {return "CHAMFER";} }
		public static string EDGE { get {return "EDGE";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcVoidingFeatureTypeEnum(string value) { return new IfcVoidingFeatureTypeEnum(string);}
		public static implicit operator string(IfcVoidingFeatureTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWallTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWallTypeEnum = ENUMERATION OF</para>
	/// <para>	(MOVABLE</para>
	/// <para>	,PARAPET</para>
	/// <para>	,PARTITIONING</para>
	/// <para>	,PLUMBINGWALL</para>
	/// <para>	,SHEAR</para>
	/// <para>	,SOLIDWALL</para>
	/// <para>	,STANDARD</para>
	/// <para>	,POLYGONAL</para>
	/// <para>	,ELEMENTEDWALL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWallTypeEnum
	{
		public static string MOVABLE { get {return "MOVABLE";} }
		public static string PARAPET { get {return "PARAPET";} }
		public static string PARTITIONING { get {return "PARTITIONING";} }
		public static string PLUMBINGWALL { get {return "PLUMBINGWALL";} }
		public static string SHEAR { get {return "SHEAR";} }
		public static string SOLIDWALL { get {return "SOLIDWALL";} }
		public static string STANDARD { get {return "STANDARD";} }
		public static string POLYGONAL { get {return "POLYGONAL";} }
		public static string ELEMENTEDWALL { get {return "ELEMENTEDWALL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWallTypeEnum(string value) { return new IfcWallTypeEnum(string);}
		public static implicit operator string(IfcWallTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWasteTerminalTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWasteTerminalTypeEnum = ENUMERATION OF</para>
	/// <para>	(FLOORTRAP</para>
	/// <para>	,FLOORWASTE</para>
	/// <para>	,GULLYSUMP</para>
	/// <para>	,GULLYTRAP</para>
	/// <para>	,ROOFDRAIN</para>
	/// <para>	,WASTEDISPOSALUNIT</para>
	/// <para>	,WASTETRAP</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWasteTerminalTypeEnum
	{
		public static string FLOORTRAP { get {return "FLOORTRAP";} }
		public static string FLOORWASTE { get {return "FLOORWASTE";} }
		public static string GULLYSUMP { get {return "GULLYSUMP";} }
		public static string GULLYTRAP { get {return "GULLYTRAP";} }
		public static string ROOFDRAIN { get {return "ROOFDRAIN";} }
		public static string WASTEDISPOSALUNIT { get {return "WASTEDISPOSALUNIT";} }
		public static string WASTETRAP { get {return "WASTETRAP";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWasteTerminalTypeEnum(string value) { return new IfcWasteTerminalTypeEnum(string);}
		public static implicit operator string(IfcWasteTerminalTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowPanelOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowPanelOperationEnum = ENUMERATION OF</para>
	/// <para>	(SIDEHUNGRIGHTHAND</para>
	/// <para>	,SIDEHUNGLEFTHAND</para>
	/// <para>	,TILTANDTURNRIGHTHAND</para>
	/// <para>	,TILTANDTURNLEFTHAND</para>
	/// <para>	,TOPHUNG</para>
	/// <para>	,BOTTOMHUNG</para>
	/// <para>	,PIVOTHORIZONTAL</para>
	/// <para>	,PIVOTVERTICAL</para>
	/// <para>	,SLIDINGHORIZONTAL</para>
	/// <para>	,SLIDINGVERTICAL</para>
	/// <para>	,REMOVABLECASEMENT</para>
	/// <para>	,FIXEDCASEMENT</para>
	/// <para>	,OTHEROPERATION</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowPanelOperationEnum
	{
		public static string SIDEHUNGRIGHTHAND { get {return "SIDEHUNGRIGHTHAND";} }
		public static string SIDEHUNGLEFTHAND { get {return "SIDEHUNGLEFTHAND";} }
		public static string TILTANDTURNRIGHTHAND { get {return "TILTANDTURNRIGHTHAND";} }
		public static string TILTANDTURNLEFTHAND { get {return "TILTANDTURNLEFTHAND";} }
		public static string TOPHUNG { get {return "TOPHUNG";} }
		public static string BOTTOMHUNG { get {return "BOTTOMHUNG";} }
		public static string PIVOTHORIZONTAL { get {return "PIVOTHORIZONTAL";} }
		public static string PIVOTVERTICAL { get {return "PIVOTVERTICAL";} }
		public static string SLIDINGHORIZONTAL { get {return "SLIDINGHORIZONTAL";} }
		public static string SLIDINGVERTICAL { get {return "SLIDINGVERTICAL";} }
		public static string REMOVABLECASEMENT { get {return "REMOVABLECASEMENT";} }
		public static string FIXEDCASEMENT { get {return "FIXEDCASEMENT";} }
		public static string OTHEROPERATION { get {return "OTHEROPERATION";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWindowPanelOperationEnum(string value) { return new IfcWindowPanelOperationEnum(string);}
		public static implicit operator string(IfcWindowPanelOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowPanelPositionEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowPanelPositionEnum = ENUMERATION OF</para>
	/// <para>	(LEFT</para>
	/// <para>	,MIDDLE</para>
	/// <para>	,RIGHT</para>
	/// <para>	,BOTTOM</para>
	/// <para>	,TOP</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowPanelPositionEnum
	{
		public static string LEFT { get {return "LEFT";} }
		public static string MIDDLE { get {return "MIDDLE";} }
		public static string RIGHT { get {return "RIGHT";} }
		public static string BOTTOM { get {return "BOTTOM";} }
		public static string TOP { get {return "TOP";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWindowPanelPositionEnum(string value) { return new IfcWindowPanelPositionEnum(string);}
		public static implicit operator string(IfcWindowPanelPositionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowStyleConstructionEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowStyleConstructionEnum = ENUMERATION OF</para>
	/// <para>	(ALUMINIUM</para>
	/// <para>	,HIGH_GRADE_STEEL</para>
	/// <para>	,STEEL</para>
	/// <para>	,WOOD</para>
	/// <para>	,ALUMINIUM_WOOD</para>
	/// <para>	,PLASTIC</para>
	/// <para>	,OTHER_CONSTRUCTION</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowStyleConstructionEnum
	{
		public static string ALUMINIUM { get {return "ALUMINIUM";} }
		public static string HIGH_GRADE_STEEL { get {return "HIGH_GRADE_STEEL";} }
		public static string STEEL { get {return "STEEL";} }
		public static string WOOD { get {return "WOOD";} }
		public static string ALUMINIUM_WOOD { get {return "ALUMINIUM_WOOD";} }
		public static string PLASTIC { get {return "PLASTIC";} }
		public static string OTHER_CONSTRUCTION { get {return "OTHER_CONSTRUCTION";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWindowStyleConstructionEnum(string value) { return new IfcWindowStyleConstructionEnum(string);}
		public static implicit operator string(IfcWindowStyleConstructionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowStyleOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowStyleOperationEnum = ENUMERATION OF</para>
	/// <para>	(SINGLE_PANEL</para>
	/// <para>	,DOUBLE_PANEL_VERTICAL</para>
	/// <para>	,DOUBLE_PANEL_HORIZONTAL</para>
	/// <para>	,TRIPLE_PANEL_VERTICAL</para>
	/// <para>	,TRIPLE_PANEL_BOTTOM</para>
	/// <para>	,TRIPLE_PANEL_TOP</para>
	/// <para>	,TRIPLE_PANEL_LEFT</para>
	/// <para>	,TRIPLE_PANEL_RIGHT</para>
	/// <para>	,TRIPLE_PANEL_HORIZONTAL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowStyleOperationEnum
	{
		public static string SINGLE_PANEL { get {return "SINGLE_PANEL";} }
		public static string DOUBLE_PANEL_VERTICAL { get {return "DOUBLE_PANEL_VERTICAL";} }
		public static string DOUBLE_PANEL_HORIZONTAL { get {return "DOUBLE_PANEL_HORIZONTAL";} }
		public static string TRIPLE_PANEL_VERTICAL { get {return "TRIPLE_PANEL_VERTICAL";} }
		public static string TRIPLE_PANEL_BOTTOM { get {return "TRIPLE_PANEL_BOTTOM";} }
		public static string TRIPLE_PANEL_TOP { get {return "TRIPLE_PANEL_TOP";} }
		public static string TRIPLE_PANEL_LEFT { get {return "TRIPLE_PANEL_LEFT";} }
		public static string TRIPLE_PANEL_RIGHT { get {return "TRIPLE_PANEL_RIGHT";} }
		public static string TRIPLE_PANEL_HORIZONTAL { get {return "TRIPLE_PANEL_HORIZONTAL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWindowStyleOperationEnum(string value) { return new IfcWindowStyleOperationEnum(string);}
		public static implicit operator string(IfcWindowStyleOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowTypeEnum = ENUMERATION OF</para>
	/// <para>	(WINDOW</para>
	/// <para>	,SKYLIGHT</para>
	/// <para>	,LIGHTDOME</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowTypeEnum
	{
		public static string WINDOW { get {return "WINDOW";} }
		public static string SKYLIGHT { get {return "SKYLIGHT";} }
		public static string LIGHTDOME { get {return "LIGHTDOME";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWindowTypeEnum(string value) { return new IfcWindowTypeEnum(string);}
		public static implicit operator string(IfcWindowTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowTypePartitioningEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowTypePartitioningEnum = ENUMERATION OF</para>
	/// <para>	(SINGLE_PANEL</para>
	/// <para>	,DOUBLE_PANEL_VERTICAL</para>
	/// <para>	,DOUBLE_PANEL_HORIZONTAL</para>
	/// <para>	,TRIPLE_PANEL_VERTICAL</para>
	/// <para>	,TRIPLE_PANEL_BOTTOM</para>
	/// <para>	,TRIPLE_PANEL_TOP</para>
	/// <para>	,TRIPLE_PANEL_LEFT</para>
	/// <para>	,TRIPLE_PANEL_RIGHT</para>
	/// <para>	,TRIPLE_PANEL_HORIZONTAL</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowTypePartitioningEnum
	{
		public static string SINGLE_PANEL { get {return "SINGLE_PANEL";} }
		public static string DOUBLE_PANEL_VERTICAL { get {return "DOUBLE_PANEL_VERTICAL";} }
		public static string DOUBLE_PANEL_HORIZONTAL { get {return "DOUBLE_PANEL_HORIZONTAL";} }
		public static string TRIPLE_PANEL_VERTICAL { get {return "TRIPLE_PANEL_VERTICAL";} }
		public static string TRIPLE_PANEL_BOTTOM { get {return "TRIPLE_PANEL_BOTTOM";} }
		public static string TRIPLE_PANEL_TOP { get {return "TRIPLE_PANEL_TOP";} }
		public static string TRIPLE_PANEL_LEFT { get {return "TRIPLE_PANEL_LEFT";} }
		public static string TRIPLE_PANEL_RIGHT { get {return "TRIPLE_PANEL_RIGHT";} }
		public static string TRIPLE_PANEL_HORIZONTAL { get {return "TRIPLE_PANEL_HORIZONTAL";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWindowTypePartitioningEnum(string value) { return new IfcWindowTypePartitioningEnum(string);}
		public static implicit operator string(IfcWindowTypePartitioningEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWorkCalendarTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWorkCalendarTypeEnum = ENUMERATION OF</para>
	/// <para>	(FIRSTSHIFT</para>
	/// <para>	,SECONDSHIFT</para>
	/// <para>	,THIRDSHIFT</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWorkCalendarTypeEnum
	{
		public static string FIRSTSHIFT { get {return "FIRSTSHIFT";} }
		public static string SECONDSHIFT { get {return "SECONDSHIFT";} }
		public static string THIRDSHIFT { get {return "THIRDSHIFT";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWorkCalendarTypeEnum(string value) { return new IfcWorkCalendarTypeEnum(string);}
		public static implicit operator string(IfcWorkCalendarTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWorkPlanTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWorkPlanTypeEnum = ENUMERATION OF</para>
	/// <para>	(ACTUAL</para>
	/// <para>	,BASELINE</para>
	/// <para>	,PLANNED</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWorkPlanTypeEnum
	{
		public static string ACTUAL { get {return "ACTUAL";} }
		public static string BASELINE { get {return "BASELINE";} }
		public static string PLANNED { get {return "PLANNED";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWorkPlanTypeEnum(string value) { return new IfcWorkPlanTypeEnum(string);}
		public static implicit operator string(IfcWorkPlanTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWorkScheduleTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWorkScheduleTypeEnum = ENUMERATION OF</para>
	/// <para>	(ACTUAL</para>
	/// <para>	,BASELINE</para>
	/// <para>	,PLANNED</para>
	/// <para>	,USERDEFINED</para>
	/// <para>	,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWorkScheduleTypeEnum
	{
		public static string ACTUAL { get {return "ACTUAL";} }
		public static string BASELINE { get {return "BASELINE";} }
		public static string PLANNED { get {return "PLANNED";} }
		public static string USERDEFINED { get {return "USERDEFINED";} }
		public static string NOTDEFINED { get {return "NOTDEFINED";} }
		public static implicit operator IfcWorkScheduleTypeEnum(string value) { return new IfcWorkScheduleTypeEnum(string);}
		public static implicit operator string(IfcWorkScheduleTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcActorSelect = SELECT
	/// <para>TYPE IfcActorSelect = SELECT</para>
	/// <para>	(IfcOrganization</para>
	/// <para>	,IfcPerson</para>
	/// <para>	,IfcPersonAndOrganization);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcActorSelect
	{
	}
	/// <summary>
	/// TYPE IfcAppliedValueSelect = SELECT
	/// <para>TYPE IfcAppliedValueSelect = SELECT</para>
	/// <para>	(IfcMeasureWithUnit</para>
	/// <para>	,IfcReference</para>
	/// <para>	,IfcValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcAppliedValueSelect
	{
	}
	/// <summary>
	/// TYPE IfcAxis2Placement = SELECT
	/// <para>TYPE IfcAxis2Placement = SELECT</para>
	/// <para>	(IfcAxis2Placement2D</para>
	/// <para>	,IfcAxis2Placement3D);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcAxis2Placement
	{
	}
	/// <summary>
	/// TYPE IfcBendingParameterSelect = SELECT
	/// <para>TYPE IfcBendingParameterSelect = SELECT</para>
	/// <para>	(IfcLengthMeasure</para>
	/// <para>	,IfcPlaneAngleMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcBendingParameterSelect
	{
	}
	/// <summary>
	/// TYPE IfcBooleanOperand = SELECT
	/// <para>TYPE IfcBooleanOperand = SELECT</para>
	/// <para>	(IfcBooleanResult</para>
	/// <para>	,IfcCsgPrimitive3D</para>
	/// <para>	,IfcHalfSpaceSolid</para>
	/// <para>	,IfcSolidModel</para>
	/// <para>	,IfcTessellatedFaceSet);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcBooleanOperand
	{
	}
	/// <summary>
	/// TYPE IfcClassificationReferenceSelect = SELECT
	/// <para>TYPE IfcClassificationReferenceSelect = SELECT</para>
	/// <para>	(IfcClassification</para>
	/// <para>	,IfcClassificationReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcClassificationReferenceSelect
	{
	}
	/// <summary>
	/// TYPE IfcClassificationSelect = SELECT
	/// <para>TYPE IfcClassificationSelect = SELECT</para>
	/// <para>	(IfcClassification</para>
	/// <para>	,IfcClassificationReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcClassificationSelect
	{
	}
	/// <summary>
	/// TYPE IfcColour = SELECT
	/// <para>TYPE IfcColour = SELECT</para>
	/// <para>	(IfcColourSpecification</para>
	/// <para>	,IfcPreDefinedColour);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcColour, IfcFillStyleSelect
	{
	}
	/// <summary>
	/// TYPE IfcColourOrFactor = SELECT
	/// <para>TYPE IfcColourOrFactor = SELECT</para>
	/// <para>	(IfcColourRgb</para>
	/// <para>	,IfcNormalisedRatioMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcColourOrFactor
	{
	}
	/// <summary>
	/// TYPE IfcCoordinateReferenceSystemSelect = SELECT
	/// <para>TYPE IfcCoordinateReferenceSystemSelect = SELECT</para>
	/// <para>	(IfcCoordinateReferenceSystem</para>
	/// <para>	,IfcGeometricRepresentationContext);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCoordinateReferenceSystemSelect
	{
	}
	/// <summary>
	/// TYPE IfcCsgSelect = SELECT
	/// <para>TYPE IfcCsgSelect = SELECT</para>
	/// <para>	(IfcBooleanResult</para>
	/// <para>	,IfcCsgPrimitive3D);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCsgSelect
	{
	}
	/// <summary>
	/// TYPE IfcCurveFontOrScaledCurveFontSelect = SELECT
	/// <para>TYPE IfcCurveFontOrScaledCurveFontSelect = SELECT</para>
	/// <para>	(IfcCurveStyleFontAndScaling</para>
	/// <para>	,IfcCurveStyleFontSelect);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveFontOrScaledCurveFontSelect
	{
	}
	/// <summary>
	/// TYPE IfcCurveOnSurface = SELECT
	/// <para>TYPE IfcCurveOnSurface = SELECT</para>
	/// <para>	(IfcCompositeCurveOnSurface</para>
	/// <para>	,IfcPcurve</para>
	/// <para>	,IfcSurfaceCurve);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveOnSurface
	{
	}
	/// <summary>
	/// TYPE IfcCurveOrEdgeCurve = SELECT
	/// <para>TYPE IfcCurveOrEdgeCurve = SELECT</para>
	/// <para>	(IfcBoundedCurve</para>
	/// <para>	,IfcEdgeCurve);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveOrEdgeCurve
	{
	}
	/// <summary>
	/// TYPE IfcCurveStyleFontSelect = SELECT
	/// <para>TYPE IfcCurveStyleFontSelect = SELECT</para>
	/// <para>	(IfcCurveStyleFont</para>
	/// <para>	,IfcPreDefinedCurveFont);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveStyleFontSelect, IfcCurveFontOrScaledCurveFontSelect
	{
	}
	/// <summary>
	/// TYPE IfcDefinitionSelect = SELECT
	/// <para>TYPE IfcDefinitionSelect = SELECT</para>
	/// <para>	(IfcObjectDefinition</para>
	/// <para>	,IfcPropertyDefinition);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcDefinitionSelect
	{
	}
	/// <summary>
	/// TYPE IfcDerivedMeasureValue = SELECT
	/// <para>TYPE IfcDerivedMeasureValue = SELECT</para>
	/// <para>	(IfcAbsorbedDoseMeasure</para>
	/// <para>	,IfcAccelerationMeasure</para>
	/// <para>	,IfcAngularVelocityMeasure</para>
	/// <para>	,IfcAreaDensityMeasure</para>
	/// <para>	,IfcCompoundPlaneAngleMeasure</para>
	/// <para>	,IfcCurvatureMeasure</para>
	/// <para>	,IfcDoseEquivalentMeasure</para>
	/// <para>	,IfcDynamicViscosityMeasure</para>
	/// <para>	,IfcElectricCapacitanceMeasure</para>
	/// <para>	,IfcElectricChargeMeasure</para>
	/// <para>	,IfcElectricConductanceMeasure</para>
	/// <para>	,IfcElectricResistanceMeasure</para>
	/// <para>	,IfcElectricVoltageMeasure</para>
	/// <para>	,IfcEnergyMeasure</para>
	/// <para>	,IfcForceMeasure</para>
	/// <para>	,IfcFrequencyMeasure</para>
	/// <para>	,IfcHeatFluxDensityMeasure</para>
	/// <para>	,IfcHeatingValueMeasure</para>
	/// <para>	,IfcIlluminanceMeasure</para>
	/// <para>	,IfcInductanceMeasure</para>
	/// <para>	,IfcIntegerCountRateMeasure</para>
	/// <para>	,IfcIonConcentrationMeasure</para>
	/// <para>	,IfcIsothermalMoistureCapacityMeasure</para>
	/// <para>	,IfcKinematicViscosityMeasure</para>
	/// <para>	,IfcLinearForceMeasure</para>
	/// <para>	,IfcLinearMomentMeasure</para>
	/// <para>	,IfcLinearStiffnessMeasure</para>
	/// <para>	,IfcLinearVelocityMeasure</para>
	/// <para>	,IfcLuminousFluxMeasure</para>
	/// <para>	,IfcLuminousIntensityDistributionMeasure</para>
	/// <para>	,IfcMagneticFluxDensityMeasure</para>
	/// <para>	,IfcMagneticFluxMeasure</para>
	/// <para>	,IfcMassDensityMeasure</para>
	/// <para>	,IfcMassFlowRateMeasure</para>
	/// <para>	,IfcMassPerLengthMeasure</para>
	/// <para>	,IfcModulusOfElasticityMeasure</para>
	/// <para>	,IfcModulusOfLinearSubgradeReactionMeasure</para>
	/// <para>	,IfcModulusOfRotationalSubgradeReactionMeasure</para>
	/// <para>	,IfcModulusOfSubgradeReactionMeasure</para>
	/// <para>	,IfcMoistureDiffusivityMeasure</para>
	/// <para>	,IfcMolecularWeightMeasure</para>
	/// <para>	,IfcMomentOfInertiaMeasure</para>
	/// <para>	,IfcMonetaryMeasure</para>
	/// <para>	,IfcPHMeasure</para>
	/// <para>	,IfcPlanarForceMeasure</para>
	/// <para>	,IfcPowerMeasure</para>
	/// <para>	,IfcPressureMeasure</para>
	/// <para>	,IfcRadioActivityMeasure</para>
	/// <para>	,IfcRotationalFrequencyMeasure</para>
	/// <para>	,IfcRotationalMassMeasure</para>
	/// <para>	,IfcRotationalStiffnessMeasure</para>
	/// <para>	,IfcSectionModulusMeasure</para>
	/// <para>	,IfcSectionalAreaIntegralMeasure</para>
	/// <para>	,IfcShearModulusMeasure</para>
	/// <para>	,IfcSoundPowerLevelMeasure</para>
	/// <para>	,IfcSoundPowerMeasure</para>
	/// <para>	,IfcSoundPressureLevelMeasure</para>
	/// <para>	,IfcSoundPressureMeasure</para>
	/// <para>	,IfcSpecificHeatCapacityMeasure</para>
	/// <para>	,IfcTemperatureGradientMeasure</para>
	/// <para>	,IfcTemperatureRateOfChangeMeasure</para>
	/// <para>	,IfcThermalAdmittanceMeasure</para>
	/// <para>	,IfcThermalConductivityMeasure</para>
	/// <para>	,IfcThermalExpansionCoefficientMeasure</para>
	/// <para>	,IfcThermalResistanceMeasure</para>
	/// <para>	,IfcThermalTransmittanceMeasure</para>
	/// <para>	,IfcTorqueMeasure</para>
	/// <para>	,IfcVaporPermeabilityMeasure</para>
	/// <para>	,IfcVolumetricFlowRateMeasure</para>
	/// <para>	,IfcWarpingConstantMeasure</para>
	/// <para>	,IfcWarpingMomentMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcDerivedMeasureValue, IfcValue
	{
	}
	/// <summary>
	/// TYPE IfcDocumentSelect = SELECT
	/// <para>TYPE IfcDocumentSelect = SELECT</para>
	/// <para>	(IfcDocumentInformation</para>
	/// <para>	,IfcDocumentReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcDocumentSelect
	{
	}
	/// <summary>
	/// TYPE IfcFillStyleSelect = SELECT
	/// <para>TYPE IfcFillStyleSelect = SELECT</para>
	/// <para>	(IfcColour</para>
	/// <para>	,IfcExternallyDefinedHatchStyle</para>
	/// <para>	,IfcFillAreaStyleHatching</para>
	/// <para>	,IfcFillAreaStyleTiles);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcFillStyleSelect
	{
	}
	/// <summary>
	/// TYPE IfcGeometricSetSelect = SELECT
	/// <para>TYPE IfcGeometricSetSelect = SELECT</para>
	/// <para>	(IfcCurve</para>
	/// <para>	,IfcPoint</para>
	/// <para>	,IfcSurface);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcGeometricSetSelect
	{
	}
	/// <summary>
	/// TYPE IfcGridPlacementDirectionSelect = SELECT
	/// <para>TYPE IfcGridPlacementDirectionSelect = SELECT</para>
	/// <para>	(IfcDirection</para>
	/// <para>	,IfcVirtualGridIntersection);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcGridPlacementDirectionSelect
	{
	}
	/// <summary>
	/// TYPE IfcHatchLineDistanceSelect = SELECT
	/// <para>TYPE IfcHatchLineDistanceSelect = SELECT</para>
	/// <para>	(IfcPositiveLengthMeasure</para>
	/// <para>	,IfcVector);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcHatchLineDistanceSelect
	{
	}
	/// <summary>
	/// TYPE IfcLayeredItem = SELECT
	/// <para>TYPE IfcLayeredItem = SELECT</para>
	/// <para>	(IfcRepresentation</para>
	/// <para>	,IfcRepresentationItem);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcLayeredItem
	{
	}
	/// <summary>
	/// TYPE IfcLibrarySelect = SELECT
	/// <para>TYPE IfcLibrarySelect = SELECT</para>
	/// <para>	(IfcLibraryInformation</para>
	/// <para>	,IfcLibraryReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcLibrarySelect
	{
	}
	/// <summary>
	/// TYPE IfcLightDistributionDataSourceSelect = SELECT
	/// <para>TYPE IfcLightDistributionDataSourceSelect = SELECT</para>
	/// <para>	(IfcExternalReference</para>
	/// <para>	,IfcLightIntensityDistribution);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcLightDistributionDataSourceSelect
	{
	}
	/// <summary>
	/// TYPE IfcMaterialSelect = SELECT
	/// <para>TYPE IfcMaterialSelect = SELECT</para>
	/// <para>	(IfcMaterialDefinition</para>
	/// <para>	,IfcMaterialList</para>
	/// <para>	,IfcMaterialUsageDefinition);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcMaterialSelect
	{
	}
	/// <summary>
	/// TYPE IfcMeasureValue = SELECT
	/// <para>TYPE IfcMeasureValue = SELECT</para>
	/// <para>	(IfcAmountOfSubstanceMeasure</para>
	/// <para>	,IfcAreaMeasure</para>
	/// <para>	,IfcComplexNumber</para>
	/// <para>	,IfcContextDependentMeasure</para>
	/// <para>	,IfcCountMeasure</para>
	/// <para>	,IfcDescriptiveMeasure</para>
	/// <para>	,IfcElectricCurrentMeasure</para>
	/// <para>	,IfcLengthMeasure</para>
	/// <para>	,IfcLuminousIntensityMeasure</para>
	/// <para>	,IfcMassMeasure</para>
	/// <para>	,IfcNonNegativeLengthMeasure</para>
	/// <para>	,IfcNormalisedRatioMeasure</para>
	/// <para>	,IfcNumericMeasure</para>
	/// <para>	,IfcParameterValue</para>
	/// <para>	,IfcPlaneAngleMeasure</para>
	/// <para>	,IfcPositiveLengthMeasure</para>
	/// <para>	,IfcPositivePlaneAngleMeasure</para>
	/// <para>	,IfcPositiveRatioMeasure</para>
	/// <para>	,IfcRatioMeasure</para>
	/// <para>	,IfcSolidAngleMeasure</para>
	/// <para>	,IfcThermodynamicTemperatureMeasure</para>
	/// <para>	,IfcTimeMeasure</para>
	/// <para>	,IfcVolumeMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcMeasureValue, IfcValue
	{
	}
	/// <summary>
	/// TYPE IfcMetricValueSelect = SELECT
	/// <para>TYPE IfcMetricValueSelect = SELECT</para>
	/// <para>	(IfcAppliedValue</para>
	/// <para>	,IfcMeasureWithUnit</para>
	/// <para>	,IfcReference</para>
	/// <para>	,IfcTable</para>
	/// <para>	,IfcTimeSeries</para>
	/// <para>	,IfcValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcMetricValueSelect
	{
	}
	/// <summary>
	/// TYPE IfcModulusOfRotationalSubgradeReactionSelect = SELECT
	/// <para>TYPE IfcModulusOfRotationalSubgradeReactionSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcModulusOfRotationalSubgradeReactionMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcModulusOfRotationalSubgradeReactionSelect
	{
	}
	/// <summary>
	/// TYPE IfcModulusOfSubgradeReactionSelect = SELECT
	/// <para>TYPE IfcModulusOfSubgradeReactionSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcModulusOfSubgradeReactionMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcModulusOfSubgradeReactionSelect
	{
	}
	/// <summary>
	/// TYPE IfcModulusOfTranslationalSubgradeReactionSelect = SELECT
	/// <para>TYPE IfcModulusOfTranslationalSubgradeReactionSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcModulusOfLinearSubgradeReactionMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcModulusOfTranslationalSubgradeReactionSelect
	{
	}
	/// <summary>
	/// TYPE IfcObjectReferenceSelect = SELECT
	/// <para>TYPE IfcObjectReferenceSelect = SELECT</para>
	/// <para>	(IfcAddress</para>
	/// <para>	,IfcAppliedValue</para>
	/// <para>	,IfcExternalReference</para>
	/// <para>	,IfcMaterialDefinition</para>
	/// <para>	,IfcOrganization</para>
	/// <para>	,IfcPerson</para>
	/// <para>	,IfcPersonAndOrganization</para>
	/// <para>	,IfcTable</para>
	/// <para>	,IfcTimeSeries);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcObjectReferenceSelect
	{
	}
	/// <summary>
	/// TYPE IfcPointOrVertexPoint = SELECT
	/// <para>TYPE IfcPointOrVertexPoint = SELECT</para>
	/// <para>	(IfcPoint</para>
	/// <para>	,IfcVertexPoint);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcPointOrVertexPoint
	{
	}
	/// <summary>
	/// TYPE IfcPresentationStyleSelect = SELECT
	/// <para>TYPE IfcPresentationStyleSelect = SELECT</para>
	/// <para>	(IfcCurveStyle</para>
	/// <para>	,IfcFillAreaStyle</para>
	/// <para>	,IfcNullStyle</para>
	/// <para>	,IfcSurfaceStyle</para>
	/// <para>	,IfcTextStyle);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcPresentationStyleSelect
	{
	}
	/// <summary>
	/// TYPE IfcProcessSelect = SELECT
	/// <para>TYPE IfcProcessSelect = SELECT</para>
	/// <para>	(IfcProcess</para>
	/// <para>	,IfcTypeProcess);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcProcessSelect
	{
	}
	/// <summary>
	/// TYPE IfcProductRepresentationSelect = SELECT
	/// <para>TYPE IfcProductRepresentationSelect = SELECT</para>
	/// <para>	(IfcProductDefinitionShape</para>
	/// <para>	,IfcRepresentationMap);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcProductRepresentationSelect
	{
	}
	/// <summary>
	/// TYPE IfcProductSelect = SELECT
	/// <para>TYPE IfcProductSelect = SELECT</para>
	/// <para>	(IfcProduct</para>
	/// <para>	,IfcTypeProduct);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcProductSelect
	{
	}
	/// <summary>
	/// TYPE IfcPropertySetDefinitionSelect = SELECT
	/// <para>TYPE IfcPropertySetDefinitionSelect = SELECT</para>
	/// <para>	(IfcPropertySetDefinition</para>
	/// <para>	,IfcPropertySetDefinitionSet);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcPropertySetDefinitionSelect
	{
	}
	/// <summary>
	/// TYPE IfcResourceObjectSelect = SELECT
	/// <para>TYPE IfcResourceObjectSelect = SELECT</para>
	/// <para>	(IfcActorRole</para>
	/// <para>	,IfcAppliedValue</para>
	/// <para>	,IfcApproval</para>
	/// <para>	,IfcConstraint</para>
	/// <para>	,IfcContextDependentUnit</para>
	/// <para>	,IfcConversionBasedUnit</para>
	/// <para>	,IfcExternalInformation</para>
	/// <para>	,IfcExternalReference</para>
	/// <para>	,IfcMaterialDefinition</para>
	/// <para>	,IfcOrganization</para>
	/// <para>	,IfcPerson</para>
	/// <para>	,IfcPersonAndOrganization</para>
	/// <para>	,IfcPhysicalQuantity</para>
	/// <para>	,IfcProfileDef</para>
	/// <para>	,IfcPropertyAbstraction</para>
	/// <para>	,IfcTimeSeries);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcResourceObjectSelect
	{
	}
	/// <summary>
	/// TYPE IfcResourceSelect = SELECT
	/// <para>TYPE IfcResourceSelect = SELECT</para>
	/// <para>	(IfcResource</para>
	/// <para>	,IfcTypeResource);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcResourceSelect
	{
	}
	/// <summary>
	/// TYPE IfcRotationalStiffnessSelect = SELECT
	/// <para>TYPE IfcRotationalStiffnessSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcRotationalStiffnessMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcRotationalStiffnessSelect
	{
	}
	/// <summary>
	/// TYPE IfcSegmentIndexSelect = SELECT
	/// <para>TYPE IfcSegmentIndexSelect = SELECT</para>
	/// <para>	(IfcArcIndex</para>
	/// <para>	,IfcLineIndex);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSegmentIndexSelect
	{
	}
	/// <summary>
	/// TYPE IfcShell = SELECT
	/// <para>TYPE IfcShell = SELECT</para>
	/// <para>	(IfcClosedShell</para>
	/// <para>	,IfcOpenShell);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcShell
	{
	}
	/// <summary>
	/// TYPE IfcSimpleValue = SELECT
	/// <para>TYPE IfcSimpleValue = SELECT</para>
	/// <para>	(IfcBinary</para>
	/// <para>	,IfcBoolean</para>
	/// <para>	,IfcDate</para>
	/// <para>	,IfcDateTime</para>
	/// <para>	,IfcDuration</para>
	/// <para>	,IfcIdentifier</para>
	/// <para>	,IfcInteger</para>
	/// <para>	,IfcLabel</para>
	/// <para>	,IfcLogical</para>
	/// <para>	,IfcPositiveInteger</para>
	/// <para>	,IfcReal</para>
	/// <para>	,IfcText</para>
	/// <para>	,IfcTime</para>
	/// <para>	,IfcTimeStamp);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSimpleValue, IfcValue
	{
	}
	/// <summary>
	/// TYPE IfcSizeSelect = SELECT
	/// <para>TYPE IfcSizeSelect = SELECT</para>
	/// <para>	(IfcDescriptiveMeasure</para>
	/// <para>	,IfcLengthMeasure</para>
	/// <para>	,IfcNormalisedRatioMeasure</para>
	/// <para>	,IfcPositiveLengthMeasure</para>
	/// <para>	,IfcPositiveRatioMeasure</para>
	/// <para>	,IfcRatioMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSizeSelect
	{
	}
	/// <summary>
	/// TYPE IfcSolidOrShell = SELECT
	/// <para>TYPE IfcSolidOrShell = SELECT</para>
	/// <para>	(IfcClosedShell</para>
	/// <para>	,IfcSolidModel);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSolidOrShell
	{
	}
	/// <summary>
	/// TYPE IfcSpaceBoundarySelect = SELECT
	/// <para>TYPE IfcSpaceBoundarySelect = SELECT</para>
	/// <para>	(IfcExternalSpatialElement</para>
	/// <para>	,IfcSpace);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSpaceBoundarySelect
	{
	}
	/// <summary>
	/// TYPE IfcSpecularHighlightSelect = SELECT
	/// <para>TYPE IfcSpecularHighlightSelect = SELECT</para>
	/// <para>	(IfcSpecularExponent</para>
	/// <para>	,IfcSpecularRoughness);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSpecularHighlightSelect
	{
	}
	/// <summary>
	/// TYPE IfcStructuralActivityAssignmentSelect = SELECT
	/// <para>TYPE IfcStructuralActivityAssignmentSelect = SELECT</para>
	/// <para>	(IfcElement</para>
	/// <para>	,IfcStructuralItem);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcStructuralActivityAssignmentSelect
	{
	}
	/// <summary>
	/// TYPE IfcStyleAssignmentSelect = SELECT
	/// <para>TYPE IfcStyleAssignmentSelect = SELECT</para>
	/// <para>	(IfcPresentationStyle</para>
	/// <para>	,IfcPresentationStyleAssignment);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcStyleAssignmentSelect
	{
	}
	/// <summary>
	/// TYPE IfcSurfaceOrFaceSurface = SELECT
	/// <para>TYPE IfcSurfaceOrFaceSurface = SELECT</para>
	/// <para>	(IfcFaceBasedSurfaceModel</para>
	/// <para>	,IfcFaceSurface</para>
	/// <para>	,IfcSurface);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSurfaceOrFaceSurface
	{
	}
	/// <summary>
	/// TYPE IfcSurfaceStyleElementSelect = SELECT
	/// <para>TYPE IfcSurfaceStyleElementSelect = SELECT</para>
	/// <para>	(IfcExternallyDefinedSurfaceStyle</para>
	/// <para>	,IfcSurfaceStyleLighting</para>
	/// <para>	,IfcSurfaceStyleRefraction</para>
	/// <para>	,IfcSurfaceStyleShading</para>
	/// <para>	,IfcSurfaceStyleWithTextures);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSurfaceStyleElementSelect
	{
	}
	/// <summary>
	/// TYPE IfcTextFontSelect = SELECT
	/// <para>TYPE IfcTextFontSelect = SELECT</para>
	/// <para>	(IfcExternallyDefinedTextFont</para>
	/// <para>	,IfcPreDefinedTextFont);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTextFontSelect
	{
	}
	/// <summary>
	/// TYPE IfcTimeOrRatioSelect = SELECT
	/// <para>TYPE IfcTimeOrRatioSelect = SELECT</para>
	/// <para>	(IfcDuration</para>
	/// <para>	,IfcRatioMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTimeOrRatioSelect
	{
	}
	/// <summary>
	/// TYPE IfcTranslationalStiffnessSelect = SELECT
	/// <para>TYPE IfcTranslationalStiffnessSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcLinearStiffnessMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTranslationalStiffnessSelect
	{
	}
	/// <summary>
	/// TYPE IfcTrimmingSelect = SELECT
	/// <para>TYPE IfcTrimmingSelect = SELECT</para>
	/// <para>	(IfcCartesianPoint</para>
	/// <para>	,IfcParameterValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTrimmingSelect
	{
	}
	/// <summary>
	/// TYPE IfcUnit = SELECT
	/// <para>TYPE IfcUnit = SELECT</para>
	/// <para>	(IfcDerivedUnit</para>
	/// <para>	,IfcMonetaryUnit</para>
	/// <para>	,IfcNamedUnit);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcUnit
	{
	}
	/// <summary>
	/// TYPE IfcValue = SELECT
	/// <para>TYPE IfcValue = SELECT</para>
	/// <para>	(IfcDerivedMeasureValue</para>
	/// <para>	,IfcMeasureValue</para>
	/// <para>	,IfcSimpleValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcValue, IfcAppliedValueSelect, IfcMetricValueSelect
	{
	}
	/// <summary>
	/// TYPE IfcVectorOrDirection = SELECT
	/// <para>TYPE IfcVectorOrDirection = SELECT</para>
	/// <para>	(IfcDirection</para>
	/// <para>	,IfcVector);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcVectorOrDirection
	{
	}
	/// <summary>
	/// TYPE IfcWarpingStiffnessSelect = SELECT
	/// <para>TYPE IfcWarpingStiffnessSelect = SELECT</para>
	/// <para>	(IfcBoolean</para>
	/// <para>	,IfcWarpingMomentMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcWarpingStiffnessSelect
	{
	}
	/// <summary>
	/// ENTITY IfcActionRequest
	/// <para>ENTITY IfcActionRequest</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcActionRequestTypeEnum;</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActionRequest : IfcControl
	{
		public IfcActionRequestTypeEnum? PredefinedType { get; set; }
		public IfcLabel? Status { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcActionRequest() : base()
		{
		}
		public IfcActionRequest(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcActionRequestTypeEnum PredefinedType, IfcLabel Status, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcActor
	/// <para>ENTITY IfcActor</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcOccupant))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para>	TheActor : IfcActorSelect;</para>
	/// <para> INVERSE</para>
	/// <para>	IsActingUpon : SET [0:?] OF IfcRelAssignsToActor FOR RelatingActor;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActor : IfcObject
	{
		public IfcActorSelect TheActor { get; set; }
		public IfcActor() : base()
		{
			TheActor = new IfcActorSelect();
		}
		public IfcActor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcActorSelect TheActor) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.TheActor = TheActor;
		}
	}
	/// <summary>
	/// ENTITY IfcActorRole;
	/// <para>ENTITY IfcActorRole;</para>
	/// <para>	Role : IfcRoleEnum;</para>
	/// <para>	UserDefinedRole : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : (Role <> IfcRoleEnum.USERDEFINED) OR</para>
	/// <para>((Role = IfcRoleEnum.USERDEFINED) AND</para>
	/// <para>  EXISTS(SELF.UserDefinedRole));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActorRole : ENTITY, IfcResourceObjectSelect
	{
		public IfcRoleEnum Role { get; set; }
		public IfcLabel? UserDefinedRole { get; set; }
		public IfcText? Description { get; set; }
		public IfcActorRole() : base()
		{
			Role = new IfcRoleEnum();
		}
		public IfcActorRole(IfcRoleEnum Role, IfcLabel UserDefinedRole, IfcText Description) : base ()
		{
			this.Role = Role;
			this.UserDefinedRole = UserDefinedRole;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcActuator
	/// <para>ENTITY IfcActuator</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcActuatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcActuatorTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcActuatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>('IFC4.IFCACTUATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActuator : IfcDistributionControlElement
	{
		public IfcActuatorTypeEnum? PredefinedType { get; set; }
		public IfcActuator() : base()
		{
		}
		public IfcActuator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcActuatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcActuatorType
	/// <para>ENTITY IfcActuatorType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcActuatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcActuatorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcActuatorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActuatorType : IfcDistributionControlElementType
	{
		public IfcActuatorTypeEnum PredefinedType { get; set; }
		public IfcActuatorType() : base()
		{
			PredefinedType = new IfcActuatorTypeEnum();
		}
		public IfcActuatorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcActuatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAddress
	/// <para>ENTITY IfcAddress</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPostalAddress</para>
	/// <para>    ,IfcTelecomAddress));</para>
	/// <para>	Purpose : OPTIONAL IfcAddressTypeEnum;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	UserDefinedPurpose : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	OfPerson : SET [0:?] OF IfcPerson FOR Addresses;</para>
	/// <para>	OfOrganization : SET [0:?] OF IfcOrganization FOR Addresses;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : (NOT(EXISTS(Purpose))) OR</para>
	/// <para>((Purpose <> IfcAddressTypeEnum.USERDEFINED) OR</para>
	/// <para>((Purpose = IfcAddressTypeEnum.USERDEFINED) AND</para>
	/// <para>  EXISTS(SELF.UserDefinedPurpose)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcAddress : ENTITY, IfcObjectReferenceSelect
	{
		public IfcAddressTypeEnum? Purpose { get; set; }
		public IfcText? Description { get; set; }
		public IfcLabel? UserDefinedPurpose { get; set; }
		public IfcAddress() : base()
		{
		}
		public IfcAddress(IfcAddressTypeEnum Purpose, IfcText Description, IfcLabel UserDefinedPurpose) : base ()
		{
			this.Purpose = Purpose;
			this.Description = Description;
			this.UserDefinedPurpose = UserDefinedPurpose;
		}
	}
	/// <summary>
	/// ENTITY IfcAdvancedBrep
	/// <para>ENTITY IfcAdvancedBrep</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAdvancedBrepWithVoids))</para>
	/// <para> SUBTYPE OF (IfcManifoldSolidBrep);</para>
	/// <para> WHERE</para>
	/// <para>	HasAdvancedFaces : SIZEOF(QUERY(Afs <* SELF\IfcManifoldSolidBrep.Outer.CfsFaces |</para>
	/// <para>  (NOT ('IFC4.IFCADVANCEDFACE' IN TYPEOF(Afs)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAdvancedBrep : IfcManifoldSolidBrep
	{
		public IfcAdvancedBrep() : base()
		{
		}
		public IfcAdvancedBrep(IfcClosedShell Outer) : base (Outer)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAdvancedBrepWithVoids
	/// <para>ENTITY IfcAdvancedBrepWithVoids</para>
	/// <para> SUBTYPE OF (IfcAdvancedBrep);</para>
	/// <para>	Voids : SET [1:?] OF IfcClosedShell;</para>
	/// <para> WHERE</para>
	/// <para>	VoidsHaveAdvancedFaces : SIZEOF (QUERY (Vsh <* Voids |</para>
	/// <para>  SIZEOF (QUERY (Afs <* Vsh.CfsFaces |</para>
	/// <para>  (NOT ('IFC4.IFCADVANCEDFACE' IN TYPEOF(Afs)))</para>
	/// <para>  )) = 0</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAdvancedBrepWithVoids : IfcAdvancedBrep
	{
		public List<IfcClosedShell> Voids { get; set; }
		public IfcAdvancedBrepWithVoids() : base()
		{
			Voids = new List<IfcClosedShell>();
		}
		public IfcAdvancedBrepWithVoids(IfcClosedShell Outer, List<IfcClosedShell> Voids) : base (Outer)
		{
			this.Voids = Voids;
		}
	}
	/// <summary>
	/// ENTITY IfcAdvancedFace
	/// <para>ENTITY IfcAdvancedFace</para>
	/// <para> SUBTYPE OF (IfcFaceSurface);</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableSurface : SIZEOF (</para>
	/// <para>['IFC4.IFCELEMENTARYSURFACE',</para>
	/// <para> 'IFC4.IFCSWEPTSURFACE',</para>
	/// <para> 'IFC4.IFCBSPLINESURFACE'] *</para>
	/// <para>TYPEOF(SELF\IfcFaceSurface.FaceSurface)) = 1;</para>
	/// <para>	RequiresEdgeCurve : SIZEOF(QUERY (ElpFbnds <* </para>
	/// <para>  QUERY (Bnds <* SELF\IfcFace.Bounds |</para>
	/// <para>    'IFC4.IFCEDGELOOP' IN TYPEOF(Bnds.Bound)) |</para>
	/// <para>     NOT (SIZEOF (QUERY (Oe <* ElpFbnds.Bound\IfcEdgeLoop.EdgeList |</para>
	/// <para>       NOT('IFC4.IFCEDGECURVE' IN </para>
	/// <para>       TYPEOF(Oe\IfcOrientedEdge.EdgeElement)</para>
	/// <para>  ))) = 0</para>
	/// <para>))) = 0;</para>
	/// <para>	ApplicableEdgeCurves : SIZEOF(QUERY (ElpFbnds <* </para>
	/// <para>  QUERY (Bnds <* SELF\IfcFace.Bounds |</para>
	/// <para>    'IFC4.IFCEDGELOOP' IN TYPEOF(Bnds.Bound)) |</para>
	/// <para>     NOT (SIZEOF (QUERY (Oe <* ElpFbnds.Bound\IfcEdgeLoop.EdgeList |</para>
	/// <para>       NOT (SIZEOF (['IFC4.IFCLINE',</para>
	/// <para>                     'IFC4.IFCCONIC',</para>
	/// <para>                     'IFC4.IFCPOLYLINE',</para>
	/// <para>                     'IFC4.IFCBSPLINECURVE'] *</para>
	/// <para>         TYPEOF(Oe\IfcOrientedEdge.EdgeElement\IfcEdgeCurve.EdgeGeometry)) = 1 )</para>
	/// <para>  )) = 0</para>
	/// <para>))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAdvancedFace : IfcFaceSurface
	{
		public IfcAdvancedFace() : base()
		{
		}
		public IfcAdvancedFace(List<IfcFaceBound> Bounds, IfcSurface FaceSurface, IfcBoolean SameSense) : base (Bounds, FaceSurface, SameSense)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminal
	/// <para>ENTITY IfcAirTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAirTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcAirTerminalTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcAirTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCAIRTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminal : IfcFlowTerminal
	{
		public IfcAirTerminalTypeEnum? PredefinedType { get; set; }
		public IfcAirTerminal() : base()
		{
		}
		public IfcAirTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAirTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminalBox
	/// <para>ENTITY IfcAirTerminalBox</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAirTerminalBoxTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcAirTerminalBoxTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcAirTerminalBoxTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCAIRTERMINALBOXTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminalBox : IfcFlowController
	{
		public IfcAirTerminalBoxTypeEnum? PredefinedType { get; set; }
		public IfcAirTerminalBox() : base()
		{
		}
		public IfcAirTerminalBox(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAirTerminalBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminalBoxType
	/// <para>ENTITY IfcAirTerminalBoxType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcAirTerminalBoxTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAirTerminalBoxTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAirTerminalBoxTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminalBoxType : IfcFlowControllerType
	{
		public IfcAirTerminalBoxTypeEnum PredefinedType { get; set; }
		public IfcAirTerminalBoxType() : base()
		{
			PredefinedType = new IfcAirTerminalBoxTypeEnum();
		}
		public IfcAirTerminalBoxType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAirTerminalBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminalType
	/// <para>ENTITY IfcAirTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcAirTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAirTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAirTerminalTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminalType : IfcFlowTerminalType
	{
		public IfcAirTerminalTypeEnum PredefinedType { get; set; }
		public IfcAirTerminalType() : base()
		{
			PredefinedType = new IfcAirTerminalTypeEnum();
		}
		public IfcAirTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAirTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirToAirHeatRecovery
	/// <para>ENTITY IfcAirToAirHeatRecovery</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAirToAirHeatRecoveryTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCAIRTOAIRHEATRECOVERYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirToAirHeatRecovery : IfcEnergyConversionDevice
	{
		public IfcAirToAirHeatRecoveryTypeEnum? PredefinedType { get; set; }
		public IfcAirToAirHeatRecovery() : base()
		{
		}
		public IfcAirToAirHeatRecovery(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAirToAirHeatRecoveryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirToAirHeatRecoveryType
	/// <para>ENTITY IfcAirToAirHeatRecoveryType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcAirToAirHeatRecoveryTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirToAirHeatRecoveryType : IfcEnergyConversionDeviceType
	{
		public IfcAirToAirHeatRecoveryTypeEnum PredefinedType { get; set; }
		public IfcAirToAirHeatRecoveryType() : base()
		{
			PredefinedType = new IfcAirToAirHeatRecoveryTypeEnum();
		}
		public IfcAirToAirHeatRecoveryType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAirToAirHeatRecoveryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlarm
	/// <para>ENTITY IfcAlarm</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAlarmTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcAlarmTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcAlarmTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>('IFC4.IFCALARMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlarm : IfcDistributionControlElement
	{
		public IfcAlarmTypeEnum? PredefinedType { get; set; }
		public IfcAlarm() : base()
		{
		}
		public IfcAlarm(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAlarmTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlarmType
	/// <para>ENTITY IfcAlarmType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcAlarmTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAlarmTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAlarmTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlarmType : IfcDistributionControlElementType
	{
		public IfcAlarmTypeEnum PredefinedType { get; set; }
		public IfcAlarmType() : base()
		{
			PredefinedType = new IfcAlarmTypeEnum();
		}
		public IfcAlarmType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAlarmTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAnnotation
	/// <para>ENTITY IfcAnnotation</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para> INVERSE</para>
	/// <para>	ContainedInStructure : SET [0:1] OF IfcRelContainedInSpatialStructure FOR RelatedElements;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAnnotation : IfcProduct
	{
		public IfcAnnotation() : base()
		{
		}
		public IfcAnnotation(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAnnotationFillArea
	/// <para>ENTITY IfcAnnotationFillArea</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	OuterBoundary : IfcCurve;</para>
	/// <para>	InnerBoundaries : OPTIONAL SET [1:?] OF IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAnnotationFillArea : IfcGeometricRepresentationItem
	{
		public IfcCurve OuterBoundary { get; set; }
		public List<IfcCurve>? InnerBoundaries { get; set; }
		public IfcAnnotationFillArea() : base()
		{
			OuterBoundary = new IfcCurve();
		}
		public IfcAnnotationFillArea(IfcCurve OuterBoundary, List<IfcCurve> InnerBoundaries) : base ()
		{
			this.OuterBoundary = OuterBoundary;
			this.InnerBoundaries = InnerBoundaries;
		}
	}
	/// <summary>
	/// ENTITY IfcApplication;
	/// <para>ENTITY IfcApplication;</para>
	/// <para>	ApplicationDeveloper : IfcOrganization;</para>
	/// <para>	Version : IfcLabel;</para>
	/// <para>	ApplicationFullName : IfcLabel;</para>
	/// <para>	ApplicationIdentifier : IfcIdentifier;</para>
	/// <para> UNIQUE</para>
	/// <para>	UR1 : ApplicationIdentifier;</para>
	/// <para>	UR2 : ApplicationFullName, Version;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcApplication : ENTITY
	{
		public IfcOrganization ApplicationDeveloper { get; set; }
		public IfcLabel Version { get; set; }
		public IfcLabel ApplicationFullName { get; set; }
		public IfcIdentifier ApplicationIdentifier { get; set; }
		public IfcApplication() : base()
		{
			ApplicationDeveloper = new IfcOrganization();
			Version = new IfcLabel();
			ApplicationFullName = new IfcLabel();
			ApplicationIdentifier = new IfcIdentifier();
		}
		public IfcApplication(IfcOrganization ApplicationDeveloper, IfcLabel Version, IfcLabel ApplicationFullName, IfcIdentifier ApplicationIdentifier) : base ()
		{
			this.ApplicationDeveloper = ApplicationDeveloper;
			this.Version = Version;
			this.ApplicationFullName = ApplicationFullName;
			this.ApplicationIdentifier = ApplicationIdentifier;
		}
	}
	/// <summary>
	/// ENTITY IfcAppliedValue
	/// <para>ENTITY IfcAppliedValue</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCostValue));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	AppliedValue : OPTIONAL IfcAppliedValueSelect;</para>
	/// <para>	UnitBasis : OPTIONAL IfcMeasureWithUnit;</para>
	/// <para>	ApplicableDate : OPTIONAL IfcDate;</para>
	/// <para>	FixedUntilDate : OPTIONAL IfcDate;</para>
	/// <para>	Category : OPTIONAL IfcLabel;</para>
	/// <para>	Condition : OPTIONAL IfcLabel;</para>
	/// <para>	ArithmeticOperator : OPTIONAL IfcArithmeticOperatorEnum;</para>
	/// <para>	Components : OPTIONAL LIST [1:?] OF IfcAppliedValue;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAppliedValue : ENTITY, IfcMetricValueSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcAppliedValueSelect? AppliedValue { get; set; }
		public IfcMeasureWithUnit? UnitBasis { get; set; }
		public IfcDate? ApplicableDate { get; set; }
		public IfcDate? FixedUntilDate { get; set; }
		public IfcLabel? Category { get; set; }
		public IfcLabel? Condition { get; set; }
		public IfcArithmeticOperatorEnum? ArithmeticOperator { get; set; }
		public List<IfcAppliedValue>? Components { get; set; }
		public IfcAppliedValue() : base()
		{
		}
		public IfcAppliedValue(IfcLabel Name, IfcText Description, IfcAppliedValueSelect AppliedValue, IfcMeasureWithUnit UnitBasis, IfcDate ApplicableDate, IfcDate FixedUntilDate, IfcLabel Category, IfcLabel Condition, IfcArithmeticOperatorEnum ArithmeticOperator, List<IfcAppliedValue> Components) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.AppliedValue = AppliedValue;
			this.UnitBasis = UnitBasis;
			this.ApplicableDate = ApplicableDate;
			this.FixedUntilDate = FixedUntilDate;
			this.Category = Category;
			this.Condition = Condition;
			this.ArithmeticOperator = ArithmeticOperator;
			this.Components = Components;
		}
	}
	/// <summary>
	/// ENTITY IfcApproval;
	/// <para>ENTITY IfcApproval;</para>
	/// <para>	Identifier : OPTIONAL IfcIdentifier;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	TimeOfApproval : OPTIONAL IfcDateTime;</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	Level : OPTIONAL IfcLabel;</para>
	/// <para>	Qualifier : OPTIONAL IfcText;</para>
	/// <para>	RequestingApproval : OPTIONAL IfcActorSelect;</para>
	/// <para>	GivingApproval : OPTIONAL IfcActorSelect;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>	ApprovedObjects : SET [0:?] OF IfcRelAssociatesApproval FOR RelatingApproval;</para>
	/// <para>	ApprovedResources : SET [0:?] OF IfcResourceApprovalRelationship FOR RelatingApproval;</para>
	/// <para>	IsRelatedWith : SET [0:?] OF IfcApprovalRelationship FOR RelatedApprovals;</para>
	/// <para>	Relates : SET [0:?] OF IfcApprovalRelationship FOR RelatingApproval;</para>
	/// <para> WHERE</para>
	/// <para>	HasIdentifierOrName : EXISTS (Identifier) OR EXISTS (Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcApproval : ENTITY, IfcResourceObjectSelect
	{
		public IfcIdentifier? Identifier { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcDateTime? TimeOfApproval { get; set; }
		public IfcLabel? Status { get; set; }
		public IfcLabel? Level { get; set; }
		public IfcText? Qualifier { get; set; }
		public IfcActorSelect? RequestingApproval { get; set; }
		public IfcActorSelect? GivingApproval { get; set; }
		public IfcApproval() : base()
		{
		}
		public IfcApproval(IfcIdentifier Identifier, IfcLabel Name, IfcText Description, IfcDateTime TimeOfApproval, IfcLabel Status, IfcLabel Level, IfcText Qualifier, IfcActorSelect RequestingApproval, IfcActorSelect GivingApproval) : base ()
		{
			this.Identifier = Identifier;
			this.Name = Name;
			this.Description = Description;
			this.TimeOfApproval = TimeOfApproval;
			this.Status = Status;
			this.Level = Level;
			this.Qualifier = Qualifier;
			this.RequestingApproval = RequestingApproval;
			this.GivingApproval = GivingApproval;
		}
	}
	/// <summary>
	/// ENTITY IfcApprovalRelationship
	/// <para>ENTITY IfcApprovalRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingApproval : IfcApproval;</para>
	/// <para>	RelatedApprovals : SET [1:?] OF IfcApproval;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcApprovalRelationship : IfcResourceLevelRelationship
	{
		public IfcApproval RelatingApproval { get; set; }
		public List<IfcApproval> RelatedApprovals { get; set; }
		public IfcApprovalRelationship() : base()
		{
			RelatingApproval = new IfcApproval();
			RelatedApprovals = new List<IfcApproval>();
		}
		public IfcApprovalRelationship(IfcLabel Name, IfcText Description, IfcApproval RelatingApproval, List<IfcApproval> RelatedApprovals) : base (Name, Description)
		{
			this.RelatingApproval = RelatingApproval;
			this.RelatedApprovals = RelatedApprovals;
		}
	}
	/// <summary>
	/// ENTITY IfcArbitraryClosedProfileDef
	/// <para>ENTITY IfcArbitraryClosedProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcArbitraryProfileDefWithVoids))</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	OuterCurve : IfcCurve;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : OuterCurve.Dim = 2;</para>
	/// <para>	WR2 : NOT('IFC4.IFCLINE' IN TYPEOF(OuterCurve));</para>
	/// <para>	WR3 : NOT('IFC4.IFCOFFSETCURVE2D' IN TYPEOF(OuterCurve));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcArbitraryClosedProfileDef : IfcProfileDef
	{
		public IfcCurve OuterCurve { get; set; }
		public IfcArbitraryClosedProfileDef() : base()
		{
			OuterCurve = new IfcCurve();
		}
		public IfcArbitraryClosedProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcCurve OuterCurve) : base (ProfileType, ProfileName)
		{
			this.OuterCurve = OuterCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcArbitraryOpenProfileDef
	/// <para>ENTITY IfcArbitraryOpenProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCenterLineProfileDef))</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	Curve : IfcBoundedCurve;</para>
	/// <para> WHERE</para>
	/// <para>	WR11 : ('IFC4.IFCCENTERLINEPROFILEDEF' IN TYPEOF(SELF)) OR </para>
	/// <para> (SELF\IfcProfileDef.ProfileType = IfcProfileTypeEnum.CURVE);</para>
	/// <para>	WR12 : Curve.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcArbitraryOpenProfileDef : IfcProfileDef
	{
		public IfcBoundedCurve Curve { get; set; }
		public IfcArbitraryOpenProfileDef() : base()
		{
			Curve = new IfcBoundedCurve();
		}
		public IfcArbitraryOpenProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcBoundedCurve Curve) : base (ProfileType, ProfileName)
		{
			this.Curve = Curve;
		}
	}
	/// <summary>
	/// ENTITY IfcArbitraryProfileDefWithVoids
	/// <para>ENTITY IfcArbitraryProfileDefWithVoids</para>
	/// <para> SUBTYPE OF (IfcArbitraryClosedProfileDef);</para>
	/// <para>	InnerCurves : SET [1:?] OF IfcCurve;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SELF\IfcProfileDef.ProfileType = AREA;</para>
	/// <para>	WR2 : SIZEOF(QUERY(temp <* InnerCurves | temp.Dim <> 2)) = 0;</para>
	/// <para>	WR3 : SIZEOF(QUERY(temp <* InnerCurves | 'IFC4.IFCLINE' IN TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcArbitraryProfileDefWithVoids : IfcArbitraryClosedProfileDef
	{
		public List<IfcCurve> InnerCurves { get; set; }
		public IfcArbitraryProfileDefWithVoids() : base()
		{
			InnerCurves = new List<IfcCurve>();
		}
		public IfcArbitraryProfileDefWithVoids(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcCurve OuterCurve, List<IfcCurve> InnerCurves) : base (ProfileType, ProfileName, OuterCurve)
		{
			this.InnerCurves = InnerCurves;
		}
	}
	/// <summary>
	/// ENTITY IfcAsset
	/// <para>ENTITY IfcAsset</para>
	/// <para> SUBTYPE OF (IfcGroup);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	OriginalValue : OPTIONAL IfcCostValue;</para>
	/// <para>	CurrentValue : OPTIONAL IfcCostValue;</para>
	/// <para>	TotalReplacementCost : OPTIONAL IfcCostValue;</para>
	/// <para>	Owner : OPTIONAL IfcActorSelect;</para>
	/// <para>	User : OPTIONAL IfcActorSelect;</para>
	/// <para>	ResponsiblePerson : OPTIONAL IfcPerson;</para>
	/// <para>	IncorporationDate : OPTIONAL IfcDate;</para>
	/// <para>	DepreciatedValue : OPTIONAL IfcCostValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAsset : IfcGroup
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcCostValue? OriginalValue { get; set; }
		public IfcCostValue? CurrentValue { get; set; }
		public IfcCostValue? TotalReplacementCost { get; set; }
		public IfcActorSelect? Owner { get; set; }
		public IfcActorSelect? User { get; set; }
		public IfcPerson? ResponsiblePerson { get; set; }
		public IfcDate? IncorporationDate { get; set; }
		public IfcCostValue? DepreciatedValue { get; set; }
		public IfcAsset() : base()
		{
		}
		public IfcAsset(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcCostValue OriginalValue, IfcCostValue CurrentValue, IfcCostValue TotalReplacementCost, IfcActorSelect Owner, IfcActorSelect User, IfcPerson ResponsiblePerson, IfcDate IncorporationDate, IfcCostValue DepreciatedValue) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
			this.OriginalValue = OriginalValue;
			this.CurrentValue = CurrentValue;
			this.TotalReplacementCost = TotalReplacementCost;
			this.Owner = Owner;
			this.User = User;
			this.ResponsiblePerson = ResponsiblePerson;
			this.IncorporationDate = IncorporationDate;
			this.DepreciatedValue = DepreciatedValue;
		}
	}
	/// <summary>
	/// ENTITY IfcAsymmetricIShapeProfileDef
	/// <para>ENTITY IfcAsymmetricIShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	BottomFlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	OverallDepth : IfcPositiveLengthMeasure;</para>
	/// <para>	WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	BottomFlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	BottomFlangeFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	TopFlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	TopFlangeThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TopFlangeFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	BottomFlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	BottomFlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>	TopFlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	TopFlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidFlangeThickness : NOT(EXISTS(TopFlangeThickness)) OR ((BottomFlangeThickness + TopFlangeThickness) < OverallDepth);</para>
	/// <para>	ValidWebThickness : (WebThickness < BottomFlangeWidth) AND (WebThickness < TopFlangeWidth);</para>
	/// <para>	ValidBottomFilletRadius : (NOT(EXISTS(BottomFlangeFilletRadius))) OR </para>
	/// <para>(BottomFlangeFilletRadius <= (BottomFlangeWidth - WebThickness)/2.);</para>
	/// <para>	ValidTopFilletRadius : (NOT(EXISTS(TopFlangeFilletRadius))) OR </para>
	/// <para>(TopFlangeFilletRadius <= (TopFlangeWidth - WebThickness)/2.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAsymmetricIShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure BottomFlangeWidth { get; set; }
		public IfcPositiveLengthMeasure OverallDepth { get; set; }
		public IfcPositiveLengthMeasure WebThickness { get; set; }
		public IfcPositiveLengthMeasure BottomFlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? BottomFlangeFilletRadius { get; set; }
		public IfcPositiveLengthMeasure TopFlangeWidth { get; set; }
		public IfcPositiveLengthMeasure? TopFlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? TopFlangeFilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? BottomFlangeEdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? BottomFlangeSlope { get; set; }
		public IfcNonNegativeLengthMeasure? TopFlangeEdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? TopFlangeSlope { get; set; }
		public IfcAsymmetricIShapeProfileDef() : base()
		{
			BottomFlangeWidth = new IfcPositiveLengthMeasure();
			OverallDepth = new IfcPositiveLengthMeasure();
			WebThickness = new IfcPositiveLengthMeasure();
			BottomFlangeThickness = new IfcPositiveLengthMeasure();
			TopFlangeWidth = new IfcPositiveLengthMeasure();
		}
		public IfcAsymmetricIShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure BottomFlangeWidth, IfcPositiveLengthMeasure OverallDepth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure BottomFlangeThickness, IfcNonNegativeLengthMeasure BottomFlangeFilletRadius, IfcPositiveLengthMeasure TopFlangeWidth, IfcPositiveLengthMeasure TopFlangeThickness, IfcNonNegativeLengthMeasure TopFlangeFilletRadius, IfcNonNegativeLengthMeasure BottomFlangeEdgeRadius, IfcPlaneAngleMeasure BottomFlangeSlope, IfcNonNegativeLengthMeasure TopFlangeEdgeRadius, IfcPlaneAngleMeasure TopFlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.BottomFlangeWidth = BottomFlangeWidth;
			this.OverallDepth = OverallDepth;
			this.WebThickness = WebThickness;
			this.BottomFlangeThickness = BottomFlangeThickness;
			this.BottomFlangeFilletRadius = BottomFlangeFilletRadius;
			this.TopFlangeWidth = TopFlangeWidth;
			this.TopFlangeThickness = TopFlangeThickness;
			this.TopFlangeFilletRadius = TopFlangeFilletRadius;
			this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius;
			this.BottomFlangeSlope = BottomFlangeSlope;
			this.TopFlangeEdgeRadius = TopFlangeEdgeRadius;
			this.TopFlangeSlope = TopFlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcAudioVisualAppliance
	/// <para>ENTITY IfcAudioVisualAppliance</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcAudioVisualApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcAudioVisualApplianceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcAudioVisualApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCAUDIOVISUALAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAudioVisualAppliance : IfcFlowTerminal
	{
		public IfcAudioVisualApplianceTypeEnum? PredefinedType { get; set; }
		public IfcAudioVisualAppliance() : base()
		{
		}
		public IfcAudioVisualAppliance(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAudioVisualApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAudioVisualApplianceType
	/// <para>ENTITY IfcAudioVisualApplianceType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcAudioVisualApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcAudioVisualApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAudioVisualApplianceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAudioVisualApplianceType : IfcFlowTerminalType
	{
		public IfcAudioVisualApplianceTypeEnum PredefinedType { get; set; }
		public IfcAudioVisualApplianceType() : base()
		{
			PredefinedType = new IfcAudioVisualApplianceTypeEnum();
		}
		public IfcAudioVisualApplianceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAudioVisualApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAxis1Placement
	/// <para>ENTITY IfcAxis1Placement</para>
	/// <para> SUBTYPE OF (IfcPlacement);</para>
	/// <para>	Axis : OPTIONAL IfcDirection;</para>
	/// <para> DERIVE</para>
	/// <para>	Z : IfcDirection := NVL (IfcNormalise(Axis), IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([0.0,0.0,1.0]));</para>
	/// <para> WHERE</para>
	/// <para>	AxisIs3D : (NOT (EXISTS (Axis))) OR (Axis.Dim = 3);</para>
	/// <para>	LocationIs3D : SELF\IfcPlacement.Location.Dim = 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAxis1Placement : IfcPlacement
	{
		public IfcDirection? Axis { get; set; }
		public IfcAxis1Placement() : base()
		{
		}
		public IfcAxis1Placement(IfcCartesianPoint Location, IfcDirection Axis) : base (Location)
		{
			this.Axis = Axis;
		}
	}
	/// <summary>
	/// ENTITY IfcAxis2Placement2D
	/// <para>ENTITY IfcAxis2Placement2D</para>
	/// <para> SUBTYPE OF (IfcPlacement);</para>
	/// <para>	RefDirection : OPTIONAL IfcDirection;</para>
	/// <para> DERIVE</para>
	/// <para>	P : LIST [2:2] OF IfcDirection := IfcBuild2Axes(RefDirection);</para>
	/// <para> WHERE</para>
	/// <para>	RefDirIs2D : (NOT (EXISTS (RefDirection))) OR (RefDirection.Dim = 2);</para>
	/// <para>	LocationIs2D : SELF\IfcPlacement.Location.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAxis2Placement2D : IfcPlacement, IfcAxis2Placement
	{
		public IfcDirection? RefDirection { get; set; }
		public IfcAxis2Placement2D() : base()
		{
		}
		public IfcAxis2Placement2D(IfcCartesianPoint Location, IfcDirection RefDirection) : base (Location)
		{
			this.RefDirection = RefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcAxis2Placement3D
	/// <para>ENTITY IfcAxis2Placement3D</para>
	/// <para> SUBTYPE OF (IfcPlacement);</para>
	/// <para>	Axis : OPTIONAL IfcDirection;</para>
	/// <para>	RefDirection : OPTIONAL IfcDirection;</para>
	/// <para> DERIVE</para>
	/// <para>	P : LIST [3:3] OF IfcDirection := IfcBuildAxes(Axis, RefDirection);</para>
	/// <para> WHERE</para>
	/// <para>	LocationIs3D : SELF\IfcPlacement.Location.Dim = 3;</para>
	/// <para>	AxisIs3D : (NOT (EXISTS (Axis))) OR (Axis.Dim = 3);</para>
	/// <para>	RefDirIs3D : (NOT (EXISTS (RefDirection))) OR (RefDirection.Dim = 3);</para>
	/// <para>	AxisToRefDirPosition : (NOT (EXISTS (Axis))) OR (NOT (EXISTS (RefDirection))) OR (IfcCrossProduct(Axis,RefDirection).Magnitude > 0.0);</para>
	/// <para>	AxisAndRefDirProvision : NOT ((EXISTS (Axis)) XOR (EXISTS (RefDirection)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAxis2Placement3D : IfcPlacement, IfcAxis2Placement
	{
		public IfcDirection? Axis { get; set; }
		public IfcDirection? RefDirection { get; set; }
		public IfcAxis2Placement3D() : base()
		{
		}
		public IfcAxis2Placement3D(IfcCartesianPoint Location, IfcDirection Axis, IfcDirection RefDirection) : base (Location)
		{
			this.Axis = Axis;
			this.RefDirection = RefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineCurve
	/// <para>ENTITY IfcBSplineCurve</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBSplineCurveWithKnots))</para>
	/// <para> SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>	Degree : IfcInteger;</para>
	/// <para>	ControlPointsList : LIST [2:?] OF IfcCartesianPoint;</para>
	/// <para>	CurveForm : IfcBSplineCurveForm;</para>
	/// <para>	ClosedCurve : IfcLogical;</para>
	/// <para>	SelfIntersect : IfcLogical;</para>
	/// <para> DERIVE</para>
	/// <para>	UpperIndexOnControlPoints : IfcInteger := (SIZEOF(ControlPointsList) - 1);</para>
	/// <para>	ControlPoints : ARRAY [0:UpperIndexOnControlPoints] OF IfcCartesianPoint := IfcListToArray(ControlPointsList,0,UpperIndexOnControlPoints);</para>
	/// <para> WHERE</para>
	/// <para>	SameDim : SIZEOF(QUERY(Temp <* ControlPointsList |</para>
	/// <para>  Temp.Dim <> ControlPointsList[1].Dim))</para>
	/// <para>= 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBSplineCurve : IfcBoundedCurve
	{
		public IfcInteger Degree { get; set; }
		public List<IfcCartesianPoint> ControlPointsList { get; set; }
		public IfcBSplineCurveForm CurveForm { get; set; }
		public IfcLogical ClosedCurve { get; set; }
		public IfcLogical SelfIntersect { get; set; }
		public IfcBSplineCurve() : base()
		{
			Degree = new IfcInteger();
			ControlPointsList = new List<IfcCartesianPoint>();
			CurveForm = new IfcBSplineCurveForm();
			ClosedCurve = new IfcLogical();
			SelfIntersect = new IfcLogical();
		}
		public IfcBSplineCurve(IfcInteger Degree, List<IfcCartesianPoint> ControlPointsList, IfcBSplineCurveForm CurveForm, IfcLogical ClosedCurve, IfcLogical SelfIntersect) : base ()
		{
			this.Degree = Degree;
			this.ControlPointsList = ControlPointsList;
			this.CurveForm = CurveForm;
			this.ClosedCurve = ClosedCurve;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineCurveWithKnots
	/// <para>ENTITY IfcBSplineCurveWithKnots</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRationalBSplineCurveWithKnots))</para>
	/// <para> SUBTYPE OF (IfcBSplineCurve);</para>
	/// <para>	KnotMultiplicities : LIST [2:?] OF IfcInteger;</para>
	/// <para>	Knots : LIST [2:?] OF IfcParameterValue;</para>
	/// <para>	KnotSpec : IfcKnotType;</para>
	/// <para> DERIVE</para>
	/// <para>	UpperIndexOnKnots : IfcInteger := SIZEOF(Knots);</para>
	/// <para> WHERE</para>
	/// <para>	ConsistentBSpline : IfcConstraintsParamBSpline(Degree, UpperIndexOnKnots,</para>
	/// <para>UpperIndexOnControlPoints, KnotMultiplicities, Knots);</para>
	/// <para>	CorrespondingKnotLists : SIZEOF(KnotMultiplicities) = UpperIndexOnKnots;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBSplineCurveWithKnots : IfcBSplineCurve
	{
		public List<IfcInteger> KnotMultiplicities { get; set; }
		public List<IfcParameterValue> Knots { get; set; }
		public IfcKnotType KnotSpec { get; set; }
		public IfcBSplineCurveWithKnots() : base()
		{
			KnotMultiplicities = new List<IfcInteger>();
			Knots = new List<IfcParameterValue>();
			KnotSpec = new IfcKnotType();
		}
		public IfcBSplineCurveWithKnots(IfcInteger Degree, List<IfcCartesianPoint> ControlPointsList, IfcBSplineCurveForm CurveForm, IfcLogical ClosedCurve, IfcLogical SelfIntersect, List<IfcInteger> KnotMultiplicities, List<IfcParameterValue> Knots, IfcKnotType KnotSpec) : base (Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect)
		{
			this.KnotMultiplicities = KnotMultiplicities;
			this.Knots = Knots;
			this.KnotSpec = KnotSpec;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineSurface
	/// <para>ENTITY IfcBSplineSurface</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBSplineSurfaceWithKnots))</para>
	/// <para> SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>	UDegree : IfcInteger;</para>
	/// <para>	VDegree : IfcInteger;</para>
	/// <para>	ControlPointsList : LIST [2:?] OF LIST [2:?] OF IfcCartesianPoint;</para>
	/// <para>	SurfaceForm : IfcBSplineSurfaceForm;</para>
	/// <para>	UClosed : IfcLogical;</para>
	/// <para>	VClosed : IfcLogical;</para>
	/// <para>	SelfIntersect : IfcLogical;</para>
	/// <para> DERIVE</para>
	/// <para>	UUpper : IfcInteger := SIZEOF(ControlPointsList) - 1;</para>
	/// <para>	VUpper : IfcInteger := SIZEOF(ControlPointsList[1]) - 1;</para>
	/// <para>	ControlPoints : ARRAY [0:UUpper] OF ARRAY [0:VUpper] OF IfcCartesianPoint := IfcMakeArrayOfArray(ControlPointsList,</para>
	/// <para>0,UUpper,0,VUpper);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBSplineSurface : IfcBoundedSurface
	{
		public IfcInteger UDegree { get; set; }
		public IfcInteger VDegree { get; set; }
		public List<List<IfcCartesianPoint >> ControlPointsList { get; set; }
		public IfcBSplineSurfaceForm SurfaceForm { get; set; }
		public IfcLogical UClosed { get; set; }
		public IfcLogical VClosed { get; set; }
		public IfcLogical SelfIntersect { get; set; }
		public IfcBSplineSurface() : base()
		{
			UDegree = new IfcInteger();
			VDegree = new IfcInteger();
			ControlPointsList = new List<List<IfcCartesianPoint >>();
			SurfaceForm = new IfcBSplineSurfaceForm();
			UClosed = new IfcLogical();
			VClosed = new IfcLogical();
			SelfIntersect = new IfcLogical();
		}
		public IfcBSplineSurface(IfcInteger UDegree, IfcInteger VDegree, List<List<IfcCartesianPoint >> ControlPointsList, IfcBSplineSurfaceForm SurfaceForm, IfcLogical UClosed, IfcLogical VClosed, IfcLogical SelfIntersect) : base ()
		{
			this.UDegree = UDegree;
			this.VDegree = VDegree;
			this.ControlPointsList = ControlPointsList;
			this.SurfaceForm = SurfaceForm;
			this.UClosed = UClosed;
			this.VClosed = VClosed;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineSurfaceWithKnots
	/// <para>ENTITY IfcBSplineSurfaceWithKnots</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRationalBSplineSurfaceWithKnots))</para>
	/// <para> SUBTYPE OF (IfcBSplineSurface);</para>
	/// <para>	UMultiplicities : LIST [2:?] OF IfcInteger;</para>
	/// <para>	VMultiplicities : LIST [2:?] OF IfcInteger;</para>
	/// <para>	UKnots : LIST [2:?] OF IfcParameterValue;</para>
	/// <para>	VKnots : LIST [2:?] OF IfcParameterValue;</para>
	/// <para>	KnotSpec : IfcKnotType;</para>
	/// <para> DERIVE</para>
	/// <para>	KnotVUpper : IfcInteger := SIZEOF(VKnots);</para>
	/// <para>	KnotUUpper : IfcInteger := SIZEOF(UKnots);</para>
	/// <para> WHERE</para>
	/// <para>	UDirectionConstraints : IfcConstraintsParamBSpline (</para>
	/// <para>  SELF\IfcBSplineSurface.UDegree, KnotUUpper, </para>
	/// <para>  SELF\IfcBSplineSurface.UUpper, UMultiplicities, UKnots);</para>
	/// <para>	VDirectionConstraints : IfcConstraintsParamBSpline (</para>
	/// <para>  SELF\IfcBSplineSurface.VDegree, KnotVUpper, </para>
	/// <para>  SELF\IfcBSplineSurface.VUpper, VMultiplicities, VKnots);</para>
	/// <para>	CorrespondingULists : SIZEOF(UMultiplicities) = KnotUUpper;</para>
	/// <para>	CorrespondingVLists : SIZEOF(VMultiplicities) = KnotVUpper;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBSplineSurfaceWithKnots : IfcBSplineSurface
	{
		public List<IfcInteger> UMultiplicities { get; set; }
		public List<IfcInteger> VMultiplicities { get; set; }
		public List<IfcParameterValue> UKnots { get; set; }
		public List<IfcParameterValue> VKnots { get; set; }
		public IfcKnotType KnotSpec { get; set; }
		public IfcBSplineSurfaceWithKnots() : base()
		{
			UMultiplicities = new List<IfcInteger>();
			VMultiplicities = new List<IfcInteger>();
			UKnots = new List<IfcParameterValue>();
			VKnots = new List<IfcParameterValue>();
			KnotSpec = new IfcKnotType();
		}
		public IfcBSplineSurfaceWithKnots(IfcInteger UDegree, IfcInteger VDegree, List<List<IfcCartesianPoint >> ControlPointsList, IfcBSplineSurfaceForm SurfaceForm, IfcLogical UClosed, IfcLogical VClosed, IfcLogical SelfIntersect, List<IfcInteger> UMultiplicities, List<IfcInteger> VMultiplicities, List<IfcParameterValue> UKnots, List<IfcParameterValue> VKnots, IfcKnotType KnotSpec) : base (UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect)
		{
			this.UMultiplicities = UMultiplicities;
			this.VMultiplicities = VMultiplicities;
			this.UKnots = UKnots;
			this.VKnots = VKnots;
			this.KnotSpec = KnotSpec;
		}
	}
	/// <summary>
	/// ENTITY IfcBeam
	/// <para>ENTITY IfcBeam</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBeamStandardCase))</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBeamTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBeamTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBeamTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCBEAMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBeam : IfcBuildingElement
	{
		public IfcBeamTypeEnum? PredefinedType { get; set; }
		public IfcBeam() : base()
		{
		}
		public IfcBeam(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBeamStandardCase
	/// <para>ENTITY IfcBeamStandardCase</para>
	/// <para> SUBTYPE OF (IfcBeam);</para>
	/// <para> WHERE</para>
	/// <para>	HasMaterialProfileSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>              ('IFC4.IFCMATERIALPROFILESETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>              )) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBeamStandardCase : IfcBeam
	{
		public IfcBeamStandardCase() : base()
		{
		}
		public IfcBeamStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBeamType
	/// <para>ENTITY IfcBeamType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcBeamTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBeamTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBeamTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBeamType : IfcBuildingElementType
	{
		public IfcBeamTypeEnum PredefinedType { get; set; }
		public IfcBeamType() : base()
		{
			PredefinedType = new IfcBeamTypeEnum();
		}
		public IfcBeamType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBlobTexture
	/// <para>ENTITY IfcBlobTexture</para>
	/// <para> SUBTYPE OF (IfcSurfaceTexture);</para>
	/// <para>	RasterFormat : IfcIdentifier;</para>
	/// <para>	RasterCode : IfcBinary;</para>
	/// <para> WHERE</para>
	/// <para>	SupportedRasterFormat : SELF.RasterFormat IN ['BMP', 'JPG', 'GIF', 'PNG'];</para>
	/// <para>	RasterCodeByteStream : BLENGTH(RasterCode) MOD 8 = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBlobTexture : IfcSurfaceTexture
	{
		public IfcIdentifier RasterFormat { get; set; }
		public IfcBinary RasterCode { get; set; }
		public IfcBlobTexture() : base()
		{
			RasterFormat = new IfcIdentifier();
			RasterCode = new IfcBinary();
		}
		public IfcBlobTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter, IfcIdentifier RasterFormat, IfcBinary RasterCode) : base (RepeatS, RepeatT, Mode, TextureTransform, Parameter)
		{
			this.RasterFormat = RasterFormat;
			this.RasterCode = RasterCode;
		}
	}
	/// <summary>
	/// ENTITY IfcBlock
	/// <para>ENTITY IfcBlock</para>
	/// <para> SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>	XLength : IfcPositiveLengthMeasure;</para>
	/// <para>	YLength : IfcPositiveLengthMeasure;</para>
	/// <para>	ZLength : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBlock : IfcCsgPrimitive3D
	{
		public IfcPositiveLengthMeasure XLength { get; set; }
		public IfcPositiveLengthMeasure YLength { get; set; }
		public IfcPositiveLengthMeasure ZLength { get; set; }
		public IfcBlock() : base()
		{
			XLength = new IfcPositiveLengthMeasure();
			YLength = new IfcPositiveLengthMeasure();
			ZLength = new IfcPositiveLengthMeasure();
		}
		public IfcBlock(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure XLength, IfcPositiveLengthMeasure YLength, IfcPositiveLengthMeasure ZLength) : base (Position)
		{
			this.XLength = XLength;
			this.YLength = YLength;
			this.ZLength = ZLength;
		}
	}
	/// <summary>
	/// ENTITY IfcBoiler
	/// <para>ENTITY IfcBoiler</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBoilerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcBoilerTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcBoilerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCBOILERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoiler : IfcEnergyConversionDevice
	{
		public IfcBoilerTypeEnum? PredefinedType { get; set; }
		public IfcBoiler() : base()
		{
		}
		public IfcBoiler(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBoilerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBoilerType
	/// <para>ENTITY IfcBoilerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcBoilerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBoilerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBoilerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoilerType : IfcEnergyConversionDeviceType
	{
		public IfcBoilerTypeEnum PredefinedType { get; set; }
		public IfcBoilerType() : base()
		{
			PredefinedType = new IfcBoilerTypeEnum();
		}
		public IfcBoilerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBoilerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBooleanClippingResult
	/// <para>ENTITY IfcBooleanClippingResult</para>
	/// <para> SUBTYPE OF (IfcBooleanResult);</para>
	/// <para> WHERE</para>
	/// <para>	FirstOperandType : ('IFC4.IFCSWEPTAREASOLID' IN TYPEOF(FirstOperand)) OR </para>
	/// <para>('IFC4.IFCSWEPTDISCSOLID' IN TYPEOF(FirstOperand)) OR </para>
	/// <para>('IFC4.IFCBOOLEANCLIPPINGRESULT' IN TYPEOF(FirstOperand));</para>
	/// <para>	SecondOperandType : ('IFC4.IFCHALFSPACESOLID' IN TYPEOF(SecondOperand));</para>
	/// <para>	OperatorType : Operator = DIFFERENCE;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBooleanClippingResult : IfcBooleanResult
	{
		public IfcBooleanClippingResult() : base()
		{
		}
		public IfcBooleanClippingResult(IfcBooleanOperator Operator, IfcBooleanOperand FirstOperand, IfcBooleanOperand SecondOperand) : base (Operator, FirstOperand, SecondOperand)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBooleanResult
	/// <para>ENTITY IfcBooleanResult</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBooleanClippingResult))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Operator : IfcBooleanOperator;</para>
	/// <para>	FirstOperand : IfcBooleanOperand;</para>
	/// <para>	SecondOperand : IfcBooleanOperand;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := FirstOperand.Dim;</para>
	/// <para> WHERE</para>
	/// <para>	SameDim : FirstOperand.Dim = SecondOperand.Dim;</para>
	/// <para>	FirstOperandClosed : NOT('IFC4.IFCTESSELLATEDFACESET' IN TYPEOF(FirstOperand)) OR (EXISTS(FirstOperand.Closed) AND FirstOperand.Closed);</para>
	/// <para>	SecondOperandClosed : NOT('IFC4.IFCTESSELLATEDFACESET' IN TYPEOF(SecondOperand)) OR (EXISTS(SecondOperand.Closed) AND SecondOperand.Closed);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBooleanResult : IfcGeometricRepresentationItem, IfcBooleanOperand, IfcCsgSelect
	{
		public IfcBooleanOperator Operator { get; set; }
		public IfcBooleanOperand FirstOperand { get; set; }
		public IfcBooleanOperand SecondOperand { get; set; }
		public IfcBooleanResult() : base()
		{
			Operator = new IfcBooleanOperator();
			FirstOperand = new IfcBooleanOperand();
			SecondOperand = new IfcBooleanOperand();
		}
		public IfcBooleanResult(IfcBooleanOperator Operator, IfcBooleanOperand FirstOperand, IfcBooleanOperand SecondOperand) : base ()
		{
			this.Operator = Operator;
			this.FirstOperand = FirstOperand;
			this.SecondOperand = SecondOperand;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryCondition
	/// <para>ENTITY IfcBoundaryCondition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBoundaryEdgeCondition</para>
	/// <para>    ,IfcBoundaryFaceCondition</para>
	/// <para>    ,IfcBoundaryNodeCondition));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBoundaryCondition : ENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcBoundaryCondition() : base()
		{
		}
		public IfcBoundaryCondition(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryCurve
	/// <para>ENTITY IfcBoundaryCurve</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcOuterBoundaryCurve))</para>
	/// <para> SUBTYPE OF (IfcCompositeCurveOnSurface);</para>
	/// <para> WHERE</para>
	/// <para>	IsClosed : SELF\IfcCompositeCurve.ClosedCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryCurve : IfcCompositeCurveOnSurface
	{
		public IfcBoundaryCurve() : base()
		{
		}
		public IfcBoundaryCurve(List<IfcCompositeCurveSegment> Segments, IfcLogical SelfIntersect) : base (Segments, SelfIntersect)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryEdgeCondition
	/// <para>ENTITY IfcBoundaryEdgeCondition</para>
	/// <para> SUBTYPE OF (IfcBoundaryCondition);</para>
	/// <para>	TranslationalStiffnessByLengthX : OPTIONAL IfcModulusOfTranslationalSubgradeReactionSelect;</para>
	/// <para>	TranslationalStiffnessByLengthY : OPTIONAL IfcModulusOfTranslationalSubgradeReactionSelect;</para>
	/// <para>	TranslationalStiffnessByLengthZ : OPTIONAL IfcModulusOfTranslationalSubgradeReactionSelect;</para>
	/// <para>	RotationalStiffnessByLengthX : OPTIONAL IfcModulusOfRotationalSubgradeReactionSelect;</para>
	/// <para>	RotationalStiffnessByLengthY : OPTIONAL IfcModulusOfRotationalSubgradeReactionSelect;</para>
	/// <para>	RotationalStiffnessByLengthZ : OPTIONAL IfcModulusOfRotationalSubgradeReactionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryEdgeCondition : IfcBoundaryCondition
	{
		public IfcModulusOfTranslationalSubgradeReactionSelect? TranslationalStiffnessByLengthX { get; set; }
		public IfcModulusOfTranslationalSubgradeReactionSelect? TranslationalStiffnessByLengthY { get; set; }
		public IfcModulusOfTranslationalSubgradeReactionSelect? TranslationalStiffnessByLengthZ { get; set; }
		public IfcModulusOfRotationalSubgradeReactionSelect? RotationalStiffnessByLengthX { get; set; }
		public IfcModulusOfRotationalSubgradeReactionSelect? RotationalStiffnessByLengthY { get; set; }
		public IfcModulusOfRotationalSubgradeReactionSelect? RotationalStiffnessByLengthZ { get; set; }
		public IfcBoundaryEdgeCondition() : base()
		{
		}
		public IfcBoundaryEdgeCondition(IfcLabel Name, IfcModulusOfTranslationalSubgradeReactionSelect TranslationalStiffnessByLengthX, IfcModulusOfTranslationalSubgradeReactionSelect TranslationalStiffnessByLengthY, IfcModulusOfTranslationalSubgradeReactionSelect TranslationalStiffnessByLengthZ, IfcModulusOfRotationalSubgradeReactionSelect RotationalStiffnessByLengthX, IfcModulusOfRotationalSubgradeReactionSelect RotationalStiffnessByLengthY, IfcModulusOfRotationalSubgradeReactionSelect RotationalStiffnessByLengthZ) : base (Name)
		{
			this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX;
			this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY;
			this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ;
			this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX;
			this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY;
			this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryFaceCondition
	/// <para>ENTITY IfcBoundaryFaceCondition</para>
	/// <para> SUBTYPE OF (IfcBoundaryCondition);</para>
	/// <para>	TranslationalStiffnessByAreaX : OPTIONAL IfcModulusOfSubgradeReactionSelect;</para>
	/// <para>	TranslationalStiffnessByAreaY : OPTIONAL IfcModulusOfSubgradeReactionSelect;</para>
	/// <para>	TranslationalStiffnessByAreaZ : OPTIONAL IfcModulusOfSubgradeReactionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryFaceCondition : IfcBoundaryCondition
	{
		public IfcModulusOfSubgradeReactionSelect? TranslationalStiffnessByAreaX { get; set; }
		public IfcModulusOfSubgradeReactionSelect? TranslationalStiffnessByAreaY { get; set; }
		public IfcModulusOfSubgradeReactionSelect? TranslationalStiffnessByAreaZ { get; set; }
		public IfcBoundaryFaceCondition() : base()
		{
		}
		public IfcBoundaryFaceCondition(IfcLabel Name, IfcModulusOfSubgradeReactionSelect TranslationalStiffnessByAreaX, IfcModulusOfSubgradeReactionSelect TranslationalStiffnessByAreaY, IfcModulusOfSubgradeReactionSelect TranslationalStiffnessByAreaZ) : base (Name)
		{
			this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX;
			this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY;
			this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryNodeCondition
	/// <para>ENTITY IfcBoundaryNodeCondition</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBoundaryNodeConditionWarping))</para>
	/// <para> SUBTYPE OF (IfcBoundaryCondition);</para>
	/// <para>	TranslationalStiffnessX : OPTIONAL IfcTranslationalStiffnessSelect;</para>
	/// <para>	TranslationalStiffnessY : OPTIONAL IfcTranslationalStiffnessSelect;</para>
	/// <para>	TranslationalStiffnessZ : OPTIONAL IfcTranslationalStiffnessSelect;</para>
	/// <para>	RotationalStiffnessX : OPTIONAL IfcRotationalStiffnessSelect;</para>
	/// <para>	RotationalStiffnessY : OPTIONAL IfcRotationalStiffnessSelect;</para>
	/// <para>	RotationalStiffnessZ : OPTIONAL IfcRotationalStiffnessSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryNodeCondition : IfcBoundaryCondition
	{
		public IfcTranslationalStiffnessSelect? TranslationalStiffnessX { get; set; }
		public IfcTranslationalStiffnessSelect? TranslationalStiffnessY { get; set; }
		public IfcTranslationalStiffnessSelect? TranslationalStiffnessZ { get; set; }
		public IfcRotationalStiffnessSelect? RotationalStiffnessX { get; set; }
		public IfcRotationalStiffnessSelect? RotationalStiffnessY { get; set; }
		public IfcRotationalStiffnessSelect? RotationalStiffnessZ { get; set; }
		public IfcBoundaryNodeCondition() : base()
		{
		}
		public IfcBoundaryNodeCondition(IfcLabel Name, IfcTranslationalStiffnessSelect TranslationalStiffnessX, IfcTranslationalStiffnessSelect TranslationalStiffnessY, IfcTranslationalStiffnessSelect TranslationalStiffnessZ, IfcRotationalStiffnessSelect RotationalStiffnessX, IfcRotationalStiffnessSelect RotationalStiffnessY, IfcRotationalStiffnessSelect RotationalStiffnessZ) : base (Name)
		{
			this.TranslationalStiffnessX = TranslationalStiffnessX;
			this.TranslationalStiffnessY = TranslationalStiffnessY;
			this.TranslationalStiffnessZ = TranslationalStiffnessZ;
			this.RotationalStiffnessX = RotationalStiffnessX;
			this.RotationalStiffnessY = RotationalStiffnessY;
			this.RotationalStiffnessZ = RotationalStiffnessZ;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryNodeConditionWarping
	/// <para>ENTITY IfcBoundaryNodeConditionWarping</para>
	/// <para> SUBTYPE OF (IfcBoundaryNodeCondition);</para>
	/// <para>	WarpingStiffness : OPTIONAL IfcWarpingStiffnessSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryNodeConditionWarping : IfcBoundaryNodeCondition
	{
		public IfcWarpingStiffnessSelect? WarpingStiffness { get; set; }
		public IfcBoundaryNodeConditionWarping() : base()
		{
		}
		public IfcBoundaryNodeConditionWarping(IfcLabel Name, IfcTranslationalStiffnessSelect TranslationalStiffnessX, IfcTranslationalStiffnessSelect TranslationalStiffnessY, IfcTranslationalStiffnessSelect TranslationalStiffnessZ, IfcRotationalStiffnessSelect RotationalStiffnessX, IfcRotationalStiffnessSelect RotationalStiffnessY, IfcRotationalStiffnessSelect RotationalStiffnessZ, IfcWarpingStiffnessSelect WarpingStiffness) : base (Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ)
		{
			this.WarpingStiffness = WarpingStiffness;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundedCurve
	/// <para>ENTITY IfcBoundedCurve</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBSplineCurve</para>
	/// <para>    ,IfcCompositeCurve</para>
	/// <para>    ,IfcIndexedPolyCurve</para>
	/// <para>    ,IfcPolyline</para>
	/// <para>    ,IfcTrimmedCurve))</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBoundedCurve : IfcCurve, IfcCurveOrEdgeCurve
	{
		public IfcBoundedCurve() : base()
		{
		}
		public IfcBoundedCurve() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBoundedSurface
	/// <para>ENTITY IfcBoundedSurface</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBSplineSurface</para>
	/// <para>    ,IfcCurveBoundedPlane</para>
	/// <para>    ,IfcCurveBoundedSurface</para>
	/// <para>    ,IfcRectangularTrimmedSurface))</para>
	/// <para> SUBTYPE OF (IfcSurface);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBoundedSurface : IfcSurface
	{
		public IfcBoundedSurface() : base()
		{
		}
		public IfcBoundedSurface() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBoundingBox
	/// <para>ENTITY IfcBoundingBox</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Corner : IfcCartesianPoint;</para>
	/// <para>	XDim : IfcPositiveLengthMeasure;</para>
	/// <para>	YDim : IfcPositiveLengthMeasure;</para>
	/// <para>	ZDim : IfcPositiveLengthMeasure;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundingBox : IfcGeometricRepresentationItem
	{
		public IfcCartesianPoint Corner { get; set; }
		public IfcPositiveLengthMeasure XDim { get; set; }
		public IfcPositiveLengthMeasure YDim { get; set; }
		public IfcPositiveLengthMeasure ZDim { get; set; }
		public IfcBoundingBox() : base()
		{
			Corner = new IfcCartesianPoint();
			XDim = new IfcPositiveLengthMeasure();
			YDim = new IfcPositiveLengthMeasure();
			ZDim = new IfcPositiveLengthMeasure();
		}
		public IfcBoundingBox(IfcCartesianPoint Corner, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim, IfcPositiveLengthMeasure ZDim) : base ()
		{
			this.Corner = Corner;
			this.XDim = XDim;
			this.YDim = YDim;
			this.ZDim = ZDim;
		}
	}
	/// <summary>
	/// ENTITY IfcBoxedHalfSpace
	/// <para>ENTITY IfcBoxedHalfSpace</para>
	/// <para> SUBTYPE OF (IfcHalfSpaceSolid);</para>
	/// <para>	Enclosure : IfcBoundingBox;</para>
	/// <para> WHERE</para>
	/// <para>	UnboundedSurface : NOT ('IFC4.IFCCURVEBOUNDEDPLANE' IN TYPEOF(SELF\IfcHalfSpaceSolid.BaseSurface));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoxedHalfSpace : IfcHalfSpaceSolid
	{
		public IfcBoundingBox Enclosure { get; set; }
		public IfcBoxedHalfSpace() : base()
		{
			Enclosure = new IfcBoundingBox();
		}
		public IfcBoxedHalfSpace(IfcSurface BaseSurface, IfcBoolean AgreementFlag, IfcBoundingBox Enclosure) : base (BaseSurface, AgreementFlag)
		{
			this.Enclosure = Enclosure;
		}
	}
	/// <summary>
	/// ENTITY IfcBuilding
	/// <para>ENTITY IfcBuilding</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>	ElevationOfRefHeight : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ElevationOfTerrain : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	BuildingAddress : OPTIONAL IfcPostalAddress;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuilding : IfcSpatialStructureElement
	{
		public IfcLengthMeasure? ElevationOfRefHeight { get; set; }
		public IfcLengthMeasure? ElevationOfTerrain { get; set; }
		public IfcPostalAddress? BuildingAddress { get; set; }
		public IfcBuilding() : base()
		{
		}
		public IfcBuilding(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcLengthMeasure ElevationOfRefHeight, IfcLengthMeasure ElevationOfTerrain, IfcPostalAddress BuildingAddress) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.ElevationOfRefHeight = ElevationOfRefHeight;
			this.ElevationOfTerrain = ElevationOfTerrain;
			this.BuildingAddress = BuildingAddress;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElement
	/// <para>ENTITY IfcBuildingElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBeam</para>
	/// <para>    ,IfcBuildingElementProxy</para>
	/// <para>    ,IfcChimney</para>
	/// <para>    ,IfcColumn</para>
	/// <para>    ,IfcCovering</para>
	/// <para>    ,IfcCurtainWall</para>
	/// <para>    ,IfcDoor</para>
	/// <para>    ,IfcFooting</para>
	/// <para>    ,IfcMember</para>
	/// <para>    ,IfcPile</para>
	/// <para>    ,IfcPlate</para>
	/// <para>    ,IfcRailing</para>
	/// <para>    ,IfcRamp</para>
	/// <para>    ,IfcRampFlight</para>
	/// <para>    ,IfcRoof</para>
	/// <para>    ,IfcShadingDevice</para>
	/// <para>    ,IfcSlab</para>
	/// <para>    ,IfcStair</para>
	/// <para>    ,IfcStairFlight</para>
	/// <para>    ,IfcWall</para>
	/// <para>    ,IfcWindow))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para> WHERE</para>
	/// <para>	MaxOneMaterialAssociation : SIZEOF (QUERY(temp <* SELF\IfcObjectDefinition.HasAssociations |</para>
	/// <para>  'IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)</para>
	/// <para>  )) <= 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBuildingElement : IfcElement
	{
		public IfcBuildingElement() : base()
		{
		}
		public IfcBuildingElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementPart
	/// <para>ENTITY IfcBuildingElementPart</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBuildingElementPartTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcBuildingElementPartTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBuildingElementPartTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4.IFCBUILDINGELEMENTPARTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementPart : IfcElementComponent
	{
		public IfcBuildingElementPartTypeEnum? PredefinedType { get; set; }
		public IfcBuildingElementPart() : base()
		{
		}
		public IfcBuildingElementPart(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBuildingElementPartTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementPartType
	/// <para>ENTITY IfcBuildingElementPartType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcBuildingElementPartTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBuildingElementPartTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBuildingElementPartTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementPartType : IfcElementComponentType
	{
		public IfcBuildingElementPartTypeEnum PredefinedType { get; set; }
		public IfcBuildingElementPartType() : base()
		{
			PredefinedType = new IfcBuildingElementPartTypeEnum();
		}
		public IfcBuildingElementPartType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBuildingElementPartTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementProxy
	/// <para>ENTITY IfcBuildingElementProxy</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBuildingElementProxyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcBuildingElementProxyTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcBuildingElementProxyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCBUILDINGELEMENTPROXYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementProxy : IfcBuildingElement
	{
		public IfcBuildingElementProxyTypeEnum? PredefinedType { get; set; }
		public IfcBuildingElementProxy() : base()
		{
		}
		public IfcBuildingElementProxy(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBuildingElementProxyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementProxyType
	/// <para>ENTITY IfcBuildingElementProxyType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcBuildingElementProxyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBuildingElementProxyTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBuildingElementProxyTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementProxyType : IfcBuildingElementType
	{
		public IfcBuildingElementProxyTypeEnum PredefinedType { get; set; }
		public IfcBuildingElementProxyType() : base()
		{
			PredefinedType = new IfcBuildingElementProxyTypeEnum();
		}
		public IfcBuildingElementProxyType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBuildingElementProxyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementType
	/// <para>ENTITY IfcBuildingElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBeamType</para>
	/// <para>    ,IfcBuildingElementProxyType</para>
	/// <para>    ,IfcChimneyType</para>
	/// <para>    ,IfcColumnType</para>
	/// <para>    ,IfcCoveringType</para>
	/// <para>    ,IfcCurtainWallType</para>
	/// <para>    ,IfcDoorType</para>
	/// <para>    ,IfcFootingType</para>
	/// <para>    ,IfcMemberType</para>
	/// <para>    ,IfcPileType</para>
	/// <para>    ,IfcPlateType</para>
	/// <para>    ,IfcRailingType</para>
	/// <para>    ,IfcRampFlightType</para>
	/// <para>    ,IfcRampType</para>
	/// <para>    ,IfcRoofType</para>
	/// <para>    ,IfcShadingDeviceType</para>
	/// <para>    ,IfcSlabType</para>
	/// <para>    ,IfcStairFlightType</para>
	/// <para>    ,IfcStairType</para>
	/// <para>    ,IfcWallType</para>
	/// <para>    ,IfcWindowType))</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBuildingElementType : IfcElementType
	{
		public IfcBuildingElementType() : base()
		{
		}
		public IfcBuildingElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingStorey
	/// <para>ENTITY IfcBuildingStorey</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>	Elevation : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingStorey : IfcSpatialStructureElement
	{
		public IfcLengthMeasure? Elevation { get; set; }
		public IfcBuildingStorey() : base()
		{
		}
		public IfcBuildingStorey(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcLengthMeasure Elevation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.Elevation = Elevation;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingSystem
	/// <para>ENTITY IfcBuildingSystem</para>
	/// <para> SUBTYPE OF (IfcSystem);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBuildingSystemTypeEnum;</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingSystem : IfcSystem
	{
		public IfcBuildingSystemTypeEnum? PredefinedType { get; set; }
		public IfcLabel? LongName { get; set; }
		public IfcBuildingSystem() : base()
		{
		}
		public IfcBuildingSystem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcBuildingSystemTypeEnum PredefinedType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcBurner
	/// <para>ENTITY IfcBurner</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcBurnerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcBurnerTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcBurnerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCBURNERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBurner : IfcEnergyConversionDevice
	{
		public IfcBurnerTypeEnum? PredefinedType { get; set; }
		public IfcBurner() : base()
		{
		}
		public IfcBurner(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBurnerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBurnerType
	/// <para>ENTITY IfcBurnerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcBurnerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcBurnerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBurnerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBurnerType : IfcEnergyConversionDeviceType
	{
		public IfcBurnerTypeEnum PredefinedType { get; set; }
		public IfcBurnerType() : base()
		{
			PredefinedType = new IfcBurnerTypeEnum();
		}
		public IfcBurnerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBurnerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCShapeProfileDef
	/// <para>ENTITY IfcCShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para>	Width : IfcPositiveLengthMeasure;</para>
	/// <para>	WallThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	Girth : IfcPositiveLengthMeasure;</para>
	/// <para>	InternalFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidGirth : Girth < (Depth / 2.);</para>
	/// <para>	ValidInternalFilletRadius : NOT(EXISTS(InternalFilletRadius)) OR</para>
	/// <para>((InternalFilletRadius <= Width/2. - WallThickness) AND (InternalFilletRadius <= Depth/2. - WallThickness));</para>
	/// <para>	ValidWallThickness : (WallThickness < Width/2.) AND (WallThickness < Depth/2.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcPositiveLengthMeasure Width { get; set; }
		public IfcPositiveLengthMeasure WallThickness { get; set; }
		public IfcPositiveLengthMeasure Girth { get; set; }
		public IfcNonNegativeLengthMeasure? InternalFilletRadius { get; set; }
		public IfcCShapeProfileDef() : base()
		{
			Depth = new IfcPositiveLengthMeasure();
			Width = new IfcPositiveLengthMeasure();
			WallThickness = new IfcPositiveLengthMeasure();
			Girth = new IfcPositiveLengthMeasure();
		}
		public IfcCShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure Width, IfcPositiveLengthMeasure WallThickness, IfcPositiveLengthMeasure Girth, IfcNonNegativeLengthMeasure InternalFilletRadius) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.Width = Width;
			this.WallThickness = WallThickness;
			this.Girth = Girth;
			this.InternalFilletRadius = InternalFilletRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierFitting
	/// <para>ENTITY IfcCableCarrierFitting</para>
	/// <para> SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCableCarrierFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCableCarrierFittingTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCableCarrierFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCABLECARRIERFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierFitting : IfcFlowFitting
	{
		public IfcCableCarrierFittingTypeEnum? PredefinedType { get; set; }
		public IfcCableCarrierFitting() : base()
		{
		}
		public IfcCableCarrierFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableCarrierFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierFittingType
	/// <para>ENTITY IfcCableCarrierFittingType</para>
	/// <para> SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>	PredefinedType : IfcCableCarrierFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCableCarrierFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableCarrierFittingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierFittingType : IfcFlowFittingType
	{
		public IfcCableCarrierFittingTypeEnum PredefinedType { get; set; }
		public IfcCableCarrierFittingType() : base()
		{
			PredefinedType = new IfcCableCarrierFittingTypeEnum();
		}
		public IfcCableCarrierFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableCarrierFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierSegment
	/// <para>ENTITY IfcCableCarrierSegment</para>
	/// <para> SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCableCarrierSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCableCarrierSegmentTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCableCarrierSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCABLECARRIERSEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierSegment : IfcFlowSegment
	{
		public IfcCableCarrierSegmentTypeEnum? PredefinedType { get; set; }
		public IfcCableCarrierSegment() : base()
		{
		}
		public IfcCableCarrierSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableCarrierSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierSegmentType
	/// <para>ENTITY IfcCableCarrierSegmentType</para>
	/// <para> SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>	PredefinedType : IfcCableCarrierSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCableCarrierSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableCarrierSegmentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierSegmentType : IfcFlowSegmentType
	{
		public IfcCableCarrierSegmentTypeEnum PredefinedType { get; set; }
		public IfcCableCarrierSegmentType() : base()
		{
			PredefinedType = new IfcCableCarrierSegmentTypeEnum();
		}
		public IfcCableCarrierSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableCarrierSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableFitting
	/// <para>ENTITY IfcCableFitting</para>
	/// <para> SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCableFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCableFittingTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCableFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCABLEFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableFitting : IfcFlowFitting
	{
		public IfcCableFittingTypeEnum? PredefinedType { get; set; }
		public IfcCableFitting() : base()
		{
		}
		public IfcCableFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableFittingType
	/// <para>ENTITY IfcCableFittingType</para>
	/// <para> SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>	PredefinedType : IfcCableFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCableFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableFittingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableFittingType : IfcFlowFittingType
	{
		public IfcCableFittingTypeEnum PredefinedType { get; set; }
		public IfcCableFittingType() : base()
		{
			PredefinedType = new IfcCableFittingTypeEnum();
		}
		public IfcCableFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableSegment
	/// <para>ENTITY IfcCableSegment</para>
	/// <para> SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCableSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCableSegmentTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCableSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCABLESEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableSegment : IfcFlowSegment
	{
		public IfcCableSegmentTypeEnum? PredefinedType { get; set; }
		public IfcCableSegment() : base()
		{
		}
		public IfcCableSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableSegmentType
	/// <para>ENTITY IfcCableSegmentType</para>
	/// <para> SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>	PredefinedType : IfcCableSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCableSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableSegmentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableSegmentType : IfcFlowSegmentType
	{
		public IfcCableSegmentTypeEnum PredefinedType { get; set; }
		public IfcCableSegmentType() : base()
		{
			PredefinedType = new IfcCableSegmentTypeEnum();
		}
		public IfcCableSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPoint
	/// <para>ENTITY IfcCartesianPoint</para>
	/// <para> SUBTYPE OF (IfcPoint);</para>
	/// <para>	Coordinates : LIST [1:3] OF IfcLengthMeasure;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := HIINDEX(Coordinates);</para>
	/// <para> WHERE</para>
	/// <para>	CP2Dor3D : HIINDEX(Coordinates) >= 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianPoint : IfcPoint, IfcTrimmingSelect
	{
		public List<IfcLengthMeasure> Coordinates { get; set; }
		public IfcCartesianPoint() : base()
		{
			Coordinates = new List<IfcLengthMeasure>();
		}
		public IfcCartesianPoint(List<IfcLengthMeasure> Coordinates) : base ()
		{
			this.Coordinates = Coordinates;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPointList
	/// <para>ENTITY IfcCartesianPointList</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCartesianPointList2D</para>
	/// <para>    ,IfcCartesianPointList3D))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := IfcPointListDim(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCartesianPointList : IfcGeometricRepresentationItem
	{
		public IfcCartesianPointList() : base()
		{
		}
		public IfcCartesianPointList() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPointList2D
	/// <para>ENTITY IfcCartesianPointList2D</para>
	/// <para> SUBTYPE OF (IfcCartesianPointList);</para>
	/// <para>	CoordList : LIST [1:?] OF LIST [2:2] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianPointList2D : IfcCartesianPointList
	{
		public List<List<IfcLengthMeasure >> CoordList { get; set; }
		public IfcCartesianPointList2D() : base()
		{
			CoordList = new List<List<IfcLengthMeasure >>();
		}
		public IfcCartesianPointList2D(List<List<IfcLengthMeasure >> CoordList) : base ()
		{
			this.CoordList = CoordList;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPointList3D
	/// <para>ENTITY IfcCartesianPointList3D</para>
	/// <para> SUBTYPE OF (IfcCartesianPointList);</para>
	/// <para>	CoordList : LIST [1:?] OF LIST [3:3] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianPointList3D : IfcCartesianPointList
	{
		public List<List<IfcLengthMeasure >> CoordList { get; set; }
		public IfcCartesianPointList3D() : base()
		{
			CoordList = new List<List<IfcLengthMeasure >>();
		}
		public IfcCartesianPointList3D(List<List<IfcLengthMeasure >> CoordList) : base ()
		{
			this.CoordList = CoordList;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator
	/// <para>ENTITY IfcCartesianTransformationOperator</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCartesianTransformationOperator2D</para>
	/// <para>    ,IfcCartesianTransformationOperator3D))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Axis1 : OPTIONAL IfcDirection;</para>
	/// <para>	Axis2 : OPTIONAL IfcDirection;</para>
	/// <para>	LocalOrigin : IfcCartesianPoint;</para>
	/// <para>	Scale : OPTIONAL IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	Scl : IfcReal := NVL(Scale, 1.0);</para>
	/// <para>	Dim : IfcDimensionCount := LocalOrigin.Dim;</para>
	/// <para> WHERE</para>
	/// <para>	ScaleGreaterZero : Scl > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCartesianTransformationOperator : IfcGeometricRepresentationItem
	{
		public IfcDirection? Axis1 { get; set; }
		public IfcDirection? Axis2 { get; set; }
		public IfcCartesianPoint LocalOrigin { get; set; }
		public IfcReal? Scale { get; set; }
		public IfcCartesianTransformationOperator() : base()
		{
			LocalOrigin = new IfcCartesianPoint();
		}
		public IfcCartesianTransformationOperator(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale) : base ()
		{
			this.Axis1 = Axis1;
			this.Axis2 = Axis2;
			this.LocalOrigin = LocalOrigin;
			this.Scale = Scale;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator2D
	/// <para>ENTITY IfcCartesianTransformationOperator2D</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCartesianTransformationOperator2DnonUniform))</para>
	/// <para> SUBTYPE OF (IfcCartesianTransformationOperator);</para>
	/// <para> DERIVE</para>
	/// <para>	U : LIST [2:2] OF IfcDirection := IfcBaseAxis(2,SELF\IfcCartesianTransformationOperator.Axis1,</para>
	/// <para>SELF\IfcCartesianTransformationOperator.Axis2,?);</para>
	/// <para> WHERE</para>
	/// <para>	DimEqual2 : SELF\IfcCartesianTransformationOperator.Dim = 2;</para>
	/// <para>	Axis1Is2D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis1)) OR </para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis1.Dim = 2);</para>
	/// <para>	Axis2Is2D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis2)) OR </para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis2.Dim = 2);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator2D : IfcCartesianTransformationOperator
	{
		public IfcCartesianTransformationOperator2D() : base()
		{
		}
		public IfcCartesianTransformationOperator2D(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale) : base (Axis1, Axis2, LocalOrigin, Scale)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator2DnonUniform
	/// <para>ENTITY IfcCartesianTransformationOperator2DnonUniform</para>
	/// <para> SUBTYPE OF (IfcCartesianTransformationOperator2D);</para>
	/// <para>	Scale2 : OPTIONAL IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	Scl2 : IfcReal := NVL(Scale2, SELF\IfcCartesianTransformationOperator.Scl);</para>
	/// <para> WHERE</para>
	/// <para>	Scale2GreaterZero : Scl2 > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator2DnonUniform : IfcCartesianTransformationOperator2D
	{
		public IfcReal? Scale2 { get; set; }
		public IfcCartesianTransformationOperator2DnonUniform() : base()
		{
		}
		public IfcCartesianTransformationOperator2DnonUniform(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale, IfcReal Scale2) : base (Axis1, Axis2, LocalOrigin, Scale)
		{
			this.Scale2 = Scale2;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator3D
	/// <para>ENTITY IfcCartesianTransformationOperator3D</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCartesianTransformationOperator3DnonUniform))</para>
	/// <para> SUBTYPE OF (IfcCartesianTransformationOperator);</para>
	/// <para>	Axis3 : OPTIONAL IfcDirection;</para>
	/// <para> DERIVE</para>
	/// <para>	U : LIST [3:3] OF IfcDirection := IfcBaseAxis(3,SELF\IfcCartesianTransformationOperator.Axis1,</para>
	/// <para>SELF\IfcCartesianTransformationOperator.Axis2,Axis3);</para>
	/// <para> WHERE</para>
	/// <para>	DimIs3D : SELF\IfcCartesianTransformationOperator.Dim = 3;</para>
	/// <para>	Axis1Is3D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis1)) OR </para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis1.Dim = 3);</para>
	/// <para>	Axis2Is3D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis2)) OR </para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis2.Dim = 3);</para>
	/// <para>	Axis3Is3D : NOT(EXISTS(Axis3)) OR (Axis3.Dim = 3);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator3D : IfcCartesianTransformationOperator
	{
		public IfcDirection? Axis3 { get; set; }
		public IfcCartesianTransformationOperator3D() : base()
		{
		}
		public IfcCartesianTransformationOperator3D(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale, IfcDirection Axis3) : base (Axis1, Axis2, LocalOrigin, Scale)
		{
			this.Axis3 = Axis3;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator3DnonUniform
	/// <para>ENTITY IfcCartesianTransformationOperator3DnonUniform</para>
	/// <para> SUBTYPE OF (IfcCartesianTransformationOperator3D);</para>
	/// <para>	Scale2 : OPTIONAL IfcReal;</para>
	/// <para>	Scale3 : OPTIONAL IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	Scl2 : IfcReal := NVL(Scale2, SELF\IfcCartesianTransformationOperator.Scl);</para>
	/// <para>	Scl3 : IfcReal := NVL(Scale3, SELF\IfcCartesianTransformationOperator.Scl);</para>
	/// <para> WHERE</para>
	/// <para>	Scale2GreaterZero : Scl2 > 0.0;</para>
	/// <para>	Scale3GreaterZero : Scl3 > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator3DnonUniform : IfcCartesianTransformationOperator3D
	{
		public IfcReal? Scale2 { get; set; }
		public IfcReal? Scale3 { get; set; }
		public IfcCartesianTransformationOperator3DnonUniform() : base()
		{
		}
		public IfcCartesianTransformationOperator3DnonUniform(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale, IfcDirection Axis3, IfcReal Scale2, IfcReal Scale3) : base (Axis1, Axis2, LocalOrigin, Scale, Axis3)
		{
			this.Scale2 = Scale2;
			this.Scale3 = Scale3;
		}
	}
	/// <summary>
	/// ENTITY IfcCenterLineProfileDef
	/// <para>ENTITY IfcCenterLineProfileDef</para>
	/// <para> SUBTYPE OF (IfcArbitraryOpenProfileDef);</para>
	/// <para>	Thickness : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCenterLineProfileDef : IfcArbitraryOpenProfileDef
	{
		public IfcPositiveLengthMeasure Thickness { get; set; }
		public IfcCenterLineProfileDef() : base()
		{
			Thickness = new IfcPositiveLengthMeasure();
		}
		public IfcCenterLineProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcBoundedCurve Curve, IfcPositiveLengthMeasure Thickness) : base (ProfileType, ProfileName, Curve)
		{
			this.Thickness = Thickness;
		}
	}
	/// <summary>
	/// ENTITY IfcChiller
	/// <para>ENTITY IfcChiller</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcChillerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcChillerTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcChillerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCHILLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChiller : IfcEnergyConversionDevice
	{
		public IfcChillerTypeEnum? PredefinedType { get; set; }
		public IfcChiller() : base()
		{
		}
		public IfcChiller(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcChillerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcChillerType
	/// <para>ENTITY IfcChillerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcChillerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcChillerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcChillerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChillerType : IfcEnergyConversionDeviceType
	{
		public IfcChillerTypeEnum PredefinedType { get; set; }
		public IfcChillerType() : base()
		{
			PredefinedType = new IfcChillerTypeEnum();
		}
		public IfcChillerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcChillerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcChimney
	/// <para>ENTITY IfcChimney</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcChimneyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcChimneyTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcChimneyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCCHIMNEYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChimney : IfcBuildingElement
	{
		public IfcChimneyTypeEnum? PredefinedType { get; set; }
		public IfcChimney() : base()
		{
		}
		public IfcChimney(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcChimneyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcChimneyType
	/// <para>ENTITY IfcChimneyType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcChimneyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcChimneyTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcChimneyTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChimneyType : IfcBuildingElementType
	{
		public IfcChimneyTypeEnum PredefinedType { get; set; }
		public IfcChimneyType() : base()
		{
			PredefinedType = new IfcChimneyTypeEnum();
		}
		public IfcChimneyType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcChimneyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCircle
	/// <para>ENTITY IfcCircle</para>
	/// <para> SUBTYPE OF (IfcConic);</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCircle : IfcConic
	{
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcCircle() : base()
		{
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcCircle(IfcAxis2Placement Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcCircleHollowProfileDef
	/// <para>ENTITY IfcCircleHollowProfileDef</para>
	/// <para> SUBTYPE OF (IfcCircleProfileDef);</para>
	/// <para>	WallThickness : IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : WallThickness < SELF\IfcCircleProfileDef.Radius;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCircleHollowProfileDef : IfcCircleProfileDef
	{
		public IfcPositiveLengthMeasure WallThickness { get; set; }
		public IfcCircleHollowProfileDef() : base()
		{
			WallThickness = new IfcPositiveLengthMeasure();
		}
		public IfcCircleHollowProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Radius, IfcPositiveLengthMeasure WallThickness) : base (ProfileType, ProfileName, Position, Radius)
		{
			this.WallThickness = WallThickness;
		}
	}
	/// <summary>
	/// ENTITY IfcCircleProfileDef
	/// <para>ENTITY IfcCircleProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCircleHollowProfileDef))</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCircleProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcCircleProfileDef() : base()
		{
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcCircleProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Radius) : base (ProfileType, ProfileName, Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcCivilElement
	/// <para>ENTITY IfcCivilElement</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCivilElement : IfcElement
	{
		public IfcCivilElement() : base()
		{
		}
		public IfcCivilElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCivilElementType
	/// <para>ENTITY IfcCivilElementType</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCivilElementType : IfcElementType
	{
		public IfcCivilElementType() : base()
		{
		}
		public IfcCivilElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcClassification
	/// <para>ENTITY IfcClassification</para>
	/// <para> SUBTYPE OF (IfcExternalInformation);</para>
	/// <para>	Source : OPTIONAL IfcLabel;</para>
	/// <para>	Edition : OPTIONAL IfcLabel;</para>
	/// <para>	EditionDate : OPTIONAL IfcDate;</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Location : OPTIONAL IfcURIReference;</para>
	/// <para>	ReferenceTokens : OPTIONAL LIST [1:?] OF IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	ClassificationForObjects : SET [0:?] OF IfcRelAssociatesClassification FOR RelatingClassification;</para>
	/// <para>	HasReferences : SET [0:?] OF IfcClassificationReference FOR ReferencedSource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcClassification : IfcExternalInformation, IfcClassificationReferenceSelect, IfcClassificationSelect
	{
		public IfcLabel? Source { get; set; }
		public IfcLabel? Edition { get; set; }
		public IfcDate? EditionDate { get; set; }
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcURIReference? Location { get; set; }
		public List<IfcIdentifier>? ReferenceTokens { get; set; }
		public IfcClassification() : base()
		{
			Name = new IfcLabel();
		}
		public IfcClassification(IfcLabel Source, IfcLabel Edition, IfcDate EditionDate, IfcLabel Name, IfcText Description, IfcURIReference Location, List<IfcIdentifier> ReferenceTokens) : base ()
		{
			this.Source = Source;
			this.Edition = Edition;
			this.EditionDate = EditionDate;
			this.Name = Name;
			this.Description = Description;
			this.Location = Location;
			this.ReferenceTokens = ReferenceTokens;
		}
	}
	/// <summary>
	/// ENTITY IfcClassificationReference
	/// <para>ENTITY IfcClassificationReference</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>	ReferencedSource : OPTIONAL IfcClassificationReferenceSelect;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Sort : OPTIONAL IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	ClassificationRefForObjects : SET [0:?] OF IfcRelAssociatesClassification FOR RelatingClassification;</para>
	/// <para>	HasReferences : SET [0:?] OF IfcClassificationReference FOR ReferencedSource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcClassificationReference : IfcExternalReference, IfcClassificationReferenceSelect, IfcClassificationSelect
	{
		public IfcClassificationReferenceSelect? ReferencedSource { get; set; }
		public IfcText? Description { get; set; }
		public IfcIdentifier? Sort { get; set; }
		public IfcClassificationReference() : base()
		{
		}
		public IfcClassificationReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name, IfcClassificationReferenceSelect ReferencedSource, IfcText Description, IfcIdentifier Sort) : base (Location, Identification, Name)
		{
			this.ReferencedSource = ReferencedSource;
			this.Description = Description;
			this.Sort = Sort;
		}
	}
	/// <summary>
	/// ENTITY IfcClosedShell
	/// <para>ENTITY IfcClosedShell</para>
	/// <para> SUBTYPE OF (IfcConnectedFaceSet);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcClosedShell : IfcConnectedFaceSet, IfcShell, IfcSolidOrShell
	{
		public IfcClosedShell() : base()
		{
		}
		public IfcClosedShell(List<IfcFace> CfsFaces) : base (CfsFaces)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCoil
	/// <para>ENTITY IfcCoil</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCoilTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCoilTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCoilTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCOILTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoil : IfcEnergyConversionDevice
	{
		public IfcCoilTypeEnum? PredefinedType { get; set; }
		public IfcCoil() : base()
		{
		}
		public IfcCoil(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCoilTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoilType
	/// <para>ENTITY IfcCoilType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcCoilTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCoilTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCoilTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoilType : IfcEnergyConversionDeviceType
	{
		public IfcCoilTypeEnum PredefinedType { get; set; }
		public IfcCoilType() : base()
		{
			PredefinedType = new IfcCoilTypeEnum();
		}
		public IfcCoilType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCoilTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcColourRgb
	/// <para>ENTITY IfcColourRgb</para>
	/// <para> SUBTYPE OF (IfcColourSpecification);</para>
	/// <para>	Red : IfcNormalisedRatioMeasure;</para>
	/// <para>	Green : IfcNormalisedRatioMeasure;</para>
	/// <para>	Blue : IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColourRgb : IfcColourSpecification, IfcColourOrFactor
	{
		public IfcNormalisedRatioMeasure Red { get; set; }
		public IfcNormalisedRatioMeasure Green { get; set; }
		public IfcNormalisedRatioMeasure Blue { get; set; }
		public IfcColourRgb() : base()
		{
			Red = new IfcNormalisedRatioMeasure();
			Green = new IfcNormalisedRatioMeasure();
			Blue = new IfcNormalisedRatioMeasure();
		}
		public IfcColourRgb(IfcLabel Name, IfcNormalisedRatioMeasure Red, IfcNormalisedRatioMeasure Green, IfcNormalisedRatioMeasure Blue) : base (Name)
		{
			this.Red = Red;
			this.Green = Green;
			this.Blue = Blue;
		}
	}
	/// <summary>
	/// ENTITY IfcColourRgbList
	/// <para>ENTITY IfcColourRgbList</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	ColourList : LIST [1:?] OF LIST [3:3] OF IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColourRgbList : IfcPresentationItem
	{
		public List<List<IfcNormalisedRatioMeasure >> ColourList { get; set; }
		public IfcColourRgbList() : base()
		{
			ColourList = new List<List<IfcNormalisedRatioMeasure >>();
		}
		public IfcColourRgbList(List<List<IfcNormalisedRatioMeasure >> ColourList) : base ()
		{
			this.ColourList = ColourList;
		}
	}
	/// <summary>
	/// ENTITY IfcColourSpecification
	/// <para>ENTITY IfcColourSpecification</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcColourRgb))</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcColourSpecification : IfcPresentationItem, IfcColour
	{
		public IfcLabel? Name { get; set; }
		public IfcColourSpecification() : base()
		{
		}
		public IfcColourSpecification(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcColumn
	/// <para>ENTITY IfcColumn</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcColumnStandardCase))</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcColumnTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcColumnTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcColumnTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCCOLUMNTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColumn : IfcBuildingElement
	{
		public IfcColumnTypeEnum? PredefinedType { get; set; }
		public IfcColumn() : base()
		{
		}
		public IfcColumn(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcColumnTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcColumnStandardCase
	/// <para>ENTITY IfcColumnStandardCase</para>
	/// <para> SUBTYPE OF (IfcColumn);</para>
	/// <para> WHERE</para>
	/// <para>	HasMaterialProfileSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>              ('IFC4.IFCMATERIALPROFILESETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>              )) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColumnStandardCase : IfcColumn
	{
		public IfcColumnStandardCase() : base()
		{
		}
		public IfcColumnStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcColumnTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcColumnType
	/// <para>ENTITY IfcColumnType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcColumnTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcColumnTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcColumnTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColumnType : IfcBuildingElementType
	{
		public IfcColumnTypeEnum PredefinedType { get; set; }
		public IfcColumnType() : base()
		{
			PredefinedType = new IfcColumnTypeEnum();
		}
		public IfcColumnType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcColumnTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCommunicationsAppliance
	/// <para>ENTITY IfcCommunicationsAppliance</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCommunicationsApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCommunicationsApplianceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCommunicationsApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCOMMUNICATIONSAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCommunicationsAppliance : IfcFlowTerminal
	{
		public IfcCommunicationsApplianceTypeEnum? PredefinedType { get; set; }
		public IfcCommunicationsAppliance() : base()
		{
		}
		public IfcCommunicationsAppliance(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCommunicationsApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCommunicationsApplianceType
	/// <para>ENTITY IfcCommunicationsApplianceType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcCommunicationsApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCommunicationsApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCommunicationsApplianceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCommunicationsApplianceType : IfcFlowTerminalType
	{
		public IfcCommunicationsApplianceTypeEnum PredefinedType { get; set; }
		public IfcCommunicationsApplianceType() : base()
		{
			PredefinedType = new IfcCommunicationsApplianceTypeEnum();
		}
		public IfcCommunicationsApplianceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCommunicationsApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcComplexProperty
	/// <para>ENTITY IfcComplexProperty</para>
	/// <para> SUBTYPE OF (IfcProperty);</para>
	/// <para>	UsageName : IfcIdentifier;</para>
	/// <para>	HasProperties : SET [1:?] OF IfcProperty;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : SIZEOF(QUERY(temp <* HasProperties | SELF :=: temp)) = 0;</para>
	/// <para>	WR22 : IfcUniquePropertyName(HasProperties);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcComplexProperty : IfcProperty
	{
		public IfcIdentifier UsageName { get; set; }
		public List<IfcProperty> HasProperties { get; set; }
		public IfcComplexProperty() : base()
		{
			UsageName = new IfcIdentifier();
			HasProperties = new List<IfcProperty>();
		}
		public IfcComplexProperty(IfcIdentifier Name, IfcText Description, IfcIdentifier UsageName, List<IfcProperty> HasProperties) : base (Name, Description)
		{
			this.UsageName = UsageName;
			this.HasProperties = HasProperties;
		}
	}
	/// <summary>
	/// ENTITY IfcComplexPropertyTemplate
	/// <para>ENTITY IfcComplexPropertyTemplate</para>
	/// <para> SUBTYPE OF (IfcPropertyTemplate);</para>
	/// <para>	UsageName : OPTIONAL IfcLabel;</para>
	/// <para>	TemplateType : OPTIONAL IfcComplexPropertyTemplateTypeEnum;</para>
	/// <para>	HasPropertyTemplates : OPTIONAL SET [1:?] OF IfcPropertyTemplate;</para>
	/// <para> WHERE</para>
	/// <para>	UniquePropertyNames : IfcUniquePropertyTemplateNames(HasPropertyTemplates);</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(temp <* HasPropertyTemplates | SELF :=: temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcComplexPropertyTemplate : IfcPropertyTemplate
	{
		public IfcLabel? UsageName { get; set; }
		public IfcComplexPropertyTemplateTypeEnum? TemplateType { get; set; }
		public List<IfcPropertyTemplate>? HasPropertyTemplates { get; set; }
		public IfcComplexPropertyTemplate() : base()
		{
		}
		public IfcComplexPropertyTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel UsageName, IfcComplexPropertyTemplateTypeEnum TemplateType, List<IfcPropertyTemplate> HasPropertyTemplates) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.UsageName = UsageName;
			this.TemplateType = TemplateType;
			this.HasPropertyTemplates = HasPropertyTemplates;
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeCurve
	/// <para>ENTITY IfcCompositeCurve</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCompositeCurveOnSurface))</para>
	/// <para> SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>	Segments : LIST [1:?] OF IfcCompositeCurveSegment;</para>
	/// <para>	SelfIntersect : IfcLogical;</para>
	/// <para> DERIVE</para>
	/// <para>	NSegments : IfcInteger := SIZEOF(Segments);</para>
	/// <para>	ClosedCurve : IfcLogical := Segments[NSegments].Transition <> Discontinuous;</para>
	/// <para> WHERE</para>
	/// <para>	CurveContinuous : ((NOT ClosedCurve) AND (SIZEOF(QUERY(Temp <* Segments | Temp.Transition = Discontinuous)) = 1)) OR ((ClosedCurve) AND (SIZEOF(QUERY(Temp <* Segments | Temp.Transition = Discontinuous)) = 0));</para>
	/// <para>	SameDim : SIZEOF( QUERY( Temp <* Segments | Temp.Dim <> Segments[1].Dim)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeCurve : IfcBoundedCurve
	{
		public List<IfcCompositeCurveSegment> Segments { get; set; }
		public IfcLogical SelfIntersect { get; set; }
		public IfcCompositeCurve() : base()
		{
			Segments = new List<IfcCompositeCurveSegment>();
			SelfIntersect = new IfcLogical();
		}
		public IfcCompositeCurve(List<IfcCompositeCurveSegment> Segments, IfcLogical SelfIntersect) : base ()
		{
			this.Segments = Segments;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeCurveOnSurface
	/// <para>ENTITY IfcCompositeCurveOnSurface</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBoundaryCurve))</para>
	/// <para> SUBTYPE OF (IfcCompositeCurve);</para>
	/// <para> DERIVE</para>
	/// <para>	BasisSurface : SET [0:1] OF IfcSurface := IfcGetBasisSurface(SELF);</para>
	/// <para> WHERE</para>
	/// <para>	SameSurface : SIZEOF(BasisSurface) > 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeCurveOnSurface : IfcCompositeCurve, IfcCurveOnSurface
	{
		public IfcCompositeCurveOnSurface() : base()
		{
		}
		public IfcCompositeCurveOnSurface(List<IfcCompositeCurveSegment> Segments, IfcLogical SelfIntersect) : base (Segments, SelfIntersect)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeCurveSegment
	/// <para>ENTITY IfcCompositeCurveSegment</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcReparametrisedCompositeCurveSegment))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Transition : IfcTransitionCode;</para>
	/// <para>	SameSense : IfcBoolean;</para>
	/// <para>	ParentCurve : IfcCurve;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := ParentCurve.Dim;</para>
	/// <para> INVERSE</para>
	/// <para>	UsingCurves : SET [1:?] OF IfcCompositeCurve FOR Segments;</para>
	/// <para> WHERE</para>
	/// <para>	ParentIsBoundedCurve : ('IFC4.IFCBOUNDEDCURVE' IN TYPEOF(ParentCurve));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeCurveSegment : IfcGeometricRepresentationItem
	{
		public IfcTransitionCode Transition { get; set; }
		public IfcBoolean SameSense { get; set; }
		public IfcCurve ParentCurve { get; set; }
		public IfcCompositeCurveSegment() : base()
		{
			Transition = new IfcTransitionCode();
			SameSense = new IfcBoolean();
			ParentCurve = new IfcCurve();
		}
		public IfcCompositeCurveSegment(IfcTransitionCode Transition, IfcBoolean SameSense, IfcCurve ParentCurve) : base ()
		{
			this.Transition = Transition;
			this.SameSense = SameSense;
			this.ParentCurve = ParentCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeProfileDef
	/// <para>ENTITY IfcCompositeProfileDef</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	Profiles : SET [2:?] OF IfcProfileDef;</para>
	/// <para>	Label : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	InvariantProfileType : SIZEOF(QUERY(temp <* Profiles | temp.ProfileType <> Profiles[1].ProfileType)) = 0;</para>
	/// <para>	NoRecursion : SIZEOF(QUERY(temp <* Profiles | 'IFC4.IFCCOMPOSITEPROFILEDEF' IN TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeProfileDef : IfcProfileDef
	{
		public List<IfcProfileDef> Profiles { get; set; }
		public IfcLabel? Label { get; set; }
		public IfcCompositeProfileDef() : base()
		{
			Profiles = new List<IfcProfileDef>();
		}
		public IfcCompositeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, List<IfcProfileDef> Profiles, IfcLabel Label) : base (ProfileType, ProfileName)
		{
			this.Profiles = Profiles;
			this.Label = Label;
		}
	}
	/// <summary>
	/// ENTITY IfcCompressor
	/// <para>ENTITY IfcCompressor</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCompressorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCompressorTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCompressorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCOMPRESSORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompressor : IfcFlowMovingDevice
	{
		public IfcCompressorTypeEnum? PredefinedType { get; set; }
		public IfcCompressor() : base()
		{
		}
		public IfcCompressor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCompressorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCompressorType
	/// <para>ENTITY IfcCompressorType</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDeviceType);</para>
	/// <para>	PredefinedType : IfcCompressorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCompressorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCompressorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompressorType : IfcFlowMovingDeviceType
	{
		public IfcCompressorTypeEnum PredefinedType { get; set; }
		public IfcCompressorType() : base()
		{
			PredefinedType = new IfcCompressorTypeEnum();
		}
		public IfcCompressorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCompressorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCondenser
	/// <para>ENTITY IfcCondenser</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCondenserTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCondenserTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCondenserTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCONDENSERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCondenser : IfcEnergyConversionDevice
	{
		public IfcCondenserTypeEnum? PredefinedType { get; set; }
		public IfcCondenser() : base()
		{
		}
		public IfcCondenser(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCondenserTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCondenserType
	/// <para>ENTITY IfcCondenserType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcCondenserTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCondenserTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCondenserTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCondenserType : IfcEnergyConversionDeviceType
	{
		public IfcCondenserTypeEnum PredefinedType { get; set; }
		public IfcCondenserType() : base()
		{
			PredefinedType = new IfcCondenserTypeEnum();
		}
		public IfcCondenserType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCondenserTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConic
	/// <para>ENTITY IfcConic</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCircle</para>
	/// <para>    ,IfcEllipse))</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	Position : IfcAxis2Placement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConic : IfcCurve
	{
		public IfcAxis2Placement Position { get; set; }
		public IfcConic() : base()
		{
			Position = new IfcAxis2Placement();
		}
		public IfcConic(IfcAxis2Placement Position) : base ()
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectedFaceSet
	/// <para>ENTITY IfcConnectedFaceSet</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcClosedShell</para>
	/// <para>    ,IfcOpenShell))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>	CfsFaces : SET [1:?] OF IfcFace;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectedFaceSet : IfcTopologicalRepresentationItem
	{
		public List<IfcFace> CfsFaces { get; set; }
		public IfcConnectedFaceSet() : base()
		{
			CfsFaces = new List<IfcFace>();
		}
		public IfcConnectedFaceSet(List<IfcFace> CfsFaces) : base ()
		{
			this.CfsFaces = CfsFaces;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionCurveGeometry
	/// <para>ENTITY IfcConnectionCurveGeometry</para>
	/// <para> SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>	CurveOnRelatingElement : IfcCurveOrEdgeCurve;</para>
	/// <para>	CurveOnRelatedElement : OPTIONAL IfcCurveOrEdgeCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionCurveGeometry : IfcConnectionGeometry
	{
		public IfcCurveOrEdgeCurve CurveOnRelatingElement { get; set; }
		public IfcCurveOrEdgeCurve? CurveOnRelatedElement { get; set; }
		public IfcConnectionCurveGeometry() : base()
		{
			CurveOnRelatingElement = new IfcCurveOrEdgeCurve();
		}
		public IfcConnectionCurveGeometry(IfcCurveOrEdgeCurve CurveOnRelatingElement, IfcCurveOrEdgeCurve CurveOnRelatedElement) : base ()
		{
			this.CurveOnRelatingElement = CurveOnRelatingElement;
			this.CurveOnRelatedElement = CurveOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionGeometry
	/// <para>ENTITY IfcConnectionGeometry</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcConnectionCurveGeometry</para>
	/// <para>    ,IfcConnectionPointGeometry</para>
	/// <para>    ,IfcConnectionSurfaceGeometry</para>
	/// <para>    ,IfcConnectionVolumeGeometry));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConnectionGeometry : ENTITY
	{
		public IfcConnectionGeometry() : base()
		{
		}
		public IfcConnectionGeometry() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionPointEccentricity
	/// <para>ENTITY IfcConnectionPointEccentricity</para>
	/// <para> SUBTYPE OF (IfcConnectionPointGeometry);</para>
	/// <para>	EccentricityInX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	EccentricityInY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	EccentricityInZ : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionPointEccentricity : IfcConnectionPointGeometry
	{
		public IfcLengthMeasure? EccentricityInX { get; set; }
		public IfcLengthMeasure? EccentricityInY { get; set; }
		public IfcLengthMeasure? EccentricityInZ { get; set; }
		public IfcConnectionPointEccentricity() : base()
		{
		}
		public IfcConnectionPointEccentricity(IfcPointOrVertexPoint PointOnRelatingElement, IfcPointOrVertexPoint PointOnRelatedElement, IfcLengthMeasure EccentricityInX, IfcLengthMeasure EccentricityInY, IfcLengthMeasure EccentricityInZ) : base (PointOnRelatingElement, PointOnRelatedElement)
		{
			this.EccentricityInX = EccentricityInX;
			this.EccentricityInY = EccentricityInY;
			this.EccentricityInZ = EccentricityInZ;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionPointGeometry
	/// <para>ENTITY IfcConnectionPointGeometry</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcConnectionPointEccentricity))</para>
	/// <para> SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>	PointOnRelatingElement : IfcPointOrVertexPoint;</para>
	/// <para>	PointOnRelatedElement : OPTIONAL IfcPointOrVertexPoint;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionPointGeometry : IfcConnectionGeometry
	{
		public IfcPointOrVertexPoint PointOnRelatingElement { get; set; }
		public IfcPointOrVertexPoint? PointOnRelatedElement { get; set; }
		public IfcConnectionPointGeometry() : base()
		{
			PointOnRelatingElement = new IfcPointOrVertexPoint();
		}
		public IfcConnectionPointGeometry(IfcPointOrVertexPoint PointOnRelatingElement, IfcPointOrVertexPoint PointOnRelatedElement) : base ()
		{
			this.PointOnRelatingElement = PointOnRelatingElement;
			this.PointOnRelatedElement = PointOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionSurfaceGeometry
	/// <para>ENTITY IfcConnectionSurfaceGeometry</para>
	/// <para> SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>	SurfaceOnRelatingElement : IfcSurfaceOrFaceSurface;</para>
	/// <para>	SurfaceOnRelatedElement : OPTIONAL IfcSurfaceOrFaceSurface;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionSurfaceGeometry : IfcConnectionGeometry
	{
		public IfcSurfaceOrFaceSurface SurfaceOnRelatingElement { get; set; }
		public IfcSurfaceOrFaceSurface? SurfaceOnRelatedElement { get; set; }
		public IfcConnectionSurfaceGeometry() : base()
		{
			SurfaceOnRelatingElement = new IfcSurfaceOrFaceSurface();
		}
		public IfcConnectionSurfaceGeometry(IfcSurfaceOrFaceSurface SurfaceOnRelatingElement, IfcSurfaceOrFaceSurface SurfaceOnRelatedElement) : base ()
		{
			this.SurfaceOnRelatingElement = SurfaceOnRelatingElement;
			this.SurfaceOnRelatedElement = SurfaceOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionVolumeGeometry
	/// <para>ENTITY IfcConnectionVolumeGeometry</para>
	/// <para> SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>	VolumeOnRelatingElement : IfcSolidOrShell;</para>
	/// <para>	VolumeOnRelatedElement : OPTIONAL IfcSolidOrShell;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionVolumeGeometry : IfcConnectionGeometry
	{
		public IfcSolidOrShell VolumeOnRelatingElement { get; set; }
		public IfcSolidOrShell? VolumeOnRelatedElement { get; set; }
		public IfcConnectionVolumeGeometry() : base()
		{
			VolumeOnRelatingElement = new IfcSolidOrShell();
		}
		public IfcConnectionVolumeGeometry(IfcSolidOrShell VolumeOnRelatingElement, IfcSolidOrShell VolumeOnRelatedElement) : base ()
		{
			this.VolumeOnRelatingElement = VolumeOnRelatingElement;
			this.VolumeOnRelatedElement = VolumeOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConstraint
	/// <para>ENTITY IfcConstraint</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMetric</para>
	/// <para>    ,IfcObjective));</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	ConstraintGrade : IfcConstraintEnum;</para>
	/// <para>	ConstraintSource : OPTIONAL IfcLabel;</para>
	/// <para>	CreatingActor : OPTIONAL IfcActorSelect;</para>
	/// <para>	CreationTime : OPTIONAL IfcDateTime;</para>
	/// <para>	UserDefinedGrade : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>	PropertiesForConstraint : SET [0:?] OF IfcResourceConstraintRelationship FOR RelatingConstraint;</para>
	/// <para> WHERE</para>
	/// <para>	WR11 : (ConstraintGrade <> IfcConstraintEnum.USERDEFINED) OR</para>
	/// <para>((ConstraintGrade = IfcConstraintEnum.USERDEFINED) AND EXISTS(SELF\IfcConstraint.UserDefinedGrade));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConstraint : ENTITY, IfcResourceObjectSelect
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcConstraintEnum ConstraintGrade { get; set; }
		public IfcLabel? ConstraintSource { get; set; }
		public IfcActorSelect? CreatingActor { get; set; }
		public IfcDateTime? CreationTime { get; set; }
		public IfcLabel? UserDefinedGrade { get; set; }
		public IfcConstraint() : base()
		{
			Name = new IfcLabel();
			ConstraintGrade = new IfcConstraintEnum();
		}
		public IfcConstraint(IfcLabel Name, IfcText Description, IfcConstraintEnum ConstraintGrade, IfcLabel ConstraintSource, IfcActorSelect CreatingActor, IfcDateTime CreationTime, IfcLabel UserDefinedGrade) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.ConstraintGrade = ConstraintGrade;
			this.ConstraintSource = ConstraintSource;
			this.CreatingActor = CreatingActor;
			this.CreationTime = CreationTime;
			this.UserDefinedGrade = UserDefinedGrade;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionEquipmentResource
	/// <para>ENTITY IfcConstructionEquipmentResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcConstructionEquipmentResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionEquipmentResource : IfcConstructionResource
	{
		public IfcConstructionEquipmentResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionEquipmentResource() : base()
		{
		}
		public IfcConstructionEquipmentResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionEquipmentResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionEquipmentResourceType
	/// <para>ENTITY IfcConstructionEquipmentResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcConstructionEquipmentResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionEquipmentResourceType : IfcConstructionResourceType
	{
		public IfcConstructionEquipmentResourceTypeEnum PredefinedType { get; set; }
		public IfcConstructionEquipmentResourceType() : base()
		{
			PredefinedType = new IfcConstructionEquipmentResourceTypeEnum();
		}
		public IfcConstructionEquipmentResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionEquipmentResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionMaterialResource
	/// <para>ENTITY IfcConstructionMaterialResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcConstructionMaterialResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcConstructionMaterialResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcConstructionMaterialResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionMaterialResource : IfcConstructionResource
	{
		public IfcConstructionMaterialResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionMaterialResource() : base()
		{
		}
		public IfcConstructionMaterialResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionMaterialResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionMaterialResourceType
	/// <para>ENTITY IfcConstructionMaterialResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcConstructionMaterialResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcConstructionMaterialResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionMaterialResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionMaterialResourceType : IfcConstructionResourceType
	{
		public IfcConstructionMaterialResourceTypeEnum PredefinedType { get; set; }
		public IfcConstructionMaterialResourceType() : base()
		{
			PredefinedType = new IfcConstructionMaterialResourceTypeEnum();
		}
		public IfcConstructionMaterialResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionMaterialResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionProductResource
	/// <para>ENTITY IfcConstructionProductResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcConstructionProductResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcConstructionProductResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcConstructionProductResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionProductResource : IfcConstructionResource
	{
		public IfcConstructionProductResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionProductResource() : base()
		{
		}
		public IfcConstructionProductResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionProductResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionProductResourceType
	/// <para>ENTITY IfcConstructionProductResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcConstructionProductResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcConstructionProductResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionProductResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionProductResourceType : IfcConstructionResourceType
	{
		public IfcConstructionProductResourceTypeEnum PredefinedType { get; set; }
		public IfcConstructionProductResourceType() : base()
		{
			PredefinedType = new IfcConstructionProductResourceTypeEnum();
		}
		public IfcConstructionProductResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionProductResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionResource
	/// <para>ENTITY IfcConstructionResource</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcConstructionEquipmentResource</para>
	/// <para>    ,IfcConstructionMaterialResource</para>
	/// <para>    ,IfcConstructionProductResource</para>
	/// <para>    ,IfcCrewResource</para>
	/// <para>    ,IfcLaborResource</para>
	/// <para>    ,IfcSubContractResource))</para>
	/// <para> SUBTYPE OF (IfcResource);</para>
	/// <para>	Usage : OPTIONAL IfcResourceTime;</para>
	/// <para>	BaseCosts : OPTIONAL LIST [1:?] OF IfcAppliedValue;</para>
	/// <para>	BaseQuantity : OPTIONAL IfcPhysicalQuantity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConstructionResource : IfcResource
	{
		public IfcResourceTime? Usage { get; set; }
		public List<IfcAppliedValue>? BaseCosts { get; set; }
		public IfcPhysicalQuantity? BaseQuantity { get; set; }
		public IfcConstructionResource() : base()
		{
		}
		public IfcConstructionResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.Usage = Usage;
			this.BaseCosts = BaseCosts;
			this.BaseQuantity = BaseQuantity;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionResourceType
	/// <para>ENTITY IfcConstructionResourceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcConstructionEquipmentResourceType</para>
	/// <para>    ,IfcConstructionMaterialResourceType</para>
	/// <para>    ,IfcConstructionProductResourceType</para>
	/// <para>    ,IfcCrewResourceType</para>
	/// <para>    ,IfcLaborResourceType</para>
	/// <para>    ,IfcSubContractResourceType))</para>
	/// <para> SUBTYPE OF (IfcTypeResource);</para>
	/// <para>	BaseCosts : OPTIONAL LIST [1:?] OF IfcAppliedValue;</para>
	/// <para>	BaseQuantity : OPTIONAL IfcPhysicalQuantity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConstructionResourceType : IfcTypeResource
	{
		public List<IfcAppliedValue>? BaseCosts { get; set; }
		public IfcPhysicalQuantity? BaseQuantity { get; set; }
		public IfcConstructionResourceType() : base()
		{
		}
		public IfcConstructionResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType)
		{
			this.BaseCosts = BaseCosts;
			this.BaseQuantity = BaseQuantity;
		}
	}
	/// <summary>
	/// ENTITY IfcContext
	/// <para>ENTITY IfcContext</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcProject</para>
	/// <para>    ,IfcProjectLibrary))</para>
	/// <para> SUBTYPE OF (IfcObjectDefinition);</para>
	/// <para>	ObjectType : OPTIONAL IfcLabel;</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para>	Phase : OPTIONAL IfcLabel;</para>
	/// <para>	RepresentationContexts : OPTIONAL SET [1:?] OF IfcRepresentationContext;</para>
	/// <para>	UnitsInContext : OPTIONAL IfcUnitAssignment;</para>
	/// <para> INVERSE</para>
	/// <para>	IsDefinedBy : SET [0:?] OF IfcRelDefinesByProperties FOR RelatedObjects;</para>
	/// <para>	Declares : SET [0:?] OF IfcRelDeclares FOR RelatingContext;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcContext : IfcObjectDefinition
	{
		public IfcLabel? ObjectType { get; set; }
		public IfcLabel? LongName { get; set; }
		public IfcLabel? Phase { get; set; }
		public List<IfcRepresentationContext>? RepresentationContexts { get; set; }
		public IfcUnitAssignment? UnitsInContext { get; set; }
		public IfcContext() : base()
		{
		}
		public IfcContext(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcLabel Phase, List<IfcRepresentationContext> RepresentationContexts, IfcUnitAssignment UnitsInContext) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ObjectType = ObjectType;
			this.LongName = LongName;
			this.Phase = Phase;
			this.RepresentationContexts = RepresentationContexts;
			this.UnitsInContext = UnitsInContext;
		}
	}
	/// <summary>
	/// ENTITY IfcContextDependentUnit
	/// <para>ENTITY IfcContextDependentUnit</para>
	/// <para> SUBTYPE OF (IfcNamedUnit);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcContextDependentUnit : IfcNamedUnit, IfcResourceObjectSelect
	{
		public IfcLabel Name { get; set; }
		public IfcContextDependentUnit() : base()
		{
			Name = new IfcLabel();
		}
		public IfcContextDependentUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcLabel Name) : base (Dimensions, UnitType)
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcControl
	/// <para>ENTITY IfcControl</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcActionRequest</para>
	/// <para>    ,IfcCostItem</para>
	/// <para>    ,IfcCostSchedule</para>
	/// <para>    ,IfcPerformanceHistory</para>
	/// <para>    ,IfcPermit</para>
	/// <para>    ,IfcProjectOrder</para>
	/// <para>    ,IfcWorkCalendar</para>
	/// <para>    ,IfcWorkControl))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	Controls : SET [0:?] OF IfcRelAssignsToControl FOR RelatingControl;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcControl : IfcObject
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcControl() : base()
		{
		}
		public IfcControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
		}
	}
	/// <summary>
	/// ENTITY IfcController
	/// <para>ENTITY IfcController</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcControllerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcControllerTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcControllerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>('IFC4.IFCCONTROLLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcController : IfcDistributionControlElement
	{
		public IfcControllerTypeEnum? PredefinedType { get; set; }
		public IfcController() : base()
		{
		}
		public IfcController(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcControllerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcControllerType
	/// <para>ENTITY IfcControllerType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcControllerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcControllerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcControllerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcControllerType : IfcDistributionControlElementType
	{
		public IfcControllerTypeEnum PredefinedType { get; set; }
		public IfcControllerType() : base()
		{
			PredefinedType = new IfcControllerTypeEnum();
		}
		public IfcControllerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcControllerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConversionBasedUnit
	/// <para>ENTITY IfcConversionBasedUnit</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcConversionBasedUnitWithOffset))</para>
	/// <para> SUBTYPE OF (IfcNamedUnit);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	ConversionFactor : IfcMeasureWithUnit;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConversionBasedUnit : IfcNamedUnit, IfcResourceObjectSelect
	{
		public IfcLabel Name { get; set; }
		public IfcMeasureWithUnit ConversionFactor { get; set; }
		public IfcConversionBasedUnit() : base()
		{
			Name = new IfcLabel();
			ConversionFactor = new IfcMeasureWithUnit();
		}
		public IfcConversionBasedUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcLabel Name, IfcMeasureWithUnit ConversionFactor) : base (Dimensions, UnitType)
		{
			this.Name = Name;
			this.ConversionFactor = ConversionFactor;
		}
	}
	/// <summary>
	/// ENTITY IfcConversionBasedUnitWithOffset
	/// <para>ENTITY IfcConversionBasedUnitWithOffset</para>
	/// <para> SUBTYPE OF (IfcConversionBasedUnit);</para>
	/// <para>	ConversionOffset : IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConversionBasedUnitWithOffset : IfcConversionBasedUnit
	{
		public IfcReal ConversionOffset { get; set; }
		public IfcConversionBasedUnitWithOffset() : base()
		{
			ConversionOffset = new IfcReal();
		}
		public IfcConversionBasedUnitWithOffset(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcLabel Name, IfcMeasureWithUnit ConversionFactor, IfcReal ConversionOffset) : base (Dimensions, UnitType, Name, ConversionFactor)
		{
			this.ConversionOffset = ConversionOffset;
		}
	}
	/// <summary>
	/// ENTITY IfcCooledBeam
	/// <para>ENTITY IfcCooledBeam</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCooledBeamTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCooledBeamTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCooledBeamTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCOOLEDBEAMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCooledBeam : IfcEnergyConversionDevice
	{
		public IfcCooledBeamTypeEnum? PredefinedType { get; set; }
		public IfcCooledBeam() : base()
		{
		}
		public IfcCooledBeam(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCooledBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCooledBeamType
	/// <para>ENTITY IfcCooledBeamType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcCooledBeamTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCooledBeamTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCooledBeamTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCooledBeamType : IfcEnergyConversionDeviceType
	{
		public IfcCooledBeamTypeEnum PredefinedType { get; set; }
		public IfcCooledBeamType() : base()
		{
			PredefinedType = new IfcCooledBeamTypeEnum();
		}
		public IfcCooledBeamType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCooledBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoolingTower
	/// <para>ENTITY IfcCoolingTower</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCoolingTowerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCoolingTowerTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCoolingTowerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCCOOLINGTOWERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoolingTower : IfcEnergyConversionDevice
	{
		public IfcCoolingTowerTypeEnum? PredefinedType { get; set; }
		public IfcCoolingTower() : base()
		{
		}
		public IfcCoolingTower(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCoolingTowerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoolingTowerType
	/// <para>ENTITY IfcCoolingTowerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcCoolingTowerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCoolingTowerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCoolingTowerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoolingTowerType : IfcEnergyConversionDeviceType
	{
		public IfcCoolingTowerTypeEnum PredefinedType { get; set; }
		public IfcCoolingTowerType() : base()
		{
			PredefinedType = new IfcCoolingTowerTypeEnum();
		}
		public IfcCoolingTowerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCoolingTowerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoordinateOperation
	/// <para>ENTITY IfcCoordinateOperation</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMapConversion));</para>
	/// <para>	SourceCRS : IfcCoordinateReferenceSystemSelect;</para>
	/// <para>	TargetCRS : IfcCoordinateReferenceSystem;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCoordinateOperation : ENTITY
	{
		public IfcCoordinateReferenceSystemSelect SourceCRS { get; set; }
		public IfcCoordinateReferenceSystem TargetCRS { get; set; }
		public IfcCoordinateOperation() : base()
		{
			SourceCRS = new IfcCoordinateReferenceSystemSelect();
			TargetCRS = new IfcCoordinateReferenceSystem();
		}
		public IfcCoordinateOperation(IfcCoordinateReferenceSystemSelect SourceCRS, IfcCoordinateReferenceSystem TargetCRS) : base ()
		{
			this.SourceCRS = SourceCRS;
			this.TargetCRS = TargetCRS;
		}
	}
	/// <summary>
	/// ENTITY IfcCoordinateReferenceSystem
	/// <para>ENTITY IfcCoordinateReferenceSystem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcProjectedCRS));</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	GeodeticDatum : OPTIONAL IfcIdentifier;</para>
	/// <para>	VerticalDatum : OPTIONAL IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	HasCoordinateOperation : SET [0:1] OF IfcCoordinateOperation FOR SourceCRS;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCoordinateReferenceSystem : ENTITY, IfcCoordinateReferenceSystemSelect
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcIdentifier? GeodeticDatum { get; set; }
		public IfcIdentifier? VerticalDatum { get; set; }
		public IfcCoordinateReferenceSystem() : base()
		{
			Name = new IfcLabel();
		}
		public IfcCoordinateReferenceSystem(IfcLabel Name, IfcText Description, IfcIdentifier GeodeticDatum, IfcIdentifier VerticalDatum) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.GeodeticDatum = GeodeticDatum;
			this.VerticalDatum = VerticalDatum;
		}
	}
	/// <summary>
	/// ENTITY IfcCostItem
	/// <para>ENTITY IfcCostItem</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCostItemTypeEnum;</para>
	/// <para>	CostValues : OPTIONAL LIST [1:?] OF IfcCostValue;</para>
	/// <para>	CostQuantities : OPTIONAL LIST [1:?] OF IfcPhysicalQuantity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCostItem : IfcControl
	{
		public IfcCostItemTypeEnum? PredefinedType { get; set; }
		public List<IfcCostValue>? CostValues { get; set; }
		public List<IfcPhysicalQuantity>? CostQuantities { get; set; }
		public IfcCostItem() : base()
		{
		}
		public IfcCostItem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcCostItemTypeEnum PredefinedType, List<IfcCostValue> CostValues, List<IfcPhysicalQuantity> CostQuantities) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.CostValues = CostValues;
			this.CostQuantities = CostQuantities;
		}
	}
	/// <summary>
	/// ENTITY IfcCostSchedule
	/// <para>ENTITY IfcCostSchedule</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCostScheduleTypeEnum;</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	SubmittedOn : OPTIONAL IfcDateTime;</para>
	/// <para>	UpdateDate : OPTIONAL IfcDateTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCostSchedule : IfcControl
	{
		public IfcCostScheduleTypeEnum? PredefinedType { get; set; }
		public IfcLabel? Status { get; set; }
		public IfcDateTime? SubmittedOn { get; set; }
		public IfcDateTime? UpdateDate { get; set; }
		public IfcCostSchedule() : base()
		{
		}
		public IfcCostSchedule(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcCostScheduleTypeEnum PredefinedType, IfcLabel Status, IfcDateTime SubmittedOn, IfcDateTime UpdateDate) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.SubmittedOn = SubmittedOn;
			this.UpdateDate = UpdateDate;
		}
	}
	/// <summary>
	/// ENTITY IfcCostValue
	/// <para>ENTITY IfcCostValue</para>
	/// <para> SUBTYPE OF (IfcAppliedValue);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCostValue : IfcAppliedValue
	{
		public IfcCostValue() : base()
		{
		}
		public IfcCostValue(IfcLabel Name, IfcText Description, IfcAppliedValueSelect AppliedValue, IfcMeasureWithUnit UnitBasis, IfcDate ApplicableDate, IfcDate FixedUntilDate, IfcLabel Category, IfcLabel Condition, IfcArithmeticOperatorEnum ArithmeticOperator, List<IfcAppliedValue> Components) : base (Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCovering
	/// <para>ENTITY IfcCovering</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCoveringTypeEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	CoversSpaces : SET [0:1] OF IfcRelCoversSpaces FOR RelatedCoverings;</para>
	/// <para>	CoversElements : SET [0:1] OF IfcRelCoversBldgElements FOR RelatedCoverings;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCoveringTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCoveringTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCCOVERINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCovering : IfcBuildingElement
	{
		public IfcCoveringTypeEnum? PredefinedType { get; set; }
		public IfcCovering() : base()
		{
		}
		public IfcCovering(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCoveringTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoveringType
	/// <para>ENTITY IfcCoveringType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcCoveringTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCoveringTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCoveringTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoveringType : IfcBuildingElementType
	{
		public IfcCoveringTypeEnum PredefinedType { get; set; }
		public IfcCoveringType() : base()
		{
			PredefinedType = new IfcCoveringTypeEnum();
		}
		public IfcCoveringType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCoveringTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCrewResource
	/// <para>ENTITY IfcCrewResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCrewResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcCrewResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcCrewResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCrewResource : IfcConstructionResource
	{
		public IfcCrewResourceTypeEnum? PredefinedType { get; set; }
		public IfcCrewResource() : base()
		{
		}
		public IfcCrewResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcCrewResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCrewResourceType
	/// <para>ENTITY IfcCrewResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcCrewResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCrewResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCrewResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCrewResourceType : IfcConstructionResourceType
	{
		public IfcCrewResourceTypeEnum PredefinedType { get; set; }
		public IfcCrewResourceType() : base()
		{
			PredefinedType = new IfcCrewResourceTypeEnum();
		}
		public IfcCrewResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcCrewResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCsgPrimitive3D
	/// <para>ENTITY IfcCsgPrimitive3D</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBlock</para>
	/// <para>    ,IfcRectangularPyramid</para>
	/// <para>    ,IfcRightCircularCone</para>
	/// <para>    ,IfcRightCircularCylinder</para>
	/// <para>    ,IfcSphere))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Position : IfcAxis2Placement3D;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCsgPrimitive3D : IfcGeometricRepresentationItem, IfcBooleanOperand, IfcCsgSelect
	{
		public IfcAxis2Placement3D Position { get; set; }
		public IfcCsgPrimitive3D() : base()
		{
			Position = new IfcAxis2Placement3D();
		}
		public IfcCsgPrimitive3D(IfcAxis2Placement3D Position) : base ()
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcCsgSolid
	/// <para>ENTITY IfcCsgSolid</para>
	/// <para> SUBTYPE OF (IfcSolidModel);</para>
	/// <para>	TreeRootExpression : IfcCsgSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCsgSolid : IfcSolidModel
	{
		public IfcCsgSelect TreeRootExpression { get; set; }
		public IfcCsgSolid() : base()
		{
			TreeRootExpression = new IfcCsgSelect();
		}
		public IfcCsgSolid(IfcCsgSelect TreeRootExpression) : base ()
		{
			this.TreeRootExpression = TreeRootExpression;
		}
	}
	/// <summary>
	/// ENTITY IfcCurrencyRelationship
	/// <para>ENTITY IfcCurrencyRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingMonetaryUnit : IfcMonetaryUnit;</para>
	/// <para>	RelatedMonetaryUnit : IfcMonetaryUnit;</para>
	/// <para>	ExchangeRate : IfcPositiveRatioMeasure;</para>
	/// <para>	RateDateTime : OPTIONAL IfcDateTime;</para>
	/// <para>	RateSource : OPTIONAL IfcLibraryInformation;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurrencyRelationship : IfcResourceLevelRelationship
	{
		public IfcMonetaryUnit RelatingMonetaryUnit { get; set; }
		public IfcMonetaryUnit RelatedMonetaryUnit { get; set; }
		public IfcPositiveRatioMeasure ExchangeRate { get; set; }
		public IfcDateTime? RateDateTime { get; set; }
		public IfcLibraryInformation? RateSource { get; set; }
		public IfcCurrencyRelationship() : base()
		{
			RelatingMonetaryUnit = new IfcMonetaryUnit();
			RelatedMonetaryUnit = new IfcMonetaryUnit();
			ExchangeRate = new IfcPositiveRatioMeasure();
		}
		public IfcCurrencyRelationship(IfcLabel Name, IfcText Description, IfcMonetaryUnit RelatingMonetaryUnit, IfcMonetaryUnit RelatedMonetaryUnit, IfcPositiveRatioMeasure ExchangeRate, IfcDateTime RateDateTime, IfcLibraryInformation RateSource) : base (Name, Description)
		{
			this.RelatingMonetaryUnit = RelatingMonetaryUnit;
			this.RelatedMonetaryUnit = RelatedMonetaryUnit;
			this.ExchangeRate = ExchangeRate;
			this.RateDateTime = RateDateTime;
			this.RateSource = RateSource;
		}
	}
	/// <summary>
	/// ENTITY IfcCurtainWall
	/// <para>ENTITY IfcCurtainWall</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcCurtainWallTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcCurtainWallTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcCurtainWallTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCCURTAINWALLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurtainWall : IfcBuildingElement
	{
		public IfcCurtainWallTypeEnum? PredefinedType { get; set; }
		public IfcCurtainWall() : base()
		{
		}
		public IfcCurtainWall(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCurtainWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCurtainWallType
	/// <para>ENTITY IfcCurtainWallType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcCurtainWallTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcCurtainWallTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCurtainWallTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurtainWallType : IfcBuildingElementType
	{
		public IfcCurtainWallTypeEnum PredefinedType { get; set; }
		public IfcCurtainWallType() : base()
		{
			PredefinedType = new IfcCurtainWallTypeEnum();
		}
		public IfcCurtainWallType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCurtainWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCurve
	/// <para>ENTITY IfcCurve</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBoundedCurve</para>
	/// <para>    ,IfcConic</para>
	/// <para>    ,IfcLine</para>
	/// <para>    ,IfcOffsetCurve2D</para>
	/// <para>    ,IfcOffsetCurve3D</para>
	/// <para>    ,IfcPcurve</para>
	/// <para>    ,IfcSurfaceCurve))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := IfcCurveDim(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCurve : IfcGeometricRepresentationItem, IfcGeometricSetSelect
	{
		public IfcCurve() : base()
		{
		}
		public IfcCurve() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCurveBoundedPlane
	/// <para>ENTITY IfcCurveBoundedPlane</para>
	/// <para> SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>	BasisSurface : IfcPlane;</para>
	/// <para>	OuterBoundary : IfcCurve;</para>
	/// <para>	InnerBoundaries : SET [0:?] OF IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveBoundedPlane : IfcBoundedSurface
	{
		public IfcPlane BasisSurface { get; set; }
		public IfcCurve OuterBoundary { get; set; }
		public List<IfcCurve> InnerBoundaries { get; set; }
		public IfcCurveBoundedPlane() : base()
		{
			BasisSurface = new IfcPlane();
			OuterBoundary = new IfcCurve();
			InnerBoundaries = new List<IfcCurve>();
		}
		public IfcCurveBoundedPlane(IfcPlane BasisSurface, IfcCurve OuterBoundary, List<IfcCurve> InnerBoundaries) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.OuterBoundary = OuterBoundary;
			this.InnerBoundaries = InnerBoundaries;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveBoundedSurface
	/// <para>ENTITY IfcCurveBoundedSurface</para>
	/// <para> SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>	BasisSurface : IfcSurface;</para>
	/// <para>	Boundaries : SET [1:?] OF IfcBoundaryCurve;</para>
	/// <para>	ImplicitOuter : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveBoundedSurface : IfcBoundedSurface
	{
		public IfcSurface BasisSurface { get; set; }
		public List<IfcBoundaryCurve> Boundaries { get; set; }
		public IfcBoolean ImplicitOuter { get; set; }
		public IfcCurveBoundedSurface() : base()
		{
			BasisSurface = new IfcSurface();
			Boundaries = new List<IfcBoundaryCurve>();
			ImplicitOuter = new IfcBoolean();
		}
		public IfcCurveBoundedSurface(IfcSurface BasisSurface, List<IfcBoundaryCurve> Boundaries, IfcBoolean ImplicitOuter) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.Boundaries = Boundaries;
			this.ImplicitOuter = ImplicitOuter;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyle
	/// <para>ENTITY IfcCurveStyle</para>
	/// <para> SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>	CurveFont : OPTIONAL IfcCurveFontOrScaledCurveFontSelect;</para>
	/// <para>	CurveWidth : OPTIONAL IfcSizeSelect;</para>
	/// <para>	CurveColour : OPTIONAL IfcColour;</para>
	/// <para>	ModelOrDraughting : OPTIONAL IfcBoolean;</para>
	/// <para> WHERE</para>
	/// <para>	MeasureOfWidth : (NOT(EXISTS(CurveWidth))) OR</para>
	/// <para>('IFC4.IFCPOSITIVELENGTHMEASURE' IN TYPEOF(CurveWidth)) OR </para>
	/// <para> (('IFC4.IFCDESCRIPTIVEMEASURE' IN TYPEOF(CurveWidth)) AND</para>
	/// <para> (CurveWidth = 'by layer'));</para>
	/// <para>	IdentifiableCurveStyle : EXISTS(CurveFont) OR EXISTS(CurveWidth) OR EXISTS(CurveColour);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyle : IfcPresentationStyle, IfcPresentationStyleSelect
	{
		public IfcCurveFontOrScaledCurveFontSelect? CurveFont { get; set; }
		public IfcSizeSelect? CurveWidth { get; set; }
		public IfcColour? CurveColour { get; set; }
		public IfcBoolean? ModelOrDraughting { get; set; }
		public IfcCurveStyle() : base()
		{
		}
		public IfcCurveStyle(IfcLabel Name, IfcCurveFontOrScaledCurveFontSelect CurveFont, IfcSizeSelect CurveWidth, IfcColour CurveColour, IfcBoolean ModelOrDraughting) : base (Name)
		{
			this.CurveFont = CurveFont;
			this.CurveWidth = CurveWidth;
			this.CurveColour = CurveColour;
			this.ModelOrDraughting = ModelOrDraughting;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyleFont
	/// <para>ENTITY IfcCurveStyleFont</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	PatternList : LIST [1:?] OF IfcCurveStyleFontPattern;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyleFont : IfcPresentationItem, IfcCurveStyleFontSelect
	{
		public IfcLabel? Name { get; set; }
		public List<IfcCurveStyleFontPattern> PatternList { get; set; }
		public IfcCurveStyleFont() : base()
		{
			PatternList = new List<IfcCurveStyleFontPattern>();
		}
		public IfcCurveStyleFont(IfcLabel Name, List<IfcCurveStyleFontPattern> PatternList) : base ()
		{
			this.Name = Name;
			this.PatternList = PatternList;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyleFontAndScaling
	/// <para>ENTITY IfcCurveStyleFontAndScaling</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	CurveFont : IfcCurveStyleFontSelect;</para>
	/// <para>	CurveFontScaling : IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyleFontAndScaling : IfcPresentationItem, IfcCurveFontOrScaledCurveFontSelect
	{
		public IfcLabel? Name { get; set; }
		public IfcCurveStyleFontSelect CurveFont { get; set; }
		public IfcPositiveRatioMeasure CurveFontScaling { get; set; }
		public IfcCurveStyleFontAndScaling() : base()
		{
			CurveFont = new IfcCurveStyleFontSelect();
			CurveFontScaling = new IfcPositiveRatioMeasure();
		}
		public IfcCurveStyleFontAndScaling(IfcLabel Name, IfcCurveStyleFontSelect CurveFont, IfcPositiveRatioMeasure CurveFontScaling) : base ()
		{
			this.Name = Name;
			this.CurveFont = CurveFont;
			this.CurveFontScaling = CurveFontScaling;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyleFontPattern
	/// <para>ENTITY IfcCurveStyleFontPattern</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	VisibleSegmentLength : IfcLengthMeasure;</para>
	/// <para>	InvisibleSegmentLength : IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	VisibleLengthGreaterEqualZero : VisibleSegmentLength >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyleFontPattern : IfcPresentationItem
	{
		public IfcLengthMeasure VisibleSegmentLength { get; set; }
		public IfcPositiveLengthMeasure InvisibleSegmentLength { get; set; }
		public IfcCurveStyleFontPattern() : base()
		{
			VisibleSegmentLength = new IfcLengthMeasure();
			InvisibleSegmentLength = new IfcPositiveLengthMeasure();
		}
		public IfcCurveStyleFontPattern(IfcLengthMeasure VisibleSegmentLength, IfcPositiveLengthMeasure InvisibleSegmentLength) : base ()
		{
			this.VisibleSegmentLength = VisibleSegmentLength;
			this.InvisibleSegmentLength = InvisibleSegmentLength;
		}
	}
	/// <summary>
	/// ENTITY IfcCylindricalSurface
	/// <para>ENTITY IfcCylindricalSurface</para>
	/// <para> SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCylindricalSurface : IfcElementarySurface
	{
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcCylindricalSurface() : base()
		{
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcCylindricalSurface(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcDamper
	/// <para>ENTITY IfcDamper</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDamperTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcDamperTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcDamperTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCDAMPERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDamper : IfcFlowController
	{
		public IfcDamperTypeEnum? PredefinedType { get; set; }
		public IfcDamper() : base()
		{
		}
		public IfcDamper(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDamperTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDamperType
	/// <para>ENTITY IfcDamperType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcDamperTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDamperTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDamperTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDamperType : IfcFlowControllerType
	{
		public IfcDamperTypeEnum PredefinedType { get; set; }
		public IfcDamperType() : base()
		{
			PredefinedType = new IfcDamperTypeEnum();
		}
		public IfcDamperType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDamperTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDerivedProfileDef
	/// <para>ENTITY IfcDerivedProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMirroredProfileDef))</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	ParentProfile : IfcProfileDef;</para>
	/// <para>	Operator : IfcCartesianTransformationOperator2D;</para>
	/// <para>	Label : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	InvariantProfileType : SELF\IfcProfileDef.ProfileType = ParentProfile.ProfileType;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDerivedProfileDef : IfcProfileDef
	{
		public IfcProfileDef ParentProfile { get; set; }
		public IfcCartesianTransformationOperator2D Operator { get; set; }
		public IfcLabel? Label { get; set; }
		public IfcDerivedProfileDef() : base()
		{
			ParentProfile = new IfcProfileDef();
			Operator = new IfcCartesianTransformationOperator2D();
		}
		public IfcDerivedProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcProfileDef ParentProfile, IfcCartesianTransformationOperator2D Operator, IfcLabel Label) : base (ProfileType, ProfileName)
		{
			this.ParentProfile = ParentProfile;
			this.Operator = Operator;
			this.Label = Label;
		}
	}
	/// <summary>
	/// ENTITY IfcDerivedUnit;
	/// <para>ENTITY IfcDerivedUnit;</para>
	/// <para>	Elements : SET [1:?] OF IfcDerivedUnitElement;</para>
	/// <para>	UnitType : IfcDerivedUnitEnum;</para>
	/// <para>	UserDefinedType : OPTIONAL IfcLabel;</para>
	/// <para> DERIVE</para>
	/// <para>	Dimensions : IfcDimensionalExponents := IfcDeriveDimensionalExponents(Elements);</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : (SIZEOF (Elements) > 1) OR ((SIZEOF (Elements) = 1) AND (Elements[1].Exponent <> 1 ));</para>
	/// <para>	WR2 : (UnitType <> IfcDerivedUnitEnum.USERDEFINED) OR</para>
	/// <para>((UnitType = IfcDerivedUnitEnum.USERDEFINED) AND </para>
	/// <para> (EXISTS(SELF.UserDefinedType)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDerivedUnit : ENTITY, IfcUnit
	{
		public List<IfcDerivedUnitElement> Elements { get; set; }
		public IfcDerivedUnitEnum UnitType { get; set; }
		public IfcLabel? UserDefinedType { get; set; }
		public IfcDerivedUnit() : base()
		{
			Elements = new List<IfcDerivedUnitElement>();
			UnitType = new IfcDerivedUnitEnum();
		}
		public IfcDerivedUnit(List<IfcDerivedUnitElement> Elements, IfcDerivedUnitEnum UnitType, IfcLabel UserDefinedType) : base ()
		{
			this.Elements = Elements;
			this.UnitType = UnitType;
			this.UserDefinedType = UserDefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDerivedUnitElement;
	/// <para>ENTITY IfcDerivedUnitElement;</para>
	/// <para>	Unit : IfcNamedUnit;</para>
	/// <para>	Exponent : INTEGER;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDerivedUnitElement : ENTITY
	{
		public IfcNamedUnit Unit { get; set; }
		public INTEGER Exponent { get; set; }
		public IfcDerivedUnitElement() : base()
		{
			Unit = new IfcNamedUnit();
			Exponent = new INTEGER();
		}
		public IfcDerivedUnitElement(IfcNamedUnit Unit, INTEGER Exponent) : base ()
		{
			this.Unit = Unit;
			this.Exponent = Exponent;
		}
	}
	/// <summary>
	/// ENTITY IfcDimensionalExponents;
	/// <para>ENTITY IfcDimensionalExponents;</para>
	/// <para>	LengthExponent : INTEGER;</para>
	/// <para>	MassExponent : INTEGER;</para>
	/// <para>	TimeExponent : INTEGER;</para>
	/// <para>	ElectricCurrentExponent : INTEGER;</para>
	/// <para>	ThermodynamicTemperatureExponent : INTEGER;</para>
	/// <para>	AmountOfSubstanceExponent : INTEGER;</para>
	/// <para>	LuminousIntensityExponent : INTEGER;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDimensionalExponents : ENTITY
	{
		public INTEGER LengthExponent { get; set; }
		public INTEGER MassExponent { get; set; }
		public INTEGER TimeExponent { get; set; }
		public INTEGER ElectricCurrentExponent { get; set; }
		public INTEGER ThermodynamicTemperatureExponent { get; set; }
		public INTEGER AmountOfSubstanceExponent { get; set; }
		public INTEGER LuminousIntensityExponent { get; set; }
		public IfcDimensionalExponents() : base()
		{
			LengthExponent = new INTEGER();
			MassExponent = new INTEGER();
			TimeExponent = new INTEGER();
			ElectricCurrentExponent = new INTEGER();
			ThermodynamicTemperatureExponent = new INTEGER();
			AmountOfSubstanceExponent = new INTEGER();
			LuminousIntensityExponent = new INTEGER();
		}
		public IfcDimensionalExponents(INTEGER LengthExponent, INTEGER MassExponent, INTEGER TimeExponent, INTEGER ElectricCurrentExponent, INTEGER ThermodynamicTemperatureExponent, INTEGER AmountOfSubstanceExponent, INTEGER LuminousIntensityExponent) : base ()
		{
			this.LengthExponent = LengthExponent;
			this.MassExponent = MassExponent;
			this.TimeExponent = TimeExponent;
			this.ElectricCurrentExponent = ElectricCurrentExponent;
			this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent;
			this.AmountOfSubstanceExponent = AmountOfSubstanceExponent;
			this.LuminousIntensityExponent = LuminousIntensityExponent;
		}
	}
	/// <summary>
	/// ENTITY IfcDirection
	/// <para>ENTITY IfcDirection</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	DirectionRatios : LIST [2:3] OF IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := HIINDEX(DirectionRatios);</para>
	/// <para> WHERE</para>
	/// <para>	MagnitudeGreaterZero : SIZEOF(QUERY(Tmp <* DirectionRatios | Tmp <> 0.0)) > 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDirection : IfcGeometricRepresentationItem, IfcGridPlacementDirectionSelect, IfcVectorOrDirection
	{
		public List<IfcReal> DirectionRatios { get; set; }
		public IfcDirection() : base()
		{
			DirectionRatios = new List<IfcReal>();
		}
		public IfcDirection(List<IfcReal> DirectionRatios) : base ()
		{
			this.DirectionRatios = DirectionRatios;
		}
	}
	/// <summary>
	/// ENTITY IfcDiscreteAccessory
	/// <para>ENTITY IfcDiscreteAccessory</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDiscreteAccessoryTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcDiscreteAccessoryTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDiscreteAccessoryTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4.IFCDISCRETEACCESSORYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDiscreteAccessory : IfcElementComponent
	{
		public IfcDiscreteAccessoryTypeEnum? PredefinedType { get; set; }
		public IfcDiscreteAccessory() : base()
		{
		}
		public IfcDiscreteAccessory(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDiscreteAccessoryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDiscreteAccessoryType
	/// <para>ENTITY IfcDiscreteAccessoryType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcDiscreteAccessoryTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDiscreteAccessoryTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDiscreteAccessoryTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDiscreteAccessoryType : IfcElementComponentType
	{
		public IfcDiscreteAccessoryTypeEnum PredefinedType { get; set; }
		public IfcDiscreteAccessoryType() : base()
		{
			PredefinedType = new IfcDiscreteAccessoryTypeEnum();
		}
		public IfcDiscreteAccessoryType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDiscreteAccessoryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionChamberElement
	/// <para>ENTITY IfcDistributionChamberElement</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDistributionChamberElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcDistributionChamberElementTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcDistributionChamberElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>('IFC4.IFCDISTRIBUTIONCHAMBERELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionChamberElement : IfcDistributionFlowElement
	{
		public IfcDistributionChamberElementTypeEnum? PredefinedType { get; set; }
		public IfcDistributionChamberElement() : base()
		{
		}
		public IfcDistributionChamberElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDistributionChamberElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionChamberElementType
	/// <para>ENTITY IfcDistributionChamberElementType</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>	PredefinedType : IfcDistributionChamberElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDistributionChamberElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDistributionChamberElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionChamberElementType : IfcDistributionFlowElementType
	{
		public IfcDistributionChamberElementTypeEnum PredefinedType { get; set; }
		public IfcDistributionChamberElementType() : base()
		{
			PredefinedType = new IfcDistributionChamberElementTypeEnum();
		}
		public IfcDistributionChamberElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDistributionChamberElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionCircuit
	/// <para>ENTITY IfcDistributionCircuit</para>
	/// <para> SUBTYPE OF (IfcDistributionSystem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionCircuit : IfcDistributionSystem
	{
		public IfcDistributionCircuit() : base()
		{
		}
		public IfcDistributionCircuit(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcDistributionSystemEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionControlElement
	/// <para>ENTITY IfcDistributionControlElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcActuator</para>
	/// <para>    ,IfcAlarm</para>
	/// <para>    ,IfcController</para>
	/// <para>    ,IfcFlowInstrument</para>
	/// <para>    ,IfcProtectiveDeviceTrippingUnit</para>
	/// <para>    ,IfcSensor</para>
	/// <para>    ,IfcUnitaryControlElement))</para>
	/// <para> SUBTYPE OF (IfcDistributionElement);</para>
	/// <para> INVERSE</para>
	/// <para>	AssignedToFlowElement : SET [0:1] OF IfcRelFlowControlElements FOR RelatedControlElements;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionControlElement : IfcDistributionElement
	{
		public IfcDistributionControlElement() : base()
		{
		}
		public IfcDistributionControlElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionControlElementType
	/// <para>ENTITY IfcDistributionControlElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcActuatorType</para>
	/// <para>    ,IfcAlarmType</para>
	/// <para>    ,IfcControllerType</para>
	/// <para>    ,IfcFlowInstrumentType</para>
	/// <para>    ,IfcProtectiveDeviceTrippingUnitType</para>
	/// <para>    ,IfcSensorType</para>
	/// <para>    ,IfcUnitaryControlElementType))</para>
	/// <para> SUBTYPE OF (IfcDistributionElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcDistributionControlElementType : IfcDistributionElementType
	{
		public IfcDistributionControlElementType() : base()
		{
		}
		public IfcDistributionControlElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionElement
	/// <para>ENTITY IfcDistributionElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDistributionControlElement</para>
	/// <para>    ,IfcDistributionFlowElement))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para> INVERSE</para>
	/// <para>	HasPorts : SET [0:?] OF IfcRelConnectsPortToElement FOR RelatedElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionElement : IfcElement
	{
		public IfcDistributionElement() : base()
		{
		}
		public IfcDistributionElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionElementType
	/// <para>ENTITY IfcDistributionElementType</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDistributionControlElementType</para>
	/// <para>    ,IfcDistributionFlowElementType))</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionElementType : IfcElementType
	{
		public IfcDistributionElementType() : base()
		{
		}
		public IfcDistributionElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionFlowElement
	/// <para>ENTITY IfcDistributionFlowElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDistributionChamberElement</para>
	/// <para>    ,IfcEnergyConversionDevice</para>
	/// <para>    ,IfcFlowController</para>
	/// <para>    ,IfcFlowFitting</para>
	/// <para>    ,IfcFlowMovingDevice</para>
	/// <para>    ,IfcFlowSegment</para>
	/// <para>    ,IfcFlowStorageDevice</para>
	/// <para>    ,IfcFlowTerminal</para>
	/// <para>    ,IfcFlowTreatmentDevice))</para>
	/// <para> SUBTYPE OF (IfcDistributionElement);</para>
	/// <para> INVERSE</para>
	/// <para>	HasControlElements : SET [0:1] OF IfcRelFlowControlElements FOR RelatingFlowElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionFlowElement : IfcDistributionElement
	{
		public IfcDistributionFlowElement() : base()
		{
		}
		public IfcDistributionFlowElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionFlowElementType
	/// <para>ENTITY IfcDistributionFlowElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDistributionChamberElementType</para>
	/// <para>    ,IfcEnergyConversionDeviceType</para>
	/// <para>    ,IfcFlowControllerType</para>
	/// <para>    ,IfcFlowFittingType</para>
	/// <para>    ,IfcFlowMovingDeviceType</para>
	/// <para>    ,IfcFlowSegmentType</para>
	/// <para>    ,IfcFlowStorageDeviceType</para>
	/// <para>    ,IfcFlowTerminalType</para>
	/// <para>    ,IfcFlowTreatmentDeviceType))</para>
	/// <para> SUBTYPE OF (IfcDistributionElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcDistributionFlowElementType : IfcDistributionElementType
	{
		public IfcDistributionFlowElementType() : base()
		{
		}
		public IfcDistributionFlowElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionPort
	/// <para>ENTITY IfcDistributionPort</para>
	/// <para> SUBTYPE OF (IfcPort);</para>
	/// <para>	FlowDirection : OPTIONAL IfcFlowDirectionEnum;</para>
	/// <para>	PredefinedType : OPTIONAL IfcDistributionPortTypeEnum;</para>
	/// <para>	SystemType : OPTIONAL IfcDistributionSystemEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionPort : IfcPort
	{
		public IfcFlowDirectionEnum? FlowDirection { get; set; }
		public IfcDistributionPortTypeEnum? PredefinedType { get; set; }
		public IfcDistributionSystemEnum? SystemType { get; set; }
		public IfcDistributionPort() : base()
		{
		}
		public IfcDistributionPort(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcFlowDirectionEnum FlowDirection, IfcDistributionPortTypeEnum PredefinedType, IfcDistributionSystemEnum SystemType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.FlowDirection = FlowDirection;
			this.PredefinedType = PredefinedType;
			this.SystemType = SystemType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionSystem
	/// <para>ENTITY IfcDistributionSystem</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDistributionCircuit))</para>
	/// <para> SUBTYPE OF (IfcSystem);</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para>	PredefinedType : OPTIONAL IfcDistributionSystemEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionSystem : IfcSystem
	{
		public IfcLabel? LongName { get; set; }
		public IfcDistributionSystemEnum? PredefinedType { get; set; }
		public IfcDistributionSystem() : base()
		{
		}
		public IfcDistributionSystem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcDistributionSystemEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.LongName = LongName;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDocumentInformation
	/// <para>ENTITY IfcDocumentInformation</para>
	/// <para> SUBTYPE OF (IfcExternalInformation);</para>
	/// <para>	Identification : IfcIdentifier;</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Location : OPTIONAL IfcURIReference;</para>
	/// <para>	Purpose : OPTIONAL IfcText;</para>
	/// <para>	IntendedUse : OPTIONAL IfcText;</para>
	/// <para>	Scope : OPTIONAL IfcText;</para>
	/// <para>	Revision : OPTIONAL IfcLabel;</para>
	/// <para>	DocumentOwner : OPTIONAL IfcActorSelect;</para>
	/// <para>	Editors : OPTIONAL SET [1:?] OF IfcActorSelect;</para>
	/// <para>	CreationTime : OPTIONAL IfcDateTime;</para>
	/// <para>	LastRevisionTime : OPTIONAL IfcDateTime;</para>
	/// <para>	ElectronicFormat : OPTIONAL IfcIdentifier;</para>
	/// <para>	ValidFrom : OPTIONAL IfcDate;</para>
	/// <para>	ValidUntil : OPTIONAL IfcDate;</para>
	/// <para>	Confidentiality : OPTIONAL IfcDocumentConfidentialityEnum;</para>
	/// <para>	Status : OPTIONAL IfcDocumentStatusEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	DocumentInfoForObjects : SET [0:?] OF IfcRelAssociatesDocument FOR RelatingDocument;</para>
	/// <para>	HasDocumentReferences : SET [0:?] OF IfcDocumentReference FOR ReferencedDocument;</para>
	/// <para>	IsPointedTo : SET [0:?] OF IfcDocumentInformationRelationship FOR RelatedDocuments;</para>
	/// <para>	IsPointer : SET [0:1] OF IfcDocumentInformationRelationship FOR RelatingDocument;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDocumentInformation : IfcExternalInformation, IfcDocumentSelect
	{
		public IfcIdentifier Identification { get; set; }
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcURIReference? Location { get; set; }
		public IfcText? Purpose { get; set; }
		public IfcText? IntendedUse { get; set; }
		public IfcText? Scope { get; set; }
		public IfcLabel? Revision { get; set; }
		public IfcActorSelect? DocumentOwner { get; set; }
		public List<IfcActorSelect>? Editors { get; set; }
		public IfcDateTime? CreationTime { get; set; }
		public IfcDateTime? LastRevisionTime { get; set; }
		public IfcIdentifier? ElectronicFormat { get; set; }
		public IfcDate? ValidFrom { get; set; }
		public IfcDate? ValidUntil { get; set; }
		public IfcDocumentConfidentialityEnum? Confidentiality { get; set; }
		public IfcDocumentStatusEnum? Status { get; set; }
		public IfcDocumentInformation() : base()
		{
			Identification = new IfcIdentifier();
			Name = new IfcLabel();
		}
		public IfcDocumentInformation(IfcIdentifier Identification, IfcLabel Name, IfcText Description, IfcURIReference Location, IfcText Purpose, IfcText IntendedUse, IfcText Scope, IfcLabel Revision, IfcActorSelect DocumentOwner, List<IfcActorSelect> Editors, IfcDateTime CreationTime, IfcDateTime LastRevisionTime, IfcIdentifier ElectronicFormat, IfcDate ValidFrom, IfcDate ValidUntil, IfcDocumentConfidentialityEnum Confidentiality, IfcDocumentStatusEnum Status) : base ()
		{
			this.Identification = Identification;
			this.Name = Name;
			this.Description = Description;
			this.Location = Location;
			this.Purpose = Purpose;
			this.IntendedUse = IntendedUse;
			this.Scope = Scope;
			this.Revision = Revision;
			this.DocumentOwner = DocumentOwner;
			this.Editors = Editors;
			this.CreationTime = CreationTime;
			this.LastRevisionTime = LastRevisionTime;
			this.ElectronicFormat = ElectronicFormat;
			this.ValidFrom = ValidFrom;
			this.ValidUntil = ValidUntil;
			this.Confidentiality = Confidentiality;
			this.Status = Status;
		}
	}
	/// <summary>
	/// ENTITY IfcDocumentInformationRelationship
	/// <para>ENTITY IfcDocumentInformationRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingDocument : IfcDocumentInformation;</para>
	/// <para>	RelatedDocuments : SET [1:?] OF IfcDocumentInformation;</para>
	/// <para>	RelationshipType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDocumentInformationRelationship : IfcResourceLevelRelationship
	{
		public IfcDocumentInformation RelatingDocument { get; set; }
		public List<IfcDocumentInformation> RelatedDocuments { get; set; }
		public IfcLabel? RelationshipType { get; set; }
		public IfcDocumentInformationRelationship() : base()
		{
			RelatingDocument = new IfcDocumentInformation();
			RelatedDocuments = new List<IfcDocumentInformation>();
		}
		public IfcDocumentInformationRelationship(IfcLabel Name, IfcText Description, IfcDocumentInformation RelatingDocument, List<IfcDocumentInformation> RelatedDocuments, IfcLabel RelationshipType) : base (Name, Description)
		{
			this.RelatingDocument = RelatingDocument;
			this.RelatedDocuments = RelatedDocuments;
			this.RelationshipType = RelationshipType;
		}
	}
	/// <summary>
	/// ENTITY IfcDocumentReference
	/// <para>ENTITY IfcDocumentReference</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	ReferencedDocument : OPTIONAL IfcDocumentInformation;</para>
	/// <para> INVERSE</para>
	/// <para>	DocumentRefForObjects : SET [0:?] OF IfcRelAssociatesDocument FOR RelatingDocument;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : EXISTS(Name) XOR EXISTS(ReferencedDocument);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDocumentReference : IfcExternalReference, IfcDocumentSelect
	{
		public IfcText? Description { get; set; }
		public IfcDocumentInformation? ReferencedDocument { get; set; }
		public IfcDocumentReference() : base()
		{
		}
		public IfcDocumentReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name, IfcText Description, IfcDocumentInformation ReferencedDocument) : base (Location, Identification, Name)
		{
			this.Description = Description;
			this.ReferencedDocument = ReferencedDocument;
		}
	}
	/// <summary>
	/// ENTITY IfcDoor
	/// <para>ENTITY IfcDoor</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDoorStandardCase))</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	OverallHeight : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	OverallWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcDoorTypeEnum;</para>
	/// <para>	OperationType : OPTIONAL IfcDoorTypeOperationEnum;</para>
	/// <para>	UserDefinedOperationType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectStyleAssigned : (SIZEOF(IsTypedBy) = 0) </para>
	/// <para>OR ('IFC4.IFCDOORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoor : IfcBuildingElement
	{
		public IfcPositiveLengthMeasure? OverallHeight { get; set; }
		public IfcPositiveLengthMeasure? OverallWidth { get; set; }
		public IfcDoorTypeEnum? PredefinedType { get; set; }
		public IfcDoorTypeOperationEnum? OperationType { get; set; }
		public IfcLabel? UserDefinedOperationType { get; set; }
		public IfcDoor() : base()
		{
		}
		public IfcDoor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure OverallHeight, IfcPositiveLengthMeasure OverallWidth, IfcDoorTypeEnum PredefinedType, IfcDoorTypeOperationEnum OperationType, IfcLabel UserDefinedOperationType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.OverallHeight = OverallHeight;
			this.OverallWidth = OverallWidth;
			this.PredefinedType = PredefinedType;
			this.OperationType = OperationType;
			this.UserDefinedOperationType = UserDefinedOperationType;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorLiningProperties
	/// <para>ENTITY IfcDoorLiningProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	LiningDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LiningThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	ThresholdDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	ThresholdThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	TransomThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	TransomOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LiningOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ThresholdOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	CasingThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	CasingDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>	LiningToPanelOffsetX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LiningToPanelOffsetY : OPTIONAL IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : NOT(EXISTS(LiningDepth) AND NOT(EXISTS(LiningThickness)));</para>
	/// <para>	WR32 : NOT(EXISTS(ThresholdDepth) AND NOT(EXISTS(ThresholdThickness)));</para>
	/// <para>	WR33 : (EXISTS(TransomOffset) AND EXISTS(TransomThickness)) XOR</para>
	/// <para>(NOT(EXISTS(TransomOffset)) AND NOT(EXISTS(TransomThickness)));</para>
	/// <para>	WR34 : (EXISTS(CasingDepth) AND EXISTS(CasingThickness)) XOR</para>
	/// <para>(NOT(EXISTS(CasingDepth)) AND NOT(EXISTS(CasingThickness)));</para>
	/// <para>	WR35 : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) </para>
	/// <para>AND </para>
	/// <para>(</para>
	/// <para> ('IFC4.IFCDOORTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>  OR</para>
	/// <para> ('IFC4.IFCDOORSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorLiningProperties : IfcPreDefinedPropertySet
	{
		public IfcPositiveLengthMeasure? LiningDepth { get; set; }
		public IfcNonNegativeLengthMeasure? LiningThickness { get; set; }
		public IfcPositiveLengthMeasure? ThresholdDepth { get; set; }
		public IfcNonNegativeLengthMeasure? ThresholdThickness { get; set; }
		public IfcNonNegativeLengthMeasure? TransomThickness { get; set; }
		public IfcLengthMeasure? TransomOffset { get; set; }
		public IfcLengthMeasure? LiningOffset { get; set; }
		public IfcLengthMeasure? ThresholdOffset { get; set; }
		public IfcPositiveLengthMeasure? CasingThickness { get; set; }
		public IfcPositiveLengthMeasure? CasingDepth { get; set; }
		public IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcLengthMeasure? LiningToPanelOffsetX { get; set; }
		public IfcLengthMeasure? LiningToPanelOffsetY { get; set; }
		public IfcDoorLiningProperties() : base()
		{
		}
		public IfcDoorLiningProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPositiveLengthMeasure LiningDepth, IfcNonNegativeLengthMeasure LiningThickness, IfcPositiveLengthMeasure ThresholdDepth, IfcNonNegativeLengthMeasure ThresholdThickness, IfcNonNegativeLengthMeasure TransomThickness, IfcLengthMeasure TransomOffset, IfcLengthMeasure LiningOffset, IfcLengthMeasure ThresholdOffset, IfcPositiveLengthMeasure CasingThickness, IfcPositiveLengthMeasure CasingDepth, IfcShapeAspect ShapeAspectStyle, IfcLengthMeasure LiningToPanelOffsetX, IfcLengthMeasure LiningToPanelOffsetY) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.LiningDepth = LiningDepth;
			this.LiningThickness = LiningThickness;
			this.ThresholdDepth = ThresholdDepth;
			this.ThresholdThickness = ThresholdThickness;
			this.TransomThickness = TransomThickness;
			this.TransomOffset = TransomOffset;
			this.LiningOffset = LiningOffset;
			this.ThresholdOffset = ThresholdOffset;
			this.CasingThickness = CasingThickness;
			this.CasingDepth = CasingDepth;
			this.ShapeAspectStyle = ShapeAspectStyle;
			this.LiningToPanelOffsetX = LiningToPanelOffsetX;
			this.LiningToPanelOffsetY = LiningToPanelOffsetY;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorPanelProperties
	/// <para>ENTITY IfcDoorPanelProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	PanelDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PanelOperation : IfcDoorPanelOperationEnum;</para>
	/// <para>	PanelWidth : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	PanelPosition : IfcDoorPanelPositionEnum;</para>
	/// <para>	ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableToType : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) </para>
	/// <para>AND </para>
	/// <para>(</para>
	/// <para> ('IFC4.IFCDOORTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>  OR</para>
	/// <para> ('IFC4.IFCDOORSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorPanelProperties : IfcPreDefinedPropertySet
	{
		public IfcPositiveLengthMeasure? PanelDepth { get; set; }
		public IfcDoorPanelOperationEnum PanelOperation { get; set; }
		public IfcNormalisedRatioMeasure? PanelWidth { get; set; }
		public IfcDoorPanelPositionEnum PanelPosition { get; set; }
		public IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcDoorPanelProperties() : base()
		{
			PanelOperation = new IfcDoorPanelOperationEnum();
			PanelPosition = new IfcDoorPanelPositionEnum();
		}
		public IfcDoorPanelProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPositiveLengthMeasure PanelDepth, IfcDoorPanelOperationEnum PanelOperation, IfcNormalisedRatioMeasure PanelWidth, IfcDoorPanelPositionEnum PanelPosition, IfcShapeAspect ShapeAspectStyle) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.PanelDepth = PanelDepth;
			this.PanelOperation = PanelOperation;
			this.PanelWidth = PanelWidth;
			this.PanelPosition = PanelPosition;
			this.ShapeAspectStyle = ShapeAspectStyle;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorStandardCase
	/// <para>ENTITY IfcDoorStandardCase</para>
	/// <para> SUBTYPE OF (IfcDoor);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorStandardCase : IfcDoor
	{
		public IfcDoorStandardCase() : base()
		{
		}
		public IfcDoorStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure OverallHeight, IfcPositiveLengthMeasure OverallWidth, IfcDoorTypeEnum PredefinedType, IfcDoorTypeOperationEnum OperationType, IfcLabel UserDefinedOperationType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDoorStyle
	/// <para>ENTITY IfcDoorStyle</para>
	/// <para> SUBTYPE OF (IfcTypeProduct);</para>
	/// <para>	OperationType : IfcDoorStyleOperationEnum;</para>
	/// <para>	ConstructionType : IfcDoorStyleConstructionEnum;</para>
	/// <para>	ParameterTakesPrecedence : IfcBoolean;</para>
	/// <para>	Sizeable : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorStyle : IfcTypeProduct
	{
		public IfcDoorStyleOperationEnum OperationType { get; set; }
		public IfcDoorStyleConstructionEnum ConstructionType { get; set; }
		public IfcBoolean ParameterTakesPrecedence { get; set; }
		public IfcBoolean Sizeable { get; set; }
		public IfcDoorStyle() : base()
		{
			OperationType = new IfcDoorStyleOperationEnum();
			ConstructionType = new IfcDoorStyleConstructionEnum();
			ParameterTakesPrecedence = new IfcBoolean();
			Sizeable = new IfcBoolean();
		}
		public IfcDoorStyle(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcDoorStyleOperationEnum OperationType, IfcDoorStyleConstructionEnum ConstructionType, IfcBoolean ParameterTakesPrecedence, IfcBoolean Sizeable) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.OperationType = OperationType;
			this.ConstructionType = ConstructionType;
			this.ParameterTakesPrecedence = ParameterTakesPrecedence;
			this.Sizeable = Sizeable;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorType
	/// <para>ENTITY IfcDoorType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcDoorTypeEnum;</para>
	/// <para>	OperationType : IfcDoorTypeOperationEnum;</para>
	/// <para>	ParameterTakesPrecedence : OPTIONAL IfcBoolean;</para>
	/// <para>	UserDefinedOperationType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDoorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDoorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorType : IfcBuildingElementType
	{
		public IfcDoorTypeEnum PredefinedType { get; set; }
		public IfcDoorTypeOperationEnum OperationType { get; set; }
		public IfcBoolean? ParameterTakesPrecedence { get; set; }
		public IfcLabel? UserDefinedOperationType { get; set; }
		public IfcDoorType() : base()
		{
			PredefinedType = new IfcDoorTypeEnum();
			OperationType = new IfcDoorTypeOperationEnum();
		}
		public IfcDoorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDoorTypeEnum PredefinedType, IfcDoorTypeOperationEnum OperationType, IfcBoolean ParameterTakesPrecedence, IfcLabel UserDefinedOperationType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.OperationType = OperationType;
			this.ParameterTakesPrecedence = ParameterTakesPrecedence;
			this.UserDefinedOperationType = UserDefinedOperationType;
		}
	}
	/// <summary>
	/// ENTITY IfcDraughtingPreDefinedColour
	/// <para>ENTITY IfcDraughtingPreDefinedColour</para>
	/// <para> SUBTYPE OF (IfcPreDefinedColour);</para>
	/// <para> WHERE</para>
	/// <para>	PreDefinedColourNames : SELF\IfcPreDefinedItem.Name IN ['black','red','green','blue','yellow',</para>
	/// <para>     'magenta','cyan','white','by layer'];</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDraughtingPreDefinedColour : IfcPreDefinedColour
	{
		public IfcDraughtingPreDefinedColour() : base()
		{
		}
		public IfcDraughtingPreDefinedColour(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDraughtingPreDefinedCurveFont
	/// <para>ENTITY IfcDraughtingPreDefinedCurveFont</para>
	/// <para> SUBTYPE OF (IfcPreDefinedCurveFont);</para>
	/// <para> WHERE</para>
	/// <para>	PreDefinedCurveFontNames : SELF\IfcPredefinedItem.Name IN</para>
	/// <para>       ['continuous',</para>
	/// <para>        'chain',</para>
	/// <para>        'chain double dash',</para>
	/// <para>        'dashed',</para>
	/// <para>        'dotted',</para>
	/// <para>        'by layer'];</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDraughtingPreDefinedCurveFont : IfcPreDefinedCurveFont
	{
		public IfcDraughtingPreDefinedCurveFont() : base()
		{
		}
		public IfcDraughtingPreDefinedCurveFont(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDuctFitting
	/// <para>ENTITY IfcDuctFitting</para>
	/// <para> SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDuctFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcDuctFittingTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcDuctFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCDUCTFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctFitting : IfcFlowFitting
	{
		public IfcDuctFittingTypeEnum? PredefinedType { get; set; }
		public IfcDuctFitting() : base()
		{
		}
		public IfcDuctFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDuctFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctFittingType
	/// <para>ENTITY IfcDuctFittingType</para>
	/// <para> SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>	PredefinedType : IfcDuctFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDuctFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDuctFittingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctFittingType : IfcFlowFittingType
	{
		public IfcDuctFittingTypeEnum PredefinedType { get; set; }
		public IfcDuctFittingType() : base()
		{
			PredefinedType = new IfcDuctFittingTypeEnum();
		}
		public IfcDuctFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDuctFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSegment
	/// <para>ENTITY IfcDuctSegment</para>
	/// <para> SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDuctSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcDuctSegmentTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcDuctSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCDUCTSEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSegment : IfcFlowSegment
	{
		public IfcDuctSegmentTypeEnum? PredefinedType { get; set; }
		public IfcDuctSegment() : base()
		{
		}
		public IfcDuctSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDuctSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSegmentType
	/// <para>ENTITY IfcDuctSegmentType</para>
	/// <para> SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>	PredefinedType : IfcDuctSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDuctSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDuctSegmentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSegmentType : IfcFlowSegmentType
	{
		public IfcDuctSegmentTypeEnum PredefinedType { get; set; }
		public IfcDuctSegmentType() : base()
		{
			PredefinedType = new IfcDuctSegmentTypeEnum();
		}
		public IfcDuctSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDuctSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSilencer
	/// <para>ENTITY IfcDuctSilencer</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcDuctSilencerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcDuctSilencerTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcDuctSilencerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCDUCTSILENCERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSilencer : IfcFlowTreatmentDevice
	{
		public IfcDuctSilencerTypeEnum? PredefinedType { get; set; }
		public IfcDuctSilencer() : base()
		{
		}
		public IfcDuctSilencer(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDuctSilencerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSilencerType
	/// <para>ENTITY IfcDuctSilencerType</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDeviceType);</para>
	/// <para>	PredefinedType : IfcDuctSilencerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcDuctSilencerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDuctSilencerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSilencerType : IfcFlowTreatmentDeviceType
	{
		public IfcDuctSilencerTypeEnum PredefinedType { get; set; }
		public IfcDuctSilencerType() : base()
		{
			PredefinedType = new IfcDuctSilencerTypeEnum();
		}
		public IfcDuctSilencerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDuctSilencerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEdge
	/// <para>ENTITY IfcEdge</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcEdgeCurve</para>
	/// <para>    ,IfcOrientedEdge</para>
	/// <para>    ,IfcSubedge))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>	EdgeStart : IfcVertex;</para>
	/// <para>	EdgeEnd : IfcVertex;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEdge : IfcTopologicalRepresentationItem
	{
		public IfcVertex EdgeStart { get; set; }
		public IfcVertex EdgeEnd { get; set; }
		public IfcEdge() : base()
		{
			EdgeStart = new IfcVertex();
			EdgeEnd = new IfcVertex();
		}
		public IfcEdge(IfcVertex EdgeStart, IfcVertex EdgeEnd) : base ()
		{
			this.EdgeStart = EdgeStart;
			this.EdgeEnd = EdgeEnd;
		}
	}
	/// <summary>
	/// ENTITY IfcEdgeCurve
	/// <para>ENTITY IfcEdgeCurve</para>
	/// <para> SUBTYPE OF (IfcEdge);</para>
	/// <para>	EdgeGeometry : IfcCurve;</para>
	/// <para>	SameSense : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEdgeCurve : IfcEdge, IfcCurveOrEdgeCurve
	{
		public IfcCurve EdgeGeometry { get; set; }
		public IfcBoolean SameSense { get; set; }
		public IfcEdgeCurve() : base()
		{
			EdgeGeometry = new IfcCurve();
			SameSense = new IfcBoolean();
		}
		public IfcEdgeCurve(IfcVertex EdgeStart, IfcVertex EdgeEnd, IfcCurve EdgeGeometry, IfcBoolean SameSense) : base (EdgeStart, EdgeEnd)
		{
			this.EdgeGeometry = EdgeGeometry;
			this.SameSense = SameSense;
		}
	}
	/// <summary>
	/// ENTITY IfcEdgeLoop
	/// <para>ENTITY IfcEdgeLoop</para>
	/// <para> SUBTYPE OF (IfcLoop);</para>
	/// <para>	EdgeList : LIST [1:?] OF IfcOrientedEdge;</para>
	/// <para> DERIVE</para>
	/// <para>	Ne : IfcInteger := SIZEOF(EdgeList);</para>
	/// <para> WHERE</para>
	/// <para>	IsClosed : (EdgeList[1].EdgeStart) :=: (EdgeList[Ne].EdgeEnd);</para>
	/// <para>	IsContinuous : IfcLoopHeadToTail(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEdgeLoop : IfcLoop
	{
		public List<IfcOrientedEdge> EdgeList { get; set; }
		public IfcEdgeLoop() : base()
		{
			EdgeList = new List<IfcOrientedEdge>();
		}
		public IfcEdgeLoop(List<IfcOrientedEdge> EdgeList) : base ()
		{
			this.EdgeList = EdgeList;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricAppliance
	/// <para>ENTITY IfcElectricAppliance</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcElectricApplianceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcElectricApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCELECTRICAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricAppliance : IfcFlowTerminal
	{
		public IfcElectricApplianceTypeEnum? PredefinedType { get; set; }
		public IfcElectricAppliance() : base()
		{
		}
		public IfcElectricAppliance(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricApplianceType
	/// <para>ENTITY IfcElectricApplianceType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcElectricApplianceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricApplianceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricApplianceType : IfcFlowTerminalType
	{
		public IfcElectricApplianceTypeEnum PredefinedType { get; set; }
		public IfcElectricApplianceType() : base()
		{
			PredefinedType = new IfcElectricApplianceTypeEnum();
		}
		public IfcElectricApplianceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricDistributionBoard
	/// <para>ENTITY IfcElectricDistributionBoard</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricDistributionBoardTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcElectricDistributionBoardTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcElectricDistributionBoardTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCELECTRICDISTRIBUTIONBOARDTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricDistributionBoard : IfcFlowController
	{
		public IfcElectricDistributionBoardTypeEnum? PredefinedType { get; set; }
		public IfcElectricDistributionBoard() : base()
		{
		}
		public IfcElectricDistributionBoard(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricDistributionBoardTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricDistributionBoardType
	/// <para>ENTITY IfcElectricDistributionBoardType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcElectricDistributionBoardTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricDistributionBoardTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricDistributionBoardTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricDistributionBoardType : IfcFlowControllerType
	{
		public IfcElectricDistributionBoardTypeEnum PredefinedType { get; set; }
		public IfcElectricDistributionBoardType() : base()
		{
			PredefinedType = new IfcElectricDistributionBoardTypeEnum();
		}
		public IfcElectricDistributionBoardType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricDistributionBoardTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricFlowStorageDevice
	/// <para>ENTITY IfcElectricFlowStorageDevice</para>
	/// <para> SUBTYPE OF (IfcFlowStorageDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricFlowStorageDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCELECTRICFLOWSTORAGEDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricFlowStorageDevice : IfcFlowStorageDevice
	{
		public IfcElectricFlowStorageDeviceTypeEnum? PredefinedType { get; set; }
		public IfcElectricFlowStorageDevice() : base()
		{
		}
		public IfcElectricFlowStorageDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricFlowStorageDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricFlowStorageDeviceType
	/// <para>ENTITY IfcElectricFlowStorageDeviceType</para>
	/// <para> SUBTYPE OF (IfcFlowStorageDeviceType);</para>
	/// <para>	PredefinedType : IfcElectricFlowStorageDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricFlowStorageDeviceType : IfcFlowStorageDeviceType
	{
		public IfcElectricFlowStorageDeviceTypeEnum PredefinedType { get; set; }
		public IfcElectricFlowStorageDeviceType() : base()
		{
			PredefinedType = new IfcElectricFlowStorageDeviceTypeEnum();
		}
		public IfcElectricFlowStorageDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricFlowStorageDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricGenerator
	/// <para>ENTITY IfcElectricGenerator</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricGeneratorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcElectricGeneratorTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcElectricGeneratorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCELECTRICGENERATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricGenerator : IfcEnergyConversionDevice
	{
		public IfcElectricGeneratorTypeEnum? PredefinedType { get; set; }
		public IfcElectricGenerator() : base()
		{
		}
		public IfcElectricGenerator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricGeneratorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricGeneratorType
	/// <para>ENTITY IfcElectricGeneratorType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcElectricGeneratorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricGeneratorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricGeneratorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricGeneratorType : IfcEnergyConversionDeviceType
	{
		public IfcElectricGeneratorTypeEnum PredefinedType { get; set; }
		public IfcElectricGeneratorType() : base()
		{
			PredefinedType = new IfcElectricGeneratorTypeEnum();
		}
		public IfcElectricGeneratorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricGeneratorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricMotor
	/// <para>ENTITY IfcElectricMotor</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricMotorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcElectricMotorTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcElectricMotorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCELECTRICMOTORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricMotor : IfcEnergyConversionDevice
	{
		public IfcElectricMotorTypeEnum? PredefinedType { get; set; }
		public IfcElectricMotor() : base()
		{
		}
		public IfcElectricMotor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricMotorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricMotorType
	/// <para>ENTITY IfcElectricMotorType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcElectricMotorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricMotorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricMotorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricMotorType : IfcEnergyConversionDeviceType
	{
		public IfcElectricMotorTypeEnum PredefinedType { get; set; }
		public IfcElectricMotorType() : base()
		{
			PredefinedType = new IfcElectricMotorTypeEnum();
		}
		public IfcElectricMotorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricMotorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricTimeControl
	/// <para>ENTITY IfcElectricTimeControl</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcElectricTimeControlTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcElectricTimeControlTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcElectricTimeControlTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCELECTRICTIMECONTROLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricTimeControl : IfcFlowController
	{
		public IfcElectricTimeControlTypeEnum? PredefinedType { get; set; }
		public IfcElectricTimeControl() : base()
		{
		}
		public IfcElectricTimeControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricTimeControlTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricTimeControlType
	/// <para>ENTITY IfcElectricTimeControlType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcElectricTimeControlTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElectricTimeControlTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricTimeControlTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricTimeControlType : IfcFlowControllerType
	{
		public IfcElectricTimeControlTypeEnum PredefinedType { get; set; }
		public IfcElectricTimeControlType() : base()
		{
			PredefinedType = new IfcElectricTimeControlTypeEnum();
		}
		public IfcElectricTimeControlType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricTimeControlTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElement
	/// <para>ENTITY IfcElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBuildingElement</para>
	/// <para>    ,IfcCivilElement</para>
	/// <para>    ,IfcDistributionElement</para>
	/// <para>    ,IfcElementAssembly</para>
	/// <para>    ,IfcElementComponent</para>
	/// <para>    ,IfcFeatureElement</para>
	/// <para>    ,IfcFurnishingElement</para>
	/// <para>    ,IfcGeographicElement</para>
	/// <para>    ,IfcTransportElement</para>
	/// <para>    ,IfcVirtualElement))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para>	Tag : OPTIONAL IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	FillsVoids : SET [0:1] OF IfcRelFillsElement FOR RelatedBuildingElement;</para>
	/// <para>	ConnectedTo : SET [0:?] OF IfcRelConnectsElements FOR RelatingElement;</para>
	/// <para>	IsInterferedByElements : SET [0:?] OF IfcRelInterferesElements FOR RelatedElement;</para>
	/// <para>	InterferesElements : SET [0:?] OF IfcRelInterferesElements FOR RelatingElement;</para>
	/// <para>	HasProjections : SET [0:?] OF IfcRelProjectsElement FOR RelatingElement;</para>
	/// <para>	ReferencedInStructures : SET [0:?] OF IfcRelReferencedInSpatialStructure FOR RelatedElements;</para>
	/// <para>	HasOpenings : SET [0:?] OF IfcRelVoidsElement FOR RelatingBuildingElement;</para>
	/// <para>	IsConnectionRealization : SET [0:?] OF IfcRelConnectsWithRealizingElements FOR RealizingElements;</para>
	/// <para>	ProvidesBoundaries : SET [0:?] OF IfcRelSpaceBoundary FOR RelatedBuildingElement;</para>
	/// <para>	ConnectedFrom : SET [0:?] OF IfcRelConnectsElements FOR RelatedElement;</para>
	/// <para>	ContainedInStructure : SET [0:1] OF IfcRelContainedInSpatialStructure FOR RelatedElements;</para>
	/// <para>	HasCoverings : SET [0:?] OF IfcRelCoversBldgElements FOR RelatingBuildingElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElement : IfcProduct, IfcStructuralActivityAssignmentSelect
	{
		public IfcIdentifier? Tag { get; set; }
		public IfcElement() : base()
		{
		}
		public IfcElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.Tag = Tag;
		}
	}
	/// <summary>
	/// ENTITY IfcElementAssembly
	/// <para>ENTITY IfcElementAssembly</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>	AssemblyPlace : OPTIONAL IfcAssemblyPlaceEnum;</para>
	/// <para>	PredefinedType : OPTIONAL IfcElementAssemblyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcElementAssemblyTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcElementAssemblyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCELEMENTASSEMBLYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElementAssembly : IfcElement
	{
		public IfcAssemblyPlaceEnum? AssemblyPlace { get; set; }
		public IfcElementAssemblyTypeEnum? PredefinedType { get; set; }
		public IfcElementAssembly() : base()
		{
		}
		public IfcElementAssembly(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAssemblyPlaceEnum AssemblyPlace, IfcElementAssemblyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.AssemblyPlace = AssemblyPlace;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElementAssemblyType
	/// <para>ENTITY IfcElementAssemblyType</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>	PredefinedType : IfcElementAssemblyTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcElementAssemblyTypeEnum.USERDEFINED) OR </para>
	/// <para>((PredefinedType = IfcElementAssemblyTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElementAssemblyType : IfcElementType
	{
		public IfcElementAssemblyTypeEnum PredefinedType { get; set; }
		public IfcElementAssemblyType() : base()
		{
			PredefinedType = new IfcElementAssemblyTypeEnum();
		}
		public IfcElementAssemblyType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElementAssemblyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElementComponent
	/// <para>ENTITY IfcElementComponent</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBuildingElementPart</para>
	/// <para>    ,IfcDiscreteAccessory</para>
	/// <para>    ,IfcFastener</para>
	/// <para>    ,IfcMechanicalFastener</para>
	/// <para>    ,IfcReinforcingElement</para>
	/// <para>    ,IfcVibrationIsolator))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementComponent : IfcElement
	{
		public IfcElementComponent() : base()
		{
		}
		public IfcElementComponent(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcElementComponentType
	/// <para>ENTITY IfcElementComponentType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBuildingElementPartType</para>
	/// <para>    ,IfcDiscreteAccessoryType</para>
	/// <para>    ,IfcFastenerType</para>
	/// <para>    ,IfcMechanicalFastenerType</para>
	/// <para>    ,IfcReinforcingElementType</para>
	/// <para>    ,IfcVibrationIsolatorType))</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementComponentType : IfcElementType
	{
		public IfcElementComponentType() : base()
		{
		}
		public IfcElementComponentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcElementQuantity
	/// <para>ENTITY IfcElementQuantity</para>
	/// <para> SUBTYPE OF (IfcQuantitySet);</para>
	/// <para>	MethodOfMeasurement : OPTIONAL IfcLabel;</para>
	/// <para>	Quantities : SET [1:?] OF IfcPhysicalQuantity;</para>
	/// <para> WHERE</para>
	/// <para>	UniqueQuantityNames : IfcUniqueQuantityNames(Quantities);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElementQuantity : IfcQuantitySet
	{
		public IfcLabel? MethodOfMeasurement { get; set; }
		public List<IfcPhysicalQuantity> Quantities { get; set; }
		public IfcElementQuantity() : base()
		{
			Quantities = new List<IfcPhysicalQuantity>();
		}
		public IfcElementQuantity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel MethodOfMeasurement, List<IfcPhysicalQuantity> Quantities) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.MethodOfMeasurement = MethodOfMeasurement;
			this.Quantities = Quantities;
		}
	}
	/// <summary>
	/// ENTITY IfcElementType
	/// <para>ENTITY IfcElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBuildingElementType</para>
	/// <para>    ,IfcCivilElementType</para>
	/// <para>    ,IfcDistributionElementType</para>
	/// <para>    ,IfcElementAssemblyType</para>
	/// <para>    ,IfcElementComponentType</para>
	/// <para>    ,IfcFurnishingElementType</para>
	/// <para>    ,IfcGeographicElementType</para>
	/// <para>    ,IfcTransportElementType))</para>
	/// <para> SUBTYPE OF (IfcTypeProduct);</para>
	/// <para>	ElementType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementType : IfcTypeProduct
	{
		public IfcLabel? ElementType { get; set; }
		public IfcElementType() : base()
		{
		}
		public IfcElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.ElementType = ElementType;
		}
	}
	/// <summary>
	/// ENTITY IfcElementarySurface
	/// <para>ENTITY IfcElementarySurface</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCylindricalSurface</para>
	/// <para>    ,IfcPlane</para>
	/// <para>    ,IfcSphericalSurface</para>
	/// <para>    ,IfcToroidalSurface))</para>
	/// <para> SUBTYPE OF (IfcSurface);</para>
	/// <para>	Position : IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementarySurface : IfcSurface
	{
		public IfcAxis2Placement3D Position { get; set; }
		public IfcElementarySurface() : base()
		{
			Position = new IfcAxis2Placement3D();
		}
		public IfcElementarySurface(IfcAxis2Placement3D Position) : base ()
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcEllipse
	/// <para>ENTITY IfcEllipse</para>
	/// <para> SUBTYPE OF (IfcConic);</para>
	/// <para>	SemiAxis1 : IfcPositiveLengthMeasure;</para>
	/// <para>	SemiAxis2 : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEllipse : IfcConic
	{
		public IfcPositiveLengthMeasure SemiAxis1 { get; set; }
		public IfcPositiveLengthMeasure SemiAxis2 { get; set; }
		public IfcEllipse() : base()
		{
			SemiAxis1 = new IfcPositiveLengthMeasure();
			SemiAxis2 = new IfcPositiveLengthMeasure();
		}
		public IfcEllipse(IfcAxis2Placement Position, IfcPositiveLengthMeasure SemiAxis1, IfcPositiveLengthMeasure SemiAxis2) : base (Position)
		{
			this.SemiAxis1 = SemiAxis1;
			this.SemiAxis2 = SemiAxis2;
		}
	}
	/// <summary>
	/// ENTITY IfcEllipseProfileDef
	/// <para>ENTITY IfcEllipseProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	SemiAxis1 : IfcPositiveLengthMeasure;</para>
	/// <para>	SemiAxis2 : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEllipseProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure SemiAxis1 { get; set; }
		public IfcPositiveLengthMeasure SemiAxis2 { get; set; }
		public IfcEllipseProfileDef() : base()
		{
			SemiAxis1 = new IfcPositiveLengthMeasure();
			SemiAxis2 = new IfcPositiveLengthMeasure();
		}
		public IfcEllipseProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure SemiAxis1, IfcPositiveLengthMeasure SemiAxis2) : base (ProfileType, ProfileName, Position)
		{
			this.SemiAxis1 = SemiAxis1;
			this.SemiAxis2 = SemiAxis2;
		}
	}
	/// <summary>
	/// ENTITY IfcEnergyConversionDevice
	/// <para>ENTITY IfcEnergyConversionDevice</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAirToAirHeatRecovery</para>
	/// <para>    ,IfcBoiler</para>
	/// <para>    ,IfcBurner</para>
	/// <para>    ,IfcChiller</para>
	/// <para>    ,IfcCoil</para>
	/// <para>    ,IfcCondenser</para>
	/// <para>    ,IfcCooledBeam</para>
	/// <para>    ,IfcCoolingTower</para>
	/// <para>    ,IfcElectricGenerator</para>
	/// <para>    ,IfcElectricMotor</para>
	/// <para>    ,IfcEngine</para>
	/// <para>    ,IfcEvaporativeCooler</para>
	/// <para>    ,IfcEvaporator</para>
	/// <para>    ,IfcHeatExchanger</para>
	/// <para>    ,IfcHumidifier</para>
	/// <para>    ,IfcMotorConnection</para>
	/// <para>    ,IfcSolarDevice</para>
	/// <para>    ,IfcTransformer</para>
	/// <para>    ,IfcTubeBundle</para>
	/// <para>    ,IfcUnitaryEquipment))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEnergyConversionDevice : IfcDistributionFlowElement
	{
		public IfcEnergyConversionDevice() : base()
		{
		}
		public IfcEnergyConversionDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcEnergyConversionDeviceType
	/// <para>ENTITY IfcEnergyConversionDeviceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAirToAirHeatRecoveryType</para>
	/// <para>    ,IfcBoilerType</para>
	/// <para>    ,IfcBurnerType</para>
	/// <para>    ,IfcChillerType</para>
	/// <para>    ,IfcCoilType</para>
	/// <para>    ,IfcCondenserType</para>
	/// <para>    ,IfcCooledBeamType</para>
	/// <para>    ,IfcCoolingTowerType</para>
	/// <para>    ,IfcElectricGeneratorType</para>
	/// <para>    ,IfcElectricMotorType</para>
	/// <para>    ,IfcEngineType</para>
	/// <para>    ,IfcEvaporativeCoolerType</para>
	/// <para>    ,IfcEvaporatorType</para>
	/// <para>    ,IfcHeatExchangerType</para>
	/// <para>    ,IfcHumidifierType</para>
	/// <para>    ,IfcMotorConnectionType</para>
	/// <para>    ,IfcSolarDeviceType</para>
	/// <para>    ,IfcTransformerType</para>
	/// <para>    ,IfcTubeBundleType</para>
	/// <para>    ,IfcUnitaryEquipmentType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcEnergyConversionDeviceType : IfcDistributionFlowElementType
	{
		public IfcEnergyConversionDeviceType() : base()
		{
		}
		public IfcEnergyConversionDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcEngine
	/// <para>ENTITY IfcEngine</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcEngineTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcEngineTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcEngineTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>('IFC4.IFCENGINETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEngine : IfcEnergyConversionDevice
	{
		public IfcEngineTypeEnum? PredefinedType { get; set; }
		public IfcEngine() : base()
		{
		}
		public IfcEngine(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEngineTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEngineType
	/// <para>ENTITY IfcEngineType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcEngineTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcEngineTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcEngineTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEngineType : IfcEnergyConversionDeviceType
	{
		public IfcEngineTypeEnum PredefinedType { get; set; }
		public IfcEngineType() : base()
		{
			PredefinedType = new IfcEngineTypeEnum();
		}
		public IfcEngineType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcEngineTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporativeCooler
	/// <para>ENTITY IfcEvaporativeCooler</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcEvaporativeCoolerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcEvaporativeCoolerTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcEvaporativeCoolerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCEVAPORATIVECOOLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporativeCooler : IfcEnergyConversionDevice
	{
		public IfcEvaporativeCoolerTypeEnum? PredefinedType { get; set; }
		public IfcEvaporativeCooler() : base()
		{
		}
		public IfcEvaporativeCooler(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEvaporativeCoolerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporativeCoolerType
	/// <para>ENTITY IfcEvaporativeCoolerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcEvaporativeCoolerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcEvaporativeCoolerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcEvaporativeCoolerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporativeCoolerType : IfcEnergyConversionDeviceType
	{
		public IfcEvaporativeCoolerTypeEnum PredefinedType { get; set; }
		public IfcEvaporativeCoolerType() : base()
		{
			PredefinedType = new IfcEvaporativeCoolerTypeEnum();
		}
		public IfcEvaporativeCoolerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcEvaporativeCoolerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporator
	/// <para>ENTITY IfcEvaporator</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcEvaporatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcEvaporatorTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcEvaporatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCEVAPORATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporator : IfcEnergyConversionDevice
	{
		public IfcEvaporatorTypeEnum? PredefinedType { get; set; }
		public IfcEvaporator() : base()
		{
		}
		public IfcEvaporator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEvaporatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporatorType
	/// <para>ENTITY IfcEvaporatorType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcEvaporatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcEvaporatorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcEvaporatorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporatorType : IfcEnergyConversionDeviceType
	{
		public IfcEvaporatorTypeEnum PredefinedType { get; set; }
		public IfcEvaporatorType() : base()
		{
			PredefinedType = new IfcEvaporatorTypeEnum();
		}
		public IfcEvaporatorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcEvaporatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvent
	/// <para>ENTITY IfcEvent</para>
	/// <para> SUBTYPE OF (IfcProcess);</para>
	/// <para>	PredefinedType : OPTIONAL IfcEventTypeEnum;</para>
	/// <para>	EventTriggerType : OPTIONAL IfcEventTriggerTypeEnum;</para>
	/// <para>	UserDefinedEventTriggerType : OPTIONAL IfcLabel;</para>
	/// <para>	EventOccurenceTime : OPTIONAL IfcEventTime;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcEventTypeEnum.USERDEFINED) OR ((PredefinedType = IfcEventTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : NOT(EXISTS(EventTriggerType)) OR (EventTriggerType <> IfcEventTriggerTypeEnum.USERDEFINED) OR ((EventTriggerType = IfcEventTriggerTypeEnum.USERDEFINED) AND EXISTS(UserDefinedEventTriggerType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvent : IfcProcess
	{
		public IfcEventTypeEnum? PredefinedType { get; set; }
		public IfcEventTriggerTypeEnum? EventTriggerType { get; set; }
		public IfcLabel? UserDefinedEventTriggerType { get; set; }
		public IfcEventTime? EventOccurenceTime { get; set; }
		public IfcEvent() : base()
		{
		}
		public IfcEvent(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcEventTypeEnum PredefinedType, IfcEventTriggerTypeEnum EventTriggerType, IfcLabel UserDefinedEventTriggerType, IfcEventTime EventOccurenceTime) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.PredefinedType = PredefinedType;
			this.EventTriggerType = EventTriggerType;
			this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
			this.EventOccurenceTime = EventOccurenceTime;
		}
	}
	/// <summary>
	/// ENTITY IfcEventTime
	/// <para>ENTITY IfcEventTime</para>
	/// <para> SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>	ActualDate : OPTIONAL IfcDateTime;</para>
	/// <para>	EarlyDate : OPTIONAL IfcDateTime;</para>
	/// <para>	LateDate : OPTIONAL IfcDateTime;</para>
	/// <para>	ScheduleDate : OPTIONAL IfcDateTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEventTime : IfcSchedulingTime
	{
		public IfcDateTime? ActualDate { get; set; }
		public IfcDateTime? EarlyDate { get; set; }
		public IfcDateTime? LateDate { get; set; }
		public IfcDateTime? ScheduleDate { get; set; }
		public IfcEventTime() : base()
		{
		}
		public IfcEventTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcDateTime ActualDate, IfcDateTime EarlyDate, IfcDateTime LateDate, IfcDateTime ScheduleDate) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.ActualDate = ActualDate;
			this.EarlyDate = EarlyDate;
			this.LateDate = LateDate;
			this.ScheduleDate = ScheduleDate;
		}
	}
	/// <summary>
	/// ENTITY IfcEventType
	/// <para>ENTITY IfcEventType</para>
	/// <para> SUBTYPE OF (IfcTypeProcess);</para>
	/// <para>	PredefinedType : IfcEventTypeEnum;</para>
	/// <para>	EventTriggerType : IfcEventTriggerTypeEnum;</para>
	/// <para>	UserDefinedEventTriggerType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcEventTypeEnum.USERDEFINED) OR ((PredefinedType = IfcEventTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType));</para>
	/// <para>	CorrectEventTriggerType : (EventTriggerType <> IfcEventTriggerTypeEnum.USERDEFINED) OR ((EventTriggerType = IfcEventTriggerTypeEnum.USERDEFINED) AND EXISTS(UserDefinedEventTriggerType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEventType : IfcTypeProcess
	{
		public IfcEventTypeEnum PredefinedType { get; set; }
		public IfcEventTriggerTypeEnum EventTriggerType { get; set; }
		public IfcLabel? UserDefinedEventTriggerType { get; set; }
		public IfcEventType() : base()
		{
			PredefinedType = new IfcEventTypeEnum();
			EventTriggerType = new IfcEventTriggerTypeEnum();
		}
		public IfcEventType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType, IfcEventTypeEnum PredefinedType, IfcEventTriggerTypeEnum EventTriggerType, IfcLabel UserDefinedEventTriggerType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType)
		{
			this.PredefinedType = PredefinedType;
			this.EventTriggerType = EventTriggerType;
			this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
		}
	}
	/// <summary>
	/// ENTITY IfcExtendedProperties
	/// <para>ENTITY IfcExtendedProperties</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMaterialProperties</para>
	/// <para>    ,IfcProfileProperties))</para>
	/// <para> SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>	Name : OPTIONAL IfcIdentifier;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Properties : SET [1:?] OF IfcProperty;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExtendedProperties : IfcPropertyAbstraction
	{
		public IfcIdentifier? Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcProperty> Properties { get; set; }
		public IfcExtendedProperties() : base()
		{
			Properties = new List<IfcProperty>();
		}
		public IfcExtendedProperties(IfcIdentifier Name, IfcText Description, List<IfcProperty> Properties) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Properties = Properties;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalInformation
	/// <para>ENTITY IfcExternalInformation</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcClassification</para>
	/// <para>    ,IfcDocumentInformation</para>
	/// <para>    ,IfcLibraryInformation));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExternalInformation : ENTITY, IfcResourceObjectSelect
	{
		public IfcExternalInformation() : base()
		{
		}
		public IfcExternalInformation() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternalReference
	/// <para>ENTITY IfcExternalReference</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcClassificationReference</para>
	/// <para>    ,IfcDocumentReference</para>
	/// <para>    ,IfcExternallyDefinedHatchStyle</para>
	/// <para>    ,IfcExternallyDefinedSurfaceStyle</para>
	/// <para>    ,IfcExternallyDefinedTextFont</para>
	/// <para>    ,IfcLibraryReference));</para>
	/// <para>	Location : OPTIONAL IfcURIReference;</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ExternalReferenceForResources : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatingReference;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : EXISTS(Identification) OR EXISTS(Location) OR EXISTS(Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExternalReference : ENTITY, IfcLightDistributionDataSourceSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcURIReference? Location { get; set; }
		public IfcIdentifier? Identification { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcExternalReference() : base()
		{
		}
		public IfcExternalReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base ()
		{
			this.Location = Location;
			this.Identification = Identification;
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalReferenceRelationship
	/// <para>ENTITY IfcExternalReferenceRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingReference : IfcExternalReference;</para>
	/// <para>	RelatedResourceObjects : SET [1:?] OF IfcResourceObjectSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternalReferenceRelationship : IfcResourceLevelRelationship
	{
		public IfcExternalReference RelatingReference { get; set; }
		public List<IfcResourceObjectSelect> RelatedResourceObjects { get; set; }
		public IfcExternalReferenceRelationship() : base()
		{
			RelatingReference = new IfcExternalReference();
			RelatedResourceObjects = new List<IfcResourceObjectSelect>();
		}
		public IfcExternalReferenceRelationship(IfcLabel Name, IfcText Description, IfcExternalReference RelatingReference, List<IfcResourceObjectSelect> RelatedResourceObjects) : base (Name, Description)
		{
			this.RelatingReference = RelatingReference;
			this.RelatedResourceObjects = RelatedResourceObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalSpatialElement
	/// <para>ENTITY IfcExternalSpatialElement</para>
	/// <para> SUBTYPE OF (IfcExternalSpatialStructureElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcExternalSpatialElementTypeEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	BoundedBy : SET [0:?] OF IfcRelSpaceBoundary FOR RelatingSpace;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternalSpatialElement : IfcExternalSpatialStructureElement, IfcSpaceBoundarySelect
	{
		public IfcExternalSpatialElementTypeEnum? PredefinedType { get; set; }
		public IfcExternalSpatialElement() : base()
		{
		}
		public IfcExternalSpatialElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcExternalSpatialElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalSpatialStructureElement
	/// <para>ENTITY IfcExternalSpatialStructureElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcExternalSpatialElement))</para>
	/// <para> SUBTYPE OF (IfcSpatialElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExternalSpatialStructureElement : IfcSpatialElement
	{
		public IfcExternalSpatialStructureElement() : base()
		{
		}
		public IfcExternalSpatialStructureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternallyDefinedHatchStyle
	/// <para>ENTITY IfcExternallyDefinedHatchStyle</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternallyDefinedHatchStyle : IfcExternalReference, IfcFillStyleSelect
	{
		public IfcExternallyDefinedHatchStyle() : base()
		{
		}
		public IfcExternallyDefinedHatchStyle(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base (Location, Identification, Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternallyDefinedSurfaceStyle
	/// <para>ENTITY IfcExternallyDefinedSurfaceStyle</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternallyDefinedSurfaceStyle : IfcExternalReference, IfcSurfaceStyleElementSelect
	{
		public IfcExternallyDefinedSurfaceStyle() : base()
		{
		}
		public IfcExternallyDefinedSurfaceStyle(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base (Location, Identification, Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternallyDefinedTextFont
	/// <para>ENTITY IfcExternallyDefinedTextFont</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternallyDefinedTextFont : IfcExternalReference, IfcTextFontSelect
	{
		public IfcExternallyDefinedTextFont() : base()
		{
		}
		public IfcExternallyDefinedTextFont(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base (Location, Identification, Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExtrudedAreaSolid
	/// <para>ENTITY IfcExtrudedAreaSolid</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcExtrudedAreaSolidTapered))</para>
	/// <para> SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>	ExtrudedDirection : IfcDirection;</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidExtrusionDirection : IfcDotProduct(IfcRepresentationItem() || IfcGeometricRepresentationItem() || IfcDirection([0.0,0.0,1.0]), SELF.ExtrudedDirection) <> 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExtrudedAreaSolid : IfcSweptAreaSolid
	{
		public IfcDirection ExtrudedDirection { get; set; }
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcExtrudedAreaSolid() : base()
		{
			ExtrudedDirection = new IfcDirection();
			Depth = new IfcPositiveLengthMeasure();
		}
		public IfcExtrudedAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcDirection ExtrudedDirection, IfcPositiveLengthMeasure Depth) : base (SweptArea, Position)
		{
			this.ExtrudedDirection = ExtrudedDirection;
			this.Depth = Depth;
		}
	}
	/// <summary>
	/// ENTITY IfcExtrudedAreaSolidTapered
	/// <para>ENTITY IfcExtrudedAreaSolidTapered</para>
	/// <para> SUBTYPE OF (IfcExtrudedAreaSolid);</para>
	/// <para>	EndSweptArea : IfcProfileDef;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectProfileAssignment : IfcTaperedSweptAreaProfiles(SELF\IfcSweptAreaSolid.SweptArea, SELF.EndSweptArea);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExtrudedAreaSolidTapered : IfcExtrudedAreaSolid
	{
		public IfcProfileDef EndSweptArea { get; set; }
		public IfcExtrudedAreaSolidTapered() : base()
		{
			EndSweptArea = new IfcProfileDef();
		}
		public IfcExtrudedAreaSolidTapered(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcDirection ExtrudedDirection, IfcPositiveLengthMeasure Depth, IfcProfileDef EndSweptArea) : base (SweptArea, Position, ExtrudedDirection, Depth)
		{
			this.EndSweptArea = EndSweptArea;
		}
	}
	/// <summary>
	/// ENTITY IfcFace
	/// <para>ENTITY IfcFace</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcFaceSurface))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>	Bounds : SET [1:?] OF IfcFaceBound;</para>
	/// <para> INVERSE</para>
	/// <para>	HasTextureMaps : SET [0:?] OF IfcTextureMap FOR MappedTo;</para>
	/// <para> WHERE</para>
	/// <para>	HasOuterBound : SIZEOF(QUERY(temp <* Bounds | 'IFC4.IFCFACEOUTERBOUND' IN TYPEOF(temp))) <= 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFace : IfcTopologicalRepresentationItem
	{
		public List<IfcFaceBound> Bounds { get; set; }
		public IfcFace() : base()
		{
			Bounds = new List<IfcFaceBound>();
		}
		public IfcFace(List<IfcFaceBound> Bounds) : base ()
		{
			this.Bounds = Bounds;
		}
	}
	/// <summary>
	/// ENTITY IfcFaceBasedSurfaceModel
	/// <para>ENTITY IfcFaceBasedSurfaceModel</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	FbsmFaces : SET [1:?] OF IfcConnectedFaceSet;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceBasedSurfaceModel : IfcGeometricRepresentationItem, IfcSurfaceOrFaceSurface
	{
		public List<IfcConnectedFaceSet> FbsmFaces { get; set; }
		public IfcFaceBasedSurfaceModel() : base()
		{
			FbsmFaces = new List<IfcConnectedFaceSet>();
		}
		public IfcFaceBasedSurfaceModel(List<IfcConnectedFaceSet> FbsmFaces) : base ()
		{
			this.FbsmFaces = FbsmFaces;
		}
	}
	/// <summary>
	/// ENTITY IfcFaceBound
	/// <para>ENTITY IfcFaceBound</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcFaceOuterBound))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>	Bound : IfcLoop;</para>
	/// <para>	Orientation : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceBound : IfcTopologicalRepresentationItem
	{
		public IfcLoop Bound { get; set; }
		public IfcBoolean Orientation { get; set; }
		public IfcFaceBound() : base()
		{
			Bound = new IfcLoop();
			Orientation = new IfcBoolean();
		}
		public IfcFaceBound(IfcLoop Bound, IfcBoolean Orientation) : base ()
		{
			this.Bound = Bound;
			this.Orientation = Orientation;
		}
	}
	/// <summary>
	/// ENTITY IfcFaceOuterBound
	/// <para>ENTITY IfcFaceOuterBound</para>
	/// <para> SUBTYPE OF (IfcFaceBound);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceOuterBound : IfcFaceBound
	{
		public IfcFaceOuterBound() : base()
		{
		}
		public IfcFaceOuterBound(IfcLoop Bound, IfcBoolean Orientation) : base (Bound, Orientation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFaceSurface
	/// <para>ENTITY IfcFaceSurface</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAdvancedFace))</para>
	/// <para> SUBTYPE OF (IfcFace);</para>
	/// <para>	FaceSurface : IfcSurface;</para>
	/// <para>	SameSense : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceSurface : IfcFace, IfcSurfaceOrFaceSurface
	{
		public IfcSurface FaceSurface { get; set; }
		public IfcBoolean SameSense { get; set; }
		public IfcFaceSurface() : base()
		{
			FaceSurface = new IfcSurface();
			SameSense = new IfcBoolean();
		}
		public IfcFaceSurface(List<IfcFaceBound> Bounds, IfcSurface FaceSurface, IfcBoolean SameSense) : base (Bounds)
		{
			this.FaceSurface = FaceSurface;
			this.SameSense = SameSense;
		}
	}
	/// <summary>
	/// ENTITY IfcFacetedBrep
	/// <para>ENTITY IfcFacetedBrep</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcFacetedBrepWithVoids))</para>
	/// <para> SUBTYPE OF (IfcManifoldSolidBrep);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFacetedBrep : IfcManifoldSolidBrep
	{
		public IfcFacetedBrep() : base()
		{
		}
		public IfcFacetedBrep(IfcClosedShell Outer) : base (Outer)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFacetedBrepWithVoids
	/// <para>ENTITY IfcFacetedBrepWithVoids</para>
	/// <para> SUBTYPE OF (IfcFacetedBrep);</para>
	/// <para>	Voids : SET [1:?] OF IfcClosedShell;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFacetedBrepWithVoids : IfcFacetedBrep
	{
		public List<IfcClosedShell> Voids { get; set; }
		public IfcFacetedBrepWithVoids() : base()
		{
			Voids = new List<IfcClosedShell>();
		}
		public IfcFacetedBrepWithVoids(IfcClosedShell Outer, List<IfcClosedShell> Voids) : base (Outer)
		{
			this.Voids = Voids;
		}
	}
	/// <summary>
	/// ENTITY IfcFailureConnectionCondition
	/// <para>ENTITY IfcFailureConnectionCondition</para>
	/// <para> SUBTYPE OF (IfcStructuralConnectionCondition);</para>
	/// <para>	TensionFailureX : OPTIONAL IfcForceMeasure;</para>
	/// <para>	TensionFailureY : OPTIONAL IfcForceMeasure;</para>
	/// <para>	TensionFailureZ : OPTIONAL IfcForceMeasure;</para>
	/// <para>	CompressionFailureX : OPTIONAL IfcForceMeasure;</para>
	/// <para>	CompressionFailureY : OPTIONAL IfcForceMeasure;</para>
	/// <para>	CompressionFailureZ : OPTIONAL IfcForceMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFailureConnectionCondition : IfcStructuralConnectionCondition
	{
		public IfcForceMeasure? TensionFailureX { get; set; }
		public IfcForceMeasure? TensionFailureY { get; set; }
		public IfcForceMeasure? TensionFailureZ { get; set; }
		public IfcForceMeasure? CompressionFailureX { get; set; }
		public IfcForceMeasure? CompressionFailureY { get; set; }
		public IfcForceMeasure? CompressionFailureZ { get; set; }
		public IfcFailureConnectionCondition() : base()
		{
		}
		public IfcFailureConnectionCondition(IfcLabel Name, IfcForceMeasure TensionFailureX, IfcForceMeasure TensionFailureY, IfcForceMeasure TensionFailureZ, IfcForceMeasure CompressionFailureX, IfcForceMeasure CompressionFailureY, IfcForceMeasure CompressionFailureZ) : base (Name)
		{
			this.TensionFailureX = TensionFailureX;
			this.TensionFailureY = TensionFailureY;
			this.TensionFailureZ = TensionFailureZ;
			this.CompressionFailureX = CompressionFailureX;
			this.CompressionFailureY = CompressionFailureY;
			this.CompressionFailureZ = CompressionFailureZ;
		}
	}
	/// <summary>
	/// ENTITY IfcFan
	/// <para>ENTITY IfcFan</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFanTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcFanTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcFanTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCFANTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFan : IfcFlowMovingDevice
	{
		public IfcFanTypeEnum? PredefinedType { get; set; }
		public IfcFan() : base()
		{
		}
		public IfcFan(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFanTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFanType
	/// <para>ENTITY IfcFanType</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDeviceType);</para>
	/// <para>	PredefinedType : IfcFanTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFanTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFanTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFanType : IfcFlowMovingDeviceType
	{
		public IfcFanTypeEnum PredefinedType { get; set; }
		public IfcFanType() : base()
		{
			PredefinedType = new IfcFanTypeEnum();
		}
		public IfcFanType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFanTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFastener
	/// <para>ENTITY IfcFastener</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFastenerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFastenerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4.IFCFASTENERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFastener : IfcElementComponent
	{
		public IfcFastenerTypeEnum? PredefinedType { get; set; }
		public IfcFastener() : base()
		{
		}
		public IfcFastener(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFastenerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFastenerType
	/// <para>ENTITY IfcFastenerType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcFastenerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFastenerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFastenerType : IfcElementComponentType
	{
		public IfcFastenerTypeEnum PredefinedType { get; set; }
		public IfcFastenerType() : base()
		{
			PredefinedType = new IfcFastenerTypeEnum();
		}
		public IfcFastenerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFastenerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFeatureElement
	/// <para>ENTITY IfcFeatureElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcFeatureElementAddition</para>
	/// <para>    ,IfcFeatureElementSubtraction</para>
	/// <para>    ,IfcSurfaceFeature))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFeatureElement : IfcElement
	{
		public IfcFeatureElement() : base()
		{
		}
		public IfcFeatureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFeatureElementAddition
	/// <para>ENTITY IfcFeatureElementAddition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcProjectionElement))</para>
	/// <para> SUBTYPE OF (IfcFeatureElement);</para>
	/// <para> INVERSE</para>
	/// <para>	ProjectsElements : IfcRelProjectsElement FOR RelatedFeatureElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFeatureElementAddition : IfcFeatureElement
	{
		public IfcFeatureElementAddition() : base()
		{
		}
		public IfcFeatureElementAddition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFeatureElementSubtraction
	/// <para>ENTITY IfcFeatureElementSubtraction</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcOpeningElement</para>
	/// <para>    ,IfcVoidingFeature))</para>
	/// <para> SUBTYPE OF (IfcFeatureElement);</para>
	/// <para> INVERSE</para>
	/// <para>	VoidsElements : IfcRelVoidsElement FOR RelatedOpeningElement;</para>
	/// <para> WHERE</para>
	/// <para>	HasNoSubtraction : SIZEOF(SELF\IfcElement.HasOpenings) = 0;</para>
	/// <para>	IsNotFilling : SIZEOF(SELF\IfcElement.FillsVoids) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFeatureElementSubtraction : IfcFeatureElement
	{
		public IfcFeatureElementSubtraction() : base()
		{
		}
		public IfcFeatureElementSubtraction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFillAreaStyle
	/// <para>ENTITY IfcFillAreaStyle</para>
	/// <para> SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>	FillStyles : SET [1:?] OF IfcFillStyleSelect;</para>
	/// <para>	ModelorDraughting : OPTIONAL IfcBoolean;</para>
	/// <para> WHERE</para>
	/// <para>	MaxOneColour : SIZEOF(QUERY(Style <* SELF.FillStyles |</para>
	/// <para>  'IFC4.IFCCOLOUR' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	MaxOneExtHatchStyle : SIZEOF(QUERY(Style <* SELF.FillStyles |</para>
	/// <para>  'IFC4.IFCEXTERNALLYDEFINEDHATCHSTYLE' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	ConsistentHatchStyleDef : IfcCorrectFillAreaStyle(SELF.FillStyles);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFillAreaStyle : IfcPresentationStyle, IfcPresentationStyleSelect
	{
		public List<IfcFillStyleSelect> FillStyles { get; set; }
		public IfcBoolean? ModelorDraughting { get; set; }
		public IfcFillAreaStyle() : base()
		{
			FillStyles = new List<IfcFillStyleSelect>();
		}
		public IfcFillAreaStyle(IfcLabel Name, List<IfcFillStyleSelect> FillStyles, IfcBoolean ModelorDraughting) : base (Name)
		{
			this.FillStyles = FillStyles;
			this.ModelorDraughting = ModelorDraughting;
		}
	}
	/// <summary>
	/// ENTITY IfcFillAreaStyleHatching
	/// <para>ENTITY IfcFillAreaStyleHatching</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	HatchLineAppearance : IfcCurveStyle;</para>
	/// <para>	StartOfNextHatchLine : IfcHatchLineDistanceSelect;</para>
	/// <para>	PointOfReferenceHatchLine : OPTIONAL IfcCartesianPoint;</para>
	/// <para>	PatternStart : OPTIONAL IfcCartesianPoint;</para>
	/// <para>	HatchLineAngle : IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	PatternStart2D : NOT(EXISTS(PatternStart)) OR (PatternStart.Dim = 2);</para>
	/// <para>	RefHatchLine2D : NOT(EXISTS(PointOfReferenceHatchLine)) OR (PointOfReferenceHatchLine.Dim = 2);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFillAreaStyleHatching : IfcGeometricRepresentationItem, IfcFillStyleSelect
	{
		public IfcCurveStyle HatchLineAppearance { get; set; }
		public IfcHatchLineDistanceSelect StartOfNextHatchLine { get; set; }
		public IfcCartesianPoint? PointOfReferenceHatchLine { get; set; }
		public IfcCartesianPoint? PatternStart { get; set; }
		public IfcPlaneAngleMeasure HatchLineAngle { get; set; }
		public IfcFillAreaStyleHatching() : base()
		{
			HatchLineAppearance = new IfcCurveStyle();
			StartOfNextHatchLine = new IfcHatchLineDistanceSelect();
			HatchLineAngle = new IfcPlaneAngleMeasure();
		}
		public IfcFillAreaStyleHatching(IfcCurveStyle HatchLineAppearance, IfcHatchLineDistanceSelect StartOfNextHatchLine, IfcCartesianPoint PointOfReferenceHatchLine, IfcCartesianPoint PatternStart, IfcPlaneAngleMeasure HatchLineAngle) : base ()
		{
			this.HatchLineAppearance = HatchLineAppearance;
			this.StartOfNextHatchLine = StartOfNextHatchLine;
			this.PointOfReferenceHatchLine = PointOfReferenceHatchLine;
			this.PatternStart = PatternStart;
			this.HatchLineAngle = HatchLineAngle;
		}
	}
	/// <summary>
	/// ENTITY IfcFillAreaStyleTiles
	/// <para>ENTITY IfcFillAreaStyleTiles</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	TilingPattern : LIST [2:2] OF IfcVector;</para>
	/// <para>	Tiles : SET [1:?] OF IfcStyledItem;</para>
	/// <para>	TilingScale : IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFillAreaStyleTiles : IfcGeometricRepresentationItem, IfcFillStyleSelect
	{
		public List<IfcVector> TilingPattern { get; set; }
		public List<IfcStyledItem> Tiles { get; set; }
		public IfcPositiveRatioMeasure TilingScale { get; set; }
		public IfcFillAreaStyleTiles() : base()
		{
			TilingPattern = new List<IfcVector>();
			Tiles = new List<IfcStyledItem>();
			TilingScale = new IfcPositiveRatioMeasure();
		}
		public IfcFillAreaStyleTiles(List<IfcVector> TilingPattern, List<IfcStyledItem> Tiles, IfcPositiveRatioMeasure TilingScale) : base ()
		{
			this.TilingPattern = TilingPattern;
			this.Tiles = Tiles;
			this.TilingScale = TilingScale;
		}
	}
	/// <summary>
	/// ENTITY IfcFilter
	/// <para>ENTITY IfcFilter</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFilterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcFilterTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcFilterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCFILTERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFilter : IfcFlowTreatmentDevice
	{
		public IfcFilterTypeEnum? PredefinedType { get; set; }
		public IfcFilter() : base()
		{
		}
		public IfcFilter(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFilterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFilterType
	/// <para>ENTITY IfcFilterType</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDeviceType);</para>
	/// <para>	PredefinedType : IfcFilterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFilterTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFilterTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFilterType : IfcFlowTreatmentDeviceType
	{
		public IfcFilterTypeEnum PredefinedType { get; set; }
		public IfcFilterType() : base()
		{
			PredefinedType = new IfcFilterTypeEnum();
		}
		public IfcFilterType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFilterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFireSuppressionTerminal
	/// <para>ENTITY IfcFireSuppressionTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFireSuppressionTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcFireSuppressionTerminalTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcFireSuppressionTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCFIRESUPPRESSIONTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFireSuppressionTerminal : IfcFlowTerminal
	{
		public IfcFireSuppressionTerminalTypeEnum? PredefinedType { get; set; }
		public IfcFireSuppressionTerminal() : base()
		{
		}
		public IfcFireSuppressionTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFireSuppressionTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFireSuppressionTerminalType
	/// <para>ENTITY IfcFireSuppressionTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcFireSuppressionTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFireSuppressionTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFireSuppressionTerminalTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFireSuppressionTerminalType : IfcFlowTerminalType
	{
		public IfcFireSuppressionTerminalTypeEnum PredefinedType { get; set; }
		public IfcFireSuppressionTerminalType() : base()
		{
			PredefinedType = new IfcFireSuppressionTerminalTypeEnum();
		}
		public IfcFireSuppressionTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFireSuppressionTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFixedReferenceSweptAreaSolid
	/// <para>ENTITY IfcFixedReferenceSweptAreaSolid</para>
	/// <para> SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>	Directrix : IfcCurve;</para>
	/// <para>	StartParam : OPTIONAL IfcParameterValue;</para>
	/// <para>	EndParam : OPTIONAL IfcParameterValue;</para>
	/// <para>	FixedReference : IfcDirection;</para>
	/// <para> WHERE</para>
	/// <para>	DirectrixBounded : (EXISTS(StartParam) AND EXISTS(EndParam)) OR </para>
	/// <para>(SIZEOF(['IFC4.IFCCONIC', 'IFC4.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFixedReferenceSweptAreaSolid : IfcSweptAreaSolid
	{
		public IfcCurve Directrix { get; set; }
		public IfcParameterValue? StartParam { get; set; }
		public IfcParameterValue? EndParam { get; set; }
		public IfcDirection FixedReference { get; set; }
		public IfcFixedReferenceSweptAreaSolid() : base()
		{
			Directrix = new IfcCurve();
			FixedReference = new IfcDirection();
		}
		public IfcFixedReferenceSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcCurve Directrix, IfcParameterValue StartParam, IfcParameterValue EndParam, IfcDirection FixedReference) : base (SweptArea, Position)
		{
			this.Directrix = Directrix;
			this.StartParam = StartParam;
			this.EndParam = EndParam;
			this.FixedReference = FixedReference;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowController
	/// <para>ENTITY IfcFlowController</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAirTerminalBox</para>
	/// <para>    ,IfcDamper</para>
	/// <para>    ,IfcElectricDistributionBoard</para>
	/// <para>    ,IfcElectricTimeControl</para>
	/// <para>    ,IfcFlowMeter</para>
	/// <para>    ,IfcProtectiveDevice</para>
	/// <para>    ,IfcSwitchingDevice</para>
	/// <para>    ,IfcValve))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowController : IfcDistributionFlowElement
	{
		public IfcFlowController() : base()
		{
		}
		public IfcFlowController(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowControllerType
	/// <para>ENTITY IfcFlowControllerType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAirTerminalBoxType</para>
	/// <para>    ,IfcDamperType</para>
	/// <para>    ,IfcElectricDistributionBoardType</para>
	/// <para>    ,IfcElectricTimeControlType</para>
	/// <para>    ,IfcFlowMeterType</para>
	/// <para>    ,IfcProtectiveDeviceType</para>
	/// <para>    ,IfcSwitchingDeviceType</para>
	/// <para>    ,IfcValveType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowControllerType : IfcDistributionFlowElementType
	{
		public IfcFlowControllerType() : base()
		{
		}
		public IfcFlowControllerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowFitting
	/// <para>ENTITY IfcFlowFitting</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCableCarrierFitting</para>
	/// <para>    ,IfcCableFitting</para>
	/// <para>    ,IfcDuctFitting</para>
	/// <para>    ,IfcJunctionBox</para>
	/// <para>    ,IfcPipeFitting))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowFitting : IfcDistributionFlowElement
	{
		public IfcFlowFitting() : base()
		{
		}
		public IfcFlowFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowFittingType
	/// <para>ENTITY IfcFlowFittingType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCableCarrierFittingType</para>
	/// <para>    ,IfcCableFittingType</para>
	/// <para>    ,IfcDuctFittingType</para>
	/// <para>    ,IfcJunctionBoxType</para>
	/// <para>    ,IfcPipeFittingType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowFittingType : IfcDistributionFlowElementType
	{
		public IfcFlowFittingType() : base()
		{
		}
		public IfcFlowFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowInstrument
	/// <para>ENTITY IfcFlowInstrument</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFlowInstrumentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcFlowInstrumentTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcFlowInstrumentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>('IFC4.IFCFLOWINSTRUMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowInstrument : IfcDistributionControlElement
	{
		public IfcFlowInstrumentTypeEnum? PredefinedType { get; set; }
		public IfcFlowInstrument() : base()
		{
		}
		public IfcFlowInstrument(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFlowInstrumentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowInstrumentType
	/// <para>ENTITY IfcFlowInstrumentType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcFlowInstrumentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFlowInstrumentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFlowInstrumentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowInstrumentType : IfcDistributionControlElementType
	{
		public IfcFlowInstrumentTypeEnum PredefinedType { get; set; }
		public IfcFlowInstrumentType() : base()
		{
			PredefinedType = new IfcFlowInstrumentTypeEnum();
		}
		public IfcFlowInstrumentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFlowInstrumentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMeter
	/// <para>ENTITY IfcFlowMeter</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFlowMeterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcFlowMeterTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcFlowMeterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCFLOWMETERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowMeter : IfcFlowController
	{
		public IfcFlowMeterTypeEnum? PredefinedType { get; set; }
		public IfcFlowMeter() : base()
		{
		}
		public IfcFlowMeter(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFlowMeterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMeterType
	/// <para>ENTITY IfcFlowMeterType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcFlowMeterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFlowMeterTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFlowMeterTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowMeterType : IfcFlowControllerType
	{
		public IfcFlowMeterTypeEnum PredefinedType { get; set; }
		public IfcFlowMeterType() : base()
		{
			PredefinedType = new IfcFlowMeterTypeEnum();
		}
		public IfcFlowMeterType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFlowMeterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMovingDevice
	/// <para>ENTITY IfcFlowMovingDevice</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCompressor</para>
	/// <para>    ,IfcFan</para>
	/// <para>    ,IfcPump))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowMovingDevice : IfcDistributionFlowElement
	{
		public IfcFlowMovingDevice() : base()
		{
		}
		public IfcFlowMovingDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMovingDeviceType
	/// <para>ENTITY IfcFlowMovingDeviceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCompressorType</para>
	/// <para>    ,IfcFanType</para>
	/// <para>    ,IfcPumpType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowMovingDeviceType : IfcDistributionFlowElementType
	{
		public IfcFlowMovingDeviceType() : base()
		{
		}
		public IfcFlowMovingDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowSegment
	/// <para>ENTITY IfcFlowSegment</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCableCarrierSegment</para>
	/// <para>    ,IfcCableSegment</para>
	/// <para>    ,IfcDuctSegment</para>
	/// <para>    ,IfcPipeSegment))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowSegment : IfcDistributionFlowElement
	{
		public IfcFlowSegment() : base()
		{
		}
		public IfcFlowSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowSegmentType
	/// <para>ENTITY IfcFlowSegmentType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCableCarrierSegmentType</para>
	/// <para>    ,IfcCableSegmentType</para>
	/// <para>    ,IfcDuctSegmentType</para>
	/// <para>    ,IfcPipeSegmentType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowSegmentType : IfcDistributionFlowElementType
	{
		public IfcFlowSegmentType() : base()
		{
		}
		public IfcFlowSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowStorageDevice
	/// <para>ENTITY IfcFlowStorageDevice</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcElectricFlowStorageDevice</para>
	/// <para>    ,IfcTank))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowStorageDevice : IfcDistributionFlowElement
	{
		public IfcFlowStorageDevice() : base()
		{
		}
		public IfcFlowStorageDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowStorageDeviceType
	/// <para>ENTITY IfcFlowStorageDeviceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcElectricFlowStorageDeviceType</para>
	/// <para>    ,IfcTankType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowStorageDeviceType : IfcDistributionFlowElementType
	{
		public IfcFlowStorageDeviceType() : base()
		{
		}
		public IfcFlowStorageDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTerminal
	/// <para>ENTITY IfcFlowTerminal</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAirTerminal</para>
	/// <para>    ,IfcAudioVisualAppliance</para>
	/// <para>    ,IfcCommunicationsAppliance</para>
	/// <para>    ,IfcElectricAppliance</para>
	/// <para>    ,IfcFireSuppressionTerminal</para>
	/// <para>    ,IfcLamp</para>
	/// <para>    ,IfcLightFixture</para>
	/// <para>    ,IfcMedicalDevice</para>
	/// <para>    ,IfcOutlet</para>
	/// <para>    ,IfcSanitaryTerminal</para>
	/// <para>    ,IfcSpaceHeater</para>
	/// <para>    ,IfcStackTerminal</para>
	/// <para>    ,IfcWasteTerminal))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowTerminal : IfcDistributionFlowElement
	{
		public IfcFlowTerminal() : base()
		{
		}
		public IfcFlowTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTerminalType
	/// <para>ENTITY IfcFlowTerminalType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAirTerminalType</para>
	/// <para>    ,IfcAudioVisualApplianceType</para>
	/// <para>    ,IfcCommunicationsApplianceType</para>
	/// <para>    ,IfcElectricApplianceType</para>
	/// <para>    ,IfcFireSuppressionTerminalType</para>
	/// <para>    ,IfcLampType</para>
	/// <para>    ,IfcLightFixtureType</para>
	/// <para>    ,IfcMedicalDeviceType</para>
	/// <para>    ,IfcOutletType</para>
	/// <para>    ,IfcSanitaryTerminalType</para>
	/// <para>    ,IfcSpaceHeaterType</para>
	/// <para>    ,IfcStackTerminalType</para>
	/// <para>    ,IfcWasteTerminalType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowTerminalType : IfcDistributionFlowElementType
	{
		public IfcFlowTerminalType() : base()
		{
		}
		public IfcFlowTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTreatmentDevice
	/// <para>ENTITY IfcFlowTreatmentDevice</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDuctSilencer</para>
	/// <para>    ,IfcFilter</para>
	/// <para>    ,IfcInterceptor))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowTreatmentDevice : IfcDistributionFlowElement
	{
		public IfcFlowTreatmentDevice() : base()
		{
		}
		public IfcFlowTreatmentDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTreatmentDeviceType
	/// <para>ENTITY IfcFlowTreatmentDeviceType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDuctSilencerType</para>
	/// <para>    ,IfcFilterType</para>
	/// <para>    ,IfcInterceptorType))</para>
	/// <para> SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowTreatmentDeviceType : IfcDistributionFlowElementType
	{
		public IfcFlowTreatmentDeviceType() : base()
		{
		}
		public IfcFlowTreatmentDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFooting
	/// <para>ENTITY IfcFooting</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFootingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT EXISTS(PredefinedType) OR</para>
	/// <para>(PredefinedType <> IfcFootingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFootingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4.IFCFOOTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFooting : IfcBuildingElement
	{
		public IfcFootingTypeEnum? PredefinedType { get; set; }
		public IfcFooting() : base()
		{
		}
		public IfcFooting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFootingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFootingType
	/// <para>ENTITY IfcFootingType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcFootingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFootingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFootingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFootingType : IfcBuildingElementType
	{
		public IfcFootingTypeEnum PredefinedType { get; set; }
		public IfcFootingType() : base()
		{
			PredefinedType = new IfcFootingTypeEnum();
		}
		public IfcFootingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFootingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFurnishingElement
	/// <para>ENTITY IfcFurnishingElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcFurniture</para>
	/// <para>    ,IfcSystemFurnitureElement))</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurnishingElement : IfcElement
	{
		public IfcFurnishingElement() : base()
		{
		}
		public IfcFurnishingElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFurnishingElementType
	/// <para>ENTITY IfcFurnishingElementType</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcFurnitureType</para>
	/// <para>    ,IfcSystemFurnitureElementType))</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurnishingElementType : IfcElementType
	{
		public IfcFurnishingElementType() : base()
		{
		}
		public IfcFurnishingElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFurniture
	/// <para>ENTITY IfcFurniture</para>
	/// <para> SUBTYPE OF (IfcFurnishingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcFurnitureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcFurnitureTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcFurnitureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>   ('IFC4.IFCFURNITURETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurniture : IfcFurnishingElement
	{
		public IfcFurnitureTypeEnum? PredefinedType { get; set; }
		public IfcFurniture() : base()
		{
		}
		public IfcFurniture(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFurnitureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFurnitureType
	/// <para>ENTITY IfcFurnitureType</para>
	/// <para> SUBTYPE OF (IfcFurnishingElementType);</para>
	/// <para>	AssemblyPlace : IfcAssemblyPlaceEnum;</para>
	/// <para>	PredefinedType : OPTIONAL IfcFurnitureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcFurnitureTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFurnitureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurnitureType : IfcFurnishingElementType
	{
		public IfcAssemblyPlaceEnum AssemblyPlace { get; set; }
		public IfcFurnitureTypeEnum? PredefinedType { get; set; }
		public IfcFurnitureType() : base()
		{
			AssemblyPlace = new IfcAssemblyPlaceEnum();
		}
		public IfcFurnitureType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAssemblyPlaceEnum AssemblyPlace, IfcFurnitureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.AssemblyPlace = AssemblyPlace;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcGeographicElement
	/// <para>ENTITY IfcGeographicElement</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcGeographicElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcGeographicElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcGeographicElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCGEOGRAPHICELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeographicElement : IfcElement
	{
		public IfcGeographicElementTypeEnum? PredefinedType { get; set; }
		public IfcGeographicElement() : base()
		{
		}
		public IfcGeographicElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcGeographicElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcGeographicElementType
	/// <para>ENTITY IfcGeographicElementType</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>	PredefinedType : IfcGeographicElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcGeographicElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcGeographicElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeographicElementType : IfcElementType
	{
		public IfcGeographicElementTypeEnum PredefinedType { get; set; }
		public IfcGeographicElementType() : base()
		{
			PredefinedType = new IfcGeographicElementTypeEnum();
		}
		public IfcGeographicElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcGeographicElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricCurveSet
	/// <para>ENTITY IfcGeometricCurveSet</para>
	/// <para> SUBTYPE OF (IfcGeometricSet);</para>
	/// <para> WHERE</para>
	/// <para>	NoSurfaces : SIZEOF(QUERY(Temp <* SELF\IfcGeometricSet.Elements |</para>
	/// <para>'IFC4.IFCSURFACE' IN TYPEOF(Temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricCurveSet : IfcGeometricSet
	{
		public IfcGeometricCurveSet() : base()
		{
		}
		public IfcGeometricCurveSet(List<IfcGeometricSetSelect> Elements) : base (Elements)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricRepresentationContext
	/// <para>ENTITY IfcGeometricRepresentationContext</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcGeometricRepresentationSubContext))</para>
	/// <para> SUBTYPE OF (IfcRepresentationContext);</para>
	/// <para>	CoordinateSpaceDimension : IfcDimensionCount;</para>
	/// <para>	Precision : OPTIONAL IfcReal;</para>
	/// <para>	WorldCoordinateSystem : IfcAxis2Placement;</para>
	/// <para>	TrueNorth : OPTIONAL IfcDirection;</para>
	/// <para> INVERSE</para>
	/// <para>	HasSubContexts : SET [0:?] OF IfcGeometricRepresentationSubContext FOR ParentContext;</para>
	/// <para>	HasCoordinateOperation : SET [0:1] OF IfcCoordinateOperation FOR SourceCRS;</para>
	/// <para> WHERE</para>
	/// <para>	North2D : NOT(EXISTS(TrueNorth)) OR (HIINDEX(TrueNorth.DirectionRatios) = 2);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricRepresentationContext : IfcRepresentationContext, IfcCoordinateReferenceSystemSelect
	{
		public IfcDimensionCount CoordinateSpaceDimension { get; set; }
		public IfcReal? Precision { get; set; }
		public IfcAxis2Placement WorldCoordinateSystem { get; set; }
		public IfcDirection? TrueNorth { get; set; }
		public IfcGeometricRepresentationContext() : base()
		{
			CoordinateSpaceDimension = new IfcDimensionCount();
			WorldCoordinateSystem = new IfcAxis2Placement();
		}
		public IfcGeometricRepresentationContext(IfcLabel ContextIdentifier, IfcLabel ContextType, IfcDimensionCount CoordinateSpaceDimension, IfcReal Precision, IfcAxis2Placement WorldCoordinateSystem, IfcDirection TrueNorth) : base (ContextIdentifier, ContextType)
		{
			this.CoordinateSpaceDimension = CoordinateSpaceDimension;
			this.Precision = Precision;
			this.WorldCoordinateSystem = WorldCoordinateSystem;
			this.TrueNorth = TrueNorth;
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricRepresentationItem
	/// <para>ENTITY IfcGeometricRepresentationItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAnnotationFillArea</para>
	/// <para>    ,IfcBooleanResult</para>
	/// <para>    ,IfcBoundingBox</para>
	/// <para>    ,IfcCartesianPointList</para>
	/// <para>    ,IfcCartesianTransformationOperator</para>
	/// <para>    ,IfcCompositeCurveSegment</para>
	/// <para>    ,IfcCsgPrimitive3D</para>
	/// <para>    ,IfcCurve</para>
	/// <para>    ,IfcDirection</para>
	/// <para>    ,IfcFaceBasedSurfaceModel</para>
	/// <para>    ,IfcFillAreaStyleHatching</para>
	/// <para>    ,IfcFillAreaStyleTiles</para>
	/// <para>    ,IfcGeometricSet</para>
	/// <para>    ,IfcHalfSpaceSolid</para>
	/// <para>    ,IfcLightSource</para>
	/// <para>    ,IfcPlacement</para>
	/// <para>    ,IfcPlanarExtent</para>
	/// <para>    ,IfcPoint</para>
	/// <para>    ,IfcSectionedSpine</para>
	/// <para>    ,IfcShellBasedSurfaceModel</para>
	/// <para>    ,IfcSolidModel</para>
	/// <para>    ,IfcSurface</para>
	/// <para>    ,IfcTessellatedItem</para>
	/// <para>    ,IfcTextLiteral</para>
	/// <para>    ,IfcVector))</para>
	/// <para> SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcGeometricRepresentationItem : IfcRepresentationItem
	{
		public IfcGeometricRepresentationItem() : base()
		{
		}
		public IfcGeometricRepresentationItem() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricRepresentationSubContext
	/// <para>ENTITY IfcGeometricRepresentationSubContext</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationContext);</para>
	/// <para>	ParentContext : IfcGeometricRepresentationContext;</para>
	/// <para>	TargetScale : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>	TargetView : IfcGeometricProjectionEnum;</para>
	/// <para>	UserDefinedTargetView : OPTIONAL IfcLabel;</para>
	/// <para> DERIVE</para>
	/// <para>	SELF\IfcGeometricRepresentationContext.WorldCoordinateSystem : IfcAxis2Placement := ParentContext.WorldCoordinateSystem;</para>
	/// <para>	SELF\IfcGeometricRepresentationContext.CoordinateSpaceDimension : IfcDimensionCount := ParentContext.CoordinateSpaceDimension;</para>
	/// <para>	SELF\IfcGeometricRepresentationContext.TrueNorth : IfcDirection := NVL(ParentContext.TrueNorth, IfcConvertDirectionInto2D(SELF\IfcGeometricRepresentationContext.WorldCoordinateSystem.P[2]));</para>
	/// <para>	SELF\IfcGeometricRepresentationContext.Precision : IfcReal := NVL(ParentContext.Precision,1.E-5);</para>
	/// <para> WHERE</para>
	/// <para>	ParentNoSub : NOT('IFC4.IFCGEOMETRICREPRESENTATIONSUBCONTEXT' IN TYPEOF(ParentContext));</para>
	/// <para>	UserTargetProvided : (TargetView <> IfcGeometricProjectionEnum.USERDEFINED) OR </para>
	/// <para>((TargetView =  IfcGeometricProjectionEnum.USERDEFINED) AND EXISTS(UserDefinedTargetView));</para>
	/// <para>	NoCoordOperation : SIZEOF(SELF\IfcGeometricRepresentationContext.HasCoordinateOperation) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricRepresentationSubContext : IfcGeometricRepresentationContext
	{
		public IfcGeometricRepresentationContext ParentContext { get; set; }
		public IfcPositiveRatioMeasure? TargetScale { get; set; }
		public IfcGeometricProjectionEnum TargetView { get; set; }
		public IfcLabel? UserDefinedTargetView { get; set; }
		public IfcGeometricRepresentationSubContext() : base()
		{
			ParentContext = new IfcGeometricRepresentationContext();
			TargetView = new IfcGeometricProjectionEnum();
		}
		public IfcGeometricRepresentationSubContext(IfcLabel ContextIdentifier, IfcLabel ContextType, IfcDimensionCount CoordinateSpaceDimension, IfcReal Precision, IfcAxis2Placement WorldCoordinateSystem, IfcDirection TrueNorth, IfcGeometricRepresentationContext ParentContext, IfcPositiveRatioMeasure TargetScale, IfcGeometricProjectionEnum TargetView, IfcLabel UserDefinedTargetView) : base (ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth)
		{
			this.ParentContext = ParentContext;
			this.TargetScale = TargetScale;
			this.TargetView = TargetView;
			this.UserDefinedTargetView = UserDefinedTargetView;
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricSet
	/// <para>ENTITY IfcGeometricSet</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcGeometricCurveSet))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Elements : SET [1:?] OF IfcGeometricSetSelect;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := Elements[1].Dim;</para>
	/// <para> WHERE</para>
	/// <para>	ConsistentDim : SIZEOF(QUERY(Temp <* Elements |</para>
	/// <para>  Temp.Dim <> Elements[1].Dim))</para>
	/// <para>= 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricSet : IfcGeometricRepresentationItem
	{
		public List<IfcGeometricSetSelect> Elements { get; set; }
		public IfcGeometricSet() : base()
		{
			Elements = new List<IfcGeometricSetSelect>();
		}
		public IfcGeometricSet(List<IfcGeometricSetSelect> Elements) : base ()
		{
			this.Elements = Elements;
		}
	}
	/// <summary>
	/// ENTITY IfcGrid
	/// <para>ENTITY IfcGrid</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para>	UAxes : LIST [1:?] OF UNIQUE IfcGridAxis;</para>
	/// <para>	VAxes : LIST [1:?] OF UNIQUE IfcGridAxis;</para>
	/// <para>	WAxes : OPTIONAL LIST [1:?] OF UNIQUE IfcGridAxis;</para>
	/// <para>	PredefinedType : OPTIONAL IfcGridTypeEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	ContainedInStructure : SET [0:1] OF IfcRelContainedInSpatialStructure FOR RelatedElements;</para>
	/// <para> WHERE</para>
	/// <para>	HasPlacement : EXISTS(SELF\IfcProduct.ObjectPlacement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGrid : IfcProduct
	{
		public IfcGrid() : base()
		{
		}
		public IfcGrid(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGridAxis;
	/// <para>ENTITY IfcGridAxis;</para>
	/// <para>	AxisTag : OPTIONAL IfcLabel;</para>
	/// <para>	AxisCurve : IfcCurve;</para>
	/// <para>	SameSense : IfcBoolean;</para>
	/// <para> INVERSE</para>
	/// <para>	PartOfW : SET [0:1] OF IfcGrid FOR WAxes;</para>
	/// <para>	PartOfV : SET [0:1] OF IfcGrid FOR VAxes;</para>
	/// <para>	PartOfU : SET [0:1] OF IfcGrid FOR UAxes;</para>
	/// <para>	HasIntersections : SET [0:?] OF IfcVirtualGridIntersection FOR IntersectingAxes;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : AxisCurve.Dim = 2;</para>
	/// <para>	WR2 : (SIZEOF(PartOfU) = 1) XOR (SIZEOF(PartOfV) = 1) XOR (SIZEOF(PartOfW) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGridAxis : ENTITY
	{
		public IfcLabel? AxisTag { get; set; }
		public IfcCurve AxisCurve { get; set; }
		public IfcBoolean SameSense { get; set; }
		public IfcGridAxis() : base()
		{
			AxisCurve = new IfcCurve();
			SameSense = new IfcBoolean();
		}
		public IfcGridAxis(IfcLabel AxisTag, IfcCurve AxisCurve, IfcBoolean SameSense) : base ()
		{
			this.AxisTag = AxisTag;
			this.AxisCurve = AxisCurve;
			this.SameSense = SameSense;
		}
	}
	/// <summary>
	/// ENTITY IfcGridPlacement
	/// <para>ENTITY IfcGridPlacement</para>
	/// <para> SUBTYPE OF (IfcObjectPlacement);</para>
	/// <para>	PlacementLocation : IfcVirtualGridIntersection;</para>
	/// <para>	PlacementRefDirection : OPTIONAL IfcGridPlacementDirectionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGridPlacement : IfcObjectPlacement
	{
		public IfcVirtualGridIntersection PlacementLocation { get; set; }
		public IfcGridPlacementDirectionSelect? PlacementRefDirection { get; set; }
		public IfcGridPlacement() : base()
		{
			PlacementLocation = new IfcVirtualGridIntersection();
		}
		public IfcGridPlacement(IfcVirtualGridIntersection PlacementLocation, IfcGridPlacementDirectionSelect PlacementRefDirection) : base ()
		{
			this.PlacementLocation = PlacementLocation;
			this.PlacementRefDirection = PlacementRefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcGroup
	/// <para>ENTITY IfcGroup</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAsset</para>
	/// <para>    ,IfcInventory</para>
	/// <para>    ,IfcStructuralLoadGroup</para>
	/// <para>    ,IfcStructuralResultGroup</para>
	/// <para>    ,IfcSystem))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para> INVERSE</para>
	/// <para>	IsGroupedBy : SET [0:?] OF IfcRelAssignsToGroup FOR RelatingGroup;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGroup : IfcObject
	{
		public IfcGroup() : base()
		{
		}
		public IfcGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcHalfSpaceSolid
	/// <para>ENTITY IfcHalfSpaceSolid</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBoxedHalfSpace</para>
	/// <para>    ,IfcPolygonalBoundedHalfSpace))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	BaseSurface : IfcSurface;</para>
	/// <para>	AgreementFlag : IfcBoolean;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHalfSpaceSolid : IfcGeometricRepresentationItem, IfcBooleanOperand
	{
		public IfcSurface BaseSurface { get; set; }
		public IfcBoolean AgreementFlag { get; set; }
		public IfcHalfSpaceSolid() : base()
		{
			BaseSurface = new IfcSurface();
			AgreementFlag = new IfcBoolean();
		}
		public IfcHalfSpaceSolid(IfcSurface BaseSurface, IfcBoolean AgreementFlag) : base ()
		{
			this.BaseSurface = BaseSurface;
			this.AgreementFlag = AgreementFlag;
		}
	}
	/// <summary>
	/// ENTITY IfcHeatExchanger
	/// <para>ENTITY IfcHeatExchanger</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcHeatExchangerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcHeatExchangerTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcHeatExchangerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCHEATEXCHANGERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHeatExchanger : IfcEnergyConversionDevice
	{
		public IfcHeatExchangerTypeEnum? PredefinedType { get; set; }
		public IfcHeatExchanger() : base()
		{
		}
		public IfcHeatExchanger(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcHeatExchangerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcHeatExchangerType
	/// <para>ENTITY IfcHeatExchangerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcHeatExchangerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcHeatExchangerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcHeatExchangerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHeatExchangerType : IfcEnergyConversionDeviceType
	{
		public IfcHeatExchangerTypeEnum PredefinedType { get; set; }
		public IfcHeatExchangerType() : base()
		{
			PredefinedType = new IfcHeatExchangerTypeEnum();
		}
		public IfcHeatExchangerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcHeatExchangerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcHumidifier
	/// <para>ENTITY IfcHumidifier</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcHumidifierTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcHumidifierTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcHumidifierTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCHUMIDIFIERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHumidifier : IfcEnergyConversionDevice
	{
		public IfcHumidifierTypeEnum? PredefinedType { get; set; }
		public IfcHumidifier() : base()
		{
		}
		public IfcHumidifier(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcHumidifierTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcHumidifierType
	/// <para>ENTITY IfcHumidifierType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcHumidifierTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcHumidifierTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcHumidifierTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHumidifierType : IfcEnergyConversionDeviceType
	{
		public IfcHumidifierTypeEnum PredefinedType { get; set; }
		public IfcHumidifierType() : base()
		{
			PredefinedType = new IfcHumidifierTypeEnum();
		}
		public IfcHumidifierType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcHumidifierTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcIShapeProfileDef
	/// <para>ENTITY IfcIShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	OverallWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	OverallDepth : IfcPositiveLengthMeasure;</para>
	/// <para>	WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	FlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	FlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidFlangeThickness : (2. * FlangeThickness) < OverallDepth;</para>
	/// <para>	ValidWebThickness : WebThickness < OverallWidth;</para>
	/// <para>	ValidFilletRadius : NOT(EXISTS(FilletRadius)) OR</para>
	/// <para>((FilletRadius <= (OverallWidth - WebThickness)/2.) AND </para>
	/// <para> (FilletRadius <= (OverallDepth - (2. * FlangeThickness))/2.));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure OverallWidth { get; set; }
		public IfcPositiveLengthMeasure OverallDepth { get; set; }
		public IfcPositiveLengthMeasure WebThickness { get; set; }
		public IfcPositiveLengthMeasure FlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? FlangeEdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? FlangeSlope { get; set; }
		public IfcIShapeProfileDef() : base()
		{
			OverallWidth = new IfcPositiveLengthMeasure();
			OverallDepth = new IfcPositiveLengthMeasure();
			WebThickness = new IfcPositiveLengthMeasure();
			FlangeThickness = new IfcPositiveLengthMeasure();
		}
		public IfcIShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure OverallWidth, IfcPositiveLengthMeasure OverallDepth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure FlangeEdgeRadius, IfcPlaneAngleMeasure FlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.OverallWidth = OverallWidth;
			this.OverallDepth = OverallDepth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.FlangeEdgeRadius = FlangeEdgeRadius;
			this.FlangeSlope = FlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcImageTexture
	/// <para>ENTITY IfcImageTexture</para>
	/// <para> SUBTYPE OF (IfcSurfaceTexture);</para>
	/// <para>	URLReference : IfcURIReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcImageTexture : IfcSurfaceTexture
	{
		public IfcURIReference URLReference { get; set; }
		public IfcImageTexture() : base()
		{
			URLReference = new IfcURIReference();
		}
		public IfcImageTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter, IfcURIReference URLReference) : base (RepeatS, RepeatT, Mode, TextureTransform, Parameter)
		{
			this.URLReference = URLReference;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedColourMap
	/// <para>ENTITY IfcIndexedColourMap</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	MappedTo : IfcTessellatedFaceSet;</para>
	/// <para>	Opacity : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	Colours : IfcColourRgbList;</para>
	/// <para>	ColourIndex : LIST [1:?] OF IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedColourMap : IfcPresentationItem
	{
		public IfcTessellatedFaceSet MappedTo { get; set; }
		public IfcNormalisedRatioMeasure? Opacity { get; set; }
		public IfcColourRgbList Colours { get; set; }
		public List<IfcPositiveInteger> ColourIndex { get; set; }
		public IfcIndexedColourMap() : base()
		{
			MappedTo = new IfcTessellatedFaceSet();
			Colours = new IfcColourRgbList();
			ColourIndex = new List<IfcPositiveInteger>();
		}
		public IfcIndexedColourMap(IfcTessellatedFaceSet MappedTo, IfcNormalisedRatioMeasure Opacity, IfcColourRgbList Colours, List<IfcPositiveInteger> ColourIndex) : base ()
		{
			this.MappedTo = MappedTo;
			this.Opacity = Opacity;
			this.Colours = Colours;
			this.ColourIndex = ColourIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedPolyCurve
	/// <para>ENTITY IfcIndexedPolyCurve</para>
	/// <para> SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>	Points : IfcCartesianPointList;</para>
	/// <para>	Segments : OPTIONAL LIST [1:?] OF IfcSegmentIndexSelect;</para>
	/// <para>	SelfIntersect : OPTIONAL IfcBoolean;</para>
	/// <para> WHERE</para>
	/// <para>	Consecutive : (SIZEOF(Segments) = 0) OR IfcConsecutiveSegments(Segments);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedPolyCurve : IfcBoundedCurve
	{
		public IfcCartesianPointList Points { get; set; }
		public List<IfcSegmentIndexSelect>? Segments { get; set; }
		public IfcBoolean? SelfIntersect { get; set; }
		public IfcIndexedPolyCurve() : base()
		{
			Points = new IfcCartesianPointList();
		}
		public IfcIndexedPolyCurve(IfcCartesianPointList Points, List<IfcSegmentIndexSelect> Segments, IfcBoolean SelfIntersect) : base ()
		{
			this.Points = Points;
			this.Segments = Segments;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedPolygonalFace
	/// <para>ENTITY IfcIndexedPolygonalFace</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcIndexedPolygonalFaceWithVoids))</para>
	/// <para> SUBTYPE OF (IfcTessellatedItem);</para>
	/// <para>	CoordIndex : LIST [3:?] OF IfcPositiveInteger;</para>
	/// <para> INVERSE</para>
	/// <para>	ToFaceSet : SET [1:?] OF IfcPolygonalFaceSet FOR Faces;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedPolygonalFace : IfcTessellatedItem
	{
		public List<IfcPositiveInteger> CoordIndex { get; set; }
		public IfcIndexedPolygonalFace() : base()
		{
			CoordIndex = new List<IfcPositiveInteger>();
		}
		public IfcIndexedPolygonalFace(List<IfcPositiveInteger> CoordIndex) : base ()
		{
			this.CoordIndex = CoordIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedPolygonalFaceWithVoids
	/// <para>ENTITY IfcIndexedPolygonalFaceWithVoids</para>
	/// <para> SUBTYPE OF (IfcIndexedPolygonalFace);</para>
	/// <para>	InnerCoordIndices : LIST [1:?] OF LIST [3:?] OF UNIQUE IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedPolygonalFaceWithVoids : IfcIndexedPolygonalFace
	{
		public IfcIndexedPolygonalFaceWithVoids() : base()
		{
		}
		public IfcIndexedPolygonalFaceWithVoids(List<IfcPositiveInteger> CoordIndex) : base (CoordIndex)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedTextureMap
	/// <para>ENTITY IfcIndexedTextureMap</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcIndexedTriangleTextureMap))</para>
	/// <para> SUBTYPE OF (IfcTextureCoordinate);</para>
	/// <para>	MappedTo : IfcTessellatedFaceSet;</para>
	/// <para>	TexCoords : IfcTextureVertexList;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcIndexedTextureMap : IfcTextureCoordinate
	{
		public IfcTessellatedFaceSet MappedTo { get; set; }
		public IfcTextureVertexList TexCoords { get; set; }
		public IfcIndexedTextureMap() : base()
		{
			MappedTo = new IfcTessellatedFaceSet();
			TexCoords = new IfcTextureVertexList();
		}
		public IfcIndexedTextureMap(List<IfcSurfaceTexture> Maps, IfcTessellatedFaceSet MappedTo, IfcTextureVertexList TexCoords) : base (Maps)
		{
			this.MappedTo = MappedTo;
			this.TexCoords = TexCoords;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedTriangleTextureMap
	/// <para>ENTITY IfcIndexedTriangleTextureMap</para>
	/// <para> SUBTYPE OF (IfcIndexedTextureMap);</para>
	/// <para>	TexCoordIndex : OPTIONAL LIST [1:?] OF LIST [3:3] OF IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedTriangleTextureMap : IfcIndexedTextureMap
	{
		public List<List<IfcPositiveInteger >>? TexCoordIndex { get; set; }
		public IfcIndexedTriangleTextureMap() : base()
		{
		}
		public IfcIndexedTriangleTextureMap(List<IfcSurfaceTexture> Maps, IfcTessellatedFaceSet MappedTo, IfcTextureVertexList TexCoords, List<List<IfcPositiveInteger >> TexCoordIndex) : base (Maps, MappedTo, TexCoords)
		{
			this.TexCoordIndex = TexCoordIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcInterceptor
	/// <para>ENTITY IfcInterceptor</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcInterceptorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcInterceptorTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcInterceptorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCINTERCEPTORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcInterceptor : IfcFlowTreatmentDevice
	{
		public IfcInterceptorTypeEnum? PredefinedType { get; set; }
		public IfcInterceptor() : base()
		{
		}
		public IfcInterceptor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcInterceptorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcInterceptorType
	/// <para>ENTITY IfcInterceptorType</para>
	/// <para> SUBTYPE OF (IfcFlowTreatmentDeviceType);</para>
	/// <para>	PredefinedType : IfcInterceptorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcInterceptorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcInterceptorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcInterceptorType : IfcFlowTreatmentDeviceType
	{
		public IfcInterceptorTypeEnum PredefinedType { get; set; }
		public IfcInterceptorType() : base()
		{
			PredefinedType = new IfcInterceptorTypeEnum();
		}
		public IfcInterceptorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcInterceptorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcIntersectionCurve
	/// <para>ENTITY IfcIntersectionCurve</para>
	/// <para> SUBTYPE OF (IfcSurfaceCurve);</para>
	/// <para> WHERE</para>
	/// <para>	TwoPCurves : SIZEOF(SELF\IfcSurfaceCurve.AssociatedGeometry) = 2;</para>
	/// <para>	DistinctSurfaces : IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[1]) <> IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[2]);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIntersectionCurve : IfcSurfaceCurve
	{
		public IfcIntersectionCurve() : base()
		{
		}
		public IfcIntersectionCurve(IfcCurve Curve3D, List<IfcPcurve> AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation MasterRepresentation) : base (Curve3D, AssociatedGeometry, MasterRepresentation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcInventory
	/// <para>ENTITY IfcInventory</para>
	/// <para> SUBTYPE OF (IfcGroup);</para>
	/// <para>	PredefinedType : OPTIONAL IfcInventoryTypeEnum;</para>
	/// <para>	Jurisdiction : OPTIONAL IfcActorSelect;</para>
	/// <para>	ResponsiblePersons : OPTIONAL SET [1:?] OF IfcPerson;</para>
	/// <para>	LastUpdateDate : OPTIONAL IfcDate;</para>
	/// <para>	CurrentValue : OPTIONAL IfcCostValue;</para>
	/// <para>	OriginalValue : OPTIONAL IfcCostValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcInventory : IfcGroup
	{
		public IfcInventoryTypeEnum? PredefinedType { get; set; }
		public IfcActorSelect? Jurisdiction { get; set; }
		public List<IfcPerson>? ResponsiblePersons { get; set; }
		public IfcDate? LastUpdateDate { get; set; }
		public IfcCostValue? CurrentValue { get; set; }
		public IfcCostValue? OriginalValue { get; set; }
		public IfcInventory() : base()
		{
		}
		public IfcInventory(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcInventoryTypeEnum PredefinedType, IfcActorSelect Jurisdiction, List<IfcPerson> ResponsiblePersons, IfcDate LastUpdateDate, IfcCostValue CurrentValue, IfcCostValue OriginalValue) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.Jurisdiction = Jurisdiction;
			this.ResponsiblePersons = ResponsiblePersons;
			this.LastUpdateDate = LastUpdateDate;
			this.CurrentValue = CurrentValue;
			this.OriginalValue = OriginalValue;
		}
	}
	/// <summary>
	/// ENTITY IfcIrregularTimeSeries
	/// <para>ENTITY IfcIrregularTimeSeries</para>
	/// <para> SUBTYPE OF (IfcTimeSeries);</para>
	/// <para>	Values : LIST [1:?] OF IfcIrregularTimeSeriesValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIrregularTimeSeries : IfcTimeSeries
	{
		public List<IfcIrregularTimeSeriesValue> Values { get; set; }
		public IfcIrregularTimeSeries() : base()
		{
			Values = new List<IfcIrregularTimeSeriesValue>();
		}
		public IfcIrregularTimeSeries(IfcLabel Name, IfcText Description, IfcDateTime StartTime, IfcDateTime EndTime, IfcTimeSeriesDataTypeEnum TimeSeriesDataType, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcUnit Unit, List<IfcIrregularTimeSeriesValue> Values) : base (Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit)
		{
			this.Values = Values;
		}
	}
	/// <summary>
	/// ENTITY IfcIrregularTimeSeriesValue;
	/// <para>ENTITY IfcIrregularTimeSeriesValue;</para>
	/// <para>	TimeStamp : IfcDateTime;</para>
	/// <para>	ListValues : LIST [1:?] OF IfcValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIrregularTimeSeriesValue : ENTITY
	{
		public IfcDateTime TimeStamp { get; set; }
		public List<IfcValue> ListValues { get; set; }
		public IfcIrregularTimeSeriesValue() : base()
		{
			TimeStamp = new IfcDateTime();
			ListValues = new List<IfcValue>();
		}
		public IfcIrregularTimeSeriesValue(IfcDateTime TimeStamp, List<IfcValue> ListValues) : base ()
		{
			this.TimeStamp = TimeStamp;
			this.ListValues = ListValues;
		}
	}
	/// <summary>
	/// ENTITY IfcJunctionBox
	/// <para>ENTITY IfcJunctionBox</para>
	/// <para> SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>	PredefinedType : OPTIONAL IfcJunctionBoxTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcJunctionBoxTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcJunctionBoxTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCJUNCTIONBOXTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcJunctionBox : IfcFlowFitting
	{
		public IfcJunctionBoxTypeEnum? PredefinedType { get; set; }
		public IfcJunctionBox() : base()
		{
		}
		public IfcJunctionBox(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcJunctionBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcJunctionBoxType
	/// <para>ENTITY IfcJunctionBoxType</para>
	/// <para> SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>	PredefinedType : IfcJunctionBoxTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcJunctionBoxTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcJunctionBoxTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcJunctionBoxType : IfcFlowFittingType
	{
		public IfcJunctionBoxTypeEnum PredefinedType { get; set; }
		public IfcJunctionBoxType() : base()
		{
			PredefinedType = new IfcJunctionBoxTypeEnum();
		}
		public IfcJunctionBoxType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcJunctionBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLShapeProfileDef
	/// <para>ENTITY IfcLShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para>	Width : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	Thickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	EdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	LegSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidThickness : (Thickness < Depth) AND (NOT(EXISTS(Width)) OR (Thickness < Width));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcPositiveLengthMeasure? Width { get; set; }
		public IfcPositiveLengthMeasure Thickness { get; set; }
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? EdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? LegSlope { get; set; }
		public IfcLShapeProfileDef() : base()
		{
			Depth = new IfcPositiveLengthMeasure();
			Thickness = new IfcPositiveLengthMeasure();
		}
		public IfcLShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure Width, IfcPositiveLengthMeasure Thickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure EdgeRadius, IfcPlaneAngleMeasure LegSlope) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.Width = Width;
			this.Thickness = Thickness;
			this.FilletRadius = FilletRadius;
			this.EdgeRadius = EdgeRadius;
			this.LegSlope = LegSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcLaborResource
	/// <para>ENTITY IfcLaborResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcLaborResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcLaborResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcLaborResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLaborResource : IfcConstructionResource
	{
		public IfcLaborResourceTypeEnum? PredefinedType { get; set; }
		public IfcLaborResource() : base()
		{
		}
		public IfcLaborResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcLaborResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLaborResourceType
	/// <para>ENTITY IfcLaborResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcLaborResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcLaborResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcLaborResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLaborResourceType : IfcConstructionResourceType
	{
		public IfcLaborResourceTypeEnum PredefinedType { get; set; }
		public IfcLaborResourceType() : base()
		{
			PredefinedType = new IfcLaborResourceTypeEnum();
		}
		public IfcLaborResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcLaborResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLagTime
	/// <para>ENTITY IfcLagTime</para>
	/// <para> SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>	LagValue : IfcTimeOrRatioSelect;</para>
	/// <para>	DurationType : IfcTaskDurationEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLagTime : IfcSchedulingTime
	{
		public IfcTimeOrRatioSelect LagValue { get; set; }
		public IfcTaskDurationEnum DurationType { get; set; }
		public IfcLagTime() : base()
		{
			LagValue = new IfcTimeOrRatioSelect();
			DurationType = new IfcTaskDurationEnum();
		}
		public IfcLagTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcTimeOrRatioSelect LagValue, IfcTaskDurationEnum DurationType) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.LagValue = LagValue;
			this.DurationType = DurationType;
		}
	}
	/// <summary>
	/// ENTITY IfcLamp
	/// <para>ENTITY IfcLamp</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcLampTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcLampTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcLampTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCLAMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLamp : IfcFlowTerminal
	{
		public IfcLampTypeEnum? PredefinedType { get; set; }
		public IfcLamp() : base()
		{
		}
		public IfcLamp(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLampType
	/// <para>ENTITY IfcLampType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcLampTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcLampTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcLampTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLampType : IfcFlowTerminalType
	{
		public IfcLampTypeEnum PredefinedType { get; set; }
		public IfcLampType() : base()
		{
			PredefinedType = new IfcLampTypeEnum();
		}
		public IfcLampType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcLampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLibraryInformation
	/// <para>ENTITY IfcLibraryInformation</para>
	/// <para> SUBTYPE OF (IfcExternalInformation);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Version : OPTIONAL IfcLabel;</para>
	/// <para>	Publisher : OPTIONAL IfcActorSelect;</para>
	/// <para>	VersionDate : OPTIONAL IfcDateTime;</para>
	/// <para>	Location : OPTIONAL IfcURIReference;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	LibraryInfoForObjects : SET [0:?] OF IfcRelAssociatesLibrary FOR RelatingLibrary;</para>
	/// <para>	HasLibraryReferences : SET [0:?] OF IfcLibraryReference FOR ReferencedLibrary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLibraryInformation : IfcExternalInformation, IfcLibrarySelect
	{
		public IfcLabel Name { get; set; }
		public IfcLabel? Version { get; set; }
		public IfcActorSelect? Publisher { get; set; }
		public IfcDateTime? VersionDate { get; set; }
		public IfcURIReference? Location { get; set; }
		public IfcText? Description { get; set; }
		public IfcLibraryInformation() : base()
		{
			Name = new IfcLabel();
		}
		public IfcLibraryInformation(IfcLabel Name, IfcLabel Version, IfcActorSelect Publisher, IfcDateTime VersionDate, IfcURIReference Location, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Version = Version;
			this.Publisher = Publisher;
			this.VersionDate = VersionDate;
			this.Location = Location;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcLibraryReference
	/// <para>ENTITY IfcLibraryReference</para>
	/// <para> SUBTYPE OF (IfcExternalReference);</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Language : OPTIONAL IfcLanguageId;</para>
	/// <para>	ReferencedLibrary : OPTIONAL IfcLibraryInformation;</para>
	/// <para> INVERSE</para>
	/// <para>	LibraryRefForObjects : SET [0:?] OF IfcRelAssociatesLibrary FOR RelatingLibrary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLibraryReference : IfcExternalReference, IfcLibrarySelect
	{
		public IfcText? Description { get; set; }
		public IfcLanguageId? Language { get; set; }
		public IfcLibraryInformation? ReferencedLibrary { get; set; }
		public IfcLibraryReference() : base()
		{
		}
		public IfcLibraryReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name, IfcText Description, IfcLanguageId Language, IfcLibraryInformation ReferencedLibrary) : base (Location, Identification, Name)
		{
			this.Description = Description;
			this.Language = Language;
			this.ReferencedLibrary = ReferencedLibrary;
		}
	}
	/// <summary>
	/// ENTITY IfcLightDistributionData;
	/// <para>ENTITY IfcLightDistributionData;</para>
	/// <para>	MainPlaneAngle : IfcPlaneAngleMeasure;</para>
	/// <para>	SecondaryPlaneAngle : LIST [1:?] OF IfcPlaneAngleMeasure;</para>
	/// <para>	LuminousIntensity : LIST [1:?] OF IfcLuminousIntensityDistributionMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightDistributionData : ENTITY
	{
		public IfcPlaneAngleMeasure MainPlaneAngle { get; set; }
		public List<IfcPlaneAngleMeasure> SecondaryPlaneAngle { get; set; }
		public List<IfcLuminousIntensityDistributionMeasure> LuminousIntensity { get; set; }
		public IfcLightDistributionData() : base()
		{
			MainPlaneAngle = new IfcPlaneAngleMeasure();
			SecondaryPlaneAngle = new List<IfcPlaneAngleMeasure>();
			LuminousIntensity = new List<IfcLuminousIntensityDistributionMeasure>();
		}
		public IfcLightDistributionData(IfcPlaneAngleMeasure MainPlaneAngle, List<IfcPlaneAngleMeasure> SecondaryPlaneAngle, List<IfcLuminousIntensityDistributionMeasure> LuminousIntensity) : base ()
		{
			this.MainPlaneAngle = MainPlaneAngle;
			this.SecondaryPlaneAngle = SecondaryPlaneAngle;
			this.LuminousIntensity = LuminousIntensity;
		}
	}
	/// <summary>
	/// ENTITY IfcLightFixture
	/// <para>ENTITY IfcLightFixture</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcLightFixtureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcLightFixtureTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcLightFixtureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCLIGHTFIXTURETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightFixture : IfcFlowTerminal
	{
		public IfcLightFixtureTypeEnum? PredefinedType { get; set; }
		public IfcLightFixture() : base()
		{
		}
		public IfcLightFixture(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLightFixtureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLightFixtureType
	/// <para>ENTITY IfcLightFixtureType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcLightFixtureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcLightFixtureTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcLightFixtureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightFixtureType : IfcFlowTerminalType
	{
		public IfcLightFixtureTypeEnum PredefinedType { get; set; }
		public IfcLightFixtureType() : base()
		{
			PredefinedType = new IfcLightFixtureTypeEnum();
		}
		public IfcLightFixtureType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcLightFixtureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLightIntensityDistribution;
	/// <para>ENTITY IfcLightIntensityDistribution;</para>
	/// <para>	LightDistributionCurve : IfcLightDistributionCurveEnum;</para>
	/// <para>	DistributionData : LIST [1:?] OF IfcLightDistributionData;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightIntensityDistribution : ENTITY, IfcLightDistributionDataSourceSelect
	{
		public IfcLightDistributionCurveEnum LightDistributionCurve { get; set; }
		public List<IfcLightDistributionData> DistributionData { get; set; }
		public IfcLightIntensityDistribution() : base()
		{
			LightDistributionCurve = new IfcLightDistributionCurveEnum();
			DistributionData = new List<IfcLightDistributionData>();
		}
		public IfcLightIntensityDistribution(IfcLightDistributionCurveEnum LightDistributionCurve, List<IfcLightDistributionData> DistributionData) : base ()
		{
			this.LightDistributionCurve = LightDistributionCurve;
			this.DistributionData = DistributionData;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSource
	/// <para>ENTITY IfcLightSource</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcLightSourceAmbient</para>
	/// <para>    ,IfcLightSourceDirectional</para>
	/// <para>    ,IfcLightSourceGoniometric</para>
	/// <para>    ,IfcLightSourcePositional))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	LightColour : IfcColourRgb;</para>
	/// <para>	AmbientIntensity : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	Intensity : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcLightSource : IfcGeometricRepresentationItem
	{
		public IfcLabel? Name { get; set; }
		public IfcColourRgb LightColour { get; set; }
		public IfcNormalisedRatioMeasure? AmbientIntensity { get; set; }
		public IfcNormalisedRatioMeasure? Intensity { get; set; }
		public IfcLightSource() : base()
		{
			LightColour = new IfcColourRgb();
		}
		public IfcLightSource(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity) : base ()
		{
			this.Name = Name;
			this.LightColour = LightColour;
			this.AmbientIntensity = AmbientIntensity;
			this.Intensity = Intensity;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceAmbient
	/// <para>ENTITY IfcLightSourceAmbient</para>
	/// <para> SUBTYPE OF (IfcLightSource);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceAmbient : IfcLightSource
	{
		public IfcLightSourceAmbient() : base()
		{
		}
		public IfcLightSourceAmbient(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceDirectional
	/// <para>ENTITY IfcLightSourceDirectional</para>
	/// <para> SUBTYPE OF (IfcLightSource);</para>
	/// <para>	Orientation : IfcDirection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceDirectional : IfcLightSource
	{
		public IfcDirection Orientation { get; set; }
		public IfcLightSourceDirectional() : base()
		{
			Orientation = new IfcDirection();
		}
		public IfcLightSourceDirectional(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcDirection Orientation) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
			this.Orientation = Orientation;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceGoniometric
	/// <para>ENTITY IfcLightSourceGoniometric</para>
	/// <para> SUBTYPE OF (IfcLightSource);</para>
	/// <para>	Position : IfcAxis2Placement3D;</para>
	/// <para>	ColourAppearance : OPTIONAL IfcColourRgb;</para>
	/// <para>	ColourTemperature : IfcThermodynamicTemperatureMeasure;</para>
	/// <para>	LuminousFlux : IfcLuminousFluxMeasure;</para>
	/// <para>	LightEmissionSource : IfcLightEmissionSourceEnum;</para>
	/// <para>	LightDistributionDataSource : IfcLightDistributionDataSourceSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceGoniometric : IfcLightSource
	{
		public IfcAxis2Placement3D Position { get; set; }
		public IfcColourRgb? ColourAppearance { get; set; }
		public IfcThermodynamicTemperatureMeasure ColourTemperature { get; set; }
		public IfcLuminousFluxMeasure LuminousFlux { get; set; }
		public IfcLightEmissionSourceEnum LightEmissionSource { get; set; }
		public IfcLightDistributionDataSourceSelect LightDistributionDataSource { get; set; }
		public IfcLightSourceGoniometric() : base()
		{
			Position = new IfcAxis2Placement3D();
			ColourTemperature = new IfcThermodynamicTemperatureMeasure();
			LuminousFlux = new IfcLuminousFluxMeasure();
			LightEmissionSource = new IfcLightEmissionSourceEnum();
			LightDistributionDataSource = new IfcLightDistributionDataSourceSelect();
		}
		public IfcLightSourceGoniometric(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcAxis2Placement3D Position, IfcColourRgb ColourAppearance, IfcThermodynamicTemperatureMeasure ColourTemperature, IfcLuminousFluxMeasure LuminousFlux, IfcLightEmissionSourceEnum LightEmissionSource, IfcLightDistributionDataSourceSelect LightDistributionDataSource) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
			this.Position = Position;
			this.ColourAppearance = ColourAppearance;
			this.ColourTemperature = ColourTemperature;
			this.LuminousFlux = LuminousFlux;
			this.LightEmissionSource = LightEmissionSource;
			this.LightDistributionDataSource = LightDistributionDataSource;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourcePositional
	/// <para>ENTITY IfcLightSourcePositional</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcLightSourceSpot))</para>
	/// <para> SUBTYPE OF (IfcLightSource);</para>
	/// <para>	Position : IfcCartesianPoint;</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>	ConstantAttenuation : IfcReal;</para>
	/// <para>	DistanceAttenuation : IfcReal;</para>
	/// <para>	QuadricAttenuation : IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourcePositional : IfcLightSource
	{
		public IfcCartesianPoint Position { get; set; }
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcReal ConstantAttenuation { get; set; }
		public IfcReal DistanceAttenuation { get; set; }
		public IfcReal QuadricAttenuation { get; set; }
		public IfcLightSourcePositional() : base()
		{
			Position = new IfcCartesianPoint();
			Radius = new IfcPositiveLengthMeasure();
			ConstantAttenuation = new IfcReal();
			DistanceAttenuation = new IfcReal();
			QuadricAttenuation = new IfcReal();
		}
		public IfcLightSourcePositional(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcCartesianPoint Position, IfcPositiveLengthMeasure Radius, IfcReal ConstantAttenuation, IfcReal DistanceAttenuation, IfcReal QuadricAttenuation) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
			this.Position = Position;
			this.Radius = Radius;
			this.ConstantAttenuation = ConstantAttenuation;
			this.DistanceAttenuation = DistanceAttenuation;
			this.QuadricAttenuation = QuadricAttenuation;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceSpot
	/// <para>ENTITY IfcLightSourceSpot</para>
	/// <para> SUBTYPE OF (IfcLightSourcePositional);</para>
	/// <para>	Orientation : IfcDirection;</para>
	/// <para>	ConcentrationExponent : OPTIONAL IfcReal;</para>
	/// <para>	SpreadAngle : IfcPositivePlaneAngleMeasure;</para>
	/// <para>	BeamWidthAngle : IfcPositivePlaneAngleMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceSpot : IfcLightSourcePositional
	{
		public IfcDirection Orientation { get; set; }
		public IfcReal? ConcentrationExponent { get; set; }
		public IfcPositivePlaneAngleMeasure SpreadAngle { get; set; }
		public IfcPositivePlaneAngleMeasure BeamWidthAngle { get; set; }
		public IfcLightSourceSpot() : base()
		{
			Orientation = new IfcDirection();
			SpreadAngle = new IfcPositivePlaneAngleMeasure();
			BeamWidthAngle = new IfcPositivePlaneAngleMeasure();
		}
		public IfcLightSourceSpot(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcCartesianPoint Position, IfcPositiveLengthMeasure Radius, IfcReal ConstantAttenuation, IfcReal DistanceAttenuation, IfcReal QuadricAttenuation, IfcDirection Orientation, IfcReal ConcentrationExponent, IfcPositivePlaneAngleMeasure SpreadAngle, IfcPositivePlaneAngleMeasure BeamWidthAngle) : base (Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation)
		{
			this.Orientation = Orientation;
			this.ConcentrationExponent = ConcentrationExponent;
			this.SpreadAngle = SpreadAngle;
			this.BeamWidthAngle = BeamWidthAngle;
		}
	}
	/// <summary>
	/// ENTITY IfcLine
	/// <para>ENTITY IfcLine</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	Pnt : IfcCartesianPoint;</para>
	/// <para>	Dir : IfcVector;</para>
	/// <para> WHERE</para>
	/// <para>	SameDim : Dir.Dim = Pnt.Dim;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLine : IfcCurve
	{
		public IfcCartesianPoint Pnt { get; set; }
		public IfcVector Dir { get; set; }
		public IfcLine() : base()
		{
			Pnt = new IfcCartesianPoint();
			Dir = new IfcVector();
		}
		public IfcLine(IfcCartesianPoint Pnt, IfcVector Dir) : base ()
		{
			this.Pnt = Pnt;
			this.Dir = Dir;
		}
	}
	/// <summary>
	/// ENTITY IfcLocalPlacement
	/// <para>ENTITY IfcLocalPlacement</para>
	/// <para> SUBTYPE OF (IfcObjectPlacement);</para>
	/// <para>	PlacementRelTo : OPTIONAL IfcObjectPlacement;</para>
	/// <para>	RelativePlacement : IfcAxis2Placement;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : IfcCorrectLocalPlacement(RelativePlacement, PlacementRelTo);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLocalPlacement : IfcObjectPlacement
	{
		public IfcObjectPlacement? PlacementRelTo { get; set; }
		public IfcAxis2Placement RelativePlacement { get; set; }
		public IfcLocalPlacement() : base()
		{
			RelativePlacement = new IfcAxis2Placement();
		}
		public IfcLocalPlacement(IfcObjectPlacement PlacementRelTo, IfcAxis2Placement RelativePlacement) : base ()
		{
			this.PlacementRelTo = PlacementRelTo;
			this.RelativePlacement = RelativePlacement;
		}
	}
	/// <summary>
	/// ENTITY IfcLoop
	/// <para>ENTITY IfcLoop</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcEdgeLoop</para>
	/// <para>    ,IfcPolyLoop</para>
	/// <para>    ,IfcVertexLoop))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLoop : IfcTopologicalRepresentationItem
	{
		public IfcLoop() : base()
		{
		}
		public IfcLoop() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcManifoldSolidBrep
	/// <para>ENTITY IfcManifoldSolidBrep</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAdvancedBrep</para>
	/// <para>    ,IfcFacetedBrep))</para>
	/// <para> SUBTYPE OF (IfcSolidModel);</para>
	/// <para>	Outer : IfcClosedShell;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcManifoldSolidBrep : IfcSolidModel
	{
		public IfcClosedShell Outer { get; set; }
		public IfcManifoldSolidBrep() : base()
		{
			Outer = new IfcClosedShell();
		}
		public IfcManifoldSolidBrep(IfcClosedShell Outer) : base ()
		{
			this.Outer = Outer;
		}
	}
	/// <summary>
	/// ENTITY IfcMapConversion
	/// <para>ENTITY IfcMapConversion</para>
	/// <para> SUBTYPE OF (IfcCoordinateOperation);</para>
	/// <para>	Eastings : IfcLengthMeasure;</para>
	/// <para>	Northings : IfcLengthMeasure;</para>
	/// <para>	OrthogonalHeight : IfcLengthMeasure;</para>
	/// <para>	XAxisAbscissa : OPTIONAL IfcReal;</para>
	/// <para>	XAxisOrdinate : OPTIONAL IfcReal;</para>
	/// <para>	Scale : OPTIONAL IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMapConversion : IfcCoordinateOperation
	{
		public IfcLengthMeasure Eastings { get; set; }
		public IfcLengthMeasure Northings { get; set; }
		public IfcLengthMeasure OrthogonalHeight { get; set; }
		public IfcReal? XAxisAbscissa { get; set; }
		public IfcReal? XAxisOrdinate { get; set; }
		public IfcReal? Scale { get; set; }
		public IfcMapConversion() : base()
		{
			Eastings = new IfcLengthMeasure();
			Northings = new IfcLengthMeasure();
			OrthogonalHeight = new IfcLengthMeasure();
		}
		public IfcMapConversion(IfcCoordinateReferenceSystemSelect SourceCRS, IfcCoordinateReferenceSystem TargetCRS, IfcLengthMeasure Eastings, IfcLengthMeasure Northings, IfcLengthMeasure OrthogonalHeight, IfcReal XAxisAbscissa, IfcReal XAxisOrdinate, IfcReal Scale) : base (SourceCRS, TargetCRS)
		{
			this.Eastings = Eastings;
			this.Northings = Northings;
			this.OrthogonalHeight = OrthogonalHeight;
			this.XAxisAbscissa = XAxisAbscissa;
			this.XAxisOrdinate = XAxisOrdinate;
			this.Scale = Scale;
		}
	}
	/// <summary>
	/// ENTITY IfcMappedItem
	/// <para>ENTITY IfcMappedItem</para>
	/// <para> SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>	MappingSource : IfcRepresentationMap;</para>
	/// <para>	MappingTarget : IfcCartesianTransformationOperator;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMappedItem : IfcRepresentationItem
	{
		public IfcRepresentationMap MappingSource { get; set; }
		public IfcCartesianTransformationOperator MappingTarget { get; set; }
		public IfcMappedItem() : base()
		{
			MappingSource = new IfcRepresentationMap();
			MappingTarget = new IfcCartesianTransformationOperator();
		}
		public IfcMappedItem(IfcRepresentationMap MappingSource, IfcCartesianTransformationOperator MappingTarget) : base ()
		{
			this.MappingSource = MappingSource;
			this.MappingTarget = MappingTarget;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterial
	/// <para>ENTITY IfcMaterial</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Category : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	HasRepresentation : SET [0:1] OF IfcMaterialDefinitionRepresentation FOR RepresentedMaterial;</para>
	/// <para>	IsRelatedWith : SET [0:?] OF IfcMaterialRelationship FOR RelatedMaterials;</para>
	/// <para>	RelatesTo : SET [0:1] OF IfcMaterialRelationship FOR RelatingMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterial : IfcMaterialDefinition
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcLabel? Category { get; set; }
		public IfcMaterial() : base()
		{
			Name = new IfcLabel();
		}
		public IfcMaterial(IfcLabel Name, IfcText Description, IfcLabel Category) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Category = Category;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialClassificationRelationship;
	/// <para>ENTITY IfcMaterialClassificationRelationship;</para>
	/// <para>	MaterialClassifications : SET [1:?] OF IfcClassificationSelect;</para>
	/// <para>	ClassifiedMaterial : IfcMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialClassificationRelationship : ENTITY
	{
		public List<IfcClassificationSelect> MaterialClassifications { get; set; }
		public IfcMaterial ClassifiedMaterial { get; set; }
		public IfcMaterialClassificationRelationship() : base()
		{
			MaterialClassifications = new List<IfcClassificationSelect>();
			ClassifiedMaterial = new IfcMaterial();
		}
		public IfcMaterialClassificationRelationship(List<IfcClassificationSelect> MaterialClassifications, IfcMaterial ClassifiedMaterial) : base ()
		{
			this.MaterialClassifications = MaterialClassifications;
			this.ClassifiedMaterial = ClassifiedMaterial;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialConstituent
	/// <para>ENTITY IfcMaterialConstituent</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Material : IfcMaterial;</para>
	/// <para>	Fraction : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	Category : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ToMaterialConstituentSet : IfcMaterialConstituentSet FOR MaterialConstituents;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialConstituent : IfcMaterialDefinition
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcMaterial Material { get; set; }
		public IfcNormalisedRatioMeasure? Fraction { get; set; }
		public IfcLabel? Category { get; set; }
		public IfcMaterialConstituent() : base()
		{
			Material = new IfcMaterial();
		}
		public IfcMaterialConstituent(IfcLabel Name, IfcText Description, IfcMaterial Material, IfcNormalisedRatioMeasure Fraction, IfcLabel Category) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Material = Material;
			this.Fraction = Fraction;
			this.Category = Category;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialConstituentSet
	/// <para>ENTITY IfcMaterialConstituentSet</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	MaterialConstituents : OPTIONAL SET [1:?] OF IfcMaterialConstituent;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialConstituentSet : IfcMaterialDefinition
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcMaterialConstituent>? MaterialConstituents { get; set; }
		public IfcMaterialConstituentSet() : base()
		{
		}
		public IfcMaterialConstituentSet(IfcLabel Name, IfcText Description, List<IfcMaterialConstituent> MaterialConstituents) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.MaterialConstituents = MaterialConstituents;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialDefinition
	/// <para>ENTITY IfcMaterialDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMaterial</para>
	/// <para>    ,IfcMaterialConstituent</para>
	/// <para>    ,IfcMaterialConstituentSet</para>
	/// <para>    ,IfcMaterialLayer</para>
	/// <para>    ,IfcMaterialLayerSet</para>
	/// <para>    ,IfcMaterialProfile</para>
	/// <para>    ,IfcMaterialProfileSet));</para>
	/// <para> INVERSE</para>
	/// <para>	AssociatedTo : SET [0:?] OF IfcRelAssociatesMaterial FOR RelatingMaterial;</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>	HasProperties : SET [0:?] OF IfcMaterialProperties FOR Material;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcMaterialDefinition : ENTITY, IfcMaterialSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcMaterialDefinition() : base()
		{
		}
		public IfcMaterialDefinition() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialDefinitionRepresentation
	/// <para>ENTITY IfcMaterialDefinitionRepresentation</para>
	/// <para> SUBTYPE OF (IfcProductRepresentation);</para>
	/// <para>	RepresentedMaterial : IfcMaterial;</para>
	/// <para> WHERE</para>
	/// <para>	OnlyStyledRepresentations : SIZEOF(QUERY(temp <* Representations | </para>
	/// <para>  (NOT('IFC4.IFCSTYLEDREPRESENTATION' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialDefinitionRepresentation : IfcProductRepresentation
	{
		public IfcMaterial RepresentedMaterial { get; set; }
		public IfcMaterialDefinitionRepresentation() : base()
		{
			RepresentedMaterial = new IfcMaterial();
		}
		public IfcMaterialDefinitionRepresentation(IfcLabel Name, IfcText Description, List<IfcRepresentation> Representations, IfcMaterial RepresentedMaterial) : base (Name, Description, Representations)
		{
			this.RepresentedMaterial = RepresentedMaterial;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayer
	/// <para>ENTITY IfcMaterialLayer</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMaterialLayerWithOffsets))</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Material : OPTIONAL IfcMaterial;</para>
	/// <para>	LayerThickness : IfcNonNegativeLengthMeasure;</para>
	/// <para>	IsVentilated : OPTIONAL IfcLogical;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Category : OPTIONAL IfcLabel;</para>
	/// <para>	Priority : OPTIONAL IfcInteger;</para>
	/// <para> INVERSE</para>
	/// <para>	ToMaterialLayerSet : IfcMaterialLayerSet FOR MaterialLayers;</para>
	/// <para> WHERE</para>
	/// <para>	NormalizedPriority : NOT(EXISTS(Priority)) OR {0 <= Priority <= 100};</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayer : IfcMaterialDefinition
	{
		public IfcMaterial? Material { get; set; }
		public IfcNonNegativeLengthMeasure LayerThickness { get; set; }
		public IfcLogical? IsVentilated { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcLabel? Category { get; set; }
		public IfcInteger? Priority { get; set; }
		public IfcMaterialLayer() : base()
		{
			LayerThickness = new IfcNonNegativeLengthMeasure();
		}
		public IfcMaterialLayer(IfcMaterial Material, IfcNonNegativeLengthMeasure LayerThickness, IfcLogical IsVentilated, IfcLabel Name, IfcText Description, IfcLabel Category, IfcInteger Priority) : base ()
		{
			this.Material = Material;
			this.LayerThickness = LayerThickness;
			this.IsVentilated = IsVentilated;
			this.Name = Name;
			this.Description = Description;
			this.Category = Category;
			this.Priority = Priority;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayerSet
	/// <para>ENTITY IfcMaterialLayerSet</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	MaterialLayers : LIST [1:?] OF IfcMaterialLayer;</para>
	/// <para>	LayerSetName : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> DERIVE</para>
	/// <para>	TotalThickness : IfcLengthMeasure := IfcMlsTotalThickness(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayerSet : IfcMaterialDefinition
	{
		public List<IfcMaterialLayer> MaterialLayers { get; set; }
		public IfcLabel? LayerSetName { get; set; }
		public IfcText? Description { get; set; }
		public IfcMaterialLayerSet() : base()
		{
			MaterialLayers = new List<IfcMaterialLayer>();
		}
		public IfcMaterialLayerSet(List<IfcMaterialLayer> MaterialLayers, IfcLabel LayerSetName, IfcText Description) : base ()
		{
			this.MaterialLayers = MaterialLayers;
			this.LayerSetName = LayerSetName;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayerSetUsage
	/// <para>ENTITY IfcMaterialLayerSetUsage</para>
	/// <para> SUBTYPE OF (IfcMaterialUsageDefinition);</para>
	/// <para>	ForLayerSet : IfcMaterialLayerSet;</para>
	/// <para>	LayerSetDirection : IfcLayerSetDirectionEnum;</para>
	/// <para>	DirectionSense : IfcDirectionSenseEnum;</para>
	/// <para>	OffsetFromReferenceLine : IfcLengthMeasure;</para>
	/// <para>	ReferenceExtent : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayerSetUsage : IfcMaterialUsageDefinition
	{
		public IfcMaterialLayerSet ForLayerSet { get; set; }
		public IfcLayerSetDirectionEnum LayerSetDirection { get; set; }
		public IfcDirectionSenseEnum DirectionSense { get; set; }
		public IfcLengthMeasure OffsetFromReferenceLine { get; set; }
		public IfcPositiveLengthMeasure? ReferenceExtent { get; set; }
		public IfcMaterialLayerSetUsage() : base()
		{
			ForLayerSet = new IfcMaterialLayerSet();
			LayerSetDirection = new IfcLayerSetDirectionEnum();
			DirectionSense = new IfcDirectionSenseEnum();
			OffsetFromReferenceLine = new IfcLengthMeasure();
		}
		public IfcMaterialLayerSetUsage(IfcMaterialLayerSet ForLayerSet, IfcLayerSetDirectionEnum LayerSetDirection, IfcDirectionSenseEnum DirectionSense, IfcLengthMeasure OffsetFromReferenceLine, IfcPositiveLengthMeasure ReferenceExtent) : base ()
		{
			this.ForLayerSet = ForLayerSet;
			this.LayerSetDirection = LayerSetDirection;
			this.DirectionSense = DirectionSense;
			this.OffsetFromReferenceLine = OffsetFromReferenceLine;
			this.ReferenceExtent = ReferenceExtent;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayerWithOffsets
	/// <para>ENTITY IfcMaterialLayerWithOffsets</para>
	/// <para> SUBTYPE OF (IfcMaterialLayer);</para>
	/// <para>	OffsetDirection : IfcLayerSetDirectionEnum;</para>
	/// <para>	OffsetValues : ARRAY [1:2] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayerWithOffsets : IfcMaterialLayer
	{
		public IfcLayerSetDirectionEnum OffsetDirection { get; set; }
		public List<IfcLengthMeasure> OffsetValues { get; set; }
		public IfcMaterialLayerWithOffsets() : base()
		{
			OffsetDirection = new IfcLayerSetDirectionEnum();
			OffsetValues = new List<IfcLengthMeasure>();
		}
		public IfcMaterialLayerWithOffsets(IfcMaterial Material, IfcNonNegativeLengthMeasure LayerThickness, IfcLogical IsVentilated, IfcLabel Name, IfcText Description, IfcLabel Category, IfcInteger Priority, IfcLayerSetDirectionEnum OffsetDirection, List<IfcLengthMeasure> OffsetValues) : base (Material, LayerThickness, IsVentilated, Name, Description, Category, Priority)
		{
			this.OffsetDirection = OffsetDirection;
			this.OffsetValues = OffsetValues;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialList;
	/// <para>ENTITY IfcMaterialList;</para>
	/// <para>	Materials : LIST [1:?] OF IfcMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialList : ENTITY, IfcMaterialSelect
	{
		public List<IfcMaterial> Materials { get; set; }
		public IfcMaterialList() : base()
		{
			Materials = new List<IfcMaterial>();
		}
		public IfcMaterialList(List<IfcMaterial> Materials) : base ()
		{
			this.Materials = Materials;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfile
	/// <para>ENTITY IfcMaterialProfile</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMaterialProfileWithOffsets))</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Material : OPTIONAL IfcMaterial;</para>
	/// <para>	Profile : IfcProfileDef;</para>
	/// <para>	Priority : OPTIONAL IfcInteger;</para>
	/// <para>	Category : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ToMaterialProfileSet : IfcMaterialProfileSet FOR MaterialProfiles;</para>
	/// <para> WHERE</para>
	/// <para>	NormalizedPriority : NOT(EXISTS(Priority)) OR {0 <= Priority <= 100};</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfile : IfcMaterialDefinition
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcMaterial? Material { get; set; }
		public IfcProfileDef Profile { get; set; }
		public IfcInteger? Priority { get; set; }
		public IfcLabel? Category { get; set; }
		public IfcMaterialProfile() : base()
		{
			Profile = new IfcProfileDef();
		}
		public IfcMaterialProfile(IfcLabel Name, IfcText Description, IfcMaterial Material, IfcProfileDef Profile, IfcInteger Priority, IfcLabel Category) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Material = Material;
			this.Profile = Profile;
			this.Priority = Priority;
			this.Category = Category;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileSet
	/// <para>ENTITY IfcMaterialProfileSet</para>
	/// <para> SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	MaterialProfiles : LIST [1:?] OF IfcMaterialProfile;</para>
	/// <para>	CompositeProfile : OPTIONAL IfcCompositeProfileDef;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileSet : IfcMaterialDefinition
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcMaterialProfile> MaterialProfiles { get; set; }
		public IfcCompositeProfileDef? CompositeProfile { get; set; }
		public IfcMaterialProfileSet() : base()
		{
			MaterialProfiles = new List<IfcMaterialProfile>();
		}
		public IfcMaterialProfileSet(IfcLabel Name, IfcText Description, List<IfcMaterialProfile> MaterialProfiles, IfcCompositeProfileDef CompositeProfile) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.MaterialProfiles = MaterialProfiles;
			this.CompositeProfile = CompositeProfile;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileSetUsage
	/// <para>ENTITY IfcMaterialProfileSetUsage</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMaterialProfileSetUsageTapering))</para>
	/// <para> SUBTYPE OF (IfcMaterialUsageDefinition);</para>
	/// <para>	ForProfileSet : IfcMaterialProfileSet;</para>
	/// <para>	CardinalPoint : OPTIONAL IfcCardinalPointReference;</para>
	/// <para>	ReferenceExtent : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileSetUsage : IfcMaterialUsageDefinition
	{
		public IfcMaterialProfileSet ForProfileSet { get; set; }
		public IfcCardinalPointReference? CardinalPoint { get; set; }
		public IfcPositiveLengthMeasure? ReferenceExtent { get; set; }
		public IfcMaterialProfileSetUsage() : base()
		{
			ForProfileSet = new IfcMaterialProfileSet();
		}
		public IfcMaterialProfileSetUsage(IfcMaterialProfileSet ForProfileSet, IfcCardinalPointReference CardinalPoint, IfcPositiveLengthMeasure ReferenceExtent) : base ()
		{
			this.ForProfileSet = ForProfileSet;
			this.CardinalPoint = CardinalPoint;
			this.ReferenceExtent = ReferenceExtent;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileSetUsageTapering
	/// <para>ENTITY IfcMaterialProfileSetUsageTapering</para>
	/// <para> SUBTYPE OF (IfcMaterialProfileSetUsage);</para>
	/// <para>	ForProfileEndSet : IfcMaterialProfileSet;</para>
	/// <para>	CardinalEndPoint : OPTIONAL IfcCardinalPointReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileSetUsageTapering : IfcMaterialProfileSetUsage
	{
		public IfcMaterialProfileSet ForProfileEndSet { get; set; }
		public IfcCardinalPointReference? CardinalEndPoint { get; set; }
		public IfcMaterialProfileSetUsageTapering() : base()
		{
			ForProfileEndSet = new IfcMaterialProfileSet();
		}
		public IfcMaterialProfileSetUsageTapering(IfcMaterialProfileSet ForProfileSet, IfcCardinalPointReference CardinalPoint, IfcPositiveLengthMeasure ReferenceExtent, IfcMaterialProfileSet ForProfileEndSet, IfcCardinalPointReference CardinalEndPoint) : base (ForProfileSet, CardinalPoint, ReferenceExtent)
		{
			this.ForProfileEndSet = ForProfileEndSet;
			this.CardinalEndPoint = CardinalEndPoint;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileWithOffsets
	/// <para>ENTITY IfcMaterialProfileWithOffsets</para>
	/// <para> SUBTYPE OF (IfcMaterialProfile);</para>
	/// <para>	OffsetValues : ARRAY [1:2] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileWithOffsets : IfcMaterialProfile
	{
		public List<IfcLengthMeasure> OffsetValues { get; set; }
		public IfcMaterialProfileWithOffsets() : base()
		{
			OffsetValues = new List<IfcLengthMeasure>();
		}
		public IfcMaterialProfileWithOffsets(IfcLabel Name, IfcText Description, IfcMaterial Material, IfcProfileDef Profile, IfcInteger Priority, IfcLabel Category, List<IfcLengthMeasure> OffsetValues) : base (Name, Description, Material, Profile, Priority, Category)
		{
			this.OffsetValues = OffsetValues;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProperties
	/// <para>ENTITY IfcMaterialProperties</para>
	/// <para> SUBTYPE OF (IfcExtendedProperties);</para>
	/// <para>	Material : IfcMaterialDefinition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProperties : IfcExtendedProperties
	{
		public IfcMaterialDefinition Material { get; set; }
		public IfcMaterialProperties() : base()
		{
			Material = new IfcMaterialDefinition();
		}
		public IfcMaterialProperties(IfcIdentifier Name, IfcText Description, List<IfcProperty> Properties, IfcMaterialDefinition Material) : base (Name, Description, Properties)
		{
			this.Material = Material;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialRelationship
	/// <para>ENTITY IfcMaterialRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingMaterial : IfcMaterial;</para>
	/// <para>	RelatedMaterials : SET [1:?] OF IfcMaterial;</para>
	/// <para>	Expression : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialRelationship : IfcResourceLevelRelationship
	{
		public IfcMaterial RelatingMaterial { get; set; }
		public List<IfcMaterial> RelatedMaterials { get; set; }
		public IfcLabel? Expression { get; set; }
		public IfcMaterialRelationship() : base()
		{
			RelatingMaterial = new IfcMaterial();
			RelatedMaterials = new List<IfcMaterial>();
		}
		public IfcMaterialRelationship(IfcLabel Name, IfcText Description, IfcMaterial RelatingMaterial, List<IfcMaterial> RelatedMaterials, IfcLabel Expression) : base (Name, Description)
		{
			this.RelatingMaterial = RelatingMaterial;
			this.RelatedMaterials = RelatedMaterials;
			this.Expression = Expression;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialUsageDefinition
	/// <para>ENTITY IfcMaterialUsageDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMaterialLayerSetUsage</para>
	/// <para>    ,IfcMaterialProfileSetUsage));</para>
	/// <para> INVERSE</para>
	/// <para>	AssociatedTo : SET [1:?] OF IfcRelAssociatesMaterial FOR RelatingMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcMaterialUsageDefinition : ENTITY, IfcMaterialSelect
	{
		public IfcMaterialUsageDefinition() : base()
		{
		}
		public IfcMaterialUsageDefinition() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMeasureWithUnit;
	/// <para>ENTITY IfcMeasureWithUnit;</para>
	/// <para>	ValueComponent : IfcValue;</para>
	/// <para>	UnitComponent : IfcUnit;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMeasureWithUnit : ENTITY, IfcAppliedValueSelect, IfcMetricValueSelect
	{
		public IfcValue ValueComponent { get; set; }
		public IfcUnit UnitComponent { get; set; }
		public IfcMeasureWithUnit() : base()
		{
			ValueComponent = new IfcValue();
			UnitComponent = new IfcUnit();
		}
		public IfcMeasureWithUnit(IfcValue ValueComponent, IfcUnit UnitComponent) : base ()
		{
			this.ValueComponent = ValueComponent;
			this.UnitComponent = UnitComponent;
		}
	}
	/// <summary>
	/// ENTITY IfcMechanicalFastener
	/// <para>ENTITY IfcMechanicalFastener</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	NominalLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcMechanicalFastenerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcMechanicalFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMechanicalFastenerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4.IFCMECHANICALFASTENERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMechanicalFastener : IfcElementComponent
	{
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcPositiveLengthMeasure? NominalLength { get; set; }
		public IfcMechanicalFastenerTypeEnum? PredefinedType { get; set; }
		public IfcMechanicalFastener() : base()
		{
		}
		public IfcMechanicalFastener(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure NominalDiameter, IfcPositiveLengthMeasure NominalLength, IfcMechanicalFastenerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.NominalDiameter = NominalDiameter;
			this.NominalLength = NominalLength;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMechanicalFastenerType
	/// <para>ENTITY IfcMechanicalFastenerType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcMechanicalFastenerTypeEnum;</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	NominalLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcMechanicalFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMechanicalFastenerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMechanicalFastenerType : IfcElementComponentType
	{
		public IfcMechanicalFastenerTypeEnum PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcPositiveLengthMeasure? NominalLength { get; set; }
		public IfcMechanicalFastenerType() : base()
		{
			PredefinedType = new IfcMechanicalFastenerTypeEnum();
		}
		public IfcMechanicalFastenerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMechanicalFastenerTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcPositiveLengthMeasure NominalLength) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.NominalLength = NominalLength;
		}
	}
	/// <summary>
	/// ENTITY IfcMedicalDevice
	/// <para>ENTITY IfcMedicalDevice</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcMedicalDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcMedicalDeviceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcMedicalDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCMEDICALDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMedicalDevice : IfcFlowTerminal
	{
		public IfcMedicalDeviceTypeEnum? PredefinedType { get; set; }
		public IfcMedicalDevice() : base()
		{
		}
		public IfcMedicalDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMedicalDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMedicalDeviceType
	/// <para>ENTITY IfcMedicalDeviceType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcMedicalDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcMedicalDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMedicalDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMedicalDeviceType : IfcFlowTerminalType
	{
		public IfcMedicalDeviceTypeEnum PredefinedType { get; set; }
		public IfcMedicalDeviceType() : base()
		{
			PredefinedType = new IfcMedicalDeviceTypeEnum();
		}
		public IfcMedicalDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMedicalDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMember
	/// <para>ENTITY IfcMember</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMemberStandardCase))</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcMemberTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcMemberTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcMemberTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCMEMBERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMember : IfcBuildingElement
	{
		public IfcMemberTypeEnum? PredefinedType { get; set; }
		public IfcMember() : base()
		{
		}
		public IfcMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMemberTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMemberStandardCase
	/// <para>ENTITY IfcMemberStandardCase</para>
	/// <para> SUBTYPE OF (IfcMember);</para>
	/// <para> WHERE</para>
	/// <para>	HasMaterialProfileSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>              ('IFC4.IFCMATERIALPROFILESETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>              )) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMemberStandardCase : IfcMember
	{
		public IfcMemberStandardCase() : base()
		{
		}
		public IfcMemberStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMemberTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMemberType
	/// <para>ENTITY IfcMemberType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcMemberTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcMemberTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMemberTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMemberType : IfcBuildingElementType
	{
		public IfcMemberTypeEnum PredefinedType { get; set; }
		public IfcMemberType() : base()
		{
			PredefinedType = new IfcMemberTypeEnum();
		}
		public IfcMemberType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMemberTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMetric
	/// <para>ENTITY IfcMetric</para>
	/// <para> SUBTYPE OF (IfcConstraint);</para>
	/// <para>	Benchmark : IfcBenchmarkEnum;</para>
	/// <para>	ValueSource : OPTIONAL IfcLabel;</para>
	/// <para>	DataValue : OPTIONAL IfcMetricValueSelect;</para>
	/// <para>	ReferencePath : OPTIONAL IfcReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMetric : IfcConstraint
	{
		public IfcBenchmarkEnum Benchmark { get; set; }
		public IfcLabel? ValueSource { get; set; }
		public IfcMetricValueSelect? DataValue { get; set; }
		public IfcReference? ReferencePath { get; set; }
		public IfcMetric() : base()
		{
			Benchmark = new IfcBenchmarkEnum();
		}
		public IfcMetric(IfcLabel Name, IfcText Description, IfcConstraintEnum ConstraintGrade, IfcLabel ConstraintSource, IfcActorSelect CreatingActor, IfcDateTime CreationTime, IfcLabel UserDefinedGrade, IfcBenchmarkEnum Benchmark, IfcLabel ValueSource, IfcMetricValueSelect DataValue, IfcReference ReferencePath) : base (Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade)
		{
			this.Benchmark = Benchmark;
			this.ValueSource = ValueSource;
			this.DataValue = DataValue;
			this.ReferencePath = ReferencePath;
		}
	}
	/// <summary>
	/// ENTITY IfcMirroredProfileDef
	/// <para>ENTITY IfcMirroredProfileDef</para>
	/// <para> SUBTYPE OF (IfcDerivedProfileDef);</para>
	/// <para> DERIVE</para>
	/// <para>	SELF\IfcDerivedProfileDef.Operator : IfcCartesianTransformationOperator2D := </para>
	/// <para>IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>IfcCartesianTransformationOperator(</para>
	/// <para>    -- Axis1</para>
	/// <para>    IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>    IfcDirection([-1., 0.]),</para>
	/// <para>    -- Axis2</para>
	/// <para>    IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>    IfcDirection([ 0., 1.]),</para>
	/// <para>    -- LocalOrigin</para>
	/// <para>    IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>    IfcPoint() || IfcCartesianPoint([0., 0.]),</para>
	/// <para>    -- Scale</para>
	/// <para>    1.) ||</para>
	/// <para>IfcCartesianTransformationOperator2D();</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMirroredProfileDef : IfcDerivedProfileDef
	{
		public IfcMirroredProfileDef() : base()
		{
		}
		public IfcMirroredProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcProfileDef ParentProfile, IfcCartesianTransformationOperator2D Operator, IfcLabel Label) : base (ProfileType, ProfileName, ParentProfile, Operator, Label)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMonetaryUnit;
	/// <para>ENTITY IfcMonetaryUnit;</para>
	/// <para>	Currency : IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMonetaryUnit : ENTITY, IfcUnit
	{
		public IfcLabel Currency { get; set; }
		public IfcMonetaryUnit() : base()
		{
			Currency = new IfcLabel();
		}
		public IfcMonetaryUnit(IfcLabel Currency) : base ()
		{
			this.Currency = Currency;
		}
	}
	/// <summary>
	/// ENTITY IfcMotorConnection
	/// <para>ENTITY IfcMotorConnection</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcMotorConnectionTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcMotorConnectionTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcMotorConnectionTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCMOTORCONNECTIONTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMotorConnection : IfcEnergyConversionDevice
	{
		public IfcMotorConnectionTypeEnum? PredefinedType { get; set; }
		public IfcMotorConnection() : base()
		{
		}
		public IfcMotorConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMotorConnectionTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMotorConnectionType
	/// <para>ENTITY IfcMotorConnectionType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcMotorConnectionTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcMotorConnectionTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMotorConnectionTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMotorConnectionType : IfcEnergyConversionDeviceType
	{
		public IfcMotorConnectionTypeEnum PredefinedType { get; set; }
		public IfcMotorConnectionType() : base()
		{
			PredefinedType = new IfcMotorConnectionTypeEnum();
		}
		public IfcMotorConnectionType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMotorConnectionTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcNamedUnit
	/// <para>ENTITY IfcNamedUnit</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcContextDependentUnit</para>
	/// <para>    ,IfcConversionBasedUnit</para>
	/// <para>    ,IfcSIUnit));</para>
	/// <para>	Dimensions : IfcDimensionalExponents;</para>
	/// <para>	UnitType : IfcUnitEnum;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : IfcCorrectDimensions (SELF.UnitType, SELF.Dimensions);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcNamedUnit : ENTITY, IfcUnit
	{
		public IfcDimensionalExponents Dimensions { get; set; }
		public IfcUnitEnum UnitType { get; set; }
		public IfcNamedUnit() : base()
		{
			Dimensions = new IfcDimensionalExponents();
			UnitType = new IfcUnitEnum();
		}
		public IfcNamedUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType) : base ()
		{
			this.Dimensions = Dimensions;
			this.UnitType = UnitType;
		}
	}
	/// <summary>
	/// ENTITY IfcObject
	/// <para>ENTITY IfcObject</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcActor</para>
	/// <para>    ,IfcControl</para>
	/// <para>    ,IfcGroup</para>
	/// <para>    ,IfcProcess</para>
	/// <para>    ,IfcProduct</para>
	/// <para>    ,IfcResource))</para>
	/// <para> SUBTYPE OF (IfcObjectDefinition);</para>
	/// <para>	ObjectType : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	IsDeclaredBy : SET [0:1] OF IfcRelDefinesByObject FOR RelatedObjects;</para>
	/// <para>	Declares : SET [0:?] OF IfcRelDefinesByObject FOR RelatingObject;</para>
	/// <para>	IsTypedBy : SET [0:1] OF IfcRelDefinesByType FOR RelatedObjects;</para>
	/// <para>	IsDefinedBy : SET [0:?] OF IfcRelDefinesByProperties FOR RelatedObjects;</para>
	/// <para> WHERE</para>
	/// <para>	UniquePropertySetNames : ((SIZEOF(IsDefinedBy) = 0) OR IfcUniqueDefinitionNames(IsDefinedBy));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcObject : IfcObjectDefinition
	{
		public IfcLabel? ObjectType { get; set; }
		public IfcObject() : base()
		{
		}
		public IfcObject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ObjectType = ObjectType;
		}
	}
	/// <summary>
	/// ENTITY IfcObjectDefinition
	/// <para>ENTITY IfcObjectDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcContext</para>
	/// <para>    ,IfcObject</para>
	/// <para>    ,IfcTypeObject))</para>
	/// <para> SUBTYPE OF (IfcRoot);</para>
	/// <para> INVERSE</para>
	/// <para>	HasAssignments : SET [0:?] OF IfcRelAssigns FOR RelatedObjects;</para>
	/// <para>	Nests : SET [0:1] OF IfcRelNests FOR RelatedObjects;</para>
	/// <para>	IsNestedBy : SET [0:?] OF IfcRelNests FOR RelatingObject;</para>
	/// <para>	HasContext : SET [0:1] OF IfcRelDeclares FOR RelatedDefinitions;</para>
	/// <para>	IsDecomposedBy : SET [0:?] OF IfcRelAggregates FOR RelatingObject;</para>
	/// <para>	Decomposes : SET [0:1] OF IfcRelAggregates FOR RelatedObjects;</para>
	/// <para>	HasAssociations : SET [0:?] OF IfcRelAssociates FOR RelatedObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcObjectDefinition : IfcRoot, IfcDefinitionSelect
	{
		public IfcObjectDefinition() : base()
		{
		}
		public IfcObjectDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcObjectPlacement
	/// <para>ENTITY IfcObjectPlacement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcGridPlacement</para>
	/// <para>    ,IfcLocalPlacement));</para>
	/// <para> INVERSE</para>
	/// <para>	PlacesObject : SET [0:?] OF IfcProduct FOR ObjectPlacement;</para>
	/// <para>	ReferencedByPlacements : SET [0:?] OF IfcLocalPlacement FOR PlacementRelTo;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcObjectPlacement : ENTITY
	{
		public IfcObjectPlacement() : base()
		{
		}
		public IfcObjectPlacement() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcObjective
	/// <para>ENTITY IfcObjective</para>
	/// <para> SUBTYPE OF (IfcConstraint);</para>
	/// <para>	BenchmarkValues : OPTIONAL LIST [1:?] OF IfcConstraint;</para>
	/// <para>	LogicalAggregator : OPTIONAL IfcLogicalOperatorEnum;</para>
	/// <para>	ObjectiveQualifier : IfcObjectiveEnum;</para>
	/// <para>	UserDefinedQualifier : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : (ObjectiveQualifier <> IfcObjectiveEnum.USERDEFINED) OR</para>
	/// <para>((ObjectiveQualifier = IfcObjectiveEnum.USERDEFINED) AND EXISTS(SELF\IfcObjective.UserDefinedQualifier));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcObjective : IfcConstraint
	{
		public List<IfcConstraint>? BenchmarkValues { get; set; }
		public IfcLogicalOperatorEnum? LogicalAggregator { get; set; }
		public IfcObjectiveEnum ObjectiveQualifier { get; set; }
		public IfcLabel? UserDefinedQualifier { get; set; }
		public IfcObjective() : base()
		{
			ObjectiveQualifier = new IfcObjectiveEnum();
		}
		public IfcObjective(IfcLabel Name, IfcText Description, IfcConstraintEnum ConstraintGrade, IfcLabel ConstraintSource, IfcActorSelect CreatingActor, IfcDateTime CreationTime, IfcLabel UserDefinedGrade, List<IfcConstraint> BenchmarkValues, IfcLogicalOperatorEnum LogicalAggregator, IfcObjectiveEnum ObjectiveQualifier, IfcLabel UserDefinedQualifier) : base (Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade)
		{
			this.BenchmarkValues = BenchmarkValues;
			this.LogicalAggregator = LogicalAggregator;
			this.ObjectiveQualifier = ObjectiveQualifier;
			this.UserDefinedQualifier = UserDefinedQualifier;
		}
	}
	/// <summary>
	/// ENTITY IfcOccupant
	/// <para>ENTITY IfcOccupant</para>
	/// <para> SUBTYPE OF (IfcActor);</para>
	/// <para>	PredefinedType : OPTIONAL IfcOccupantTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : NOT(PredefinedType = IfcOccupantTypeEnum.USERDEFINED) </para>
	/// <para>OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOccupant : IfcActor
	{
		public IfcOccupantTypeEnum? PredefinedType { get; set; }
		public IfcOccupant() : base()
		{
		}
		public IfcOccupant(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcActorSelect TheActor, IfcOccupantTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOffsetCurve2D
	/// <para>ENTITY IfcOffsetCurve2D</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	BasisCurve : IfcCurve;</para>
	/// <para>	Distance : IfcLengthMeasure;</para>
	/// <para>	SelfIntersect : IfcLogical;</para>
	/// <para> WHERE</para>
	/// <para>	DimIs2D : BasisCurve.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOffsetCurve2D : IfcCurve
	{
		public IfcCurve BasisCurve { get; set; }
		public IfcLengthMeasure Distance { get; set; }
		public IfcLogical SelfIntersect { get; set; }
		public IfcOffsetCurve2D() : base()
		{
			BasisCurve = new IfcCurve();
			Distance = new IfcLengthMeasure();
			SelfIntersect = new IfcLogical();
		}
		public IfcOffsetCurve2D(IfcCurve BasisCurve, IfcLengthMeasure Distance, IfcLogical SelfIntersect) : base ()
		{
			this.BasisCurve = BasisCurve;
			this.Distance = Distance;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcOffsetCurve3D
	/// <para>ENTITY IfcOffsetCurve3D</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	BasisCurve : IfcCurve;</para>
	/// <para>	Distance : IfcLengthMeasure;</para>
	/// <para>	SelfIntersect : IfcLogical;</para>
	/// <para>	RefDirection : IfcDirection;</para>
	/// <para> WHERE</para>
	/// <para>	DimIs2D : BasisCurve.Dim = 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOffsetCurve3D : IfcCurve
	{
		public IfcCurve BasisCurve { get; set; }
		public IfcLengthMeasure Distance { get; set; }
		public IfcLogical SelfIntersect { get; set; }
		public IfcDirection RefDirection { get; set; }
		public IfcOffsetCurve3D() : base()
		{
			BasisCurve = new IfcCurve();
			Distance = new IfcLengthMeasure();
			SelfIntersect = new IfcLogical();
			RefDirection = new IfcDirection();
		}
		public IfcOffsetCurve3D(IfcCurve BasisCurve, IfcLengthMeasure Distance, IfcLogical SelfIntersect, IfcDirection RefDirection) : base ()
		{
			this.BasisCurve = BasisCurve;
			this.Distance = Distance;
			this.SelfIntersect = SelfIntersect;
			this.RefDirection = RefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcOpenShell
	/// <para>ENTITY IfcOpenShell</para>
	/// <para> SUBTYPE OF (IfcConnectedFaceSet);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOpenShell : IfcConnectedFaceSet, IfcShell
	{
		public IfcOpenShell() : base()
		{
		}
		public IfcOpenShell(List<IfcFace> CfsFaces) : base (CfsFaces)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcOpeningElement
	/// <para>ENTITY IfcOpeningElement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcOpeningStandardCase))</para>
	/// <para> SUBTYPE OF (IfcFeatureElementSubtraction);</para>
	/// <para>	PredefinedType : OPTIONAL IfcOpeningElementTypeEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	HasFillings : SET [0:?] OF IfcRelFillsElement FOR RelatingOpeningElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOpeningElement : IfcFeatureElementSubtraction
	{
		public IfcOpeningElementTypeEnum? PredefinedType { get; set; }
		public IfcOpeningElement() : base()
		{
		}
		public IfcOpeningElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcOpeningElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOpeningStandardCase
	/// <para>ENTITY IfcOpeningStandardCase</para>
	/// <para> SUBTYPE OF (IfcOpeningElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOpeningStandardCase : IfcOpeningElement
	{
		public IfcOpeningStandardCase() : base()
		{
		}
		public IfcOpeningStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcOpeningElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcOrganization;
	/// <para>ENTITY IfcOrganization;</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Roles : OPTIONAL LIST [1:?] OF IfcActorRole;</para>
	/// <para>	Addresses : OPTIONAL LIST [1:?] OF IfcAddress;</para>
	/// <para> INVERSE</para>
	/// <para>	IsRelatedBy : SET [0:?] OF IfcOrganizationRelationship FOR RelatedOrganizations;</para>
	/// <para>	Relates : SET [0:?] OF IfcOrganizationRelationship FOR RelatingOrganization;</para>
	/// <para>	Engages : SET [0:?] OF IfcPersonAndOrganization FOR TheOrganization;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOrganization : ENTITY, IfcActorSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcActorRole>? Roles { get; set; }
		public List<IfcAddress>? Addresses { get; set; }
		public IfcOrganization() : base()
		{
			Name = new IfcLabel();
		}
		public IfcOrganization(IfcIdentifier Identification, IfcLabel Name, IfcText Description, List<IfcActorRole> Roles, List<IfcAddress> Addresses) : base ()
		{
			this.Identification = Identification;
			this.Name = Name;
			this.Description = Description;
			this.Roles = Roles;
			this.Addresses = Addresses;
		}
	}
	/// <summary>
	/// ENTITY IfcOrganizationRelationship
	/// <para>ENTITY IfcOrganizationRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingOrganization : IfcOrganization;</para>
	/// <para>	RelatedOrganizations : SET [1:?] OF IfcOrganization;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOrganizationRelationship : IfcResourceLevelRelationship
	{
		public IfcOrganization RelatingOrganization { get; set; }
		public List<IfcOrganization> RelatedOrganizations { get; set; }
		public IfcOrganizationRelationship() : base()
		{
			RelatingOrganization = new IfcOrganization();
			RelatedOrganizations = new List<IfcOrganization>();
		}
		public IfcOrganizationRelationship(IfcLabel Name, IfcText Description, IfcOrganization RelatingOrganization, List<IfcOrganization> RelatedOrganizations) : base (Name, Description)
		{
			this.RelatingOrganization = RelatingOrganization;
			this.RelatedOrganizations = RelatedOrganizations;
		}
	}
	/// <summary>
	/// ENTITY IfcOrientedEdge
	/// <para>ENTITY IfcOrientedEdge</para>
	/// <para> SUBTYPE OF (IfcEdge);</para>
	/// <para>	EdgeElement : IfcEdge;</para>
	/// <para>	Orientation : IfcBoolean;</para>
	/// <para> DERIVE</para>
	/// <para>	SELF\IfcEdge.EdgeStart : IfcVertex := IfcBooleanChoose </para>
	/// <para>(Orientation, EdgeElement.EdgeStart, EdgeElement.EdgeEnd);</para>
	/// <para>	SELF\IfcEdge.EdgeEnd : IfcVertex := IfcBooleanChoose </para>
	/// <para>(Orientation, EdgeElement.EdgeEnd, EdgeElement.EdgeStart);</para>
	/// <para> WHERE</para>
	/// <para>	EdgeElementNotOriented : NOT('IFC4.IFCORIENTEDEDGE' IN TYPEOF(EdgeElement));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOrientedEdge : IfcEdge
	{
		public IfcEdge EdgeElement { get; set; }
		public IfcBoolean Orientation { get; set; }
		public IfcOrientedEdge() : base()
		{
			EdgeElement = new IfcEdge();
			Orientation = new IfcBoolean();
		}
		public IfcOrientedEdge(IfcVertex EdgeStart, IfcVertex EdgeEnd, IfcEdge EdgeElement, IfcBoolean Orientation) : base (EdgeStart, EdgeEnd)
		{
			this.EdgeElement = EdgeElement;
			this.Orientation = Orientation;
		}
	}
	/// <summary>
	/// ENTITY IfcOuterBoundaryCurve
	/// <para>ENTITY IfcOuterBoundaryCurve</para>
	/// <para> SUBTYPE OF (IfcBoundaryCurve);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOuterBoundaryCurve : IfcBoundaryCurve
	{
		public IfcOuterBoundaryCurve() : base()
		{
		}
		public IfcOuterBoundaryCurve(List<IfcCompositeCurveSegment> Segments, IfcLogical SelfIntersect) : base (Segments, SelfIntersect)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcOutlet
	/// <para>ENTITY IfcOutlet</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcOutletTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcOutletTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcOutletTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCOUTLETTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOutlet : IfcFlowTerminal
	{
		public IfcOutletTypeEnum? PredefinedType { get; set; }
		public IfcOutlet() : base()
		{
		}
		public IfcOutlet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcOutletTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOutletType
	/// <para>ENTITY IfcOutletType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcOutletTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcOutletTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcOutletTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOutletType : IfcFlowTerminalType
	{
		public IfcOutletTypeEnum PredefinedType { get; set; }
		public IfcOutletType() : base()
		{
			PredefinedType = new IfcOutletTypeEnum();
		}
		public IfcOutletType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcOutletTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOwnerHistory;
	/// <para>ENTITY IfcOwnerHistory;</para>
	/// <para>	OwningUser : IfcPersonAndOrganization;</para>
	/// <para>	OwningApplication : IfcApplication;</para>
	/// <para>	State : OPTIONAL IfcStateEnum;</para>
	/// <para>	ChangeAction : OPTIONAL IfcChangeActionEnum;</para>
	/// <para>	LastModifiedDate : OPTIONAL IfcTimeStamp;</para>
	/// <para>	LastModifyingUser : OPTIONAL IfcPersonAndOrganization;</para>
	/// <para>	LastModifyingApplication : OPTIONAL IfcApplication;</para>
	/// <para>	CreationDate : IfcTimeStamp;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectChangeAction : (EXISTS(LastModifiedDate)) OR</para>
	/// <para>(NOT(EXISTS(LastModifiedDate)) AND NOT(EXISTS(ChangeAction))) OR</para>
	/// <para>(NOT(EXISTS(LastModifiedDate)) AND EXISTS(ChangeAction) AND ((ChangeAction = IfcChangeActionEnum.NOTDEFINED) OR (ChangeAction = IfcChangeActionEnum.NOCHANGE)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOwnerHistory : ENTITY
	{
		public IfcPersonAndOrganization OwningUser { get; set; }
		public IfcApplication OwningApplication { get; set; }
		public IfcStateEnum? State { get; set; }
		public IfcChangeActionEnum? ChangeAction { get; set; }
		public IfcTimeStamp? LastModifiedDate { get; set; }
		public IfcPersonAndOrganization? LastModifyingUser { get; set; }
		public IfcApplication? LastModifyingApplication { get; set; }
		public IfcTimeStamp CreationDate { get; set; }
		public IfcOwnerHistory() : base()
		{
			OwningUser = new IfcPersonAndOrganization();
			OwningApplication = new IfcApplication();
			CreationDate = new IfcTimeStamp();
		}
		public IfcOwnerHistory(IfcPersonAndOrganization OwningUser, IfcApplication OwningApplication, IfcStateEnum State, IfcChangeActionEnum ChangeAction, IfcTimeStamp LastModifiedDate, IfcPersonAndOrganization LastModifyingUser, IfcApplication LastModifyingApplication, IfcTimeStamp CreationDate) : base ()
		{
			this.OwningUser = OwningUser;
			this.OwningApplication = OwningApplication;
			this.State = State;
			this.ChangeAction = ChangeAction;
			this.LastModifiedDate = LastModifiedDate;
			this.LastModifyingUser = LastModifyingUser;
			this.LastModifyingApplication = LastModifyingApplication;
			this.CreationDate = CreationDate;
		}
	}
	/// <summary>
	/// ENTITY IfcParameterizedProfileDef
	/// <para>ENTITY IfcParameterizedProfileDef</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAsymmetricIShapeProfileDef</para>
	/// <para>    ,IfcCShapeProfileDef</para>
	/// <para>    ,IfcCircleProfileDef</para>
	/// <para>    ,IfcEllipseProfileDef</para>
	/// <para>    ,IfcIShapeProfileDef</para>
	/// <para>    ,IfcLShapeProfileDef</para>
	/// <para>    ,IfcRectangleProfileDef</para>
	/// <para>    ,IfcTShapeProfileDef</para>
	/// <para>    ,IfcTrapeziumProfileDef</para>
	/// <para>    ,IfcUShapeProfileDef</para>
	/// <para>    ,IfcZShapeProfileDef))</para>
	/// <para> SUBTYPE OF (IfcProfileDef);</para>
	/// <para>	Position : OPTIONAL IfcAxis2Placement2D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcParameterizedProfileDef : IfcProfileDef
	{
		public IfcAxis2Placement2D? Position { get; set; }
		public IfcParameterizedProfileDef() : base()
		{
		}
		public IfcParameterizedProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position) : base (ProfileType, ProfileName)
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcPath
	/// <para>ENTITY IfcPath</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>	EdgeList : LIST [1:?] OF UNIQUE IfcOrientedEdge;</para>
	/// <para> WHERE</para>
	/// <para>	IsContinuous : IfcPathHeadToTail(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPath : IfcTopologicalRepresentationItem
	{
		public IfcPath() : base()
		{
		}
		public IfcPath() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPcurve
	/// <para>ENTITY IfcPcurve</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	BasisSurface : IfcSurface;</para>
	/// <para>	ReferenceCurve : IfcCurve;</para>
	/// <para> WHERE</para>
	/// <para>	DimIs2D : ReferenceCurve.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPcurve : IfcCurve, IfcCurveOnSurface
	{
		public IfcSurface BasisSurface { get; set; }
		public IfcCurve ReferenceCurve { get; set; }
		public IfcPcurve() : base()
		{
			BasisSurface = new IfcSurface();
			ReferenceCurve = new IfcCurve();
		}
		public IfcPcurve(IfcSurface BasisSurface, IfcCurve ReferenceCurve) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.ReferenceCurve = ReferenceCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcPerformanceHistory
	/// <para>ENTITY IfcPerformanceHistory</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	LifeCyclePhase : IfcLabel;</para>
	/// <para>	PredefinedType : OPTIONAL IfcPerformanceHistoryTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPerformanceHistory : IfcControl
	{
		public IfcLabel LifeCyclePhase { get; set; }
		public IfcPerformanceHistoryTypeEnum? PredefinedType { get; set; }
		public IfcPerformanceHistory() : base()
		{
			LifeCyclePhase = new IfcLabel();
		}
		public IfcPerformanceHistory(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcLabel LifeCyclePhase, IfcPerformanceHistoryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.LifeCyclePhase = LifeCyclePhase;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPermeableCoveringProperties
	/// <para>ENTITY IfcPermeableCoveringProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	OperationType : IfcPermeableCoveringOperationEnum;</para>
	/// <para>	PanelPosition : IfcWindowPanelPositionEnum;</para>
	/// <para>	FrameDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	FrameThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPermeableCoveringProperties : IfcPreDefinedPropertySet
	{
		public IfcPermeableCoveringOperationEnum OperationType { get; set; }
		public IfcWindowPanelPositionEnum PanelPosition { get; set; }
		public IfcPositiveLengthMeasure? FrameDepth { get; set; }
		public IfcPositiveLengthMeasure? FrameThickness { get; set; }
		public IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcPermeableCoveringProperties() : base()
		{
			OperationType = new IfcPermeableCoveringOperationEnum();
			PanelPosition = new IfcWindowPanelPositionEnum();
		}
		public IfcPermeableCoveringProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPermeableCoveringOperationEnum OperationType, IfcWindowPanelPositionEnum PanelPosition, IfcPositiveLengthMeasure FrameDepth, IfcPositiveLengthMeasure FrameThickness, IfcShapeAspect ShapeAspectStyle) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.OperationType = OperationType;
			this.PanelPosition = PanelPosition;
			this.FrameDepth = FrameDepth;
			this.FrameThickness = FrameThickness;
			this.ShapeAspectStyle = ShapeAspectStyle;
		}
	}
	/// <summary>
	/// ENTITY IfcPermit
	/// <para>ENTITY IfcPermit</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPermitTypeEnum;</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPermit : IfcControl
	{
		public IfcPermitTypeEnum? PredefinedType { get; set; }
		public IfcLabel? Status { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcPermit() : base()
		{
		}
		public IfcPermit(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcPermitTypeEnum PredefinedType, IfcLabel Status, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcPerson;
	/// <para>ENTITY IfcPerson;</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	FamilyName : OPTIONAL IfcLabel;</para>
	/// <para>	GivenName : OPTIONAL IfcLabel;</para>
	/// <para>	MiddleNames : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	PrefixTitles : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	SuffixTitles : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	Roles : OPTIONAL LIST [1:?] OF IfcActorRole;</para>
	/// <para>	Addresses : OPTIONAL LIST [1:?] OF IfcAddress;</para>
	/// <para> INVERSE</para>
	/// <para>	EngagedIn : SET [0:?] OF IfcPersonAndOrganization FOR ThePerson;</para>
	/// <para> WHERE</para>
	/// <para>	IdentifiablePerson : EXISTS(Identification) OR EXISTS(FamilyName) OR EXISTS(GivenName);</para>
	/// <para>	ValidSetOfNames : NOT EXISTS(MiddleNames) OR EXISTS(FamilyName) OR EXISTS(GivenName);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPerson : ENTITY, IfcActorSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcLabel? FamilyName { get; set; }
		public IfcLabel? GivenName { get; set; }
		public List<IfcLabel>? MiddleNames { get; set; }
		public List<IfcLabel>? PrefixTitles { get; set; }
		public List<IfcLabel>? SuffixTitles { get; set; }
		public List<IfcActorRole>? Roles { get; set; }
		public List<IfcAddress>? Addresses { get; set; }
		public IfcPerson() : base()
		{
		}
		public IfcPerson(IfcIdentifier Identification, IfcLabel FamilyName, IfcLabel GivenName, List<IfcLabel> MiddleNames, List<IfcLabel> PrefixTitles, List<IfcLabel> SuffixTitles, List<IfcActorRole> Roles, List<IfcAddress> Addresses) : base ()
		{
			this.Identification = Identification;
			this.FamilyName = FamilyName;
			this.GivenName = GivenName;
			this.MiddleNames = MiddleNames;
			this.PrefixTitles = PrefixTitles;
			this.SuffixTitles = SuffixTitles;
			this.Roles = Roles;
			this.Addresses = Addresses;
		}
	}
	/// <summary>
	/// ENTITY IfcPersonAndOrganization;
	/// <para>ENTITY IfcPersonAndOrganization;</para>
	/// <para>	ThePerson : IfcPerson;</para>
	/// <para>	TheOrganization : IfcOrganization;</para>
	/// <para>	Roles : OPTIONAL LIST [1:?] OF IfcActorRole;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPersonAndOrganization : ENTITY, IfcActorSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcPerson ThePerson { get; set; }
		public IfcOrganization TheOrganization { get; set; }
		public List<IfcActorRole>? Roles { get; set; }
		public IfcPersonAndOrganization() : base()
		{
			ThePerson = new IfcPerson();
			TheOrganization = new IfcOrganization();
		}
		public IfcPersonAndOrganization(IfcPerson ThePerson, IfcOrganization TheOrganization, List<IfcActorRole> Roles) : base ()
		{
			this.ThePerson = ThePerson;
			this.TheOrganization = TheOrganization;
			this.Roles = Roles;
		}
	}
	/// <summary>
	/// ENTITY IfcPhysicalComplexQuantity
	/// <para>ENTITY IfcPhysicalComplexQuantity</para>
	/// <para> SUBTYPE OF (IfcPhysicalQuantity);</para>
	/// <para>	HasQuantities : SET [1:?] OF IfcPhysicalQuantity;</para>
	/// <para>	Discrimination : IfcLabel;</para>
	/// <para>	Quality : OPTIONAL IfcLabel;</para>
	/// <para>	Usage : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(temp <* HasQuantities | SELF :=: temp)) = 0;</para>
	/// <para>	UniqueQuantityNames : IfcUniqueQuantityNames(HasQuantities);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPhysicalComplexQuantity : IfcPhysicalQuantity
	{
		public List<IfcPhysicalQuantity> HasQuantities { get; set; }
		public IfcLabel Discrimination { get; set; }
		public IfcLabel? Quality { get; set; }
		public IfcLabel? Usage { get; set; }
		public IfcPhysicalComplexQuantity() : base()
		{
			HasQuantities = new List<IfcPhysicalQuantity>();
			Discrimination = new IfcLabel();
		}
		public IfcPhysicalComplexQuantity(IfcLabel Name, IfcText Description, List<IfcPhysicalQuantity> HasQuantities, IfcLabel Discrimination, IfcLabel Quality, IfcLabel Usage) : base (Name, Description)
		{
			this.HasQuantities = HasQuantities;
			this.Discrimination = Discrimination;
			this.Quality = Quality;
			this.Usage = Usage;
		}
	}
	/// <summary>
	/// ENTITY IfcPhysicalQuantity
	/// <para>ENTITY IfcPhysicalQuantity</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPhysicalComplexQuantity</para>
	/// <para>    ,IfcPhysicalSimpleQuantity));</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>	PartOfComplex : SET [0:1] OF IfcPhysicalComplexQuantity FOR HasQuantities;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPhysicalQuantity : ENTITY, IfcResourceObjectSelect
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcPhysicalQuantity() : base()
		{
			Name = new IfcLabel();
		}
		public IfcPhysicalQuantity(IfcLabel Name, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcPhysicalSimpleQuantity
	/// <para>ENTITY IfcPhysicalSimpleQuantity</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcQuantityArea</para>
	/// <para>    ,IfcQuantityCount</para>
	/// <para>    ,IfcQuantityLength</para>
	/// <para>    ,IfcQuantityTime</para>
	/// <para>    ,IfcQuantityVolume</para>
	/// <para>    ,IfcQuantityWeight))</para>
	/// <para> SUBTYPE OF (IfcPhysicalQuantity);</para>
	/// <para>	Unit : OPTIONAL IfcNamedUnit;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPhysicalSimpleQuantity : IfcPhysicalQuantity
	{
		public IfcNamedUnit? Unit { get; set; }
		public IfcPhysicalSimpleQuantity() : base()
		{
		}
		public IfcPhysicalSimpleQuantity(IfcLabel Name, IfcText Description, IfcNamedUnit Unit) : base (Name, Description)
		{
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcPile
	/// <para>ENTITY IfcPile</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPileTypeEnum;</para>
	/// <para>	ConstructionType : OPTIONAL IfcPileConstructionEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT EXISTS(PredefinedType) OR</para>
	/// <para>(PredefinedType <> IfcPileTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPileTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4.IFCPILETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPile : IfcBuildingElement
	{
		public IfcPileTypeEnum? PredefinedType { get; set; }
		public IfcPileConstructionEnum? ConstructionType { get; set; }
		public IfcPile() : base()
		{
		}
		public IfcPile(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPileTypeEnum PredefinedType, IfcPileConstructionEnum ConstructionType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
			this.ConstructionType = ConstructionType;
		}
	}
	/// <summary>
	/// ENTITY IfcPileType
	/// <para>ENTITY IfcPileType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcPileTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPileTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPileTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPileType : IfcBuildingElementType
	{
		public IfcPileTypeEnum PredefinedType { get; set; }
		public IfcPileType() : base()
		{
			PredefinedType = new IfcPileTypeEnum();
		}
		public IfcPileType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPileTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeFitting
	/// <para>ENTITY IfcPipeFitting</para>
	/// <para> SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPipeFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcPipeFittingTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcPipeFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCPIPEFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeFitting : IfcFlowFitting
	{
		public IfcPipeFittingTypeEnum? PredefinedType { get; set; }
		public IfcPipeFitting() : base()
		{
		}
		public IfcPipeFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPipeFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeFittingType
	/// <para>ENTITY IfcPipeFittingType</para>
	/// <para> SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>	PredefinedType : IfcPipeFittingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPipeFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPipeFittingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeFittingType : IfcFlowFittingType
	{
		public IfcPipeFittingTypeEnum PredefinedType { get; set; }
		public IfcPipeFittingType() : base()
		{
			PredefinedType = new IfcPipeFittingTypeEnum();
		}
		public IfcPipeFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPipeFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeSegment
	/// <para>ENTITY IfcPipeSegment</para>
	/// <para> SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPipeSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcPipeSegmentTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcPipeSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCPIPESEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeSegment : IfcFlowSegment
	{
		public IfcPipeSegmentTypeEnum? PredefinedType { get; set; }
		public IfcPipeSegment() : base()
		{
		}
		public IfcPipeSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPipeSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeSegmentType
	/// <para>ENTITY IfcPipeSegmentType</para>
	/// <para> SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>	PredefinedType : IfcPipeSegmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPipeSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPipeSegmentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeSegmentType : IfcFlowSegmentType
	{
		public IfcPipeSegmentTypeEnum PredefinedType { get; set; }
		public IfcPipeSegmentType() : base()
		{
			PredefinedType = new IfcPipeSegmentTypeEnum();
		}
		public IfcPipeSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPipeSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPixelTexture
	/// <para>ENTITY IfcPixelTexture</para>
	/// <para> SUBTYPE OF (IfcSurfaceTexture);</para>
	/// <para>	Width : IfcInteger;</para>
	/// <para>	Height : IfcInteger;</para>
	/// <para>	ColourComponents : IfcInteger;</para>
	/// <para>	Pixel : LIST [1:?] OF IfcBinary;</para>
	/// <para> WHERE</para>
	/// <para>	MinPixelInS : Width >= 1;</para>
	/// <para>	MinPixelInT : Height >= 1;</para>
	/// <para>	NumberOfColours : {1 <= ColourComponents <= 4};</para>
	/// <para>	SizeOfPixelList : SIZEOF(Pixel) = (Width * Height);</para>
	/// <para>	PixelAsByteAndSameLength : SIZEOF(QUERY(temp<* Pixel |</para>
	/// <para> (BLENGTH(temp) MOD 8 = 0) AND</para>
	/// <para> (BLENGTH(temp) = BLENGTH(Pixel[1]))</para>
	/// <para>)) = SIZEOF(Pixel);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPixelTexture : IfcSurfaceTexture
	{
		public IfcInteger Width { get; set; }
		public IfcInteger Height { get; set; }
		public IfcInteger ColourComponents { get; set; }
		public List<IfcBinary> Pixel { get; set; }
		public IfcPixelTexture() : base()
		{
			Width = new IfcInteger();
			Height = new IfcInteger();
			ColourComponents = new IfcInteger();
			Pixel = new List<IfcBinary>();
		}
		public IfcPixelTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter, IfcInteger Width, IfcInteger Height, IfcInteger ColourComponents, List<IfcBinary> Pixel) : base (RepeatS, RepeatT, Mode, TextureTransform, Parameter)
		{
			this.Width = Width;
			this.Height = Height;
			this.ColourComponents = ColourComponents;
			this.Pixel = Pixel;
		}
	}
	/// <summary>
	/// ENTITY IfcPlacement
	/// <para>ENTITY IfcPlacement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAxis1Placement</para>
	/// <para>    ,IfcAxis2Placement2D</para>
	/// <para>    ,IfcAxis2Placement3D))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Location : IfcCartesianPoint;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := Location.Dim;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPlacement : IfcGeometricRepresentationItem
	{
		public IfcCartesianPoint Location { get; set; }
		public IfcPlacement() : base()
		{
			Location = new IfcCartesianPoint();
		}
		public IfcPlacement(IfcCartesianPoint Location) : base ()
		{
			this.Location = Location;
		}
	}
	/// <summary>
	/// ENTITY IfcPlanarBox
	/// <para>ENTITY IfcPlanarBox</para>
	/// <para> SUBTYPE OF (IfcPlanarExtent);</para>
	/// <para>	Placement : IfcAxis2Placement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlanarBox : IfcPlanarExtent
	{
		public IfcAxis2Placement Placement { get; set; }
		public IfcPlanarBox() : base()
		{
			Placement = new IfcAxis2Placement();
		}
		public IfcPlanarBox(IfcLengthMeasure SizeInX, IfcLengthMeasure SizeInY, IfcAxis2Placement Placement) : base (SizeInX, SizeInY)
		{
			this.Placement = Placement;
		}
	}
	/// <summary>
	/// ENTITY IfcPlanarExtent
	/// <para>ENTITY IfcPlanarExtent</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPlanarBox))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	SizeInX : IfcLengthMeasure;</para>
	/// <para>	SizeInY : IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlanarExtent : IfcGeometricRepresentationItem
	{
		public IfcLengthMeasure SizeInX { get; set; }
		public IfcLengthMeasure SizeInY { get; set; }
		public IfcPlanarExtent() : base()
		{
			SizeInX = new IfcLengthMeasure();
			SizeInY = new IfcLengthMeasure();
		}
		public IfcPlanarExtent(IfcLengthMeasure SizeInX, IfcLengthMeasure SizeInY) : base ()
		{
			this.SizeInX = SizeInX;
			this.SizeInY = SizeInY;
		}
	}
	/// <summary>
	/// ENTITY IfcPlane
	/// <para>ENTITY IfcPlane</para>
	/// <para> SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlane : IfcElementarySurface
	{
		public IfcPlane() : base()
		{
		}
		public IfcPlane(IfcAxis2Placement3D Position) : base (Position)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPlate
	/// <para>ENTITY IfcPlate</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPlateStandardCase))</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPlateTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcPlateTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcPlateTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCPLATETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlate : IfcBuildingElement
	{
		public IfcPlateTypeEnum? PredefinedType { get; set; }
		public IfcPlate() : base()
		{
		}
		public IfcPlate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPlateTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPlateStandardCase
	/// <para>ENTITY IfcPlateStandardCase</para>
	/// <para> SUBTYPE OF (IfcPlate);</para>
	/// <para> WHERE</para>
	/// <para>	HasMaterialLayerSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>              ('IFC4.IFCMATERIALLAYERSETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>              )) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlateStandardCase : IfcPlate
	{
		public IfcPlateStandardCase() : base()
		{
		}
		public IfcPlateStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPlateTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPlateType
	/// <para>ENTITY IfcPlateType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcPlateTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPlateTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPlateTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlateType : IfcBuildingElementType
	{
		public IfcPlateTypeEnum PredefinedType { get; set; }
		public IfcPlateType() : base()
		{
			PredefinedType = new IfcPlateTypeEnum();
		}
		public IfcPlateType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPlateTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPoint
	/// <para>ENTITY IfcPoint</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCartesianPoint</para>
	/// <para>    ,IfcPointOnCurve</para>
	/// <para>    ,IfcPointOnSurface))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPoint : IfcGeometricRepresentationItem, IfcGeometricSetSelect, IfcPointOrVertexPoint
	{
		public IfcPoint() : base()
		{
		}
		public IfcPoint() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPointOnCurve
	/// <para>ENTITY IfcPointOnCurve</para>
	/// <para> SUBTYPE OF (IfcPoint);</para>
	/// <para>	BasisCurve : IfcCurve;</para>
	/// <para>	PointParameter : IfcParameterValue;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := BasisCurve.Dim;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPointOnCurve : IfcPoint
	{
		public IfcCurve BasisCurve { get; set; }
		public IfcParameterValue PointParameter { get; set; }
		public IfcPointOnCurve() : base()
		{
			BasisCurve = new IfcCurve();
			PointParameter = new IfcParameterValue();
		}
		public IfcPointOnCurve(IfcCurve BasisCurve, IfcParameterValue PointParameter) : base ()
		{
			this.BasisCurve = BasisCurve;
			this.PointParameter = PointParameter;
		}
	}
	/// <summary>
	/// ENTITY IfcPointOnSurface
	/// <para>ENTITY IfcPointOnSurface</para>
	/// <para> SUBTYPE OF (IfcPoint);</para>
	/// <para>	BasisSurface : IfcSurface;</para>
	/// <para>	PointParameterU : IfcParameterValue;</para>
	/// <para>	PointParameterV : IfcParameterValue;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := BasisSurface.Dim;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPointOnSurface : IfcPoint
	{
		public IfcSurface BasisSurface { get; set; }
		public IfcParameterValue PointParameterU { get; set; }
		public IfcParameterValue PointParameterV { get; set; }
		public IfcPointOnSurface() : base()
		{
			BasisSurface = new IfcSurface();
			PointParameterU = new IfcParameterValue();
			PointParameterV = new IfcParameterValue();
		}
		public IfcPointOnSurface(IfcSurface BasisSurface, IfcParameterValue PointParameterU, IfcParameterValue PointParameterV) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.PointParameterU = PointParameterU;
			this.PointParameterV = PointParameterV;
		}
	}
	/// <summary>
	/// ENTITY IfcPolyLoop
	/// <para>ENTITY IfcPolyLoop</para>
	/// <para> SUBTYPE OF (IfcLoop);</para>
	/// <para>	Polygon : LIST [3:?] OF UNIQUE IfcCartesianPoint;</para>
	/// <para> WHERE</para>
	/// <para>	AllPointsSameDim : SIZEOF(QUERY(Temp <* Polygon | Temp.Dim <> Polygon[1].Dim)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolyLoop : IfcLoop
	{
		public IfcPolyLoop() : base()
		{
		}
		public IfcPolyLoop() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPolygonalBoundedHalfSpace
	/// <para>ENTITY IfcPolygonalBoundedHalfSpace</para>
	/// <para> SUBTYPE OF (IfcHalfSpaceSolid);</para>
	/// <para>	Position : IfcAxis2Placement3D;</para>
	/// <para>	PolygonalBoundary : IfcBoundedCurve;</para>
	/// <para> WHERE</para>
	/// <para>	BoundaryDim : PolygonalBoundary.Dim = 2;</para>
	/// <para>	BoundaryType : SIZEOF(TYPEOF(PolygonalBoundary) * [</para>
	/// <para>  'IFC4.IFCPOLYLINE', </para>
	/// <para>  'IFC4.IFCCOMPOSITECURVE']</para>
	/// <para>) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolygonalBoundedHalfSpace : IfcHalfSpaceSolid
	{
		public IfcAxis2Placement3D Position { get; set; }
		public IfcBoundedCurve PolygonalBoundary { get; set; }
		public IfcPolygonalBoundedHalfSpace() : base()
		{
			Position = new IfcAxis2Placement3D();
			PolygonalBoundary = new IfcBoundedCurve();
		}
		public IfcPolygonalBoundedHalfSpace(IfcSurface BaseSurface, IfcBoolean AgreementFlag, IfcAxis2Placement3D Position, IfcBoundedCurve PolygonalBoundary) : base (BaseSurface, AgreementFlag)
		{
			this.Position = Position;
			this.PolygonalBoundary = PolygonalBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcPolygonalFaceSet
	/// <para>ENTITY IfcPolygonalFaceSet</para>
	/// <para> SUBTYPE OF (IfcTessellatedFaceSet);</para>
	/// <para>	Closed : OPTIONAL IfcBoolean;</para>
	/// <para>	Faces : LIST [1:?] OF IfcIndexedPolygonalFace;</para>
	/// <para>	PnIndex : OPTIONAL LIST [1:?] OF IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolygonalFaceSet : IfcTessellatedFaceSet
	{
		public IfcBoolean? Closed { get; set; }
		public List<IfcIndexedPolygonalFace> Faces { get; set; }
		public List<IfcPositiveInteger>? PnIndex { get; set; }
		public IfcPolygonalFaceSet() : base()
		{
			Faces = new List<IfcIndexedPolygonalFace>();
		}
		public IfcPolygonalFaceSet(IfcCartesianPointList3D Coordinates, IfcBoolean Closed, List<IfcIndexedPolygonalFace> Faces, List<IfcPositiveInteger> PnIndex) : base (Coordinates)
		{
			this.Closed = Closed;
			this.Faces = Faces;
			this.PnIndex = PnIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcPolyline
	/// <para>ENTITY IfcPolyline</para>
	/// <para> SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>	Points : LIST [2:?] OF IfcCartesianPoint;</para>
	/// <para> WHERE</para>
	/// <para>	SameDim : SIZEOF(QUERY(Temp <* Points | Temp.Dim <> Points[1].Dim)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolyline : IfcBoundedCurve
	{
		public List<IfcCartesianPoint> Points { get; set; }
		public IfcPolyline() : base()
		{
			Points = new List<IfcCartesianPoint>();
		}
		public IfcPolyline(List<IfcCartesianPoint> Points) : base ()
		{
			this.Points = Points;
		}
	}
	/// <summary>
	/// ENTITY IfcPort
	/// <para>ENTITY IfcPort</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDistributionPort))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para> INVERSE</para>
	/// <para>	ContainedIn : SET [0:1] OF IfcRelConnectsPortToElement FOR RelatingPort;</para>
	/// <para>	ConnectedFrom : SET [0:1] OF IfcRelConnectsPorts FOR RelatedPort;</para>
	/// <para>	ConnectedTo : SET [0:1] OF IfcRelConnectsPorts FOR RelatingPort;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPort : IfcProduct
	{
		public IfcPort() : base()
		{
		}
		public IfcPort(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPostalAddress
	/// <para>ENTITY IfcPostalAddress</para>
	/// <para> SUBTYPE OF (IfcAddress);</para>
	/// <para>	InternalLocation : OPTIONAL IfcLabel;</para>
	/// <para>	AddressLines : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	PostalBox : OPTIONAL IfcLabel;</para>
	/// <para>	Town : OPTIONAL IfcLabel;</para>
	/// <para>	Region : OPTIONAL IfcLabel;</para>
	/// <para>	PostalCode : OPTIONAL IfcLabel;</para>
	/// <para>	Country : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : EXISTS (InternalLocation) OR </para>
	/// <para>EXISTS (AddressLines) OR</para>
	/// <para>EXISTS (PostalBox) OR</para>
	/// <para>EXISTS (PostalCode) OR</para>
	/// <para>EXISTS (Town) OR </para>
	/// <para>EXISTS (Region) OR  </para>
	/// <para>EXISTS (Country);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPostalAddress : IfcAddress
	{
		public IfcLabel? InternalLocation { get; set; }
		public List<IfcLabel>? AddressLines { get; set; }
		public IfcLabel? PostalBox { get; set; }
		public IfcLabel? Town { get; set; }
		public IfcLabel? Region { get; set; }
		public IfcLabel? PostalCode { get; set; }
		public IfcLabel? Country { get; set; }
		public IfcPostalAddress() : base()
		{
		}
		public IfcPostalAddress(IfcAddressTypeEnum Purpose, IfcText Description, IfcLabel UserDefinedPurpose, IfcLabel InternalLocation, List<IfcLabel> AddressLines, IfcLabel PostalBox, IfcLabel Town, IfcLabel Region, IfcLabel PostalCode, IfcLabel Country) : base (Purpose, Description, UserDefinedPurpose)
		{
			this.InternalLocation = InternalLocation;
			this.AddressLines = AddressLines;
			this.PostalBox = PostalBox;
			this.Town = Town;
			this.Region = Region;
			this.PostalCode = PostalCode;
			this.Country = Country;
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedColour
	/// <para>ENTITY IfcPreDefinedColour</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDraughtingPreDefinedColour))</para>
	/// <para> SUBTYPE OF (IfcPreDefinedItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedColour : IfcPreDefinedItem, IfcColour
	{
		public IfcPreDefinedColour() : base()
		{
		}
		public IfcPreDefinedColour(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedCurveFont
	/// <para>ENTITY IfcPreDefinedCurveFont</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDraughtingPreDefinedCurveFont))</para>
	/// <para> SUBTYPE OF (IfcPreDefinedItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedCurveFont : IfcPreDefinedItem, IfcCurveStyleFontSelect
	{
		public IfcPreDefinedCurveFont() : base()
		{
		}
		public IfcPreDefinedCurveFont(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedItem
	/// <para>ENTITY IfcPreDefinedItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPreDefinedColour</para>
	/// <para>    ,IfcPreDefinedCurveFont</para>
	/// <para>    ,IfcPreDefinedTextFont))</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedItem : IfcPresentationItem
	{
		public IfcLabel Name { get; set; }
		public IfcPreDefinedItem() : base()
		{
			Name = new IfcLabel();
		}
		public IfcPreDefinedItem(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedProperties
	/// <para>ENTITY IfcPreDefinedProperties</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcReinforcementBarProperties</para>
	/// <para>    ,IfcSectionProperties</para>
	/// <para>    ,IfcSectionReinforcementProperties))</para>
	/// <para> SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedProperties : IfcPropertyAbstraction
	{
		public IfcPreDefinedProperties() : base()
		{
		}
		public IfcPreDefinedProperties() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedPropertySet
	/// <para>ENTITY IfcPreDefinedPropertySet</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDoorLiningProperties</para>
	/// <para>    ,IfcDoorPanelProperties</para>
	/// <para>    ,IfcPermeableCoveringProperties</para>
	/// <para>    ,IfcReinforcementDefinitionProperties</para>
	/// <para>    ,IfcWindowLiningProperties</para>
	/// <para>    ,IfcWindowPanelProperties))</para>
	/// <para> SUBTYPE OF (IfcPropertySetDefinition);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedPropertySet : IfcPropertySetDefinition
	{
		public IfcPreDefinedPropertySet() : base()
		{
		}
		public IfcPreDefinedPropertySet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedTextFont
	/// <para>ENTITY IfcPreDefinedTextFont</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcTextStyleFontModel))</para>
	/// <para> SUBTYPE OF (IfcPreDefinedItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedTextFont : IfcPreDefinedItem, IfcTextFontSelect
	{
		public IfcPreDefinedTextFont() : base()
		{
		}
		public IfcPreDefinedTextFont(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationItem
	/// <para>ENTITY IfcPresentationItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcColourRgbList</para>
	/// <para>    ,IfcColourSpecification</para>
	/// <para>    ,IfcCurveStyleFont</para>
	/// <para>    ,IfcCurveStyleFontAndScaling</para>
	/// <para>    ,IfcCurveStyleFontPattern</para>
	/// <para>    ,IfcIndexedColourMap</para>
	/// <para>    ,IfcPreDefinedItem</para>
	/// <para>    ,IfcSurfaceStyleLighting</para>
	/// <para>    ,IfcSurfaceStyleRefraction</para>
	/// <para>    ,IfcSurfaceStyleShading</para>
	/// <para>    ,IfcSurfaceStyleWithTextures</para>
	/// <para>    ,IfcSurfaceTexture</para>
	/// <para>    ,IfcTextStyleForDefinedFont</para>
	/// <para>    ,IfcTextStyleTextModel</para>
	/// <para>    ,IfcTextureCoordinate</para>
	/// <para>    ,IfcTextureVertex</para>
	/// <para>    ,IfcTextureVertexList));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPresentationItem : ENTITY
	{
		public IfcPresentationItem() : base()
		{
		}
		public IfcPresentationItem() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationLayerAssignment
	/// <para>ENTITY IfcPresentationLayerAssignment</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPresentationLayerWithStyle));</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	AssignedItems : SET [1:?] OF IfcLayeredItem;</para>
	/// <para>	Identifier : OPTIONAL IfcIdentifier;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableItems : SIZEOF(QUERY(temp <* AssignedItems | (</para>
	/// <para>  SIZEOF(TYPEOF(temp) * [</para>
	/// <para>    'IFC4.IFCSHAPEREPRESENTATION',</para>
	/// <para>    'IFC4.IFCGEOMETRICREPRESENTATIONITEM',</para>
	/// <para>    'IFC4.IFCMAPPEDITEM']) = 1)</para>
	/// <para>)) = SIZEOF(AssignedItems);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPresentationLayerAssignment : ENTITY
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcLayeredItem> AssignedItems { get; set; }
		public IfcIdentifier? Identifier { get; set; }
		public IfcPresentationLayerAssignment() : base()
		{
			Name = new IfcLabel();
			AssignedItems = new List<IfcLayeredItem>();
		}
		public IfcPresentationLayerAssignment(IfcLabel Name, IfcText Description, List<IfcLayeredItem> AssignedItems, IfcIdentifier Identifier) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.AssignedItems = AssignedItems;
			this.Identifier = Identifier;
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationLayerWithStyle
	/// <para>ENTITY IfcPresentationLayerWithStyle</para>
	/// <para> SUBTYPE OF (IfcPresentationLayerAssignment);</para>
	/// <para>	LayerOn : IfcLogical;</para>
	/// <para>	LayerFrozen : IfcLogical;</para>
	/// <para>	LayerBlocked : IfcLogical;</para>
	/// <para>	LayerStyles : SET [0:?] OF IfcPresentationStyle;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableOnlyToItems : SIZEOF(QUERY(temp <* AssignedItems | (</para>
	/// <para>  SIZEOF(TYPEOF(temp) * [</para>
	/// <para>    'IFC4.IFCGEOMETRICREPRESENTATIONITEM',</para>
	/// <para>    'IFC4.IFCMAPPEDITEM']) = 1)</para>
	/// <para>)) = SIZEOF(AssignedItems);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPresentationLayerWithStyle : IfcPresentationLayerAssignment
	{
		public IfcLogical LayerOn { get; set; }
		public IfcLogical LayerFrozen { get; set; }
		public IfcLogical LayerBlocked { get; set; }
		public List<IfcPresentationStyle> LayerStyles { get; set; }
		public IfcPresentationLayerWithStyle() : base()
		{
			LayerOn = new IfcLogical();
			LayerFrozen = new IfcLogical();
			LayerBlocked = new IfcLogical();
			LayerStyles = new List<IfcPresentationStyle>();
		}
		public IfcPresentationLayerWithStyle(IfcLabel Name, IfcText Description, List<IfcLayeredItem> AssignedItems, IfcIdentifier Identifier, IfcLogical LayerOn, IfcLogical LayerFrozen, IfcLogical LayerBlocked, List<IfcPresentationStyle> LayerStyles) : base (Name, Description, AssignedItems, Identifier)
		{
			this.LayerOn = LayerOn;
			this.LayerFrozen = LayerFrozen;
			this.LayerBlocked = LayerBlocked;
			this.LayerStyles = LayerStyles;
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationStyle
	/// <para>ENTITY IfcPresentationStyle</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCurveStyle</para>
	/// <para>    ,IfcFillAreaStyle</para>
	/// <para>    ,IfcSurfaceStyle</para>
	/// <para>    ,IfcTextStyle));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPresentationStyle : ENTITY, IfcStyleAssignmentSelect
	{
		public IfcLabel? Name { get; set; }
		public IfcPresentationStyle() : base()
		{
		}
		public IfcPresentationStyle(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationStyleAssignment;
	/// <para>ENTITY IfcPresentationStyleAssignment;</para>
	/// <para>	Styles : SET [1:?] OF IfcPresentationStyleSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPresentationStyleAssignment : ENTITY, IfcStyleAssignmentSelect
	{
		public List<IfcPresentationStyleSelect> Styles { get; set; }
		public IfcPresentationStyleAssignment() : base()
		{
			Styles = new List<IfcPresentationStyleSelect>();
		}
		public IfcPresentationStyleAssignment(List<IfcPresentationStyleSelect> Styles) : base ()
		{
			this.Styles = Styles;
		}
	}
	/// <summary>
	/// ENTITY IfcProcedure
	/// <para>ENTITY IfcProcedure</para>
	/// <para> SUBTYPE OF (IfcProcess);</para>
	/// <para>	PredefinedType : OPTIONAL IfcProcedureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcProcedureTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcProcedureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProcedure : IfcProcess
	{
		public IfcProcedureTypeEnum? PredefinedType { get; set; }
		public IfcProcedure() : base()
		{
		}
		public IfcProcedure(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcProcedureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProcedureType
	/// <para>ENTITY IfcProcedureType</para>
	/// <para> SUBTYPE OF (IfcTypeProcess);</para>
	/// <para>	PredefinedType : IfcProcedureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcProcedureTypeEnum.USERDEFINED) OR ((PredefinedType = IfcProcedureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProcedureType : IfcTypeProcess
	{
		public IfcProcedureTypeEnum PredefinedType { get; set; }
		public IfcProcedureType() : base()
		{
			PredefinedType = new IfcProcedureTypeEnum();
		}
		public IfcProcedureType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType, IfcProcedureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProcess
	/// <para>ENTITY IfcProcess</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcEvent</para>
	/// <para>    ,IfcProcedure</para>
	/// <para>    ,IfcTask))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	IsPredecessorTo : SET [0:?] OF IfcRelSequence FOR RelatingProcess;</para>
	/// <para>	IsSuccessorFrom : SET [0:?] OF IfcRelSequence FOR RelatedProcess;</para>
	/// <para>	OperatesOn : SET [0:?] OF IfcRelAssignsToProcess FOR RelatingProcess;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProcess : IfcObject, IfcProcessSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcProcess() : base()
		{
		}
		public IfcProcess(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcProduct
	/// <para>ENTITY IfcProduct</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcAnnotation</para>
	/// <para>    ,IfcElement</para>
	/// <para>    ,IfcGrid</para>
	/// <para>    ,IfcPort</para>
	/// <para>    ,IfcProxy</para>
	/// <para>    ,IfcSpatialElement</para>
	/// <para>    ,IfcStructuralActivity</para>
	/// <para>    ,IfcStructuralItem))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para>	ObjectPlacement : OPTIONAL IfcObjectPlacement;</para>
	/// <para>	Representation : OPTIONAL IfcProductRepresentation;</para>
	/// <para> INVERSE</para>
	/// <para>	ReferencedBy : SET [0:?] OF IfcRelAssignsToProduct FOR RelatingProduct;</para>
	/// <para> WHERE</para>
	/// <para>	PlacementForShapeRepresentation : (EXISTS(Representation) AND EXISTS(ObjectPlacement))</para>
	/// <para>            OR (EXISTS(Representation) AND </para>
	/// <para>			   (SIZEOF(QUERY(temp <* Representation.Representations | 'IFC4.IFCSHAPEREPRESENTATION' IN TYPEOF(temp))) = 0))</para>
	/// <para>            OR (NOT(EXISTS(Representation)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProduct : IfcObject, IfcProductSelect
	{
		public IfcObjectPlacement? ObjectPlacement { get; set; }
		public IfcProductRepresentation? Representation { get; set; }
		public IfcProduct() : base()
		{
		}
		public IfcProduct(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.ObjectPlacement = ObjectPlacement;
			this.Representation = Representation;
		}
	}
	/// <summary>
	/// ENTITY IfcProductDefinitionShape
	/// <para>ENTITY IfcProductDefinitionShape</para>
	/// <para> SUBTYPE OF (IfcProductRepresentation);</para>
	/// <para> INVERSE</para>
	/// <para>	ShapeOfProduct : SET [1:?] OF IfcProduct FOR Representation;</para>
	/// <para>	HasShapeAspects : SET [0:?] OF IfcShapeAspect FOR PartOfProductDefinitionShape;</para>
	/// <para> WHERE</para>
	/// <para>	OnlyShapeModel : SIZEOF(QUERY(temp <* Representations | </para>
	/// <para>  (NOT('IFC4.IFCSHAPEMODEL' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProductDefinitionShape : IfcProductRepresentation, IfcProductRepresentationSelect
	{
		public IfcProductDefinitionShape() : base()
		{
		}
		public IfcProductDefinitionShape(IfcLabel Name, IfcText Description, List<IfcRepresentation> Representations) : base (Name, Description, Representations)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProductRepresentation
	/// <para>ENTITY IfcProductRepresentation</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcMaterialDefinitionRepresentation</para>
	/// <para>    ,IfcProductDefinitionShape));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Representations : LIST [1:?] OF IfcRepresentation;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProductRepresentation : ENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public List<IfcRepresentation> Representations { get; set; }
		public IfcProductRepresentation() : base()
		{
			Representations = new List<IfcRepresentation>();
		}
		public IfcProductRepresentation(IfcLabel Name, IfcText Description, List<IfcRepresentation> Representations) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Representations = Representations;
		}
	}
	/// <summary>
	/// ENTITY IfcProfileDef
	/// <para>ENTITY IfcProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcArbitraryClosedProfileDef</para>
	/// <para>    ,IfcArbitraryOpenProfileDef</para>
	/// <para>    ,IfcCompositeProfileDef</para>
	/// <para>    ,IfcDerivedProfileDef</para>
	/// <para>    ,IfcParameterizedProfileDef));</para>
	/// <para>	ProfileType : IfcProfileTypeEnum;</para>
	/// <para>	ProfileName : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>	HasProperties : SET [0:?] OF IfcProfileProperties FOR ProfileDefinition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProfileDef : ENTITY, IfcResourceObjectSelect
	{
		public IfcProfileTypeEnum ProfileType { get; set; }
		public IfcLabel? ProfileName { get; set; }
		public IfcProfileDef() : base()
		{
			ProfileType = new IfcProfileTypeEnum();
		}
		public IfcProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName) : base ()
		{
			this.ProfileType = ProfileType;
			this.ProfileName = ProfileName;
		}
	}
	/// <summary>
	/// ENTITY IfcProfileProperties
	/// <para>ENTITY IfcProfileProperties</para>
	/// <para> SUBTYPE OF (IfcExtendedProperties);</para>
	/// <para>	ProfileDefinition : IfcProfileDef;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProfileProperties : IfcExtendedProperties
	{
		public IfcProfileDef ProfileDefinition { get; set; }
		public IfcProfileProperties() : base()
		{
			ProfileDefinition = new IfcProfileDef();
		}
		public IfcProfileProperties(IfcIdentifier Name, IfcText Description, List<IfcProperty> Properties, IfcProfileDef ProfileDefinition) : base (Name, Description, Properties)
		{
			this.ProfileDefinition = ProfileDefinition;
		}
	}
	/// <summary>
	/// ENTITY IfcProject
	/// <para>ENTITY IfcProject</para>
	/// <para> SUBTYPE OF (IfcContext);</para>
	/// <para> WHERE</para>
	/// <para>	HasName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	CorrectContext : NOT(EXISTS(SELF\IfcContext.RepresentationContexts)) OR</para>
	/// <para>(SIZEOF(QUERY(Temp <* SELF\IfcContext.RepresentationContexts |</para>
	/// <para> 'IFC4.IFCGEOMETRICREPRESENTATIONSUBCONTEXT' IN TYPEOF(Temp)</para>
	/// <para>  )) = 0);</para>
	/// <para>	NoDecomposition : SIZEOF(SELF\IfcObjectDefinition.Decomposes) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProject : IfcContext
	{
		public IfcProject() : base()
		{
		}
		public IfcProject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcLabel Phase, List<IfcRepresentationContext> RepresentationContexts, IfcUnitAssignment UnitsInContext) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProjectLibrary
	/// <para>ENTITY IfcProjectLibrary</para>
	/// <para> SUBTYPE OF (IfcContext);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectLibrary : IfcContext
	{
		public IfcProjectLibrary() : base()
		{
		}
		public IfcProjectLibrary(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcLabel Phase, List<IfcRepresentationContext> RepresentationContexts, IfcUnitAssignment UnitsInContext) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProjectOrder
	/// <para>ENTITY IfcProjectOrder</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcProjectOrderTypeEnum;</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectOrder : IfcControl
	{
		public IfcProjectOrderTypeEnum? PredefinedType { get; set; }
		public IfcLabel? Status { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcProjectOrder() : base()
		{
		}
		public IfcProjectOrder(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcProjectOrderTypeEnum PredefinedType, IfcLabel Status, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcProjectedCRS
	/// <para>ENTITY IfcProjectedCRS</para>
	/// <para> SUBTYPE OF (IfcCoordinateReferenceSystem);</para>
	/// <para>	MapProjection : OPTIONAL IfcIdentifier;</para>
	/// <para>	MapZone : OPTIONAL IfcIdentifier;</para>
	/// <para>	MapUnit : OPTIONAL IfcNamedUnit;</para>
	/// <para> WHERE</para>
	/// <para>	IsLengthUnit : NOT(EXISTS(MapUnit)) OR (MapUnit.UnitType = IfcUnitEnum.LENGTHUNIT);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectedCRS : IfcCoordinateReferenceSystem
	{
		public IfcIdentifier? MapProjection { get; set; }
		public IfcIdentifier? MapZone { get; set; }
		public IfcNamedUnit? MapUnit { get; set; }
		public IfcProjectedCRS() : base()
		{
		}
		public IfcProjectedCRS(IfcLabel Name, IfcText Description, IfcIdentifier GeodeticDatum, IfcIdentifier VerticalDatum, IfcIdentifier MapProjection, IfcIdentifier MapZone, IfcNamedUnit MapUnit) : base (Name, Description, GeodeticDatum, VerticalDatum)
		{
			this.MapProjection = MapProjection;
			this.MapZone = MapZone;
			this.MapUnit = MapUnit;
		}
	}
	/// <summary>
	/// ENTITY IfcProjectionElement
	/// <para>ENTITY IfcProjectionElement</para>
	/// <para> SUBTYPE OF (IfcFeatureElementAddition);</para>
	/// <para>	PredefinedType : OPTIONAL IfcProjectionElementTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectionElement : IfcFeatureElementAddition
	{
		public IfcProjectionElementTypeEnum? PredefinedType { get; set; }
		public IfcProjectionElement() : base()
		{
		}
		public IfcProjectionElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcProjectionElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProperty
	/// <para>ENTITY IfcProperty</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcComplexProperty</para>
	/// <para>    ,IfcSimpleProperty))</para>
	/// <para> SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>	Name : IfcIdentifier;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	PartOfPset : SET [0:?] OF IfcPropertySet FOR HasProperties;</para>
	/// <para>	PropertyForDependance : SET [0:?] OF IfcPropertyDependencyRelationship FOR DependingProperty;</para>
	/// <para>	PropertyDependsOn : SET [0:?] OF IfcPropertyDependencyRelationship FOR DependantProperty;</para>
	/// <para>	PartOfComplex : SET [0:?] OF IfcComplexProperty FOR HasProperties;</para>
	/// <para>	HasConstraints : SET [0:?] OF IfcResourceConstraintRelationship FOR RelatedResourceObjects;</para>
	/// <para>	HasApprovals : SET [0:?] OF IfcResourceApprovalRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProperty : IfcPropertyAbstraction
	{
		public IfcIdentifier Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcProperty() : base()
		{
			Name = new IfcIdentifier();
		}
		public IfcProperty(IfcIdentifier Name, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyAbstraction
	/// <para>ENTITY IfcPropertyAbstraction</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcExtendedProperties</para>
	/// <para>    ,IfcPreDefinedProperties</para>
	/// <para>    ,IfcProperty</para>
	/// <para>    ,IfcPropertyEnumeration));</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyAbstraction : ENTITY, IfcResourceObjectSelect
	{
		public IfcPropertyAbstraction() : base()
		{
		}
		public IfcPropertyAbstraction() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyBoundedValue
	/// <para>ENTITY IfcPropertyBoundedValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	UpperBoundValue : OPTIONAL IfcValue;</para>
	/// <para>	LowerBoundValue : OPTIONAL IfcValue;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para>	SetPointValue : OPTIONAL IfcValue;</para>
	/// <para> WHERE</para>
	/// <para>	SameUnitUpperLower : NOT(EXISTS(UpperBoundValue)) OR NOT(EXISTS(LowerBoundValue)) OR</para>
	/// <para>(TYPEOF(UpperBoundValue) = TYPEOF(LowerBoundValue));</para>
	/// <para>	SameUnitUpperSet : NOT(EXISTS(UpperBoundValue)) OR NOT(EXISTS(SetPointValue)) OR</para>
	/// <para>(TYPEOF(UpperBoundValue) = TYPEOF(SetPointValue));</para>
	/// <para>	SameUnitLowerSet : NOT(EXISTS(LowerBoundValue)) OR NOT(EXISTS(SetPointValue)) OR</para>
	/// <para>(TYPEOF(LowerBoundValue) = TYPEOF(SetPointValue));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyBoundedValue : IfcSimpleProperty
	{
		public IfcValue? UpperBoundValue { get; set; }
		public IfcValue? LowerBoundValue { get; set; }
		public IfcUnit? Unit { get; set; }
		public IfcValue? SetPointValue { get; set; }
		public IfcPropertyBoundedValue() : base()
		{
		}
		public IfcPropertyBoundedValue(IfcIdentifier Name, IfcText Description, IfcValue UpperBoundValue, IfcValue LowerBoundValue, IfcUnit Unit, IfcValue SetPointValue) : base (Name, Description)
		{
			this.UpperBoundValue = UpperBoundValue;
			this.LowerBoundValue = LowerBoundValue;
			this.Unit = Unit;
			this.SetPointValue = SetPointValue;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyDefinition
	/// <para>ENTITY IfcPropertyDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPropertySetDefinition</para>
	/// <para>    ,IfcPropertyTemplateDefinition))</para>
	/// <para> SUBTYPE OF (IfcRoot);</para>
	/// <para> INVERSE</para>
	/// <para>	HasContext : SET [0:1] OF IfcRelDeclares FOR RelatedDefinitions;</para>
	/// <para>	HasAssociations : SET [0:?] OF IfcRelAssociates FOR RelatedObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyDefinition : IfcRoot, IfcDefinitionSelect
	{
		public IfcPropertyDefinition() : base()
		{
		}
		public IfcPropertyDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyDependencyRelationship
	/// <para>ENTITY IfcPropertyDependencyRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	DependingProperty : IfcProperty;</para>
	/// <para>	DependantProperty : IfcProperty;</para>
	/// <para>	Expression : OPTIONAL IfcText;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : DependingProperty :<>: DependantProperty;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyDependencyRelationship : IfcResourceLevelRelationship
	{
		public IfcProperty DependingProperty { get; set; }
		public IfcProperty DependantProperty { get; set; }
		public IfcText? Expression { get; set; }
		public IfcPropertyDependencyRelationship() : base()
		{
			DependingProperty = new IfcProperty();
			DependantProperty = new IfcProperty();
		}
		public IfcPropertyDependencyRelationship(IfcLabel Name, IfcText Description, IfcProperty DependingProperty, IfcProperty DependantProperty, IfcText Expression) : base (Name, Description)
		{
			this.DependingProperty = DependingProperty;
			this.DependantProperty = DependantProperty;
			this.Expression = Expression;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyEnumeratedValue
	/// <para>ENTITY IfcPropertyEnumeratedValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	EnumerationValues : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>	EnumerationReference : OPTIONAL IfcPropertyEnumeration;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(EnumerationReference)) </para>
	/// <para>OR  NOT(EXISTS(EnumerationValues)) </para>
	/// <para>OR  (SIZEOF(QUERY(temp <* EnumerationValues |</para>
	/// <para>    temp IN EnumerationReference.EnumerationValues))</para>
	/// <para>    = SIZEOF(EnumerationValues));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyEnumeratedValue : IfcSimpleProperty
	{
		public List<IfcValue>? EnumerationValues { get; set; }
		public IfcPropertyEnumeration? EnumerationReference { get; set; }
		public IfcPropertyEnumeratedValue() : base()
		{
		}
		public IfcPropertyEnumeratedValue(IfcIdentifier Name, IfcText Description, List<IfcValue> EnumerationValues, IfcPropertyEnumeration EnumerationReference) : base (Name, Description)
		{
			this.EnumerationValues = EnumerationValues;
			this.EnumerationReference = EnumerationReference;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyEnumeration
	/// <para>ENTITY IfcPropertyEnumeration</para>
	/// <para> SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	EnumerationValues : LIST [1:?] OF UNIQUE IfcValue;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para> UNIQUE</para>
	/// <para>	UR1 : Name;</para>
	/// <para> WHERE</para>
	/// <para>	WR01 : SIZEOF(QUERY(temp <* SELF.EnumerationValues | </para>
	/// <para>  NOT(TYPEOF(SELF.EnumerationValues[1]) = TYPEOF(temp))</para>
	/// <para>  )) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyEnumeration : IfcPropertyAbstraction
	{
		public IfcLabel Name { get; set; }
		public IfcPropertyEnumeration() : base()
		{
			Name = new IfcLabel();
		}
		public IfcPropertyEnumeration(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyListValue
	/// <para>ENTITY IfcPropertyListValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	ListValues : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : SIZEOF(QUERY(temp <* SELF.ListValues | </para>
	/// <para>  NOT(TYPEOF(SELF.ListValues[1]) = TYPEOF(temp))</para>
	/// <para>  )) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyListValue : IfcSimpleProperty
	{
		public List<IfcValue>? ListValues { get; set; }
		public IfcUnit? Unit { get; set; }
		public IfcPropertyListValue() : base()
		{
		}
		public IfcPropertyListValue(IfcIdentifier Name, IfcText Description, List<IfcValue> ListValues, IfcUnit Unit) : base (Name, Description)
		{
			this.ListValues = ListValues;
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyReferenceValue
	/// <para>ENTITY IfcPropertyReferenceValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	UsageName : OPTIONAL IfcText;</para>
	/// <para>	PropertyReference : OPTIONAL IfcObjectReferenceSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyReferenceValue : IfcSimpleProperty
	{
		public IfcText? UsageName { get; set; }
		public IfcObjectReferenceSelect? PropertyReference { get; set; }
		public IfcPropertyReferenceValue() : base()
		{
		}
		public IfcPropertyReferenceValue(IfcIdentifier Name, IfcText Description, IfcText UsageName, IfcObjectReferenceSelect PropertyReference) : base (Name, Description)
		{
			this.UsageName = UsageName;
			this.PropertyReference = PropertyReference;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySet
	/// <para>ENTITY IfcPropertySet</para>
	/// <para> SUBTYPE OF (IfcPropertySetDefinition);</para>
	/// <para>	HasProperties : SET [1:?] OF IfcProperty;</para>
	/// <para> WHERE</para>
	/// <para>	ExistsName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	UniquePropertyNames : IfcUniquePropertyName(HasProperties);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertySet : IfcPropertySetDefinition
	{
		public List<IfcProperty> HasProperties { get; set; }
		public IfcPropertySet() : base()
		{
			HasProperties = new List<IfcProperty>();
		}
		public IfcPropertySet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcProperty> HasProperties) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.HasProperties = HasProperties;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySetDefinition
	/// <para>ENTITY IfcPropertySetDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPreDefinedPropertySet</para>
	/// <para>    ,IfcPropertySet</para>
	/// <para>    ,IfcQuantitySet))</para>
	/// <para> SUBTYPE OF (IfcPropertyDefinition);</para>
	/// <para> INVERSE</para>
	/// <para>	DefinesType : SET [0:?] OF IfcTypeObject FOR HasPropertySets;</para>
	/// <para>	IsDefinedBy : SET [0:?] OF IfcRelDefinesByTemplate FOR RelatedPropertySets;</para>
	/// <para>	DefinesOccurrence : SET [0:?] OF IfcRelDefinesByProperties FOR RelatingPropertyDefinition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertySetDefinition : IfcPropertyDefinition, IfcPropertySetDefinitionSelect
	{
		public IfcPropertySetDefinition() : base()
		{
		}
		public IfcPropertySetDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySetTemplate
	/// <para>ENTITY IfcPropertySetTemplate</para>
	/// <para> SUBTYPE OF (IfcPropertyTemplateDefinition);</para>
	/// <para>	TemplateType : OPTIONAL IfcPropertySetTemplateTypeEnum;</para>
	/// <para>	ApplicableEntity : OPTIONAL IfcIdentifier;</para>
	/// <para>	HasPropertyTemplates : SET [1:?] OF IfcPropertyTemplate;</para>
	/// <para> INVERSE</para>
	/// <para>	Defines : SET [0:?] OF IfcRelDefinesByTemplate FOR RelatingTemplate;</para>
	/// <para> WHERE</para>
	/// <para>	ExistsName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	UniquePropertyNames : IfcUniquePropertyTemplateNames(HasPropertyTemplates);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertySetTemplate : IfcPropertyTemplateDefinition
	{
		public IfcPropertySetTemplateTypeEnum? TemplateType { get; set; }
		public IfcIdentifier? ApplicableEntity { get; set; }
		public List<IfcPropertyTemplate> HasPropertyTemplates { get; set; }
		public IfcPropertySetTemplate() : base()
		{
			HasPropertyTemplates = new List<IfcPropertyTemplate>();
		}
		public IfcPropertySetTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPropertySetTemplateTypeEnum TemplateType, IfcIdentifier ApplicableEntity, List<IfcPropertyTemplate> HasPropertyTemplates) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.TemplateType = TemplateType;
			this.ApplicableEntity = ApplicableEntity;
			this.HasPropertyTemplates = HasPropertyTemplates;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySingleValue
	/// <para>ENTITY IfcPropertySingleValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	NominalValue : OPTIONAL IfcValue;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertySingleValue : IfcSimpleProperty
	{
		public IfcValue? NominalValue { get; set; }
		public IfcUnit? Unit { get; set; }
		public IfcPropertySingleValue() : base()
		{
		}
		public IfcPropertySingleValue(IfcIdentifier Name, IfcText Description, IfcValue NominalValue, IfcUnit Unit) : base (Name, Description)
		{
			this.NominalValue = NominalValue;
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyTableValue
	/// <para>ENTITY IfcPropertyTableValue</para>
	/// <para> SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>	DefiningValues : OPTIONAL LIST [1:?] OF UNIQUE IfcValue;</para>
	/// <para>	DefinedValues : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>	Expression : OPTIONAL IfcText;</para>
	/// <para>	DefiningUnit : OPTIONAL IfcUnit;</para>
	/// <para>	DefinedUnit : OPTIONAL IfcUnit;</para>
	/// <para>	CurveInterpolation : OPTIONAL IfcCurveInterpolationEnum;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : (NOT(EXISTS(DefiningValues)) AND NOT(EXISTS(DefinedValues)))</para>
	/// <para>OR (SIZEOF(DefiningValues) = SIZEOF(DefinedValues));</para>
	/// <para>	WR22 : NOT(EXISTS(DefiningValues)) OR </para>
	/// <para>(SIZEOF(QUERY(temp <* SELF.DefiningValues | TYPEOF(temp) <> TYPEOF(SELF.DefiningValues[1])</para>
	/// <para>)) = 0);</para>
	/// <para>	WR23 : NOT(EXISTS(DefinedValues)) OR </para>
	/// <para>(SIZEOF(QUERY(temp <* SELF.DefinedValues | TYPEOF(temp) <> TYPEOF(SELF.DefinedValues[1])</para>
	/// <para>)) = 0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyTableValue : IfcSimpleProperty
	{
		public IfcPropertyTableValue() : base()
		{
		}
		public IfcPropertyTableValue(IfcIdentifier Name, IfcText Description) : base (Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyTemplate
	/// <para>ENTITY IfcPropertyTemplate</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcComplexPropertyTemplate</para>
	/// <para>    ,IfcSimplePropertyTemplate))</para>
	/// <para> SUBTYPE OF (IfcPropertyTemplateDefinition);</para>
	/// <para> INVERSE</para>
	/// <para>	PartOfComplexTemplate : SET [0:?] OF IfcComplexPropertyTemplate FOR HasPropertyTemplates;</para>
	/// <para>	PartOfPsetTemplate : SET [0:?] OF IfcPropertySetTemplate FOR HasPropertyTemplates;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyTemplate : IfcPropertyTemplateDefinition
	{
		public IfcPropertyTemplate() : base()
		{
		}
		public IfcPropertyTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyTemplateDefinition
	/// <para>ENTITY IfcPropertyTemplateDefinition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPropertySetTemplate</para>
	/// <para>    ,IfcPropertyTemplate))</para>
	/// <para> SUBTYPE OF (IfcPropertyDefinition);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyTemplateDefinition : IfcPropertyDefinition
	{
		public IfcPropertyTemplateDefinition() : base()
		{
		}
		public IfcPropertyTemplateDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDevice
	/// <para>ENTITY IfcProtectiveDevice</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcProtectiveDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcProtectiveDeviceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcProtectiveDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCPROTECTIVEDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDevice : IfcFlowController
	{
		public IfcProtectiveDeviceTypeEnum? PredefinedType { get; set; }
		public IfcProtectiveDevice() : base()
		{
		}
		public IfcProtectiveDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcProtectiveDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDeviceTrippingUnit
	/// <para>ENTITY IfcProtectiveDeviceTrippingUnit</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcProtectiveDeviceTrippingUnitTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCPROTECTIVEDEVICETRIPPINGUNITTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDeviceTrippingUnit : IfcDistributionControlElement
	{
		public IfcProtectiveDeviceTrippingUnitTypeEnum? PredefinedType { get; set; }
		public IfcProtectiveDeviceTrippingUnit() : base()
		{
		}
		public IfcProtectiveDeviceTrippingUnit(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcProtectiveDeviceTrippingUnitTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDeviceTrippingUnitType
	/// <para>ENTITY IfcProtectiveDeviceTrippingUnitType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcProtectiveDeviceTrippingUnitTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDeviceTrippingUnitType : IfcDistributionControlElementType
	{
		public IfcProtectiveDeviceTrippingUnitTypeEnum PredefinedType { get; set; }
		public IfcProtectiveDeviceTrippingUnitType() : base()
		{
			PredefinedType = new IfcProtectiveDeviceTrippingUnitTypeEnum();
		}
		public IfcProtectiveDeviceTrippingUnitType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcProtectiveDeviceTrippingUnitTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDeviceType
	/// <para>ENTITY IfcProtectiveDeviceType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcProtectiveDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcProtectiveDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcProtectiveDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDeviceType : IfcFlowControllerType
	{
		public IfcProtectiveDeviceTypeEnum PredefinedType { get; set; }
		public IfcProtectiveDeviceType() : base()
		{
			PredefinedType = new IfcProtectiveDeviceTypeEnum();
		}
		public IfcProtectiveDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcProtectiveDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProxy
	/// <para>ENTITY IfcProxy</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para>	ProxyType : IfcObjectTypeEnum;</para>
	/// <para>	Tag : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProxy : IfcProduct
	{
		public IfcObjectTypeEnum ProxyType { get; set; }
		public IfcLabel? Tag { get; set; }
		public IfcProxy() : base()
		{
			ProxyType = new IfcObjectTypeEnum();
		}
		public IfcProxy(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcObjectTypeEnum ProxyType, IfcLabel Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.ProxyType = ProxyType;
			this.Tag = Tag;
		}
	}
	/// <summary>
	/// ENTITY IfcPump
	/// <para>ENTITY IfcPump</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcPumpTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcPumpTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcPumpTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCPUMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPump : IfcFlowMovingDevice
	{
		public IfcPumpTypeEnum? PredefinedType { get; set; }
		public IfcPump() : base()
		{
		}
		public IfcPump(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPumpTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPumpType
	/// <para>ENTITY IfcPumpType</para>
	/// <para> SUBTYPE OF (IfcFlowMovingDeviceType);</para>
	/// <para>	PredefinedType : IfcPumpTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcPumpTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPumpTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPumpType : IfcFlowMovingDeviceType
	{
		public IfcPumpTypeEnum PredefinedType { get; set; }
		public IfcPumpType() : base()
		{
			PredefinedType = new IfcPumpTypeEnum();
		}
		public IfcPumpType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPumpTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityArea
	/// <para>ENTITY IfcQuantityArea</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	AreaValue : IfcAreaMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.AREAUNIT);</para>
	/// <para>	WR22 : AreaValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityArea : IfcPhysicalSimpleQuantity
	{
		public IfcAreaMeasure AreaValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityArea() : base()
		{
			AreaValue = new IfcAreaMeasure();
		}
		public IfcQuantityArea(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcAreaMeasure AreaValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.AreaValue = AreaValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityCount
	/// <para>ENTITY IfcQuantityCount</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	CountValue : IfcCountMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : CountValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityCount : IfcPhysicalSimpleQuantity
	{
		public IfcCountMeasure CountValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityCount() : base()
		{
			CountValue = new IfcCountMeasure();
		}
		public IfcQuantityCount(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcCountMeasure CountValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.CountValue = CountValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityLength
	/// <para>ENTITY IfcQuantityLength</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	LengthValue : IfcLengthMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.LENGTHUNIT);</para>
	/// <para>	WR22 : LengthValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityLength : IfcPhysicalSimpleQuantity
	{
		public IfcLengthMeasure LengthValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityLength() : base()
		{
			LengthValue = new IfcLengthMeasure();
		}
		public IfcQuantityLength(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcLengthMeasure LengthValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.LengthValue = LengthValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantitySet
	/// <para>ENTITY IfcQuantitySet</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcElementQuantity))</para>
	/// <para> SUBTYPE OF (IfcPropertySetDefinition);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcQuantitySet : IfcPropertySetDefinition
	{
		public IfcQuantitySet() : base()
		{
		}
		public IfcQuantitySet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityTime
	/// <para>ENTITY IfcQuantityTime</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	TimeValue : IfcTimeMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.TIMEUNIT);</para>
	/// <para>	WR22 : TimeValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityTime : IfcPhysicalSimpleQuantity
	{
		public IfcTimeMeasure TimeValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityTime() : base()
		{
			TimeValue = new IfcTimeMeasure();
		}
		public IfcQuantityTime(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcTimeMeasure TimeValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.TimeValue = TimeValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityVolume
	/// <para>ENTITY IfcQuantityVolume</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	VolumeValue : IfcVolumeMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.VOLUMEUNIT);</para>
	/// <para>	WR22 : VolumeValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityVolume : IfcPhysicalSimpleQuantity
	{
		public IfcVolumeMeasure VolumeValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityVolume() : base()
		{
			VolumeValue = new IfcVolumeMeasure();
		}
		public IfcQuantityVolume(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcVolumeMeasure VolumeValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.VolumeValue = VolumeValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityWeight
	/// <para>ENTITY IfcQuantityWeight</para>
	/// <para> SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>	WeightValue : IfcMassMeasure;</para>
	/// <para>	Formula : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>   (SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.MASSUNIT);</para>
	/// <para>	WR22 : WeightValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityWeight : IfcPhysicalSimpleQuantity
	{
		public IfcMassMeasure WeightValue { get; set; }
		public IfcLabel? Formula { get; set; }
		public IfcQuantityWeight() : base()
		{
			WeightValue = new IfcMassMeasure();
		}
		public IfcQuantityWeight(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcMassMeasure WeightValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.WeightValue = WeightValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcRailing
	/// <para>ENTITY IfcRailing</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRailingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRailingTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRailingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCRAILINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRailing : IfcBuildingElement
	{
		public IfcRailingTypeEnum? PredefinedType { get; set; }
		public IfcRailing() : base()
		{
		}
		public IfcRailing(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRailingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRailingType
	/// <para>ENTITY IfcRailingType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcRailingTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcRailingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRailingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRailingType : IfcBuildingElementType
	{
		public IfcRailingTypeEnum PredefinedType { get; set; }
		public IfcRailingType() : base()
		{
			PredefinedType = new IfcRailingTypeEnum();
		}
		public IfcRailingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRailingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRamp
	/// <para>ENTITY IfcRamp</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRampTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRampTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRampTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCRAMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRamp : IfcBuildingElement
	{
		public IfcRampTypeEnum? PredefinedType { get; set; }
		public IfcRamp() : base()
		{
		}
		public IfcRamp(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRampFlight
	/// <para>ENTITY IfcRampFlight</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRampFlightTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRampFlightTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRampFlightTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCRAMPFLIGHTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRampFlight : IfcBuildingElement
	{
		public IfcRampFlightTypeEnum? PredefinedType { get; set; }
		public IfcRampFlight() : base()
		{
		}
		public IfcRampFlight(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRampFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRampFlightType
	/// <para>ENTITY IfcRampFlightType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcRampFlightTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcRampFlightTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRampFlightTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRampFlightType : IfcBuildingElementType
	{
		public IfcRampFlightTypeEnum PredefinedType { get; set; }
		public IfcRampFlightType() : base()
		{
			PredefinedType = new IfcRampFlightTypeEnum();
		}
		public IfcRampFlightType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRampFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRampType
	/// <para>ENTITY IfcRampType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcRampTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcRampTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRampTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRampType : IfcBuildingElementType
	{
		public IfcRampTypeEnum PredefinedType { get; set; }
		public IfcRampType() : base()
		{
			PredefinedType = new IfcRampTypeEnum();
		}
		public IfcRampType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRationalBSplineCurveWithKnots
	/// <para>ENTITY IfcRationalBSplineCurveWithKnots</para>
	/// <para> SUBTYPE OF (IfcBSplineCurveWithKnots);</para>
	/// <para>	WeightsData : LIST [2:?] OF IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	Weights : ARRAY [0:UpperIndexOnControlPoints] OF IfcReal := IfcListToArray(WeightsData,0,SELF\IfcBSplineCurve.UpperIndexOnControlPoints);</para>
	/// <para> WHERE</para>
	/// <para>	SameNumOfWeightsAndPoints : SIZEOF(WeightsData) = SIZEOF(SELF\IfcBSplineCurve.ControlPointsList);</para>
	/// <para>	WeightsGreaterZero : IfcCurveWeightsPositive(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRationalBSplineCurveWithKnots : IfcBSplineCurveWithKnots
	{
		public List<IfcReal> WeightsData { get; set; }
		public IfcRationalBSplineCurveWithKnots() : base()
		{
			WeightsData = new List<IfcReal>();
		}
		public IfcRationalBSplineCurveWithKnots(IfcInteger Degree, List<IfcCartesianPoint> ControlPointsList, IfcBSplineCurveForm CurveForm, IfcLogical ClosedCurve, IfcLogical SelfIntersect, List<IfcInteger> KnotMultiplicities, List<IfcParameterValue> Knots, IfcKnotType KnotSpec, List<IfcReal> WeightsData) : base (Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec)
		{
			this.WeightsData = WeightsData;
		}
	}
	/// <summary>
	/// ENTITY IfcRationalBSplineSurfaceWithKnots
	/// <para>ENTITY IfcRationalBSplineSurfaceWithKnots</para>
	/// <para> SUBTYPE OF (IfcBSplineSurfaceWithKnots);</para>
	/// <para>	WeightsData : LIST [2:?] OF LIST [2:?] OF IfcReal;</para>
	/// <para> DERIVE</para>
	/// <para>	Weights : ARRAY [0:UUpper] OF ARRAY [0:VUpper] OF IfcReal := IfcMakeArrayOfArray(WeightsData,0,UUpper,0,VUpper);</para>
	/// <para> WHERE</para>
	/// <para>	CorrespondingWeightsDataLists : (SIZEOF(WeightsData) = SIZEOF(SELF\IfcBSplineSurface.ControlPointsList))</para>
	/// <para>AND </para>
	/// <para>(SIZEOF(WeightsData[1]) = SIZEOF(SELF\IfcBSplineSurface.ControlPointsList[1]));</para>
	/// <para>	WeightValuesGreaterZero : IfcSurfaceWeightsPositive(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRationalBSplineSurfaceWithKnots : IfcBSplineSurfaceWithKnots
	{
		public List<List<IfcReal >> WeightsData { get; set; }
		public IfcRationalBSplineSurfaceWithKnots() : base()
		{
			WeightsData = new List<List<IfcReal >>();
		}
		public IfcRationalBSplineSurfaceWithKnots(IfcInteger UDegree, IfcInteger VDegree, List<List<IfcCartesianPoint >> ControlPointsList, IfcBSplineSurfaceForm SurfaceForm, IfcLogical UClosed, IfcLogical VClosed, IfcLogical SelfIntersect, List<IfcInteger> UMultiplicities, List<IfcInteger> VMultiplicities, List<IfcParameterValue> UKnots, List<IfcParameterValue> VKnots, IfcKnotType KnotSpec, List<List<IfcReal >> WeightsData) : base (UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec)
		{
			this.WeightsData = WeightsData;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangleHollowProfileDef
	/// <para>ENTITY IfcRectangleHollowProfileDef</para>
	/// <para> SUBTYPE OF (IfcRectangleProfileDef);</para>
	/// <para>	WallThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	InnerFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	OuterFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidWallThickness : (WallThickness < (SELF\IfcRectangleProfileDef.XDim/2.)) AND </para>
	/// <para>(WallThickness < (SELF\IfcRectangleProfileDef.YDim/2.));</para>
	/// <para>	ValidInnerRadius : NOT(EXISTS(InnerFilletRadius)) OR </para>
	/// <para>((InnerFilletRadius <= (SELF\IfcRectangleProfileDef.XDim/2. - WallThickness)) AND </para>
	/// <para> (InnerFilletRadius <= (SELF\IfcRectangleProfileDef.YDim/2. - WallThickness)));</para>
	/// <para>	ValidOuterRadius : NOT(EXISTS(OuterFilletRadius)) OR </para>
	/// <para>((OuterFilletRadius <= (SELF\IfcRectangleProfileDef.XDim/2.)) AND </para>
	/// <para> (OuterFilletRadius <= (SELF\IfcRectangleProfileDef.YDim/2.)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangleHollowProfileDef : IfcRectangleProfileDef
	{
		public IfcPositiveLengthMeasure WallThickness { get; set; }
		public IfcNonNegativeLengthMeasure? InnerFilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? OuterFilletRadius { get; set; }
		public IfcRectangleHollowProfileDef() : base()
		{
			WallThickness = new IfcPositiveLengthMeasure();
		}
		public IfcRectangleHollowProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim, IfcPositiveLengthMeasure WallThickness, IfcNonNegativeLengthMeasure InnerFilletRadius, IfcNonNegativeLengthMeasure OuterFilletRadius) : base (ProfileType, ProfileName, Position, XDim, YDim)
		{
			this.WallThickness = WallThickness;
			this.InnerFilletRadius = InnerFilletRadius;
			this.OuterFilletRadius = OuterFilletRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangleProfileDef
	/// <para>ENTITY IfcRectangleProfileDef</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRectangleHollowProfileDef</para>
	/// <para>    ,IfcRoundedRectangleProfileDef))</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	XDim : IfcPositiveLengthMeasure;</para>
	/// <para>	YDim : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangleProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure XDim { get; set; }
		public IfcPositiveLengthMeasure YDim { get; set; }
		public IfcRectangleProfileDef() : base()
		{
			XDim = new IfcPositiveLengthMeasure();
			YDim = new IfcPositiveLengthMeasure();
		}
		public IfcRectangleProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim) : base (ProfileType, ProfileName, Position)
		{
			this.XDim = XDim;
			this.YDim = YDim;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangularPyramid
	/// <para>ENTITY IfcRectangularPyramid</para>
	/// <para> SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>	XLength : IfcPositiveLengthMeasure;</para>
	/// <para>	YLength : IfcPositiveLengthMeasure;</para>
	/// <para>	Height : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangularPyramid : IfcCsgPrimitive3D
	{
		public IfcPositiveLengthMeasure XLength { get; set; }
		public IfcPositiveLengthMeasure YLength { get; set; }
		public IfcPositiveLengthMeasure Height { get; set; }
		public IfcRectangularPyramid() : base()
		{
			XLength = new IfcPositiveLengthMeasure();
			YLength = new IfcPositiveLengthMeasure();
			Height = new IfcPositiveLengthMeasure();
		}
		public IfcRectangularPyramid(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure XLength, IfcPositiveLengthMeasure YLength, IfcPositiveLengthMeasure Height) : base (Position)
		{
			this.XLength = XLength;
			this.YLength = YLength;
			this.Height = Height;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangularTrimmedSurface
	/// <para>ENTITY IfcRectangularTrimmedSurface</para>
	/// <para> SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>	BasisSurface : IfcSurface;</para>
	/// <para>	U1 : IfcParameterValue;</para>
	/// <para>	V1 : IfcParameterValue;</para>
	/// <para>	U2 : IfcParameterValue;</para>
	/// <para>	V2 : IfcParameterValue;</para>
	/// <para>	Usense : IfcBoolean;</para>
	/// <para>	Vsense : IfcBoolean;</para>
	/// <para> WHERE</para>
	/// <para>	U1AndU2Different : U1 <> U2;</para>
	/// <para>	V1AndV2Different : V1 <> V2;</para>
	/// <para>	UsenseCompatible : (('IFC4.IFCELEMENTARYSURFACE' IN TYPEOF(BasisSurface)) AND</para>
	/// <para>         (NOT ('IFC4.IFCPLANE' IN TYPEOF(BasisSurface)))) OR</para>
	/// <para>         ('IFC4.IFCSURFACEOFREVOLUTION' IN TYPEOF(BasisSurface)) OR</para>
	/// <para>         (Usense = (U2 > U1));</para>
	/// <para>	VsenseCompatible : Vsense = (V2 > V1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangularTrimmedSurface : IfcBoundedSurface
	{
		public IfcSurface BasisSurface { get; set; }
		public IfcParameterValue U1 { get; set; }
		public IfcParameterValue V1 { get; set; }
		public IfcParameterValue U2 { get; set; }
		public IfcParameterValue V2 { get; set; }
		public IfcBoolean Usense { get; set; }
		public IfcBoolean Vsense { get; set; }
		public IfcRectangularTrimmedSurface() : base()
		{
			BasisSurface = new IfcSurface();
			U1 = new IfcParameterValue();
			V1 = new IfcParameterValue();
			U2 = new IfcParameterValue();
			V2 = new IfcParameterValue();
			Usense = new IfcBoolean();
			Vsense = new IfcBoolean();
		}
		public IfcRectangularTrimmedSurface(IfcSurface BasisSurface, IfcParameterValue U1, IfcParameterValue V1, IfcParameterValue U2, IfcParameterValue V2, IfcBoolean Usense, IfcBoolean Vsense) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.U1 = U1;
			this.V1 = V1;
			this.U2 = U2;
			this.V2 = V2;
			this.Usense = Usense;
			this.Vsense = Vsense;
		}
	}
	/// <summary>
	/// ENTITY IfcRecurrencePattern;
	/// <para>ENTITY IfcRecurrencePattern;</para>
	/// <para>	RecurrenceType : IfcRecurrenceTypeEnum;</para>
	/// <para>	DayComponent : OPTIONAL SET [1:?] OF IfcDayInMonthNumber;</para>
	/// <para>	WeekdayComponent : OPTIONAL SET [1:?] OF IfcDayInWeekNumber;</para>
	/// <para>	MonthComponent : OPTIONAL SET [1:?] OF IfcMonthInYearNumber;</para>
	/// <para>	Position : OPTIONAL IfcInteger;</para>
	/// <para>	Interval : OPTIONAL IfcInteger;</para>
	/// <para>	Occurrences : OPTIONAL IfcInteger;</para>
	/// <para>	TimePeriods : OPTIONAL LIST [1:?] OF IfcTimePeriod;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRecurrencePattern : ENTITY
	{
		public IfcRecurrenceTypeEnum RecurrenceType { get; set; }
		public List<IfcDayInMonthNumber>? DayComponent { get; set; }
		public List<IfcDayInWeekNumber>? WeekdayComponent { get; set; }
		public List<IfcMonthInYearNumber>? MonthComponent { get; set; }
		public IfcInteger? Position { get; set; }
		public IfcInteger? Interval { get; set; }
		public IfcInteger? Occurrences { get; set; }
		public List<IfcTimePeriod>? TimePeriods { get; set; }
		public IfcRecurrencePattern() : base()
		{
			RecurrenceType = new IfcRecurrenceTypeEnum();
		}
		public IfcRecurrencePattern(IfcRecurrenceTypeEnum RecurrenceType, List<IfcDayInMonthNumber> DayComponent, List<IfcDayInWeekNumber> WeekdayComponent, List<IfcMonthInYearNumber> MonthComponent, IfcInteger Position, IfcInteger Interval, IfcInteger Occurrences, List<IfcTimePeriod> TimePeriods) : base ()
		{
			this.RecurrenceType = RecurrenceType;
			this.DayComponent = DayComponent;
			this.WeekdayComponent = WeekdayComponent;
			this.MonthComponent = MonthComponent;
			this.Position = Position;
			this.Interval = Interval;
			this.Occurrences = Occurrences;
			this.TimePeriods = TimePeriods;
		}
	}
	/// <summary>
	/// ENTITY IfcReference;
	/// <para>ENTITY IfcReference;</para>
	/// <para>	TypeIdentifier : OPTIONAL IfcIdentifier;</para>
	/// <para>	AttributeIdentifier : OPTIONAL IfcIdentifier;</para>
	/// <para>	InstanceName : OPTIONAL IfcLabel;</para>
	/// <para>	ListPositions : OPTIONAL LIST [1:?] OF IfcInteger;</para>
	/// <para>	InnerReference : OPTIONAL IfcReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReference : ENTITY, IfcAppliedValueSelect, IfcMetricValueSelect
	{
		public IfcIdentifier? TypeIdentifier { get; set; }
		public IfcIdentifier? AttributeIdentifier { get; set; }
		public IfcLabel? InstanceName { get; set; }
		public List<IfcInteger>? ListPositions { get; set; }
		public IfcReference? InnerReference { get; set; }
		public IfcReference() : base()
		{
		}
		public IfcReference(IfcIdentifier TypeIdentifier, IfcIdentifier AttributeIdentifier, IfcLabel InstanceName, List<IfcInteger> ListPositions, IfcReference InnerReference) : base ()
		{
			this.TypeIdentifier = TypeIdentifier;
			this.AttributeIdentifier = AttributeIdentifier;
			this.InstanceName = InstanceName;
			this.ListPositions = ListPositions;
			this.InnerReference = InnerReference;
		}
	}
	/// <summary>
	/// ENTITY IfcRegularTimeSeries
	/// <para>ENTITY IfcRegularTimeSeries</para>
	/// <para> SUBTYPE OF (IfcTimeSeries);</para>
	/// <para>	TimeStep : IfcTimeMeasure;</para>
	/// <para>	Values : LIST [1:?] OF IfcTimeSeriesValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRegularTimeSeries : IfcTimeSeries
	{
		public IfcTimeMeasure TimeStep { get; set; }
		public List<IfcTimeSeriesValue> Values { get; set; }
		public IfcRegularTimeSeries() : base()
		{
			TimeStep = new IfcTimeMeasure();
			Values = new List<IfcTimeSeriesValue>();
		}
		public IfcRegularTimeSeries(IfcLabel Name, IfcText Description, IfcDateTime StartTime, IfcDateTime EndTime, IfcTimeSeriesDataTypeEnum TimeSeriesDataType, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcUnit Unit, IfcTimeMeasure TimeStep, List<IfcTimeSeriesValue> Values) : base (Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit)
		{
			this.TimeStep = TimeStep;
			this.Values = Values;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcementBarProperties
	/// <para>ENTITY IfcReinforcementBarProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedProperties);</para>
	/// <para>	TotalCrossSectionArea : IfcAreaMeasure;</para>
	/// <para>	SteelGrade : IfcLabel;</para>
	/// <para>	BarSurface : OPTIONAL IfcReinforcingBarSurfaceEnum;</para>
	/// <para>	EffectiveDepth : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	NominalBarDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	BarCount : OPTIONAL IfcCountMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcementBarProperties : IfcPreDefinedProperties
	{
		public IfcAreaMeasure TotalCrossSectionArea { get; set; }
		public IfcLabel SteelGrade { get; set; }
		public IfcReinforcingBarSurfaceEnum? BarSurface { get; set; }
		public IfcLengthMeasure? EffectiveDepth { get; set; }
		public IfcPositiveLengthMeasure? NominalBarDiameter { get; set; }
		public IfcCountMeasure? BarCount { get; set; }
		public IfcReinforcementBarProperties() : base()
		{
			TotalCrossSectionArea = new IfcAreaMeasure();
			SteelGrade = new IfcLabel();
		}
		public IfcReinforcementBarProperties(IfcAreaMeasure TotalCrossSectionArea, IfcLabel SteelGrade, IfcReinforcingBarSurfaceEnum BarSurface, IfcLengthMeasure EffectiveDepth, IfcPositiveLengthMeasure NominalBarDiameter, IfcCountMeasure BarCount) : base ()
		{
			this.TotalCrossSectionArea = TotalCrossSectionArea;
			this.SteelGrade = SteelGrade;
			this.BarSurface = BarSurface;
			this.EffectiveDepth = EffectiveDepth;
			this.NominalBarDiameter = NominalBarDiameter;
			this.BarCount = BarCount;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcementDefinitionProperties
	/// <para>ENTITY IfcReinforcementDefinitionProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	DefinitionType : OPTIONAL IfcLabel;</para>
	/// <para>	ReinforcementSectionDefinitions : LIST [1:?] OF IfcSectionReinforcementProperties;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcementDefinitionProperties : IfcPreDefinedPropertySet
	{
		public IfcLabel? DefinitionType { get; set; }
		public List<IfcSectionReinforcementProperties> ReinforcementSectionDefinitions { get; set; }
		public IfcReinforcementDefinitionProperties() : base()
		{
			ReinforcementSectionDefinitions = new List<IfcSectionReinforcementProperties>();
		}
		public IfcReinforcementDefinitionProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel DefinitionType, List<IfcSectionReinforcementProperties> ReinforcementSectionDefinitions) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.DefinitionType = DefinitionType;
			this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingBar
	/// <para>ENTITY IfcReinforcingBar</para>
	/// <para> SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	BarLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcReinforcingBarTypeEnum;</para>
	/// <para>	BarSurface : OPTIONAL IfcReinforcingBarSurfaceEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT EXISTS(PredefinedType) OR</para>
	/// <para>(PredefinedType <> IfcReinforcingBarTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcReinforcingBarTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4.IFCREINFORCINGBARTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingBar : IfcReinforcingElement
	{
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcAreaMeasure? CrossSectionArea { get; set; }
		public IfcPositiveLengthMeasure? BarLength { get; set; }
		public IfcReinforcingBarTypeEnum? PredefinedType { get; set; }
		public IfcReinforcingBarSurfaceEnum? BarSurface { get; set; }
		public IfcReinforcingBar() : base()
		{
		}
		public IfcReinforcingBar(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcPositiveLengthMeasure BarLength, IfcReinforcingBarTypeEnum PredefinedType, IfcReinforcingBarSurfaceEnum BarSurface) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.BarLength = BarLength;
			this.PredefinedType = PredefinedType;
			this.BarSurface = BarSurface;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingBarType
	/// <para>ENTITY IfcReinforcingBarType</para>
	/// <para> SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>	PredefinedType : IfcReinforcingBarTypeEnum;</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	BarLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	BarSurface : OPTIONAL IfcReinforcingBarSurfaceEnum;</para>
	/// <para>	BendingShapeCode : OPTIONAL IfcLabel;</para>
	/// <para>	BendingParameters : OPTIONAL LIST [1:?] OF IfcBendingParameterSelect;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcReinforcingBarTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcReinforcingBarTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>	BendingShapeCodeProvided : NOT EXISTS(BendingParameters) OR EXISTS(BendingShapeCode);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingBarType : IfcReinforcingElementType
	{
		public IfcReinforcingBarTypeEnum PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcAreaMeasure? CrossSectionArea { get; set; }
		public IfcPositiveLengthMeasure? BarLength { get; set; }
		public IfcReinforcingBarSurfaceEnum? BarSurface { get; set; }
		public IfcLabel? BendingShapeCode { get; set; }
		public List<IfcBendingParameterSelect>? BendingParameters { get; set; }
		public IfcReinforcingBarType() : base()
		{
			PredefinedType = new IfcReinforcingBarTypeEnum();
		}
		public IfcReinforcingBarType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcReinforcingBarTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcPositiveLengthMeasure BarLength, IfcReinforcingBarSurfaceEnum BarSurface, IfcLabel BendingShapeCode, List<IfcBendingParameterSelect> BendingParameters) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.BarLength = BarLength;
			this.BarSurface = BarSurface;
			this.BendingShapeCode = BendingShapeCode;
			this.BendingParameters = BendingParameters;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingElement
	/// <para>ENTITY IfcReinforcingElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcReinforcingBar</para>
	/// <para>    ,IfcReinforcingMesh</para>
	/// <para>    ,IfcTendon</para>
	/// <para>    ,IfcTendonAnchor))</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	SteelGrade : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcReinforcingElement : IfcElementComponent
	{
		public IfcLabel? SteelGrade { get; set; }
		public IfcReinforcingElement() : base()
		{
		}
		public IfcReinforcingElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.SteelGrade = SteelGrade;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingElementType
	/// <para>ENTITY IfcReinforcingElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcReinforcingBarType</para>
	/// <para>    ,IfcReinforcingMeshType</para>
	/// <para>    ,IfcTendonAnchorType</para>
	/// <para>    ,IfcTendonType))</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcReinforcingElementType : IfcElementComponentType
	{
		public IfcReinforcingElementType() : base()
		{
		}
		public IfcReinforcingElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingMesh
	/// <para>ENTITY IfcReinforcingMesh</para>
	/// <para> SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>	MeshLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	MeshWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LongitudinalBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TransverseBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LongitudinalBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	TransverseBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	LongitudinalBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TransverseBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcReinforcingMeshTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT EXISTS(PredefinedType) OR</para>
	/// <para>(PredefinedType <> IfcReinforcingMeshTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcReinforcingMeshTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4.IFCREINFORCINGMESHTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingMesh : IfcReinforcingElement
	{
		public IfcPositiveLengthMeasure? MeshLength { get; set; }
		public IfcPositiveLengthMeasure? MeshWidth { get; set; }
		public IfcPositiveLengthMeasure? LongitudinalBarNominalDiameter { get; set; }
		public IfcPositiveLengthMeasure? TransverseBarNominalDiameter { get; set; }
		public IfcAreaMeasure? LongitudinalBarCrossSectionArea { get; set; }
		public IfcAreaMeasure? TransverseBarCrossSectionArea { get; set; }
		public IfcPositiveLengthMeasure? LongitudinalBarSpacing { get; set; }
		public IfcPositiveLengthMeasure? TransverseBarSpacing { get; set; }
		public IfcReinforcingMeshTypeEnum? PredefinedType { get; set; }
		public IfcReinforcingMesh() : base()
		{
		}
		public IfcReinforcingMesh(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcPositiveLengthMeasure MeshLength, IfcPositiveLengthMeasure MeshWidth, IfcPositiveLengthMeasure LongitudinalBarNominalDiameter, IfcPositiveLengthMeasure TransverseBarNominalDiameter, IfcAreaMeasure LongitudinalBarCrossSectionArea, IfcAreaMeasure TransverseBarCrossSectionArea, IfcPositiveLengthMeasure LongitudinalBarSpacing, IfcPositiveLengthMeasure TransverseBarSpacing, IfcReinforcingMeshTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.MeshLength = MeshLength;
			this.MeshWidth = MeshWidth;
			this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
			this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
			this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
			this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
			this.LongitudinalBarSpacing = LongitudinalBarSpacing;
			this.TransverseBarSpacing = TransverseBarSpacing;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingMeshType
	/// <para>ENTITY IfcReinforcingMeshType</para>
	/// <para> SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>	PredefinedType : IfcReinforcingMeshTypeEnum;</para>
	/// <para>	MeshLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	MeshWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LongitudinalBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TransverseBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LongitudinalBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	TransverseBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	LongitudinalBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TransverseBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	BendingShapeCode : OPTIONAL IfcLabel;</para>
	/// <para>	BendingParameters : OPTIONAL LIST [1:?] OF IfcBendingParameterSelect;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcReinforcingMeshTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcReinforcingMeshTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>	BendingShapeCodeProvided : NOT EXISTS(BendingParameters) OR EXISTS(BendingShapeCode);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingMeshType : IfcReinforcingElementType
	{
		public IfcReinforcingMeshTypeEnum PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? MeshLength { get; set; }
		public IfcPositiveLengthMeasure? MeshWidth { get; set; }
		public IfcPositiveLengthMeasure? LongitudinalBarNominalDiameter { get; set; }
		public IfcPositiveLengthMeasure? TransverseBarNominalDiameter { get; set; }
		public IfcAreaMeasure? LongitudinalBarCrossSectionArea { get; set; }
		public IfcAreaMeasure? TransverseBarCrossSectionArea { get; set; }
		public IfcPositiveLengthMeasure? LongitudinalBarSpacing { get; set; }
		public IfcPositiveLengthMeasure? TransverseBarSpacing { get; set; }
		public IfcLabel? BendingShapeCode { get; set; }
		public List<IfcBendingParameterSelect>? BendingParameters { get; set; }
		public IfcReinforcingMeshType() : base()
		{
			PredefinedType = new IfcReinforcingMeshTypeEnum();
		}
		public IfcReinforcingMeshType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcReinforcingMeshTypeEnum PredefinedType, IfcPositiveLengthMeasure MeshLength, IfcPositiveLengthMeasure MeshWidth, IfcPositiveLengthMeasure LongitudinalBarNominalDiameter, IfcPositiveLengthMeasure TransverseBarNominalDiameter, IfcAreaMeasure LongitudinalBarCrossSectionArea, IfcAreaMeasure TransverseBarCrossSectionArea, IfcPositiveLengthMeasure LongitudinalBarSpacing, IfcPositiveLengthMeasure TransverseBarSpacing, IfcLabel BendingShapeCode, List<IfcBendingParameterSelect> BendingParameters) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.MeshLength = MeshLength;
			this.MeshWidth = MeshWidth;
			this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
			this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
			this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
			this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
			this.LongitudinalBarSpacing = LongitudinalBarSpacing;
			this.TransverseBarSpacing = TransverseBarSpacing;
			this.BendingShapeCode = BendingShapeCode;
			this.BendingParameters = BendingParameters;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAggregates
	/// <para>ENTITY IfcRelAggregates</para>
	/// <para> SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>	RelatingObject : IfcObjectDefinition;</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcObjectDefinition;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* RelatedObjects | RelatingObject :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAggregates : IfcRelDecomposes
	{
		public IfcObjectDefinition RelatingObject { get; set; }
		public List<IfcObjectDefinition> RelatedObjects { get; set; }
		public IfcRelAggregates() : base()
		{
			RelatingObject = new IfcObjectDefinition();
			RelatedObjects = new List<IfcObjectDefinition>();
		}
		public IfcRelAggregates(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcObjectDefinition RelatingObject, List<IfcObjectDefinition> RelatedObjects) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingObject = RelatingObject;
			this.RelatedObjects = RelatedObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssigns
	/// <para>ENTITY IfcRelAssigns</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelAssignsToActor</para>
	/// <para>    ,IfcRelAssignsToControl</para>
	/// <para>    ,IfcRelAssignsToGroup</para>
	/// <para>    ,IfcRelAssignsToProcess</para>
	/// <para>    ,IfcRelAssignsToProduct</para>
	/// <para>    ,IfcRelAssignsToResource))</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcObjectDefinition;</para>
	/// <para>	RelatedObjectsType : OPTIONAL IfcObjectTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : IfcCorrectObjectAssignment(RelatedObjectsType, RelatedObjects);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelAssigns : IfcRelationship
	{
		public List<IfcObjectDefinition> RelatedObjects { get; set; }
		public IfcObjectTypeEnum? RelatedObjectsType { get; set; }
		public IfcRelAssigns() : base()
		{
			RelatedObjects = new List<IfcObjectDefinition>();
		}
		public IfcRelAssigns(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatedObjectsType = RelatedObjectsType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToActor
	/// <para>ENTITY IfcRelAssignsToActor</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingActor : IfcActor;</para>
	/// <para>	ActingRole : OPTIONAL IfcActorRole;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingActor :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToActor : IfcRelAssigns
	{
		public IfcActor RelatingActor { get; set; }
		public IfcActorRole? ActingRole { get; set; }
		public IfcRelAssignsToActor() : base()
		{
			RelatingActor = new IfcActor();
		}
		public IfcRelAssignsToActor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcActor RelatingActor, IfcActorRole ActingRole) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingActor = RelatingActor;
			this.ActingRole = ActingRole;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToControl
	/// <para>ENTITY IfcRelAssignsToControl</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingControl : IfcControl;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingControl :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToControl : IfcRelAssigns
	{
		public IfcControl RelatingControl { get; set; }
		public IfcRelAssignsToControl() : base()
		{
			RelatingControl = new IfcControl();
		}
		public IfcRelAssignsToControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcControl RelatingControl) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingControl = RelatingControl;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToGroup
	/// <para>ENTITY IfcRelAssignsToGroup</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelAssignsToGroupByFactor))</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingGroup : IfcGroup;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingGroup :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToGroup : IfcRelAssigns
	{
		public IfcGroup RelatingGroup { get; set; }
		public IfcRelAssignsToGroup() : base()
		{
			RelatingGroup = new IfcGroup();
		}
		public IfcRelAssignsToGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcGroup RelatingGroup) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingGroup = RelatingGroup;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToGroupByFactor
	/// <para>ENTITY IfcRelAssignsToGroupByFactor</para>
	/// <para> SUBTYPE OF (IfcRelAssignsToGroup);</para>
	/// <para>	Factor : IfcRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToGroupByFactor : IfcRelAssignsToGroup
	{
		public IfcRatioMeasure Factor { get; set; }
		public IfcRelAssignsToGroupByFactor() : base()
		{
			Factor = new IfcRatioMeasure();
		}
		public IfcRelAssignsToGroupByFactor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcGroup RelatingGroup, IfcRatioMeasure Factor) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup)
		{
			this.Factor = Factor;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToProcess
	/// <para>ENTITY IfcRelAssignsToProcess</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingProcess : IfcProcessSelect;</para>
	/// <para>	QuantityInProcess : OPTIONAL IfcMeasureWithUnit;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingProcess :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToProcess : IfcRelAssigns
	{
		public IfcProcessSelect RelatingProcess { get; set; }
		public IfcMeasureWithUnit? QuantityInProcess { get; set; }
		public IfcRelAssignsToProcess() : base()
		{
			RelatingProcess = new IfcProcessSelect();
		}
		public IfcRelAssignsToProcess(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcProcessSelect RelatingProcess, IfcMeasureWithUnit QuantityInProcess) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingProcess = RelatingProcess;
			this.QuantityInProcess = QuantityInProcess;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToProduct
	/// <para>ENTITY IfcRelAssignsToProduct</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingProduct : IfcProductSelect;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingProduct :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToProduct : IfcRelAssigns
	{
		public IfcProductSelect RelatingProduct { get; set; }
		public IfcRelAssignsToProduct() : base()
		{
			RelatingProduct = new IfcProductSelect();
		}
		public IfcRelAssignsToProduct(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcProductSelect RelatingProduct) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingProduct = RelatingProduct;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToResource
	/// <para>ENTITY IfcRelAssignsToResource</para>
	/// <para> SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>	RelatingResource : IfcResourceSelect;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingResource :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToResource : IfcRelAssigns
	{
		public IfcResourceSelect RelatingResource { get; set; }
		public IfcRelAssignsToResource() : base()
		{
			RelatingResource = new IfcResourceSelect();
		}
		public IfcRelAssignsToResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcResourceSelect RelatingResource) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingResource = RelatingResource;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociates
	/// <para>ENTITY IfcRelAssociates</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelAssociatesApproval</para>
	/// <para>    ,IfcRelAssociatesClassification</para>
	/// <para>    ,IfcRelAssociatesConstraint</para>
	/// <para>    ,IfcRelAssociatesDocument</para>
	/// <para>    ,IfcRelAssociatesLibrary</para>
	/// <para>    ,IfcRelAssociatesMaterial))</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcDefinitionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelAssociates : IfcRelationship
	{
		public List<IfcDefinitionSelect> RelatedObjects { get; set; }
		public IfcRelAssociates() : base()
		{
			RelatedObjects = new List<IfcDefinitionSelect>();
		}
		public IfcRelAssociates(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesApproval
	/// <para>ENTITY IfcRelAssociatesApproval</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingApproval : IfcApproval;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesApproval : IfcRelAssociates
	{
		public IfcApproval RelatingApproval { get; set; }
		public IfcRelAssociatesApproval() : base()
		{
			RelatingApproval = new IfcApproval();
		}
		public IfcRelAssociatesApproval(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcApproval RelatingApproval) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingApproval = RelatingApproval;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesClassification
	/// <para>ENTITY IfcRelAssociatesClassification</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingClassification : IfcClassificationSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesClassification : IfcRelAssociates
	{
		public IfcClassificationSelect RelatingClassification { get; set; }
		public IfcRelAssociatesClassification() : base()
		{
			RelatingClassification = new IfcClassificationSelect();
		}
		public IfcRelAssociatesClassification(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcClassificationSelect RelatingClassification) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingClassification = RelatingClassification;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesConstraint
	/// <para>ENTITY IfcRelAssociatesConstraint</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	Intent : OPTIONAL IfcLabel;</para>
	/// <para>	RelatingConstraint : IfcConstraint;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesConstraint : IfcRelAssociates
	{
		public IfcLabel? Intent { get; set; }
		public IfcConstraint RelatingConstraint { get; set; }
		public IfcRelAssociatesConstraint() : base()
		{
			RelatingConstraint = new IfcConstraint();
		}
		public IfcRelAssociatesConstraint(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcLabel Intent, IfcConstraint RelatingConstraint) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.Intent = Intent;
			this.RelatingConstraint = RelatingConstraint;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesDocument
	/// <para>ENTITY IfcRelAssociatesDocument</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingDocument : IfcDocumentSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesDocument : IfcRelAssociates
	{
		public IfcDocumentSelect RelatingDocument { get; set; }
		public IfcRelAssociatesDocument() : base()
		{
			RelatingDocument = new IfcDocumentSelect();
		}
		public IfcRelAssociatesDocument(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcDocumentSelect RelatingDocument) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingDocument = RelatingDocument;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesLibrary
	/// <para>ENTITY IfcRelAssociatesLibrary</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingLibrary : IfcLibrarySelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesLibrary : IfcRelAssociates
	{
		public IfcLibrarySelect RelatingLibrary { get; set; }
		public IfcRelAssociatesLibrary() : base()
		{
			RelatingLibrary = new IfcLibrarySelect();
		}
		public IfcRelAssociatesLibrary(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcLibrarySelect RelatingLibrary) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingLibrary = RelatingLibrary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesMaterial
	/// <para>ENTITY IfcRelAssociatesMaterial</para>
	/// <para> SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>	RelatingMaterial : IfcMaterialSelect;</para>
	/// <para> WHERE</para>
	/// <para>	NoVoidElement : SIZEOF(QUERY(temp <* SELF\IfcRelAssociates.RelatedObjects | </para>
	/// <para>  ('IFC4.IFCFEATUREELEMENTSUBTRACTION' IN TYPEOF(temp)) OR </para>
	/// <para>  ('IFC4.IFCVIRTUALELEMENT' IN TYPEOF(temp)) </para>
	/// <para>)) = 0;</para>
	/// <para>	AllowedElements : SIZEOF(QUERY(temp <* SELF\IfcRelAssociates.RelatedObjects | (</para>
	/// <para>  SIZEOF(TYPEOF(temp) * [   </para>
	/// <para>    'IFC4.IFCELEMENT', </para>
	/// <para>    'IFC4.IFCELEMENTTYPE',</para>
	/// <para>    'IFC4.IFCWINDOWSTYLE',</para>
	/// <para>    'IFC4.IFCDOORSTYLE',</para>
	/// <para>    'IFC4.IFCSTRUCTURALMEMBER',</para>
	/// <para>    'IFC4.IFCPORT']) = 0) </para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesMaterial : IfcRelAssociates
	{
		public IfcMaterialSelect RelatingMaterial { get; set; }
		public IfcRelAssociatesMaterial() : base()
		{
			RelatingMaterial = new IfcMaterialSelect();
		}
		public IfcRelAssociatesMaterial(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcMaterialSelect RelatingMaterial) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingMaterial = RelatingMaterial;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnects
	/// <para>ENTITY IfcRelConnects</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelConnectsElements</para>
	/// <para>    ,IfcRelConnectsPortToElement</para>
	/// <para>    ,IfcRelConnectsPorts</para>
	/// <para>    ,IfcRelConnectsStructuralActivity</para>
	/// <para>    ,IfcRelConnectsStructuralMember</para>
	/// <para>    ,IfcRelContainedInSpatialStructure</para>
	/// <para>    ,IfcRelCoversBldgElements</para>
	/// <para>    ,IfcRelCoversSpaces</para>
	/// <para>    ,IfcRelFillsElement</para>
	/// <para>    ,IfcRelFlowControlElements</para>
	/// <para>    ,IfcRelInterferesElements</para>
	/// <para>    ,IfcRelReferencedInSpatialStructure</para>
	/// <para>    ,IfcRelSequence</para>
	/// <para>    ,IfcRelServicesBuildings</para>
	/// <para>    ,IfcRelSpaceBoundary))</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelConnects : IfcRelationship
	{
		public IfcRelConnects() : base()
		{
		}
		public IfcRelConnects(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsElements
	/// <para>ENTITY IfcRelConnectsElements</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelConnectsPathElements</para>
	/// <para>    ,IfcRelConnectsWithRealizingElements))</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	ConnectionGeometry : OPTIONAL IfcConnectionGeometry;</para>
	/// <para>	RelatingElement : IfcElement;</para>
	/// <para>	RelatedElement : IfcElement;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : RelatingElement :<>: RelatedElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsElements : IfcRelConnects
	{
		public IfcConnectionGeometry? ConnectionGeometry { get; set; }
		public IfcElement RelatingElement { get; set; }
		public IfcElement RelatedElement { get; set; }
		public IfcRelConnectsElements() : base()
		{
			RelatingElement = new IfcElement();
			RelatedElement = new IfcElement();
		}
		public IfcRelConnectsElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcConnectionGeometry ConnectionGeometry, IfcElement RelatingElement, IfcElement RelatedElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ConnectionGeometry = ConnectionGeometry;
			this.RelatingElement = RelatingElement;
			this.RelatedElement = RelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsPathElements
	/// <para>ENTITY IfcRelConnectsPathElements</para>
	/// <para> SUBTYPE OF (IfcRelConnectsElements);</para>
	/// <para>	RelatingPriorities : LIST [0:?] OF IfcInteger;</para>
	/// <para>	RelatedPriorities : LIST [0:?] OF IfcInteger;</para>
	/// <para>	RelatedConnectionType : IfcConnectionTypeEnum;</para>
	/// <para>	RelatingConnectionType : IfcConnectionTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	NormalizedRelatingPriorities : (SIZEOF(RelatingPriorities) = 0)</para>
	/// <para>OR</para>
	/// <para>(SIZEOF (QUERY (temp <* RelatingPriorities</para>
	/// <para>  | {0 <= temp <= 100}</para>
	/// <para>  )) = SIZEOF(RelatingPriorities));</para>
	/// <para>	NormalizedRelatedPriorities : (SIZEOF(RelatedPriorities) = 0)</para>
	/// <para>OR</para>
	/// <para>(SIZEOF (QUERY (temp <* RelatedPriorities</para>
	/// <para>  | {0 <= temp <= 100}</para>
	/// <para>  )) = SIZEOF(RelatedPriorities));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsPathElements : IfcRelConnectsElements
	{
		public List<IfcInteger> RelatingPriorities { get; set; }
		public List<IfcInteger> RelatedPriorities { get; set; }
		public IfcConnectionTypeEnum RelatedConnectionType { get; set; }
		public IfcConnectionTypeEnum RelatingConnectionType { get; set; }
		public IfcRelConnectsPathElements() : base()
		{
			RelatingPriorities = new List<IfcInteger>();
			RelatedPriorities = new List<IfcInteger>();
			RelatedConnectionType = new IfcConnectionTypeEnum();
			RelatingConnectionType = new IfcConnectionTypeEnum();
		}
		public IfcRelConnectsPathElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcConnectionGeometry ConnectionGeometry, IfcElement RelatingElement, IfcElement RelatedElement, List<IfcInteger> RelatingPriorities, List<IfcInteger> RelatedPriorities, IfcConnectionTypeEnum RelatedConnectionType, IfcConnectionTypeEnum RelatingConnectionType) : base (GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement)
		{
			this.RelatingPriorities = RelatingPriorities;
			this.RelatedPriorities = RelatedPriorities;
			this.RelatedConnectionType = RelatedConnectionType;
			this.RelatingConnectionType = RelatingConnectionType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsPortToElement
	/// <para>ENTITY IfcRelConnectsPortToElement</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingPort : IfcPort;</para>
	/// <para>	RelatedElement : IfcDistributionElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsPortToElement : IfcRelConnects
	{
		public IfcPort RelatingPort { get; set; }
		public IfcDistributionElement RelatedElement { get; set; }
		public IfcRelConnectsPortToElement() : base()
		{
			RelatingPort = new IfcPort();
			RelatedElement = new IfcDistributionElement();
		}
		public IfcRelConnectsPortToElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPort RelatingPort, IfcDistributionElement RelatedElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingPort = RelatingPort;
			this.RelatedElement = RelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsPorts
	/// <para>ENTITY IfcRelConnectsPorts</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingPort : IfcPort;</para>
	/// <para>	RelatedPort : IfcPort;</para>
	/// <para>	RealizingElement : OPTIONAL IfcElement;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : RelatingPort :<>: RelatedPort;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsPorts : IfcRelConnects
	{
		public IfcPort RelatingPort { get; set; }
		public IfcPort RelatedPort { get; set; }
		public IfcElement? RealizingElement { get; set; }
		public IfcRelConnectsPorts() : base()
		{
			RelatingPort = new IfcPort();
			RelatedPort = new IfcPort();
		}
		public IfcRelConnectsPorts(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPort RelatingPort, IfcPort RelatedPort, IfcElement RealizingElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingPort = RelatingPort;
			this.RelatedPort = RelatedPort;
			this.RealizingElement = RealizingElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsStructuralActivity
	/// <para>ENTITY IfcRelConnectsStructuralActivity</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingElement : IfcStructuralActivityAssignmentSelect;</para>
	/// <para>	RelatedStructuralActivity : IfcStructuralActivity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsStructuralActivity : IfcRelConnects
	{
		public IfcStructuralActivityAssignmentSelect RelatingElement { get; set; }
		public IfcStructuralActivity RelatedStructuralActivity { get; set; }
		public IfcRelConnectsStructuralActivity() : base()
		{
			RelatingElement = new IfcStructuralActivityAssignmentSelect();
			RelatedStructuralActivity = new IfcStructuralActivity();
		}
		public IfcRelConnectsStructuralActivity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcStructuralActivityAssignmentSelect RelatingElement, IfcStructuralActivity RelatedStructuralActivity) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingElement = RelatingElement;
			this.RelatedStructuralActivity = RelatedStructuralActivity;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsStructuralMember
	/// <para>ENTITY IfcRelConnectsStructuralMember</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelConnectsWithEccentricity))</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingStructuralMember : IfcStructuralMember;</para>
	/// <para>	RelatedStructuralConnection : IfcStructuralConnection;</para>
	/// <para>	AppliedCondition : OPTIONAL IfcBoundaryCondition;</para>
	/// <para>	AdditionalConditions : OPTIONAL IfcStructuralConnectionCondition;</para>
	/// <para>	SupportedLength : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ConditionCoordinateSystem : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsStructuralMember : IfcRelConnects
	{
		public IfcStructuralMember RelatingStructuralMember { get; set; }
		public IfcStructuralConnection RelatedStructuralConnection { get; set; }
		public IfcBoundaryCondition? AppliedCondition { get; set; }
		public IfcStructuralConnectionCondition? AdditionalConditions { get; set; }
		public IfcLengthMeasure? SupportedLength { get; set; }
		public IfcAxis2Placement3D? ConditionCoordinateSystem { get; set; }
		public IfcRelConnectsStructuralMember() : base()
		{
			RelatingStructuralMember = new IfcStructuralMember();
			RelatedStructuralConnection = new IfcStructuralConnection();
		}
		public IfcRelConnectsStructuralMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcStructuralMember RelatingStructuralMember, IfcStructuralConnection RelatedStructuralConnection, IfcBoundaryCondition AppliedCondition, IfcStructuralConnectionCondition AdditionalConditions, IfcLengthMeasure SupportedLength, IfcAxis2Placement3D ConditionCoordinateSystem) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingStructuralMember = RelatingStructuralMember;
			this.RelatedStructuralConnection = RelatedStructuralConnection;
			this.AppliedCondition = AppliedCondition;
			this.AdditionalConditions = AdditionalConditions;
			this.SupportedLength = SupportedLength;
			this.ConditionCoordinateSystem = ConditionCoordinateSystem;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsWithEccentricity
	/// <para>ENTITY IfcRelConnectsWithEccentricity</para>
	/// <para> SUBTYPE OF (IfcRelConnectsStructuralMember);</para>
	/// <para>	ConnectionConstraint : IfcConnectionGeometry;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsWithEccentricity : IfcRelConnectsStructuralMember
	{
		public IfcConnectionGeometry ConnectionConstraint { get; set; }
		public IfcRelConnectsWithEccentricity() : base()
		{
			ConnectionConstraint = new IfcConnectionGeometry();
		}
		public IfcRelConnectsWithEccentricity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcStructuralMember RelatingStructuralMember, IfcStructuralConnection RelatedStructuralConnection, IfcBoundaryCondition AppliedCondition, IfcStructuralConnectionCondition AdditionalConditions, IfcLengthMeasure SupportedLength, IfcAxis2Placement3D ConditionCoordinateSystem, IfcConnectionGeometry ConnectionConstraint) : base (GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem)
		{
			this.ConnectionConstraint = ConnectionConstraint;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsWithRealizingElements
	/// <para>ENTITY IfcRelConnectsWithRealizingElements</para>
	/// <para> SUBTYPE OF (IfcRelConnectsElements);</para>
	/// <para>	RealizingElements : SET [1:?] OF IfcElement;</para>
	/// <para>	ConnectionType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsWithRealizingElements : IfcRelConnectsElements
	{
		public List<IfcElement> RealizingElements { get; set; }
		public IfcLabel? ConnectionType { get; set; }
		public IfcRelConnectsWithRealizingElements() : base()
		{
			RealizingElements = new List<IfcElement>();
		}
		public IfcRelConnectsWithRealizingElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcConnectionGeometry ConnectionGeometry, IfcElement RelatingElement, IfcElement RelatedElement, List<IfcElement> RealizingElements, IfcLabel ConnectionType) : base (GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement)
		{
			this.RealizingElements = RealizingElements;
			this.ConnectionType = ConnectionType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelContainedInSpatialStructure
	/// <para>ENTITY IfcRelContainedInSpatialStructure</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatedElements : SET [1:?] OF IfcProduct;</para>
	/// <para>	RelatingStructure : IfcSpatialElement;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : SIZEOF(QUERY(temp <* RelatedElements | 'IFC4.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelContainedInSpatialStructure : IfcRelConnects
	{
		public List<IfcProduct> RelatedElements { get; set; }
		public IfcSpatialElement RelatingStructure { get; set; }
		public IfcRelContainedInSpatialStructure() : base()
		{
			RelatedElements = new List<IfcProduct>();
			RelatingStructure = new IfcSpatialElement();
		}
		public IfcRelContainedInSpatialStructure(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcProduct> RelatedElements, IfcSpatialElement RelatingStructure) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedElements = RelatedElements;
			this.RelatingStructure = RelatingStructure;
		}
	}
	/// <summary>
	/// ENTITY IfcRelCoversBldgElements
	/// <para>ENTITY IfcRelCoversBldgElements</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingBuildingElement : IfcElement;</para>
	/// <para>	RelatedCoverings : SET [1:?] OF IfcCovering;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelCoversBldgElements : IfcRelConnects
	{
		public IfcElement RelatingBuildingElement { get; set; }
		public List<IfcCovering> RelatedCoverings { get; set; }
		public IfcRelCoversBldgElements() : base()
		{
			RelatingBuildingElement = new IfcElement();
			RelatedCoverings = new List<IfcCovering>();
		}
		public IfcRelCoversBldgElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingBuildingElement, List<IfcCovering> RelatedCoverings) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingBuildingElement = RelatingBuildingElement;
			this.RelatedCoverings = RelatedCoverings;
		}
	}
	/// <summary>
	/// ENTITY IfcRelCoversSpaces
	/// <para>ENTITY IfcRelCoversSpaces</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingSpace : IfcSpace;</para>
	/// <para>	RelatedCoverings : SET [1:?] OF IfcCovering;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelCoversSpaces : IfcRelConnects
	{
		public IfcSpace RelatingSpace { get; set; }
		public List<IfcCovering> RelatedCoverings { get; set; }
		public IfcRelCoversSpaces() : base()
		{
			RelatingSpace = new IfcSpace();
			RelatedCoverings = new List<IfcCovering>();
		}
		public IfcRelCoversSpaces(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpace RelatingSpace, List<IfcCovering> RelatedCoverings) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingSpace = RelatingSpace;
			this.RelatedCoverings = RelatedCoverings;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDeclares
	/// <para>ENTITY IfcRelDeclares</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>	RelatingContext : IfcContext;</para>
	/// <para>	RelatedDefinitions : SET [1:?] OF IfcDefinitionSelect;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* RelatedDefinitions | RelatingContext :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDeclares : IfcRelationship
	{
		public IfcContext RelatingContext { get; set; }
		public List<IfcDefinitionSelect> RelatedDefinitions { get; set; }
		public IfcRelDeclares() : base()
		{
			RelatingContext = new IfcContext();
			RelatedDefinitions = new List<IfcDefinitionSelect>();
		}
		public IfcRelDeclares(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcContext RelatingContext, List<IfcDefinitionSelect> RelatedDefinitions) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingContext = RelatingContext;
			this.RelatedDefinitions = RelatedDefinitions;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDecomposes
	/// <para>ENTITY IfcRelDecomposes</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelAggregates</para>
	/// <para>    ,IfcRelNests</para>
	/// <para>    ,IfcRelProjectsElement</para>
	/// <para>    ,IfcRelVoidsElement))</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelDecomposes : IfcRelationship
	{
		public IfcRelDecomposes() : base()
		{
		}
		public IfcRelDecomposes(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefines
	/// <para>ENTITY IfcRelDefines</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelDefinesByObject</para>
	/// <para>    ,IfcRelDefinesByProperties</para>
	/// <para>    ,IfcRelDefinesByTemplate</para>
	/// <para>    ,IfcRelDefinesByType))</para>
	/// <para> SUBTYPE OF (IfcRelationship);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelDefines : IfcRelationship
	{
		public IfcRelDefines() : base()
		{
		}
		public IfcRelDefines(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByObject
	/// <para>ENTITY IfcRelDefinesByObject</para>
	/// <para> SUBTYPE OF (IfcRelDefines);</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcObject;</para>
	/// <para>	RelatingObject : IfcObject;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByObject : IfcRelDefines
	{
		public List<IfcObject> RelatedObjects { get; set; }
		public IfcObject RelatingObject { get; set; }
		public IfcRelDefinesByObject() : base()
		{
			RelatedObjects = new List<IfcObject>();
			RelatingObject = new IfcObject();
		}
		public IfcRelDefinesByObject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObject> RelatedObjects, IfcObject RelatingObject) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatingObject = RelatingObject;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByProperties
	/// <para>ENTITY IfcRelDefinesByProperties</para>
	/// <para> SUBTYPE OF (IfcRelDefines);</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcObjectDefinition;</para>
	/// <para>	RelatingPropertyDefinition : IfcPropertySetDefinitionSelect;</para>
	/// <para> WHERE</para>
	/// <para>	NoRelatedTypeObject : SIZEOF(QUERY(Types <* SELF\IfcRelDefinesByProperties.RelatedObjects |  'IFC4.IFCTYPEOBJECT' IN TYPEOF(Types))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByProperties : IfcRelDefines
	{
		public List<IfcObjectDefinition> RelatedObjects { get; set; }
		public IfcPropertySetDefinitionSelect RelatingPropertyDefinition { get; set; }
		public IfcRelDefinesByProperties() : base()
		{
			RelatedObjects = new List<IfcObjectDefinition>();
			RelatingPropertyDefinition = new IfcPropertySetDefinitionSelect();
		}
		public IfcRelDefinesByProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcPropertySetDefinitionSelect RelatingPropertyDefinition) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatingPropertyDefinition = RelatingPropertyDefinition;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByTemplate
	/// <para>ENTITY IfcRelDefinesByTemplate</para>
	/// <para> SUBTYPE OF (IfcRelDefines);</para>
	/// <para>	RelatedPropertySets : SET [1:?] OF IfcPropertySetDefinition;</para>
	/// <para>	RelatingTemplate : IfcPropertySetTemplate;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByTemplate : IfcRelDefines
	{
		public List<IfcPropertySetDefinition> RelatedPropertySets { get; set; }
		public IfcPropertySetTemplate RelatingTemplate { get; set; }
		public IfcRelDefinesByTemplate() : base()
		{
			RelatedPropertySets = new List<IfcPropertySetDefinition>();
			RelatingTemplate = new IfcPropertySetTemplate();
		}
		public IfcRelDefinesByTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcPropertySetDefinition> RelatedPropertySets, IfcPropertySetTemplate RelatingTemplate) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedPropertySets = RelatedPropertySets;
			this.RelatingTemplate = RelatingTemplate;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByType
	/// <para>ENTITY IfcRelDefinesByType</para>
	/// <para> SUBTYPE OF (IfcRelDefines);</para>
	/// <para>	RelatedObjects : SET [1:?] OF IfcObject;</para>
	/// <para>	RelatingType : IfcTypeObject;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByType : IfcRelDefines
	{
		public List<IfcObject> RelatedObjects { get; set; }
		public IfcTypeObject RelatingType { get; set; }
		public IfcRelDefinesByType() : base()
		{
			RelatedObjects = new List<IfcObject>();
			RelatingType = new IfcTypeObject();
		}
		public IfcRelDefinesByType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObject> RelatedObjects, IfcTypeObject RelatingType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatingType = RelatingType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelFillsElement
	/// <para>ENTITY IfcRelFillsElement</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingOpeningElement : IfcOpeningElement;</para>
	/// <para>	RelatedBuildingElement : IfcElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelFillsElement : IfcRelConnects
	{
		public IfcOpeningElement RelatingOpeningElement { get; set; }
		public IfcElement RelatedBuildingElement { get; set; }
		public IfcRelFillsElement() : base()
		{
			RelatingOpeningElement = new IfcOpeningElement();
			RelatedBuildingElement = new IfcElement();
		}
		public IfcRelFillsElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcOpeningElement RelatingOpeningElement, IfcElement RelatedBuildingElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingOpeningElement = RelatingOpeningElement;
			this.RelatedBuildingElement = RelatedBuildingElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelFlowControlElements
	/// <para>ENTITY IfcRelFlowControlElements</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatedControlElements : SET [1:?] OF IfcDistributionControlElement;</para>
	/// <para>	RelatingFlowElement : IfcDistributionFlowElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelFlowControlElements : IfcRelConnects
	{
		public List<IfcDistributionControlElement> RelatedControlElements { get; set; }
		public IfcDistributionFlowElement RelatingFlowElement { get; set; }
		public IfcRelFlowControlElements() : base()
		{
			RelatedControlElements = new List<IfcDistributionControlElement>();
			RelatingFlowElement = new IfcDistributionFlowElement();
		}
		public IfcRelFlowControlElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDistributionControlElement> RelatedControlElements, IfcDistributionFlowElement RelatingFlowElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedControlElements = RelatedControlElements;
			this.RelatingFlowElement = RelatingFlowElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelInterferesElements
	/// <para>ENTITY IfcRelInterferesElements</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingElement : IfcElement;</para>
	/// <para>	RelatedElement : IfcElement;</para>
	/// <para>	InterferenceGeometry : OPTIONAL IfcConnectionGeometry;</para>
	/// <para>	InterferenceType : OPTIONAL IfcIdentifier;</para>
	/// <para>	ImpliedOrder : LOGICAL;</para>
	/// <para> WHERE</para>
	/// <para>	NotSelfReference : RelatingElement :<>: RelatedElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelInterferesElements : IfcRelConnects
	{
		public IfcElement RelatingElement { get; set; }
		public IfcElement RelatedElement { get; set; }
		public IfcConnectionGeometry? InterferenceGeometry { get; set; }
		public IfcIdentifier? InterferenceType { get; set; }
		public LOGICAL ImpliedOrder { get; set; }
		public IfcRelInterferesElements() : base()
		{
			RelatingElement = new IfcElement();
			RelatedElement = new IfcElement();
			ImpliedOrder = new LOGICAL();
		}
		public IfcRelInterferesElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingElement, IfcElement RelatedElement, IfcConnectionGeometry InterferenceGeometry, IfcIdentifier InterferenceType, LOGICAL ImpliedOrder) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingElement = RelatingElement;
			this.RelatedElement = RelatedElement;
			this.InterferenceGeometry = InterferenceGeometry;
			this.InterferenceType = InterferenceType;
			this.ImpliedOrder = ImpliedOrder;
		}
	}
	/// <summary>
	/// ENTITY IfcRelNests
	/// <para>ENTITY IfcRelNests</para>
	/// <para> SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>	RelatingObject : IfcObjectDefinition;</para>
	/// <para>	RelatedObjects : LIST [1:?] OF IfcObjectDefinition;</para>
	/// <para> WHERE</para>
	/// <para>	NoSelfReference : SIZEOF(QUERY(Temp <* RelatedObjects | RelatingObject :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelNests : IfcRelDecomposes
	{
		public IfcObjectDefinition RelatingObject { get; set; }
		public List<IfcObjectDefinition> RelatedObjects { get; set; }
		public IfcRelNests() : base()
		{
			RelatingObject = new IfcObjectDefinition();
			RelatedObjects = new List<IfcObjectDefinition>();
		}
		public IfcRelNests(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcObjectDefinition RelatingObject, List<IfcObjectDefinition> RelatedObjects) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingObject = RelatingObject;
			this.RelatedObjects = RelatedObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcRelProjectsElement
	/// <para>ENTITY IfcRelProjectsElement</para>
	/// <para> SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>	RelatingElement : IfcElement;</para>
	/// <para>	RelatedFeatureElement : IfcFeatureElementAddition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelProjectsElement : IfcRelDecomposes
	{
		public IfcElement RelatingElement { get; set; }
		public IfcFeatureElementAddition RelatedFeatureElement { get; set; }
		public IfcRelProjectsElement() : base()
		{
			RelatingElement = new IfcElement();
			RelatedFeatureElement = new IfcFeatureElementAddition();
		}
		public IfcRelProjectsElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingElement, IfcFeatureElementAddition RelatedFeatureElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingElement = RelatingElement;
			this.RelatedFeatureElement = RelatedFeatureElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelReferencedInSpatialStructure
	/// <para>ENTITY IfcRelReferencedInSpatialStructure</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatedElements : SET [1:?] OF IfcProduct;</para>
	/// <para>	RelatingStructure : IfcSpatialElement;</para>
	/// <para> WHERE</para>
	/// <para>	AllowedRelatedElements : SIZEOF(QUERY(temp <* RelatedElements | ('IFC4.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF(temp)) AND (NOT ('IFC4.IFCSPACE' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelReferencedInSpatialStructure : IfcRelConnects
	{
		public List<IfcProduct> RelatedElements { get; set; }
		public IfcSpatialElement RelatingStructure { get; set; }
		public IfcRelReferencedInSpatialStructure() : base()
		{
			RelatedElements = new List<IfcProduct>();
			RelatingStructure = new IfcSpatialElement();
		}
		public IfcRelReferencedInSpatialStructure(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcProduct> RelatedElements, IfcSpatialElement RelatingStructure) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedElements = RelatedElements;
			this.RelatingStructure = RelatingStructure;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSequence
	/// <para>ENTITY IfcRelSequence</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingProcess : IfcProcess;</para>
	/// <para>	RelatedProcess : IfcProcess;</para>
	/// <para>	TimeLag : OPTIONAL IfcLagTime;</para>
	/// <para>	SequenceType : OPTIONAL IfcSequenceEnum;</para>
	/// <para>	UserDefinedSequenceType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	AvoidInconsistentSequence : RelatingProcess :<>: RelatedProcess;</para>
	/// <para>	CorrectSequenceType : (SequenceType <> IfcSequenceEnum.USERDEFINED) OR ((SequenceType = IfcSequenceEnum.USERDEFINED) AND EXISTS(UserDefinedSequenceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSequence : IfcRelConnects
	{
		public IfcProcess RelatingProcess { get; set; }
		public IfcProcess RelatedProcess { get; set; }
		public IfcLagTime? TimeLag { get; set; }
		public IfcSequenceEnum? SequenceType { get; set; }
		public IfcLabel? UserDefinedSequenceType { get; set; }
		public IfcRelSequence() : base()
		{
			RelatingProcess = new IfcProcess();
			RelatedProcess = new IfcProcess();
		}
		public IfcRelSequence(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcProcess RelatingProcess, IfcProcess RelatedProcess, IfcLagTime TimeLag, IfcSequenceEnum SequenceType, IfcLabel UserDefinedSequenceType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingProcess = RelatingProcess;
			this.RelatedProcess = RelatedProcess;
			this.TimeLag = TimeLag;
			this.SequenceType = SequenceType;
			this.UserDefinedSequenceType = UserDefinedSequenceType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelServicesBuildings
	/// <para>ENTITY IfcRelServicesBuildings</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingSystem : IfcSystem;</para>
	/// <para>	RelatedBuildings : SET [1:?] OF IfcSpatialElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelServicesBuildings : IfcRelConnects
	{
		public IfcSystem RelatingSystem { get; set; }
		public List<IfcSpatialElement> RelatedBuildings { get; set; }
		public IfcRelServicesBuildings() : base()
		{
			RelatingSystem = new IfcSystem();
			RelatedBuildings = new List<IfcSpatialElement>();
		}
		public IfcRelServicesBuildings(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSystem RelatingSystem, List<IfcSpatialElement> RelatedBuildings) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingSystem = RelatingSystem;
			this.RelatedBuildings = RelatedBuildings;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSpaceBoundary
	/// <para>ENTITY IfcRelSpaceBoundary</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelSpaceBoundary1stLevel))</para>
	/// <para> SUBTYPE OF (IfcRelConnects);</para>
	/// <para>	RelatingSpace : IfcSpaceBoundarySelect;</para>
	/// <para>	RelatedBuildingElement : IfcElement;</para>
	/// <para>	ConnectionGeometry : OPTIONAL IfcConnectionGeometry;</para>
	/// <para>	PhysicalOrVirtualBoundary : IfcPhysicalOrVirtualEnum;</para>
	/// <para>	InternalOrExternalBoundary : IfcInternalOrExternalEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPhysOrVirt : ((PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.Physical) </para>
	/// <para>  AND (NOT('IFC4.IFCVIRTUALELEMENT' IN TYPEOF(RelatedBuildingElement)))) </para>
	/// <para>OR </para>
	/// <para>((PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.Virtual) </para>
	/// <para>  AND (('IFC4.IFCVIRTUALELEMENT' IN TYPEOF(RelatedBuildingElement)) </para>
	/// <para>  OR   ('IFC4.IFCOPENINGELEMENT' IN TYPEOF(RelatedBuildingElement)))) </para>
	/// <para>OR </para>
	/// <para>(PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.NotDefined);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSpaceBoundary : IfcRelConnects
	{
		public IfcSpaceBoundarySelect RelatingSpace { get; set; }
		public IfcElement RelatedBuildingElement { get; set; }
		public IfcConnectionGeometry? ConnectionGeometry { get; set; }
		public IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary { get; set; }
		public IfcInternalOrExternalEnum InternalOrExternalBoundary { get; set; }
		public IfcRelSpaceBoundary() : base()
		{
			RelatingSpace = new IfcSpaceBoundarySelect();
			RelatedBuildingElement = new IfcElement();
			PhysicalOrVirtualBoundary = new IfcPhysicalOrVirtualEnum();
			InternalOrExternalBoundary = new IfcInternalOrExternalEnum();
		}
		public IfcRelSpaceBoundary(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpaceBoundarySelect RelatingSpace, IfcElement RelatedBuildingElement, IfcConnectionGeometry ConnectionGeometry, IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum InternalOrExternalBoundary) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingSpace = RelatingSpace;
			this.RelatedBuildingElement = RelatedBuildingElement;
			this.ConnectionGeometry = ConnectionGeometry;
			this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
			this.InternalOrExternalBoundary = InternalOrExternalBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSpaceBoundary1stLevel
	/// <para>ENTITY IfcRelSpaceBoundary1stLevel</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelSpaceBoundary2ndLevel))</para>
	/// <para> SUBTYPE OF (IfcRelSpaceBoundary);</para>
	/// <para>	ParentBoundary : OPTIONAL IfcRelSpaceBoundary1stLevel;</para>
	/// <para> INVERSE</para>
	/// <para>	InnerBoundaries : SET [0:?] OF IfcRelSpaceBoundary1stLevel FOR ParentBoundary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSpaceBoundary1stLevel : IfcRelSpaceBoundary
	{
		public IfcRelSpaceBoundary1stLevel? ParentBoundary { get; set; }
		public IfcRelSpaceBoundary1stLevel() : base()
		{
		}
		public IfcRelSpaceBoundary1stLevel(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpaceBoundarySelect RelatingSpace, IfcElement RelatedBuildingElement, IfcConnectionGeometry ConnectionGeometry, IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel ParentBoundary) : base (GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary)
		{
			this.ParentBoundary = ParentBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSpaceBoundary2ndLevel
	/// <para>ENTITY IfcRelSpaceBoundary2ndLevel</para>
	/// <para> SUBTYPE OF (IfcRelSpaceBoundary1stLevel);</para>
	/// <para>	CorrespondingBoundary : OPTIONAL IfcRelSpaceBoundary2ndLevel;</para>
	/// <para> INVERSE</para>
	/// <para>	Corresponds : SET [0:1] OF IfcRelSpaceBoundary2ndLevel FOR CorrespondingBoundary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSpaceBoundary2ndLevel : IfcRelSpaceBoundary1stLevel
	{
		public IfcRelSpaceBoundary2ndLevel? CorrespondingBoundary { get; set; }
		public IfcRelSpaceBoundary2ndLevel() : base()
		{
		}
		public IfcRelSpaceBoundary2ndLevel(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpaceBoundarySelect RelatingSpace, IfcElement RelatedBuildingElement, IfcConnectionGeometry ConnectionGeometry, IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel ParentBoundary, IfcRelSpaceBoundary2ndLevel CorrespondingBoundary) : base (GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary)
		{
			this.CorrespondingBoundary = CorrespondingBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelVoidsElement
	/// <para>ENTITY IfcRelVoidsElement</para>
	/// <para> SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>	RelatingBuildingElement : IfcElement;</para>
	/// <para>	RelatedOpeningElement : IfcFeatureElementSubtraction;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelVoidsElement : IfcRelDecomposes
	{
		public IfcElement RelatingBuildingElement { get; set; }
		public IfcFeatureElementSubtraction RelatedOpeningElement { get; set; }
		public IfcRelVoidsElement() : base()
		{
			RelatingBuildingElement = new IfcElement();
			RelatedOpeningElement = new IfcFeatureElementSubtraction();
		}
		public IfcRelVoidsElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingBuildingElement, IfcFeatureElementSubtraction RelatedOpeningElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingBuildingElement = RelatingBuildingElement;
			this.RelatedOpeningElement = RelatedOpeningElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelationship
	/// <para>ENTITY IfcRelationship</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRelAssigns</para>
	/// <para>    ,IfcRelAssociates</para>
	/// <para>    ,IfcRelConnects</para>
	/// <para>    ,IfcRelDeclares</para>
	/// <para>    ,IfcRelDecomposes</para>
	/// <para>    ,IfcRelDefines))</para>
	/// <para> SUBTYPE OF (IfcRoot);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelationship : IfcRoot
	{
		public IfcRelationship() : base()
		{
		}
		public IfcRelationship(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcReparametrisedCompositeCurveSegment
	/// <para>ENTITY IfcReparametrisedCompositeCurveSegment</para>
	/// <para> SUBTYPE OF (IfcCompositeCurveSegment);</para>
	/// <para>	ParamLength : IfcParameterValue;</para>
	/// <para> WHERE</para>
	/// <para>	PositiveLengthParameter : ParamLength > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReparametrisedCompositeCurveSegment : IfcCompositeCurveSegment
	{
		public IfcParameterValue ParamLength { get; set; }
		public IfcReparametrisedCompositeCurveSegment() : base()
		{
			ParamLength = new IfcParameterValue();
		}
		public IfcReparametrisedCompositeCurveSegment(IfcTransitionCode Transition, IfcBoolean SameSense, IfcCurve ParentCurve, IfcParameterValue ParamLength) : base (Transition, SameSense, ParentCurve)
		{
			this.ParamLength = ParamLength;
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentation
	/// <para>ENTITY IfcRepresentation</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcShapeModel</para>
	/// <para>    ,IfcStyleModel));</para>
	/// <para>	ContextOfItems : IfcRepresentationContext;</para>
	/// <para>	RepresentationIdentifier : OPTIONAL IfcLabel;</para>
	/// <para>	RepresentationType : OPTIONAL IfcLabel;</para>
	/// <para>	Items : SET [1:?] OF IfcRepresentationItem;</para>
	/// <para> INVERSE</para>
	/// <para>	RepresentationMap : SET [0:1] OF IfcRepresentationMap FOR MappedRepresentation;</para>
	/// <para>	LayerAssignments : SET [0:?] OF IfcPresentationLayerAssignment FOR AssignedItems;</para>
	/// <para>	OfProductRepresentation : SET [0:?] OF IfcProductRepresentation FOR Representations;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRepresentation : ENTITY, IfcLayeredItem
	{
		public IfcRepresentationContext ContextOfItems { get; set; }
		public IfcLabel? RepresentationIdentifier { get; set; }
		public IfcLabel? RepresentationType { get; set; }
		public List<IfcRepresentationItem> Items { get; set; }
		public IfcRepresentation() : base()
		{
			ContextOfItems = new IfcRepresentationContext();
			Items = new List<IfcRepresentationItem>();
		}
		public IfcRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base ()
		{
			this.ContextOfItems = ContextOfItems;
			this.RepresentationIdentifier = RepresentationIdentifier;
			this.RepresentationType = RepresentationType;
			this.Items = Items;
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentationContext
	/// <para>ENTITY IfcRepresentationContext</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcGeometricRepresentationContext));</para>
	/// <para>	ContextIdentifier : OPTIONAL IfcLabel;</para>
	/// <para>	ContextType : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	RepresentationsInContext : SET [0:?] OF IfcRepresentation FOR ContextOfItems;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRepresentationContext : ENTITY
	{
		public IfcLabel? ContextIdentifier { get; set; }
		public IfcLabel? ContextType { get; set; }
		public IfcRepresentationContext() : base()
		{
		}
		public IfcRepresentationContext(IfcLabel ContextIdentifier, IfcLabel ContextType) : base ()
		{
			this.ContextIdentifier = ContextIdentifier;
			this.ContextType = ContextType;
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentationItem
	/// <para>ENTITY IfcRepresentationItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcGeometricRepresentationItem</para>
	/// <para>    ,IfcMappedItem</para>
	/// <para>    ,IfcStyledItem</para>
	/// <para>    ,IfcTopologicalRepresentationItem));</para>
	/// <para> INVERSE</para>
	/// <para>	LayerAssignment : SET [0:1] OF IfcPresentationLayerAssignment FOR AssignedItems;</para>
	/// <para>	StyledByItem : SET [0:1] OF IfcStyledItem FOR Item;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRepresentationItem : ENTITY, IfcLayeredItem
	{
		public IfcRepresentationItem() : base()
		{
		}
		public IfcRepresentationItem() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentationMap;
	/// <para>ENTITY IfcRepresentationMap;</para>
	/// <para>	MappingOrigin : IfcAxis2Placement;</para>
	/// <para>	MappedRepresentation : IfcRepresentation;</para>
	/// <para> INVERSE</para>
	/// <para>	HasShapeAspects : SET [0:?] OF IfcShapeAspect FOR PartOfProductDefinitionShape;</para>
	/// <para>	MapUsage : SET [0:?] OF IfcMappedItem FOR MappingSource;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableMappedRepr : 'IFC4.IFCSHAPEMODEL' IN TYPEOF(MappedRepresentation);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRepresentationMap : ENTITY, IfcProductRepresentationSelect
	{
		public IfcAxis2Placement MappingOrigin { get; set; }
		public IfcRepresentation MappedRepresentation { get; set; }
		public IfcRepresentationMap() : base()
		{
			MappingOrigin = new IfcAxis2Placement();
			MappedRepresentation = new IfcRepresentation();
		}
		public IfcRepresentationMap(IfcAxis2Placement MappingOrigin, IfcRepresentation MappedRepresentation) : base ()
		{
			this.MappingOrigin = MappingOrigin;
			this.MappedRepresentation = MappedRepresentation;
		}
	}
	/// <summary>
	/// ENTITY IfcResource
	/// <para>ENTITY IfcResource</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcConstructionResource))</para>
	/// <para> SUBTYPE OF (IfcObject);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para> INVERSE</para>
	/// <para>	ResourceOf : SET [0:?] OF IfcRelAssignsToResource FOR RelatingResource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcResource : IfcObject, IfcResourceSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcResource() : base()
		{
		}
		public IfcResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceApprovalRelationship
	/// <para>ENTITY IfcResourceApprovalRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatedResourceObjects : SET [1:?] OF IfcResourceObjectSelect;</para>
	/// <para>	RelatingApproval : IfcApproval;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcResourceApprovalRelationship : IfcResourceLevelRelationship
	{
		public List<IfcResourceObjectSelect> RelatedResourceObjects { get; set; }
		public IfcApproval RelatingApproval { get; set; }
		public IfcResourceApprovalRelationship() : base()
		{
			RelatedResourceObjects = new List<IfcResourceObjectSelect>();
			RelatingApproval = new IfcApproval();
		}
		public IfcResourceApprovalRelationship(IfcLabel Name, IfcText Description, List<IfcResourceObjectSelect> RelatedResourceObjects, IfcApproval RelatingApproval) : base (Name, Description)
		{
			this.RelatedResourceObjects = RelatedResourceObjects;
			this.RelatingApproval = RelatingApproval;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceConstraintRelationship
	/// <para>ENTITY IfcResourceConstraintRelationship</para>
	/// <para> SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>	RelatingConstraint : IfcConstraint;</para>
	/// <para>	RelatedResourceObjects : SET [1:?] OF IfcResourceObjectSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcResourceConstraintRelationship : IfcResourceLevelRelationship
	{
		public IfcConstraint RelatingConstraint { get; set; }
		public List<IfcResourceObjectSelect> RelatedResourceObjects { get; set; }
		public IfcResourceConstraintRelationship() : base()
		{
			RelatingConstraint = new IfcConstraint();
			RelatedResourceObjects = new List<IfcResourceObjectSelect>();
		}
		public IfcResourceConstraintRelationship(IfcLabel Name, IfcText Description, IfcConstraint RelatingConstraint, List<IfcResourceObjectSelect> RelatedResourceObjects) : base (Name, Description)
		{
			this.RelatingConstraint = RelatingConstraint;
			this.RelatedResourceObjects = RelatedResourceObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceLevelRelationship
	/// <para>ENTITY IfcResourceLevelRelationship</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcApprovalRelationship</para>
	/// <para>    ,IfcCurrencyRelationship</para>
	/// <para>    ,IfcDocumentInformationRelationship</para>
	/// <para>    ,IfcExternalReferenceRelationship</para>
	/// <para>    ,IfcMaterialRelationship</para>
	/// <para>    ,IfcOrganizationRelationship</para>
	/// <para>    ,IfcPropertyDependencyRelationship</para>
	/// <para>    ,IfcResourceApprovalRelationship</para>
	/// <para>    ,IfcResourceConstraintRelationship));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcResourceLevelRelationship : ENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcResourceLevelRelationship() : base()
		{
		}
		public IfcResourceLevelRelationship(IfcLabel Name, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceTime
	/// <para>ENTITY IfcResourceTime</para>
	/// <para> SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>	ScheduleWork : OPTIONAL IfcDuration;</para>
	/// <para>	ScheduleUsage : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>	ScheduleStart : OPTIONAL IfcDateTime;</para>
	/// <para>	ScheduleFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	ScheduleContour : OPTIONAL IfcLabel;</para>
	/// <para>	LevelingDelay : OPTIONAL IfcDuration;</para>
	/// <para>	IsOverAllocated : OPTIONAL IfcBoolean;</para>
	/// <para>	StatusTime : OPTIONAL IfcDateTime;</para>
	/// <para>	ActualWork : OPTIONAL IfcDuration;</para>
	/// <para>	ActualUsage : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>	ActualStart : OPTIONAL IfcDateTime;</para>
	/// <para>	ActualFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	RemainingWork : OPTIONAL IfcDuration;</para>
	/// <para>	RemainingUsage : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>	Completion : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcResourceTime : IfcSchedulingTime
	{
		public IfcDuration? ScheduleWork { get; set; }
		public IfcPositiveRatioMeasure? ScheduleUsage { get; set; }
		public IfcDateTime? ScheduleStart { get; set; }
		public IfcDateTime? ScheduleFinish { get; set; }
		public IfcLabel? ScheduleContour { get; set; }
		public IfcDuration? LevelingDelay { get; set; }
		public IfcBoolean? IsOverAllocated { get; set; }
		public IfcDateTime? StatusTime { get; set; }
		public IfcDuration? ActualWork { get; set; }
		public IfcPositiveRatioMeasure? ActualUsage { get; set; }
		public IfcDateTime? ActualStart { get; set; }
		public IfcDateTime? ActualFinish { get; set; }
		public IfcDuration? RemainingWork { get; set; }
		public IfcPositiveRatioMeasure? RemainingUsage { get; set; }
		public IfcPositiveRatioMeasure? Completion { get; set; }
		public IfcResourceTime() : base()
		{
		}
		public IfcResourceTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcDuration ScheduleWork, IfcPositiveRatioMeasure ScheduleUsage, IfcDateTime ScheduleStart, IfcDateTime ScheduleFinish, IfcLabel ScheduleContour, IfcDuration LevelingDelay, IfcBoolean IsOverAllocated, IfcDateTime StatusTime, IfcDuration ActualWork, IfcPositiveRatioMeasure ActualUsage, IfcDateTime ActualStart, IfcDateTime ActualFinish, IfcDuration RemainingWork, IfcPositiveRatioMeasure RemainingUsage, IfcPositiveRatioMeasure Completion) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.ScheduleWork = ScheduleWork;
			this.ScheduleUsage = ScheduleUsage;
			this.ScheduleStart = ScheduleStart;
			this.ScheduleFinish = ScheduleFinish;
			this.ScheduleContour = ScheduleContour;
			this.LevelingDelay = LevelingDelay;
			this.IsOverAllocated = IsOverAllocated;
			this.StatusTime = StatusTime;
			this.ActualWork = ActualWork;
			this.ActualUsage = ActualUsage;
			this.ActualStart = ActualStart;
			this.ActualFinish = ActualFinish;
			this.RemainingWork = RemainingWork;
			this.RemainingUsage = RemainingUsage;
			this.Completion = Completion;
		}
	}
	/// <summary>
	/// ENTITY IfcRevolvedAreaSolid
	/// <para>ENTITY IfcRevolvedAreaSolid</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcRevolvedAreaSolidTapered))</para>
	/// <para> SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>	Axis : IfcAxis1Placement;</para>
	/// <para>	Angle : IfcPlaneAngleMeasure;</para>
	/// <para> DERIVE</para>
	/// <para>	AxisLine : IfcLine := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcCurve() || IfcLine(Axis.Location, </para>
	/// <para>  IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector(Axis.Z,1.0));</para>
	/// <para> WHERE</para>
	/// <para>	AxisStartInXY : Axis.Location.Coordinates[3] = 0.0;</para>
	/// <para>	AxisDirectionInXY : Axis.Z.DirectionRatios[3] = 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRevolvedAreaSolid : IfcSweptAreaSolid
	{
		public IfcAxis1Placement Axis { get; set; }
		public IfcPlaneAngleMeasure Angle { get; set; }
		public IfcRevolvedAreaSolid() : base()
		{
			Axis = new IfcAxis1Placement();
			Angle = new IfcPlaneAngleMeasure();
		}
		public IfcRevolvedAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcAxis1Placement Axis, IfcPlaneAngleMeasure Angle) : base (SweptArea, Position)
		{
			this.Axis = Axis;
			this.Angle = Angle;
		}
	}
	/// <summary>
	/// ENTITY IfcRevolvedAreaSolidTapered
	/// <para>ENTITY IfcRevolvedAreaSolidTapered</para>
	/// <para> SUBTYPE OF (IfcRevolvedAreaSolid);</para>
	/// <para>	EndSweptArea : IfcProfileDef;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectProfileAssignment : IfcTaperedSweptAreaProfiles(SELF\IfcSweptAreaSolid.SweptArea, SELF.EndSweptArea);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRevolvedAreaSolidTapered : IfcRevolvedAreaSolid
	{
		public IfcProfileDef EndSweptArea { get; set; }
		public IfcRevolvedAreaSolidTapered() : base()
		{
			EndSweptArea = new IfcProfileDef();
		}
		public IfcRevolvedAreaSolidTapered(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcAxis1Placement Axis, IfcPlaneAngleMeasure Angle, IfcProfileDef EndSweptArea) : base (SweptArea, Position, Axis, Angle)
		{
			this.EndSweptArea = EndSweptArea;
		}
	}
	/// <summary>
	/// ENTITY IfcRightCircularCone
	/// <para>ENTITY IfcRightCircularCone</para>
	/// <para> SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>	Height : IfcPositiveLengthMeasure;</para>
	/// <para>	BottomRadius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRightCircularCone : IfcCsgPrimitive3D
	{
		public IfcPositiveLengthMeasure Height { get; set; }
		public IfcPositiveLengthMeasure BottomRadius { get; set; }
		public IfcRightCircularCone() : base()
		{
			Height = new IfcPositiveLengthMeasure();
			BottomRadius = new IfcPositiveLengthMeasure();
		}
		public IfcRightCircularCone(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Height, IfcPositiveLengthMeasure BottomRadius) : base (Position)
		{
			this.Height = Height;
			this.BottomRadius = BottomRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcRightCircularCylinder
	/// <para>ENTITY IfcRightCircularCylinder</para>
	/// <para> SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>	Height : IfcPositiveLengthMeasure;</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRightCircularCylinder : IfcCsgPrimitive3D
	{
		public IfcPositiveLengthMeasure Height { get; set; }
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcRightCircularCylinder() : base()
		{
			Height = new IfcPositiveLengthMeasure();
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcRightCircularCylinder(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Height, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Height = Height;
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcRoof
	/// <para>ENTITY IfcRoof</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcRoofTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcRoofTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcRoofTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCROOFTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoof : IfcBuildingElement
	{
		public IfcRoofTypeEnum? PredefinedType { get; set; }
		public IfcRoof() : base()
		{
		}
		public IfcRoof(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRoofTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRoofType
	/// <para>ENTITY IfcRoofType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcRoofTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcRoofTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRoofTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoofType : IfcBuildingElementType
	{
		public IfcRoofTypeEnum PredefinedType { get; set; }
		public IfcRoofType() : base()
		{
			PredefinedType = new IfcRoofTypeEnum();
		}
		public IfcRoofType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRoofTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRoot
	/// <para>ENTITY IfcRoot</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcObjectDefinition</para>
	/// <para>    ,IfcPropertyDefinition</para>
	/// <para>    ,IfcRelationship));</para>
	/// <para>	GlobalId : IfcGloballyUniqueId;</para>
	/// <para>	OwnerHistory : OPTIONAL IfcOwnerHistory;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para> UNIQUE</para>
	/// <para>	UR1 : GlobalId;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRoot : ENTITY
	{
		public IfcGloballyUniqueId GlobalId { get; set; }
		public IfcOwnerHistory? OwnerHistory { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcRoot() : base()
		{
			GlobalId = new IfcGloballyUniqueId();
		}
		public IfcRoot(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base ()
		{
			this.GlobalId = GlobalId;
			this.OwnerHistory = OwnerHistory;
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcRoundedRectangleProfileDef
	/// <para>ENTITY IfcRoundedRectangleProfileDef</para>
	/// <para> SUBTYPE OF (IfcRectangleProfileDef);</para>
	/// <para>	RoundingRadius : IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidRadius : ((RoundingRadius <= (SELF\IfcRectangleProfileDef.XDim/2.)) AND </para>
	/// <para> (RoundingRadius <= (SELF\IfcRectangleProfileDef.YDim/2.)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoundedRectangleProfileDef : IfcRectangleProfileDef
	{
		public IfcPositiveLengthMeasure RoundingRadius { get; set; }
		public IfcRoundedRectangleProfileDef() : base()
		{
			RoundingRadius = new IfcPositiveLengthMeasure();
		}
		public IfcRoundedRectangleProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim, IfcPositiveLengthMeasure RoundingRadius) : base (ProfileType, ProfileName, Position, XDim, YDim)
		{
			this.RoundingRadius = RoundingRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcSIUnit
	/// <para>ENTITY IfcSIUnit</para>
	/// <para> SUBTYPE OF (IfcNamedUnit);</para>
	/// <para>	Prefix : OPTIONAL IfcSIPrefix;</para>
	/// <para>	Name : IfcSIUnitName;</para>
	/// <para> DERIVE</para>
	/// <para>	SELF\IfcNamedUnit.Dimensions : IfcDimensionalExponents := IfcDimensionsForSiUnit (SELF.Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSIUnit : IfcNamedUnit
	{
		public IfcSIPrefix? Prefix { get; set; }
		public IfcSIUnitName Name { get; set; }
		public IfcSIUnit() : base()
		{
			Name = new IfcSIUnitName();
		}
		public IfcSIUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcSIPrefix Prefix, IfcSIUnitName Name) : base (Dimensions, UnitType)
		{
			this.Prefix = Prefix;
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcSanitaryTerminal
	/// <para>ENTITY IfcSanitaryTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSanitaryTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcSanitaryTerminalTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcSanitaryTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCSANITARYTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSanitaryTerminal : IfcFlowTerminal
	{
		public IfcSanitaryTerminalTypeEnum? PredefinedType { get; set; }
		public IfcSanitaryTerminal() : base()
		{
		}
		public IfcSanitaryTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSanitaryTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSanitaryTerminalType
	/// <para>ENTITY IfcSanitaryTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcSanitaryTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSanitaryTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSanitaryTerminalTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSanitaryTerminalType : IfcFlowTerminalType
	{
		public IfcSanitaryTerminalTypeEnum PredefinedType { get; set; }
		public IfcSanitaryTerminalType() : base()
		{
			PredefinedType = new IfcSanitaryTerminalTypeEnum();
		}
		public IfcSanitaryTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSanitaryTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSchedulingTime
	/// <para>ENTITY IfcSchedulingTime</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcEventTime</para>
	/// <para>    ,IfcLagTime</para>
	/// <para>    ,IfcResourceTime</para>
	/// <para>    ,IfcTaskTime</para>
	/// <para>    ,IfcWorkTime));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	DataOrigin : OPTIONAL IfcDataOriginEnum;</para>
	/// <para>	UserDefinedDataOrigin : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSchedulingTime : ENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcDataOriginEnum? DataOrigin { get; set; }
		public IfcLabel? UserDefinedDataOrigin { get; set; }
		public IfcSchedulingTime() : base()
		{
		}
		public IfcSchedulingTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin) : base ()
		{
			this.Name = Name;
			this.DataOrigin = DataOrigin;
			this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		}
	}
	/// <summary>
	/// ENTITY IfcSeamCurve
	/// <para>ENTITY IfcSeamCurve</para>
	/// <para> SUBTYPE OF (IfcSurfaceCurve);</para>
	/// <para> WHERE</para>
	/// <para>	TwoPCurves : SIZEOF(SELF\IfcSurfaceCurve.AssociatedGeometry) = 2;</para>
	/// <para>	SameSurface : IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[1]) = IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[2]);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSeamCurve : IfcSurfaceCurve
	{
		public IfcSeamCurve() : base()
		{
		}
		public IfcSeamCurve(IfcCurve Curve3D, List<IfcPcurve> AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation MasterRepresentation) : base (Curve3D, AssociatedGeometry, MasterRepresentation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSectionProperties
	/// <para>ENTITY IfcSectionProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedProperties);</para>
	/// <para>	SectionType : IfcSectionTypeEnum;</para>
	/// <para>	StartProfile : IfcProfileDef;</para>
	/// <para>	EndProfile : OPTIONAL IfcProfileDef;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionProperties : IfcPreDefinedProperties
	{
		public IfcSectionTypeEnum SectionType { get; set; }
		public IfcProfileDef StartProfile { get; set; }
		public IfcProfileDef? EndProfile { get; set; }
		public IfcSectionProperties() : base()
		{
			SectionType = new IfcSectionTypeEnum();
			StartProfile = new IfcProfileDef();
		}
		public IfcSectionProperties(IfcSectionTypeEnum SectionType, IfcProfileDef StartProfile, IfcProfileDef EndProfile) : base ()
		{
			this.SectionType = SectionType;
			this.StartProfile = StartProfile;
			this.EndProfile = EndProfile;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionReinforcementProperties
	/// <para>ENTITY IfcSectionReinforcementProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedProperties);</para>
	/// <para>	LongitudinalStartPosition : IfcLengthMeasure;</para>
	/// <para>	LongitudinalEndPosition : IfcLengthMeasure;</para>
	/// <para>	TransversePosition : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	ReinforcementRole : IfcReinforcingBarRoleEnum;</para>
	/// <para>	SectionDefinition : IfcSectionProperties;</para>
	/// <para>	CrossSectionReinforcementDefinitions : SET [1:?] OF IfcReinforcementBarProperties;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionReinforcementProperties : IfcPreDefinedProperties
	{
		public IfcLengthMeasure LongitudinalStartPosition { get; set; }
		public IfcLengthMeasure LongitudinalEndPosition { get; set; }
		public IfcLengthMeasure? TransversePosition { get; set; }
		public IfcReinforcingBarRoleEnum ReinforcementRole { get; set; }
		public IfcSectionProperties SectionDefinition { get; set; }
		public List<IfcReinforcementBarProperties> CrossSectionReinforcementDefinitions { get; set; }
		public IfcSectionReinforcementProperties() : base()
		{
			LongitudinalStartPosition = new IfcLengthMeasure();
			LongitudinalEndPosition = new IfcLengthMeasure();
			ReinforcementRole = new IfcReinforcingBarRoleEnum();
			SectionDefinition = new IfcSectionProperties();
			CrossSectionReinforcementDefinitions = new List<IfcReinforcementBarProperties>();
		}
		public IfcSectionReinforcementProperties(IfcLengthMeasure LongitudinalStartPosition, IfcLengthMeasure LongitudinalEndPosition, IfcLengthMeasure TransversePosition, IfcReinforcingBarRoleEnum ReinforcementRole, IfcSectionProperties SectionDefinition, List<IfcReinforcementBarProperties> CrossSectionReinforcementDefinitions) : base ()
		{
			this.LongitudinalStartPosition = LongitudinalStartPosition;
			this.LongitudinalEndPosition = LongitudinalEndPosition;
			this.TransversePosition = TransversePosition;
			this.ReinforcementRole = ReinforcementRole;
			this.SectionDefinition = SectionDefinition;
			this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionedSpine
	/// <para>ENTITY IfcSectionedSpine</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	SpineCurve : IfcCompositeCurve;</para>
	/// <para>	CrossSections : LIST [2:?] OF IfcProfileDef;</para>
	/// <para>	CrossSectionPositions : LIST [2:?] OF IfcAxis2Placement3D;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := 3;</para>
	/// <para> WHERE</para>
	/// <para>	CorrespondingSectionPositions : SIZEOF(CrossSections) = SIZEOF(CrossSectionPositions);</para>
	/// <para>	ConsistentProfileTypes : SIZEOF(QUERY(temp <* CrossSections | CrossSections[1].ProfileType <> temp.ProfileType)) = 0;</para>
	/// <para>	SpineCurveDim : SpineCurve.Dim = 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionedSpine : IfcGeometricRepresentationItem
	{
		public IfcCompositeCurve SpineCurve { get; set; }
		public List<IfcProfileDef> CrossSections { get; set; }
		public List<IfcAxis2Placement3D> CrossSectionPositions { get; set; }
		public IfcSectionedSpine() : base()
		{
			SpineCurve = new IfcCompositeCurve();
			CrossSections = new List<IfcProfileDef>();
			CrossSectionPositions = new List<IfcAxis2Placement3D>();
		}
		public IfcSectionedSpine(IfcCompositeCurve SpineCurve, List<IfcProfileDef> CrossSections, List<IfcAxis2Placement3D> CrossSectionPositions) : base ()
		{
			this.SpineCurve = SpineCurve;
			this.CrossSections = CrossSections;
			this.CrossSectionPositions = CrossSectionPositions;
		}
	}
	/// <summary>
	/// ENTITY IfcSensor
	/// <para>ENTITY IfcSensor</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSensorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcSensorTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcSensorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>('IFC4.IFCSENSORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSensor : IfcDistributionControlElement
	{
		public IfcSensorTypeEnum? PredefinedType { get; set; }
		public IfcSensor() : base()
		{
		}
		public IfcSensor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSensorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSensorType
	/// <para>ENTITY IfcSensorType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcSensorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSensorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSensorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSensorType : IfcDistributionControlElementType
	{
		public IfcSensorTypeEnum PredefinedType { get; set; }
		public IfcSensorType() : base()
		{
			PredefinedType = new IfcSensorTypeEnum();
		}
		public IfcSensorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSensorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcShadingDevice
	/// <para>ENTITY IfcShadingDevice</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcShadingDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcShadingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcShadingDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCSHADINGDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShadingDevice : IfcBuildingElement
	{
		public IfcShadingDeviceTypeEnum? PredefinedType { get; set; }
		public IfcShadingDevice() : base()
		{
		}
		public IfcShadingDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcShadingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcShadingDeviceType
	/// <para>ENTITY IfcShadingDeviceType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcShadingDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcShadingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcShadingDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShadingDeviceType : IfcBuildingElementType
	{
		public IfcShadingDeviceTypeEnum PredefinedType { get; set; }
		public IfcShadingDeviceType() : base()
		{
			PredefinedType = new IfcShadingDeviceTypeEnum();
		}
		public IfcShadingDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcShadingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcShapeAspect;
	/// <para>ENTITY IfcShapeAspect;</para>
	/// <para>	ShapeRepresentations : LIST [1:?] OF IfcShapeModel;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	ProductDefinitional : IfcLogical;</para>
	/// <para>	PartOfProductDefinitionShape : OPTIONAL IfcProductRepresentationSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShapeAspect : ENTITY
	{
		public List<IfcShapeModel> ShapeRepresentations { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcLogical ProductDefinitional { get; set; }
		public IfcProductRepresentationSelect? PartOfProductDefinitionShape { get; set; }
		public IfcShapeAspect() : base()
		{
			ShapeRepresentations = new List<IfcShapeModel>();
			ProductDefinitional = new IfcLogical();
		}
		public IfcShapeAspect(List<IfcShapeModel> ShapeRepresentations, IfcLabel Name, IfcText Description, IfcLogical ProductDefinitional, IfcProductRepresentationSelect PartOfProductDefinitionShape) : base ()
		{
			this.ShapeRepresentations = ShapeRepresentations;
			this.Name = Name;
			this.Description = Description;
			this.ProductDefinitional = ProductDefinitional;
			this.PartOfProductDefinitionShape = PartOfProductDefinitionShape;
		}
	}
	/// <summary>
	/// ENTITY IfcShapeModel
	/// <para>ENTITY IfcShapeModel</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcShapeRepresentation</para>
	/// <para>    ,IfcTopologyRepresentation))</para>
	/// <para> SUBTYPE OF (IfcRepresentation);</para>
	/// <para> INVERSE</para>
	/// <para>	OfShapeAspect : SET [0:1] OF IfcShapeAspect FOR ShapeRepresentations;</para>
	/// <para> WHERE</para>
	/// <para>	WR11 : (SIZEOF(SELF\IfcRepresentation.OfProductRepresentation) = 1) XOR </para>
	/// <para>(SIZEOF(SELF\IfcRepresentation.RepresentationMap) = 1) XOR</para>
	/// <para>(SIZEOF(OfShapeAspect) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcShapeModel : IfcRepresentation
	{
		public IfcShapeModel() : base()
		{
		}
		public IfcShapeModel(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcShapeRepresentation
	/// <para>ENTITY IfcShapeRepresentation</para>
	/// <para> SUBTYPE OF (IfcShapeModel);</para>
	/// <para> WHERE</para>
	/// <para>	CorrectContext : 'IFC4.IFCGEOMETRICREPRESENTATIONCONTEXT' </para>
	/// <para>IN TYPEOF(SELF\IfcRepresentation.ContextOfItems);</para>
	/// <para>	NoTopologicalItem : SIZEOF(QUERY(temp <* Items | </para>
	/// <para>  ('IFC4.IFCTOPOLOGICALREPRESENTATIONITEM' IN TYPEOF(temp))</para>
	/// <para>    AND (NOT(SIZEOF(</para>
	/// <para>      ['IFC4.IFCVERTEXPOINT',</para>
	/// <para>       'IFC4.IFCEDGECURVE',</para>
	/// <para>       'IFC4.IFCFACESURFACE'] * TYPEOF(temp)) = 1))</para>
	/// <para>)) = 0;</para>
	/// <para>	HasRepresentationType : EXISTS(SELF\IfcRepresentation.RepresentationType);</para>
	/// <para>	HasRepresentationIdentifier : EXISTS(SELF\IfcRepresentation.RepresentationIdentifier);</para>
	/// <para>	CorrectItemsForType : IfcShapeRepresentationTypes(SELF\IfcRepresentation.RepresentationType, SELF\IfcRepresentation.Items);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShapeRepresentation : IfcShapeModel
	{
		public IfcShapeRepresentation() : base()
		{
		}
		public IfcShapeRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcShellBasedSurfaceModel
	/// <para>ENTITY IfcShellBasedSurfaceModel</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	SbsmBoundary : SET [1:?] OF IfcShell;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShellBasedSurfaceModel : IfcGeometricRepresentationItem
	{
		public List<IfcShell> SbsmBoundary { get; set; }
		public IfcShellBasedSurfaceModel() : base()
		{
			SbsmBoundary = new List<IfcShell>();
		}
		public IfcShellBasedSurfaceModel(List<IfcShell> SbsmBoundary) : base ()
		{
			this.SbsmBoundary = SbsmBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcSimpleProperty
	/// <para>ENTITY IfcSimpleProperty</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPropertyBoundedValue</para>
	/// <para>    ,IfcPropertyEnumeratedValue</para>
	/// <para>    ,IfcPropertyListValue</para>
	/// <para>    ,IfcPropertyReferenceValue</para>
	/// <para>    ,IfcPropertySingleValue</para>
	/// <para>    ,IfcPropertyTableValue))</para>
	/// <para> SUBTYPE OF (IfcProperty);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSimpleProperty : IfcProperty
	{
		public IfcSimpleProperty() : base()
		{
		}
		public IfcSimpleProperty(IfcIdentifier Name, IfcText Description) : base (Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSimplePropertyTemplate
	/// <para>ENTITY IfcSimplePropertyTemplate</para>
	/// <para> SUBTYPE OF (IfcPropertyTemplate);</para>
	/// <para>	TemplateType : OPTIONAL IfcSimplePropertyTemplateTypeEnum;</para>
	/// <para>	PrimaryMeasureType : OPTIONAL IfcLabel;</para>
	/// <para>	SecondaryMeasureType : OPTIONAL IfcLabel;</para>
	/// <para>	Enumerators : OPTIONAL IfcPropertyEnumeration;</para>
	/// <para>	PrimaryUnit : OPTIONAL IfcUnit;</para>
	/// <para>	SecondaryUnit : OPTIONAL IfcUnit;</para>
	/// <para>	Expression : OPTIONAL IfcLabel;</para>
	/// <para>	AccessState : OPTIONAL IfcStateEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSimplePropertyTemplate : IfcPropertyTemplate
	{
		public IfcSimplePropertyTemplateTypeEnum? TemplateType { get; set; }
		public IfcLabel? PrimaryMeasureType { get; set; }
		public IfcLabel? SecondaryMeasureType { get; set; }
		public IfcPropertyEnumeration? Enumerators { get; set; }
		public IfcUnit? PrimaryUnit { get; set; }
		public IfcUnit? SecondaryUnit { get; set; }
		public IfcLabel? Expression { get; set; }
		public IfcStateEnum? AccessState { get; set; }
		public IfcSimplePropertyTemplate() : base()
		{
		}
		public IfcSimplePropertyTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSimplePropertyTemplateTypeEnum TemplateType, IfcLabel PrimaryMeasureType, IfcLabel SecondaryMeasureType, IfcPropertyEnumeration Enumerators, IfcUnit PrimaryUnit, IfcUnit SecondaryUnit, IfcLabel Expression, IfcStateEnum AccessState) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.TemplateType = TemplateType;
			this.PrimaryMeasureType = PrimaryMeasureType;
			this.SecondaryMeasureType = SecondaryMeasureType;
			this.Enumerators = Enumerators;
			this.PrimaryUnit = PrimaryUnit;
			this.SecondaryUnit = SecondaryUnit;
			this.Expression = Expression;
			this.AccessState = AccessState;
		}
	}
	/// <summary>
	/// ENTITY IfcSite
	/// <para>ENTITY IfcSite</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>	RefLatitude : OPTIONAL IfcCompoundPlaneAngleMeasure;</para>
	/// <para>	RefLongitude : OPTIONAL IfcCompoundPlaneAngleMeasure;</para>
	/// <para>	RefElevation : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LandTitleNumber : OPTIONAL IfcLabel;</para>
	/// <para>	SiteAddress : OPTIONAL IfcPostalAddress;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSite : IfcSpatialStructureElement
	{
		public IfcCompoundPlaneAngleMeasure? RefLatitude { get; set; }
		public IfcCompoundPlaneAngleMeasure? RefLongitude { get; set; }
		public IfcLengthMeasure? RefElevation { get; set; }
		public IfcLabel? LandTitleNumber { get; set; }
		public IfcPostalAddress? SiteAddress { get; set; }
		public IfcSite() : base()
		{
		}
		public IfcSite(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcCompoundPlaneAngleMeasure RefLatitude, IfcCompoundPlaneAngleMeasure RefLongitude, IfcLengthMeasure RefElevation, IfcLabel LandTitleNumber, IfcPostalAddress SiteAddress) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.RefLatitude = RefLatitude;
			this.RefLongitude = RefLongitude;
			this.RefElevation = RefElevation;
			this.LandTitleNumber = LandTitleNumber;
			this.SiteAddress = SiteAddress;
		}
	}
	/// <summary>
	/// ENTITY IfcSlab
	/// <para>ENTITY IfcSlab</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcSlabElementedCase</para>
	/// <para>    ,IfcSlabStandardCase))</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSlabTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSlabTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSlabTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCSLABTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlab : IfcBuildingElement
	{
		public IfcSlabTypeEnum? PredefinedType { get; set; }
		public IfcSlab() : base()
		{
		}
		public IfcSlab(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSlabTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSlabElementedCase
	/// <para>ENTITY IfcSlabElementedCase</para>
	/// <para> SUBTYPE OF (IfcSlab);</para>
	/// <para> WHERE</para>
	/// <para>	HasDecomposition : HIINDEX(SELF\IfcObjectDefinition.IsDecomposedBy) > 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlabElementedCase : IfcSlab
	{
		public IfcSlabElementedCase() : base()
		{
		}
		public IfcSlabElementedCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSlabTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSlabStandardCase
	/// <para>ENTITY IfcSlabStandardCase</para>
	/// <para> SUBTYPE OF (IfcSlab);</para>
	/// <para> WHERE</para>
	/// <para>	HasMaterialLayerSetusage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>              ('IFC4.IFCMATERIALLAYERSETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>              )) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlabStandardCase : IfcSlab
	{
		public IfcSlabStandardCase() : base()
		{
		}
		public IfcSlabStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSlabTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSlabType
	/// <para>ENTITY IfcSlabType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcSlabTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSlabTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSlabTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlabType : IfcBuildingElementType
	{
		public IfcSlabTypeEnum PredefinedType { get; set; }
		public IfcSlabType() : base()
		{
			PredefinedType = new IfcSlabTypeEnum();
		}
		public IfcSlabType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSlabTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSlippageConnectionCondition
	/// <para>ENTITY IfcSlippageConnectionCondition</para>
	/// <para> SUBTYPE OF (IfcStructuralConnectionCondition);</para>
	/// <para>	SlippageX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	SlippageY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	SlippageZ : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlippageConnectionCondition : IfcStructuralConnectionCondition
	{
		public IfcLengthMeasure? SlippageX { get; set; }
		public IfcLengthMeasure? SlippageY { get; set; }
		public IfcLengthMeasure? SlippageZ { get; set; }
		public IfcSlippageConnectionCondition() : base()
		{
		}
		public IfcSlippageConnectionCondition(IfcLabel Name, IfcLengthMeasure SlippageX, IfcLengthMeasure SlippageY, IfcLengthMeasure SlippageZ) : base (Name)
		{
			this.SlippageX = SlippageX;
			this.SlippageY = SlippageY;
			this.SlippageZ = SlippageZ;
		}
	}
	/// <summary>
	/// ENTITY IfcSolarDevice
	/// <para>ENTITY IfcSolarDevice</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSolarDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcSolarDeviceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcSolarDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCSOLARDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSolarDevice : IfcEnergyConversionDevice
	{
		public IfcSolarDeviceTypeEnum? PredefinedType { get; set; }
		public IfcSolarDevice() : base()
		{
		}
		public IfcSolarDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSolarDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSolarDeviceType
	/// <para>ENTITY IfcSolarDeviceType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcSolarDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSolarDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSolarDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSolarDeviceType : IfcEnergyConversionDeviceType
	{
		public IfcSolarDeviceTypeEnum PredefinedType { get; set; }
		public IfcSolarDeviceType() : base()
		{
			PredefinedType = new IfcSolarDeviceTypeEnum();
		}
		public IfcSolarDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSolarDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSolidModel
	/// <para>ENTITY IfcSolidModel</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcCsgSolid</para>
	/// <para>    ,IfcManifoldSolidBrep</para>
	/// <para>    ,IfcSweptAreaSolid</para>
	/// <para>    ,IfcSweptDiskSolid))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSolidModel : IfcGeometricRepresentationItem, IfcBooleanOperand, IfcSolidOrShell
	{
		public IfcSolidModel() : base()
		{
		}
		public IfcSolidModel() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSpace
	/// <para>ENTITY IfcSpace</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSpaceTypeEnum;</para>
	/// <para>	ElevationWithFlooring : OPTIONAL IfcLengthMeasure;</para>
	/// <para> INVERSE</para>
	/// <para>	HasCoverings : SET [0:?] OF IfcRelCoversSpaces FOR RelatingSpace;</para>
	/// <para>	BoundedBy : SET [0:?] OF IfcRelSpaceBoundary FOR RelatingSpace;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSpaceTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSpaceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCSPACETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpace : IfcSpatialStructureElement, IfcSpaceBoundarySelect
	{
		public IfcSpaceTypeEnum? PredefinedType { get; set; }
		public IfcLengthMeasure? ElevationWithFlooring { get; set; }
		public IfcSpace() : base()
		{
		}
		public IfcSpace(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcSpaceTypeEnum PredefinedType, IfcLengthMeasure ElevationWithFlooring) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.PredefinedType = PredefinedType;
			this.ElevationWithFlooring = ElevationWithFlooring;
		}
	}
	/// <summary>
	/// ENTITY IfcSpaceHeater
	/// <para>ENTITY IfcSpaceHeater</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSpaceHeaterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcSpaceHeaterTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcSpaceHeaterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCSPACEHEATERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpaceHeater : IfcFlowTerminal
	{
		public IfcSpaceHeaterTypeEnum? PredefinedType { get; set; }
		public IfcSpaceHeater() : base()
		{
		}
		public IfcSpaceHeater(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSpaceHeaterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpaceHeaterType
	/// <para>ENTITY IfcSpaceHeaterType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcSpaceHeaterTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSpaceHeaterTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSpaceHeaterTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpaceHeaterType : IfcFlowTerminalType
	{
		public IfcSpaceHeaterTypeEnum PredefinedType { get; set; }
		public IfcSpaceHeaterType() : base()
		{
			PredefinedType = new IfcSpaceHeaterTypeEnum();
		}
		public IfcSpaceHeaterType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSpaceHeaterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpaceType
	/// <para>ENTITY IfcSpaceType</para>
	/// <para> SUBTYPE OF (IfcSpatialStructureElementType);</para>
	/// <para>	PredefinedType : IfcSpaceTypeEnum;</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSpaceTypeEnum.USERDEFINED) OR </para>
	/// <para>((PredefinedType = IfcSpaceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcSpatialElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpaceType : IfcSpatialStructureElementType
	{
		public IfcSpaceTypeEnum PredefinedType { get; set; }
		public IfcLabel? LongName { get; set; }
		public IfcSpaceType() : base()
		{
			PredefinedType = new IfcSpaceTypeEnum();
		}
		public IfcSpaceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSpaceTypeEnum PredefinedType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialElement
	/// <para>ENTITY IfcSpatialElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcExternalSpatialStructureElement</para>
	/// <para>    ,IfcSpatialStructureElement</para>
	/// <para>    ,IfcSpatialZone))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ContainsElements : SET [0:?] OF IfcRelContainedInSpatialStructure FOR RelatingStructure;</para>
	/// <para>	ServicedBySystems : SET [0:?] OF IfcRelServicesBuildings FOR RelatedBuildings;</para>
	/// <para>	ReferencesElements : SET [0:?] OF IfcRelReferencedInSpatialStructure FOR RelatingStructure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialElement : IfcProduct
	{
		public IfcLabel? LongName { get; set; }
		public IfcSpatialElement() : base()
		{
		}
		public IfcSpatialElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialElementType
	/// <para>ENTITY IfcSpatialElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcSpatialStructureElementType</para>
	/// <para>    ,IfcSpatialZoneType))</para>
	/// <para> SUBTYPE OF (IfcTypeProduct);</para>
	/// <para>	ElementType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialElementType : IfcTypeProduct
	{
		public IfcLabel? ElementType { get; set; }
		public IfcSpatialElementType() : base()
		{
		}
		public IfcSpatialElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.ElementType = ElementType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialStructureElement
	/// <para>ENTITY IfcSpatialStructureElement</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBuilding</para>
	/// <para>    ,IfcBuildingStorey</para>
	/// <para>    ,IfcSite</para>
	/// <para>    ,IfcSpace))</para>
	/// <para> SUBTYPE OF (IfcSpatialElement);</para>
	/// <para>	CompositionType : OPTIONAL IfcElementCompositionEnum;</para>
	/// <para> WHERE</para>
	/// <para>	WR41 : (HIINDEX(SELF\IfcObjectDefinition.Decomposes) = 1) </para>
	/// <para>AND</para>
	/// <para>('IFC4.IFCRELAGGREGATES' IN TYPEOF(SELF\IfcObjectDefinition.Decomposes[1])) </para>
	/// <para>AND</para>
	/// <para>(('IFC4.IFCPROJECT' IN TYPEOF (SELF\IfcObjectDefinition.Decomposes[1].RelatingObject)) OR</para>
	/// <para> ('IFC4.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF (SELF\IfcObjectDefinition.Decomposes[1].RelatingObject))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialStructureElement : IfcSpatialElement
	{
		public IfcElementCompositionEnum? CompositionType { get; set; }
		public IfcSpatialStructureElement() : base()
		{
		}
		public IfcSpatialStructureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
			this.CompositionType = CompositionType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialStructureElementType
	/// <para>ENTITY IfcSpatialStructureElementType</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcSpaceType))</para>
	/// <para> SUBTYPE OF (IfcSpatialElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialStructureElementType : IfcSpatialElementType
	{
		public IfcSpatialStructureElementType() : base()
		{
		}
		public IfcSpatialStructureElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialZone
	/// <para>ENTITY IfcSpatialZone</para>
	/// <para> SUBTYPE OF (IfcSpatialElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSpatialZoneTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcSpatialZoneTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcSpatialZoneTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCSPATIALZONETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpatialZone : IfcSpatialElement
	{
		public IfcSpatialZoneTypeEnum? PredefinedType { get; set; }
		public IfcSpatialZone() : base()
		{
		}
		public IfcSpatialZone(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcSpatialZoneTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialZoneType
	/// <para>ENTITY IfcSpatialZoneType</para>
	/// <para> SUBTYPE OF (IfcSpatialElementType);</para>
	/// <para>	PredefinedType : IfcSpatialZoneTypeEnum;</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSpatialZoneTypeEnum.USERDEFINED) OR </para>
	/// <para>((PredefinedType = IfcSpatialZoneTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcSpatialElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpatialZoneType : IfcSpatialElementType
	{
		public IfcSpatialZoneTypeEnum PredefinedType { get; set; }
		public IfcLabel? LongName { get; set; }
		public IfcSpatialZoneType() : base()
		{
			PredefinedType = new IfcSpatialZoneTypeEnum();
		}
		public IfcSpatialZoneType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSpatialZoneTypeEnum PredefinedType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcSphere
	/// <para>ENTITY IfcSphere</para>
	/// <para> SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSphere : IfcCsgPrimitive3D
	{
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcSphere() : base()
		{
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcSphere(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcSphericalSurface
	/// <para>ENTITY IfcSphericalSurface</para>
	/// <para> SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSphericalSurface : IfcElementarySurface
	{
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcSphericalSurface() : base()
		{
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcSphericalSurface(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcStackTerminal
	/// <para>ENTITY IfcStackTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcStackTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcStackTerminalTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcStackTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCSTACKTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStackTerminal : IfcFlowTerminal
	{
		public IfcStackTerminalTypeEnum? PredefinedType { get; set; }
		public IfcStackTerminal() : base()
		{
		}
		public IfcStackTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcStackTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStackTerminalType
	/// <para>ENTITY IfcStackTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcStackTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcStackTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcStackTerminalTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStackTerminalType : IfcFlowTerminalType
	{
		public IfcStackTerminalTypeEnum PredefinedType { get; set; }
		public IfcStackTerminalType() : base()
		{
			PredefinedType = new IfcStackTerminalTypeEnum();
		}
		public IfcStackTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcStackTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStair
	/// <para>ENTITY IfcStair</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcStairTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcStairTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcStairTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCSTAIRTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStair : IfcBuildingElement
	{
		public IfcStairTypeEnum? PredefinedType { get; set; }
		public IfcStair() : base()
		{
		}
		public IfcStair(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcStairTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStairFlight
	/// <para>ENTITY IfcStairFlight</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	NumberOfRisers : OPTIONAL IfcInteger;</para>
	/// <para>	NumberOfTreads : OPTIONAL IfcInteger;</para>
	/// <para>	RiserHeight : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	TreadLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcStairFlightTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcStairFlightTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcStairFlightTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCSTAIRFLIGHTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStairFlight : IfcBuildingElement
	{
		public IfcInteger? NumberOfRisers { get; set; }
		public IfcInteger? NumberOfTreads { get; set; }
		public IfcPositiveLengthMeasure? RiserHeight { get; set; }
		public IfcPositiveLengthMeasure? TreadLength { get; set; }
		public IfcStairFlightTypeEnum? PredefinedType { get; set; }
		public IfcStairFlight() : base()
		{
		}
		public IfcStairFlight(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcInteger NumberOfRisers, IfcInteger NumberOfTreads, IfcPositiveLengthMeasure RiserHeight, IfcPositiveLengthMeasure TreadLength, IfcStairFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.NumberOfRisers = NumberOfRisers;
			this.NumberOfTreads = NumberOfTreads;
			this.RiserHeight = RiserHeight;
			this.TreadLength = TreadLength;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStairFlightType
	/// <para>ENTITY IfcStairFlightType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcStairFlightTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcStairFlightTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcStairFlightTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStairFlightType : IfcBuildingElementType
	{
		public IfcStairFlightTypeEnum PredefinedType { get; set; }
		public IfcStairFlightType() : base()
		{
			PredefinedType = new IfcStairFlightTypeEnum();
		}
		public IfcStairFlightType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcStairFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStairType
	/// <para>ENTITY IfcStairType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcStairTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcStairTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcStairTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStairType : IfcBuildingElementType
	{
		public IfcStairTypeEnum PredefinedType { get; set; }
		public IfcStairType() : base()
		{
			PredefinedType = new IfcStairTypeEnum();
		}
		public IfcStairType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcStairTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralAction
	/// <para>ENTITY IfcStructuralAction</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralCurveAction</para>
	/// <para>    ,IfcStructuralPointAction</para>
	/// <para>    ,IfcStructuralSurfaceAction))</para>
	/// <para> SUBTYPE OF (IfcStructuralActivity);</para>
	/// <para>	DestabilizingLoad : OPTIONAL IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralAction : IfcStructuralActivity
	{
		public IfcBoolean? DestabilizingLoad { get; set; }
		public IfcStructuralAction() : base()
		{
		}
		public IfcStructuralAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
			this.DestabilizingLoad = DestabilizingLoad;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralActivity
	/// <para>ENTITY IfcStructuralActivity</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralAction</para>
	/// <para>    ,IfcStructuralReaction))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para>	AppliedLoad : IfcStructuralLoad;</para>
	/// <para>	GlobalOrLocal : IfcGlobalOrLocalEnum;</para>
	/// <para> INVERSE</para>
	/// <para>	AssignedToStructuralItem : SET [0:1] OF IfcRelConnectsStructuralActivity FOR RelatedStructuralActivity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralActivity : IfcProduct
	{
		public IfcStructuralLoad AppliedLoad { get; set; }
		public IfcGlobalOrLocalEnum GlobalOrLocal { get; set; }
		public IfcStructuralActivity() : base()
		{
			AppliedLoad = new IfcStructuralLoad();
			GlobalOrLocal = new IfcGlobalOrLocalEnum();
		}
		public IfcStructuralActivity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.AppliedLoad = AppliedLoad;
			this.GlobalOrLocal = GlobalOrLocal;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralAnalysisModel
	/// <para>ENTITY IfcStructuralAnalysisModel</para>
	/// <para> SUBTYPE OF (IfcSystem);</para>
	/// <para>	PredefinedType : IfcAnalysisModelTypeEnum;</para>
	/// <para>	OrientationOf2DPlane : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>	LoadedBy : OPTIONAL SET [1:?] OF IfcStructuralLoadGroup;</para>
	/// <para>	HasResults : OPTIONAL SET [1:?] OF IfcStructuralResultGroup;</para>
	/// <para>	SharedPlacement : OPTIONAL IfcObjectPlacement;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcAnalysisModelTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralAnalysisModel : IfcSystem
	{
		public IfcAnalysisModelTypeEnum PredefinedType { get; set; }
		public IfcAxis2Placement3D? OrientationOf2DPlane { get; set; }
		public List<IfcStructuralLoadGroup>? LoadedBy { get; set; }
		public List<IfcStructuralResultGroup>? HasResults { get; set; }
		public IfcObjectPlacement? SharedPlacement { get; set; }
		public IfcStructuralAnalysisModel() : base()
		{
			PredefinedType = new IfcAnalysisModelTypeEnum();
		}
		public IfcStructuralAnalysisModel(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcAnalysisModelTypeEnum PredefinedType, IfcAxis2Placement3D OrientationOf2DPlane, List<IfcStructuralLoadGroup> LoadedBy, List<IfcStructuralResultGroup> HasResults, IfcObjectPlacement SharedPlacement) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.OrientationOf2DPlane = OrientationOf2DPlane;
			this.LoadedBy = LoadedBy;
			this.HasResults = HasResults;
			this.SharedPlacement = SharedPlacement;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralConnection
	/// <para>ENTITY IfcStructuralConnection</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralCurveConnection</para>
	/// <para>    ,IfcStructuralPointConnection</para>
	/// <para>    ,IfcStructuralSurfaceConnection))</para>
	/// <para> SUBTYPE OF (IfcStructuralItem);</para>
	/// <para>	AppliedCondition : OPTIONAL IfcBoundaryCondition;</para>
	/// <para> INVERSE</para>
	/// <para>	ConnectsStructuralMembers : SET [1:?] OF IfcRelConnectsStructuralMember FOR RelatedStructuralConnection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralConnection : IfcStructuralItem
	{
		public IfcBoundaryCondition? AppliedCondition { get; set; }
		public IfcStructuralConnection() : base()
		{
		}
		public IfcStructuralConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.AppliedCondition = AppliedCondition;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralConnectionCondition
	/// <para>ENTITY IfcStructuralConnectionCondition</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcFailureConnectionCondition</para>
	/// <para>    ,IfcSlippageConnectionCondition));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralConnectionCondition : ENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcStructuralConnectionCondition() : base()
		{
		}
		public IfcStructuralConnectionCondition(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveAction
	/// <para>ENTITY IfcStructuralCurveAction</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralLinearAction))</para>
	/// <para> SUBTYPE OF (IfcStructuralAction);</para>
	/// <para>	ProjectedOrTrue : OPTIONAL IfcProjectedOrTrueLengthEnum;</para>
	/// <para>	PredefinedType : IfcStructuralCurveActivityTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	ProjectedIsGlobal : (NOT EXISTS(ProjectedOrTrue)) OR</para>
	/// <para>((ProjectedOrTrue <> PROJECTED_LENGTH) OR</para>
	/// <para> (SELF\IfcStructuralActivity.GlobalOrLocal = GLOBAL_COORDS));</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcStructuralCurveActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>	SuitablePredefinedType : PredefinedType <> IfcStructuralCurveActivityTypeEnum.EQUIDISTANT;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveAction : IfcStructuralAction
	{
		public IfcProjectedOrTrueLengthEnum? ProjectedOrTrue { get; set; }
		public IfcStructuralCurveActivityTypeEnum PredefinedType { get; set; }
		public IfcStructuralCurveAction() : base()
		{
			PredefinedType = new IfcStructuralCurveActivityTypeEnum();
		}
		public IfcStructuralCurveAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
		{
			this.ProjectedOrTrue = ProjectedOrTrue;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveConnection
	/// <para>ENTITY IfcStructuralCurveConnection</para>
	/// <para> SUBTYPE OF (IfcStructuralConnection);</para>
	/// <para>	Axis : IfcDirection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveConnection : IfcStructuralConnection
	{
		public IfcDirection Axis { get; set; }
		public IfcStructuralCurveConnection() : base()
		{
			Axis = new IfcDirection();
		}
		public IfcStructuralCurveConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition, IfcDirection Axis) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
		{
			this.Axis = Axis;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveMember
	/// <para>ENTITY IfcStructuralCurveMember</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralCurveMemberVarying))</para>
	/// <para> SUBTYPE OF (IfcStructuralMember);</para>
	/// <para>	PredefinedType : IfcStructuralCurveMemberTypeEnum;</para>
	/// <para>	Axis : IfcDirection;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcStructuralCurveMemberTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveMember : IfcStructuralMember
	{
		public IfcStructuralCurveMemberTypeEnum PredefinedType { get; set; }
		public IfcDirection Axis { get; set; }
		public IfcStructuralCurveMember() : base()
		{
			PredefinedType = new IfcStructuralCurveMemberTypeEnum();
			Axis = new IfcDirection();
		}
		public IfcStructuralCurveMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralCurveMemberTypeEnum PredefinedType, IfcDirection Axis) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.PredefinedType = PredefinedType;
			this.Axis = Axis;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveMemberVarying
	/// <para>ENTITY IfcStructuralCurveMemberVarying</para>
	/// <para> SUBTYPE OF (IfcStructuralCurveMember);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveMemberVarying : IfcStructuralCurveMember
	{
		public IfcStructuralCurveMemberVarying() : base()
		{
		}
		public IfcStructuralCurveMemberVarying(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralCurveMemberTypeEnum PredefinedType, IfcDirection Axis) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveReaction
	/// <para>ENTITY IfcStructuralCurveReaction</para>
	/// <para> SUBTYPE OF (IfcStructuralReaction);</para>
	/// <para>	PredefinedType : IfcStructuralCurveActivityTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcStructuralCurveActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>	SuitablePredefinedType : (PredefinedType <> IfcStructuralCurveActivityTypeEnum.SINUS) AND (PredefinedType <> IfcStructuralCurveActivityTypeEnum.PARABOLA);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveReaction : IfcStructuralReaction
	{
		public IfcStructuralCurveActivityTypeEnum PredefinedType { get; set; }
		public IfcStructuralCurveReaction() : base()
		{
			PredefinedType = new IfcStructuralCurveActivityTypeEnum();
		}
		public IfcStructuralCurveReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcStructuralCurveActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralItem
	/// <para>ENTITY IfcStructuralItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralConnection</para>
	/// <para>    ,IfcStructuralMember))</para>
	/// <para> SUBTYPE OF (IfcProduct);</para>
	/// <para> INVERSE</para>
	/// <para>	AssignedStructuralActivity : SET [0:?] OF IfcRelConnectsStructuralActivity FOR RelatingElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralItem : IfcProduct, IfcStructuralActivityAssignmentSelect
	{
		public IfcStructuralItem() : base()
		{
		}
		public IfcStructuralItem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLinearAction
	/// <para>ENTITY IfcStructuralLinearAction</para>
	/// <para> SUBTYPE OF (IfcStructuralCurveAction);</para>
	/// <para> WHERE</para>
	/// <para>	SuitableLoadType : SIZEOF(['IFC4.IFCSTRUCTURALLOADLINEARFORCE', 'IFC4.IFCSTRUCTURALLOADTEMPERATURE'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>	ConstPredefinedType : SELF\IfcStructuralCurveAction.PredefinedType = IfcStructuralCurveActivityTypeEnum.CONST;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLinearAction : IfcStructuralCurveAction
	{
		public IfcStructuralLinearAction() : base()
		{
		}
		public IfcStructuralLinearAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoad
	/// <para>ENTITY IfcStructuralLoad</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralLoadConfiguration</para>
	/// <para>    ,IfcStructuralLoadOrResult));</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralLoad : ENTITY
	{
		public IfcLabel? Name { get; set; }
		public IfcStructuralLoad() : base()
		{
		}
		public IfcStructuralLoad(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadCase
	/// <para>ENTITY IfcStructuralLoadCase</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadGroup);</para>
	/// <para>	SelfWeightCoefficients : OPTIONAL LIST [3:3] OF IfcRatioMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	IsLoadCasePredefinedType : SELF\IfcStructuralLoadGroup.PredefinedType = IfcLoadGroupTypeEnum.LOAD_CASE;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadCase : IfcStructuralLoadGroup
	{
		public List<IfcRatioMeasure>? SelfWeightCoefficients { get; set; }
		public IfcStructuralLoadCase() : base()
		{
		}
		public IfcStructuralLoadCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLoadGroupTypeEnum PredefinedType, IfcActionTypeEnum ActionType, IfcActionSourceTypeEnum ActionSource, IfcRatioMeasure Coefficient, IfcLabel Purpose, List<IfcRatioMeasure> SelfWeightCoefficients) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose)
		{
			this.SelfWeightCoefficients = SelfWeightCoefficients;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadConfiguration
	/// <para>ENTITY IfcStructuralLoadConfiguration</para>
	/// <para> SUBTYPE OF (IfcStructuralLoad);</para>
	/// <para>	Values : LIST [1:?] OF IfcStructuralLoadOrResult;</para>
	/// <para>	Locations : OPTIONAL LIST [1:?] OF UNIQUE LIST [1:2] OF IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidListSize : NOT EXISTS(Locations) OR (SIZEOF(Locations) = SIZEOF(Values));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadConfiguration : IfcStructuralLoad
	{
		public List<IfcStructuralLoadOrResult> Values { get; set; }
		public IfcStructuralLoadConfiguration() : base()
		{
			Values = new List<IfcStructuralLoadOrResult>();
		}
		public IfcStructuralLoadConfiguration(IfcLabel Name, List<IfcStructuralLoadOrResult> Values) : base (Name)
		{
			this.Values = Values;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadGroup
	/// <para>ENTITY IfcStructuralLoadGroup</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralLoadCase))</para>
	/// <para> SUBTYPE OF (IfcGroup);</para>
	/// <para>	PredefinedType : IfcLoadGroupTypeEnum;</para>
	/// <para>	ActionType : IfcActionTypeEnum;</para>
	/// <para>	ActionSource : IfcActionSourceTypeEnum;</para>
	/// <para>	Coefficient : OPTIONAL IfcRatioMeasure;</para>
	/// <para>	Purpose : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	SourceOfResultGroup : SET [0:1] OF IfcStructuralResultGroup FOR ResultForLoadGroup;</para>
	/// <para>	LoadGroupFor : SET [0:?] OF IfcStructuralAnalysisModel FOR LoadedBy;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (</para>
	/// <para>  (PredefinedType <> IfcLoadGroupTypeEnum.USERDEFINED) AND</para>
	/// <para>  (ActionType <> IfcActionTypeEnum.USERDEFINED) AND</para>
	/// <para>  (ActionSource <> IfcActionSourceTypeEnum.USERDEFINED)</para>
	/// <para>) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadGroup : IfcGroup
	{
		public IfcLoadGroupTypeEnum PredefinedType { get; set; }
		public IfcActionTypeEnum ActionType { get; set; }
		public IfcActionSourceTypeEnum ActionSource { get; set; }
		public IfcRatioMeasure? Coefficient { get; set; }
		public IfcLabel? Purpose { get; set; }
		public IfcStructuralLoadGroup() : base()
		{
			PredefinedType = new IfcLoadGroupTypeEnum();
			ActionType = new IfcActionTypeEnum();
			ActionSource = new IfcActionSourceTypeEnum();
		}
		public IfcStructuralLoadGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLoadGroupTypeEnum PredefinedType, IfcActionTypeEnum ActionType, IfcActionSourceTypeEnum ActionSource, IfcRatioMeasure Coefficient, IfcLabel Purpose) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.ActionType = ActionType;
			this.ActionSource = ActionSource;
			this.Coefficient = Coefficient;
			this.Purpose = Purpose;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadLinearForce
	/// <para>ENTITY IfcStructuralLoadLinearForce</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>	LinearForceX : OPTIONAL IfcLinearForceMeasure;</para>
	/// <para>	LinearForceY : OPTIONAL IfcLinearForceMeasure;</para>
	/// <para>	LinearForceZ : OPTIONAL IfcLinearForceMeasure;</para>
	/// <para>	LinearMomentX : OPTIONAL IfcLinearMomentMeasure;</para>
	/// <para>	LinearMomentY : OPTIONAL IfcLinearMomentMeasure;</para>
	/// <para>	LinearMomentZ : OPTIONAL IfcLinearMomentMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadLinearForce : IfcStructuralLoadStatic
	{
		public IfcLinearForceMeasure? LinearForceX { get; set; }
		public IfcLinearForceMeasure? LinearForceY { get; set; }
		public IfcLinearForceMeasure? LinearForceZ { get; set; }
		public IfcLinearMomentMeasure? LinearMomentX { get; set; }
		public IfcLinearMomentMeasure? LinearMomentY { get; set; }
		public IfcLinearMomentMeasure? LinearMomentZ { get; set; }
		public IfcStructuralLoadLinearForce() : base()
		{
		}
		public IfcStructuralLoadLinearForce(IfcLabel Name, IfcLinearForceMeasure LinearForceX, IfcLinearForceMeasure LinearForceY, IfcLinearForceMeasure LinearForceZ, IfcLinearMomentMeasure LinearMomentX, IfcLinearMomentMeasure LinearMomentY, IfcLinearMomentMeasure LinearMomentZ) : base (Name)
		{
			this.LinearForceX = LinearForceX;
			this.LinearForceY = LinearForceY;
			this.LinearForceZ = LinearForceZ;
			this.LinearMomentX = LinearMomentX;
			this.LinearMomentY = LinearMomentY;
			this.LinearMomentZ = LinearMomentZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadOrResult
	/// <para>ENTITY IfcStructuralLoadOrResult</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralLoadStatic</para>
	/// <para>    ,IfcSurfaceReinforcementArea))</para>
	/// <para> SUBTYPE OF (IfcStructuralLoad);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralLoadOrResult : IfcStructuralLoad
	{
		public IfcStructuralLoadOrResult() : base()
		{
		}
		public IfcStructuralLoadOrResult(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadPlanarForce
	/// <para>ENTITY IfcStructuralLoadPlanarForce</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>	PlanarForceX : OPTIONAL IfcPlanarForceMeasure;</para>
	/// <para>	PlanarForceY : OPTIONAL IfcPlanarForceMeasure;</para>
	/// <para>	PlanarForceZ : OPTIONAL IfcPlanarForceMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadPlanarForce : IfcStructuralLoadStatic
	{
		public IfcPlanarForceMeasure? PlanarForceX { get; set; }
		public IfcPlanarForceMeasure? PlanarForceY { get; set; }
		public IfcPlanarForceMeasure? PlanarForceZ { get; set; }
		public IfcStructuralLoadPlanarForce() : base()
		{
		}
		public IfcStructuralLoadPlanarForce(IfcLabel Name, IfcPlanarForceMeasure PlanarForceX, IfcPlanarForceMeasure PlanarForceY, IfcPlanarForceMeasure PlanarForceZ) : base (Name)
		{
			this.PlanarForceX = PlanarForceX;
			this.PlanarForceY = PlanarForceY;
			this.PlanarForceZ = PlanarForceZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleDisplacement
	/// <para>ENTITY IfcStructuralLoadSingleDisplacement</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralLoadSingleDisplacementDistortion))</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>	DisplacementX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	DisplacementY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	DisplacementZ : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	RotationalDisplacementRX : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>	RotationalDisplacementRY : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>	RotationalDisplacementRZ : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleDisplacement : IfcStructuralLoadStatic
	{
		public IfcLengthMeasure? DisplacementX { get; set; }
		public IfcLengthMeasure? DisplacementY { get; set; }
		public IfcLengthMeasure? DisplacementZ { get; set; }
		public IfcPlaneAngleMeasure? RotationalDisplacementRX { get; set; }
		public IfcPlaneAngleMeasure? RotationalDisplacementRY { get; set; }
		public IfcPlaneAngleMeasure? RotationalDisplacementRZ { get; set; }
		public IfcStructuralLoadSingleDisplacement() : base()
		{
		}
		public IfcStructuralLoadSingleDisplacement(IfcLabel Name, IfcLengthMeasure DisplacementX, IfcLengthMeasure DisplacementY, IfcLengthMeasure DisplacementZ, IfcPlaneAngleMeasure RotationalDisplacementRX, IfcPlaneAngleMeasure RotationalDisplacementRY, IfcPlaneAngleMeasure RotationalDisplacementRZ) : base (Name)
		{
			this.DisplacementX = DisplacementX;
			this.DisplacementY = DisplacementY;
			this.DisplacementZ = DisplacementZ;
			this.RotationalDisplacementRX = RotationalDisplacementRX;
			this.RotationalDisplacementRY = RotationalDisplacementRY;
			this.RotationalDisplacementRZ = RotationalDisplacementRZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleDisplacementDistortion
	/// <para>ENTITY IfcStructuralLoadSingleDisplacementDistortion</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadSingleDisplacement);</para>
	/// <para>	Distortion : OPTIONAL IfcCurvatureMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleDisplacementDistortion : IfcStructuralLoadSingleDisplacement
	{
		public IfcCurvatureMeasure? Distortion { get; set; }
		public IfcStructuralLoadSingleDisplacementDistortion() : base()
		{
		}
		public IfcStructuralLoadSingleDisplacementDistortion(IfcLabel Name, IfcLengthMeasure DisplacementX, IfcLengthMeasure DisplacementY, IfcLengthMeasure DisplacementZ, IfcPlaneAngleMeasure RotationalDisplacementRX, IfcPlaneAngleMeasure RotationalDisplacementRY, IfcPlaneAngleMeasure RotationalDisplacementRZ, IfcCurvatureMeasure Distortion) : base (Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ)
		{
			this.Distortion = Distortion;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleForce
	/// <para>ENTITY IfcStructuralLoadSingleForce</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralLoadSingleForceWarping))</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>	ForceX : OPTIONAL IfcForceMeasure;</para>
	/// <para>	ForceY : OPTIONAL IfcForceMeasure;</para>
	/// <para>	ForceZ : OPTIONAL IfcForceMeasure;</para>
	/// <para>	MomentX : OPTIONAL IfcTorqueMeasure;</para>
	/// <para>	MomentY : OPTIONAL IfcTorqueMeasure;</para>
	/// <para>	MomentZ : OPTIONAL IfcTorqueMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleForce : IfcStructuralLoadStatic
	{
		public IfcForceMeasure? ForceX { get; set; }
		public IfcForceMeasure? ForceY { get; set; }
		public IfcForceMeasure? ForceZ { get; set; }
		public IfcTorqueMeasure? MomentX { get; set; }
		public IfcTorqueMeasure? MomentY { get; set; }
		public IfcTorqueMeasure? MomentZ { get; set; }
		public IfcStructuralLoadSingleForce() : base()
		{
		}
		public IfcStructuralLoadSingleForce(IfcLabel Name, IfcForceMeasure ForceX, IfcForceMeasure ForceY, IfcForceMeasure ForceZ, IfcTorqueMeasure MomentX, IfcTorqueMeasure MomentY, IfcTorqueMeasure MomentZ) : base (Name)
		{
			this.ForceX = ForceX;
			this.ForceY = ForceY;
			this.ForceZ = ForceZ;
			this.MomentX = MomentX;
			this.MomentY = MomentY;
			this.MomentZ = MomentZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleForceWarping
	/// <para>ENTITY IfcStructuralLoadSingleForceWarping</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadSingleForce);</para>
	/// <para>	WarpingMoment : OPTIONAL IfcWarpingMomentMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleForceWarping : IfcStructuralLoadSingleForce
	{
		public IfcWarpingMomentMeasure? WarpingMoment { get; set; }
		public IfcStructuralLoadSingleForceWarping() : base()
		{
		}
		public IfcStructuralLoadSingleForceWarping(IfcLabel Name, IfcForceMeasure ForceX, IfcForceMeasure ForceY, IfcForceMeasure ForceZ, IfcTorqueMeasure MomentX, IfcTorqueMeasure MomentY, IfcTorqueMeasure MomentZ, IfcWarpingMomentMeasure WarpingMoment) : base (Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ)
		{
			this.WarpingMoment = WarpingMoment;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadStatic
	/// <para>ENTITY IfcStructuralLoadStatic</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralLoadLinearForce</para>
	/// <para>    ,IfcStructuralLoadPlanarForce</para>
	/// <para>    ,IfcStructuralLoadSingleDisplacement</para>
	/// <para>    ,IfcStructuralLoadSingleForce</para>
	/// <para>    ,IfcStructuralLoadTemperature))</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadOrResult);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralLoadStatic : IfcStructuralLoadOrResult
	{
		public IfcStructuralLoadStatic() : base()
		{
		}
		public IfcStructuralLoadStatic(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadTemperature
	/// <para>ENTITY IfcStructuralLoadTemperature</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>	DeltaTConstant : OPTIONAL IfcThermodynamicTemperatureMeasure;</para>
	/// <para>	DeltaTY : OPTIONAL IfcThermodynamicTemperatureMeasure;</para>
	/// <para>	DeltaTZ : OPTIONAL IfcThermodynamicTemperatureMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadTemperature : IfcStructuralLoadStatic
	{
		public IfcThermodynamicTemperatureMeasure? DeltaTConstant { get; set; }
		public IfcThermodynamicTemperatureMeasure? DeltaTY { get; set; }
		public IfcThermodynamicTemperatureMeasure? DeltaTZ { get; set; }
		public IfcStructuralLoadTemperature() : base()
		{
		}
		public IfcStructuralLoadTemperature(IfcLabel Name, IfcThermodynamicTemperatureMeasure DeltaTConstant, IfcThermodynamicTemperatureMeasure DeltaTY, IfcThermodynamicTemperatureMeasure DeltaTZ) : base (Name)
		{
			this.DeltaTConstant = DeltaTConstant;
			this.DeltaTY = DeltaTY;
			this.DeltaTZ = DeltaTZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralMember
	/// <para>ENTITY IfcStructuralMember</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralCurveMember</para>
	/// <para>    ,IfcStructuralSurfaceMember))</para>
	/// <para> SUBTYPE OF (IfcStructuralItem);</para>
	/// <para> INVERSE</para>
	/// <para>	ConnectedBy : SET [0:?] OF IfcRelConnectsStructuralMember FOR RelatingStructuralMember;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralMember : IfcStructuralItem
	{
		public IfcStructuralMember() : base()
		{
		}
		public IfcStructuralMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPlanarAction
	/// <para>ENTITY IfcStructuralPlanarAction</para>
	/// <para> SUBTYPE OF (IfcStructuralSurfaceAction);</para>
	/// <para> WHERE</para>
	/// <para>	SuitableLoadType : SIZEOF(['IFC4.IFCSTRUCTURALLOADPLANARFORCE', 'IFC4.IFCSTRUCTURALLOADTEMPERATURE'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>	ConstPredefinedType : SELF\IfcStructuralSurfaceAction.PredefinedType = IfcStructuralSurfaceActivityTypeEnum.CONST;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPlanarAction : IfcStructuralSurfaceAction
	{
		public IfcStructuralPlanarAction() : base()
		{
		}
		public IfcStructuralPlanarAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPointAction
	/// <para>ENTITY IfcStructuralPointAction</para>
	/// <para> SUBTYPE OF (IfcStructuralAction);</para>
	/// <para> WHERE</para>
	/// <para>	SuitableLoadType : SIZEOF(['IFC4.IFCSTRUCTURALLOADSINGLEFORCE', 'IFC4.IFCSTRUCTURALLOADSINGLEDISPLACEMENT'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPointAction : IfcStructuralAction
	{
		public IfcStructuralPointAction() : base()
		{
		}
		public IfcStructuralPointAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPointConnection
	/// <para>ENTITY IfcStructuralPointConnection</para>
	/// <para> SUBTYPE OF (IfcStructuralConnection);</para>
	/// <para>	ConditionCoordinateSystem : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPointConnection : IfcStructuralConnection
	{
		public IfcAxis2Placement3D? ConditionCoordinateSystem { get; set; }
		public IfcStructuralPointConnection() : base()
		{
		}
		public IfcStructuralPointConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition, IfcAxis2Placement3D ConditionCoordinateSystem) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
		{
			this.ConditionCoordinateSystem = ConditionCoordinateSystem;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPointReaction
	/// <para>ENTITY IfcStructuralPointReaction</para>
	/// <para> SUBTYPE OF (IfcStructuralReaction);</para>
	/// <para> WHERE</para>
	/// <para>	SuitableLoadType : SIZEOF(['IFC4.IFCSTRUCTURALLOADSINGLEFORCE', 'IFC4.IFCSTRUCTURALLOADSINGLEDISPLACEMENT'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPointReaction : IfcStructuralReaction
	{
		public IfcStructuralPointReaction() : base()
		{
		}
		public IfcStructuralPointReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralReaction
	/// <para>ENTITY IfcStructuralReaction</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralCurveReaction</para>
	/// <para>    ,IfcStructuralPointReaction</para>
	/// <para>    ,IfcStructuralSurfaceReaction))</para>
	/// <para> SUBTYPE OF (IfcStructuralActivity);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralReaction : IfcStructuralActivity
	{
		public IfcStructuralReaction() : base()
		{
		}
		public IfcStructuralReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralResultGroup
	/// <para>ENTITY IfcStructuralResultGroup</para>
	/// <para> SUBTYPE OF (IfcGroup);</para>
	/// <para>	TheoryType : IfcAnalysisTheoryTypeEnum;</para>
	/// <para>	ResultForLoadGroup : OPTIONAL IfcStructuralLoadGroup;</para>
	/// <para>	IsLinear : IfcBoolean;</para>
	/// <para> INVERSE</para>
	/// <para>	ResultGroupFor : SET [0:1] OF IfcStructuralAnalysisModel FOR HasResults;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (TheoryType <> IfcAnalysisTheoryTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralResultGroup : IfcGroup
	{
		public IfcAnalysisTheoryTypeEnum TheoryType { get; set; }
		public IfcStructuralLoadGroup? ResultForLoadGroup { get; set; }
		public IfcBoolean IsLinear { get; set; }
		public IfcStructuralResultGroup() : base()
		{
			TheoryType = new IfcAnalysisTheoryTypeEnum();
			IsLinear = new IfcBoolean();
		}
		public IfcStructuralResultGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcAnalysisTheoryTypeEnum TheoryType, IfcStructuralLoadGroup ResultForLoadGroup, IfcBoolean IsLinear) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.TheoryType = TheoryType;
			this.ResultForLoadGroup = ResultForLoadGroup;
			this.IsLinear = IsLinear;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceAction
	/// <para>ENTITY IfcStructuralSurfaceAction</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralPlanarAction))</para>
	/// <para> SUBTYPE OF (IfcStructuralAction);</para>
	/// <para>	ProjectedOrTrue : OPTIONAL IfcProjectedOrTrueLengthEnum;</para>
	/// <para>	PredefinedType : IfcStructuralSurfaceActivityTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	ProjectedIsGlobal : (NOT EXISTS(ProjectedOrTrue)) OR</para>
	/// <para>((ProjectedOrTrue <> PROJECTED_LENGTH) OR</para>
	/// <para> (SELF\IfcStructuralActivity.GlobalOrLocal = GLOBAL_COORDS));</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcStructuralSurfaceActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceAction : IfcStructuralAction
	{
		public IfcProjectedOrTrueLengthEnum? ProjectedOrTrue { get; set; }
		public IfcStructuralSurfaceActivityTypeEnum PredefinedType { get; set; }
		public IfcStructuralSurfaceAction() : base()
		{
			PredefinedType = new IfcStructuralSurfaceActivityTypeEnum();
		}
		public IfcStructuralSurfaceAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
		{
			this.ProjectedOrTrue = ProjectedOrTrue;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceConnection
	/// <para>ENTITY IfcStructuralSurfaceConnection</para>
	/// <para> SUBTYPE OF (IfcStructuralConnection);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceConnection : IfcStructuralConnection
	{
		public IfcStructuralSurfaceConnection() : base()
		{
		}
		public IfcStructuralSurfaceConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceMember
	/// <para>ENTITY IfcStructuralSurfaceMember</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStructuralSurfaceMemberVarying))</para>
	/// <para> SUBTYPE OF (IfcStructuralMember);</para>
	/// <para>	PredefinedType : IfcStructuralSurfaceMemberTypeEnum;</para>
	/// <para>	Thickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : (PredefinedType <> IfcStructuralSurfaceMemberTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceMember : IfcStructuralMember
	{
		public IfcStructuralSurfaceMemberTypeEnum PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? Thickness { get; set; }
		public IfcStructuralSurfaceMember() : base()
		{
			PredefinedType = new IfcStructuralSurfaceMemberTypeEnum();
		}
		public IfcStructuralSurfaceMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralSurfaceMemberTypeEnum PredefinedType, IfcPositiveLengthMeasure Thickness) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.PredefinedType = PredefinedType;
			this.Thickness = Thickness;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceMemberVarying
	/// <para>ENTITY IfcStructuralSurfaceMemberVarying</para>
	/// <para> SUBTYPE OF (IfcStructuralSurfaceMember);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceMemberVarying : IfcStructuralSurfaceMember
	{
		public IfcStructuralSurfaceMemberVarying() : base()
		{
		}
		public IfcStructuralSurfaceMemberVarying(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralSurfaceMemberTypeEnum PredefinedType, IfcPositiveLengthMeasure Thickness) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceReaction
	/// <para>ENTITY IfcStructuralSurfaceReaction</para>
	/// <para> SUBTYPE OF (IfcStructuralReaction);</para>
	/// <para>	PredefinedType : IfcStructuralSurfaceActivityTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasPredefinedType : (PredefinedType <> IfcStructuralSurfaceActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceReaction : IfcStructuralReaction
	{
		public IfcStructuralSurfaceActivityTypeEnum PredefinedType { get; set; }
		public IfcStructuralSurfaceReaction() : base()
		{
			PredefinedType = new IfcStructuralSurfaceActivityTypeEnum();
		}
		public IfcStructuralSurfaceReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcStructuralSurfaceActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStyleModel
	/// <para>ENTITY IfcStyleModel</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcStyledRepresentation))</para>
	/// <para> SUBTYPE OF (IfcRepresentation);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStyleModel : IfcRepresentation
	{
		public IfcStyleModel() : base()
		{
		}
		public IfcStyleModel(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStyledItem
	/// <para>ENTITY IfcStyledItem</para>
	/// <para> SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>	Item : OPTIONAL IfcRepresentationItem;</para>
	/// <para>	Styles : SET [1:?] OF IfcStyleAssignmentSelect;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableItem : NOT('IFC4.IFCSTYLEDITEM' IN TYPEOF(Item));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStyledItem : IfcRepresentationItem
	{
		public IfcRepresentationItem? Item { get; set; }
		public List<IfcStyleAssignmentSelect> Styles { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcStyledItem() : base()
		{
			Styles = new List<IfcStyleAssignmentSelect>();
		}
		public IfcStyledItem(IfcRepresentationItem Item, List<IfcStyleAssignmentSelect> Styles, IfcLabel Name) : base ()
		{
			this.Item = Item;
			this.Styles = Styles;
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcStyledRepresentation
	/// <para>ENTITY IfcStyledRepresentation</para>
	/// <para> SUBTYPE OF (IfcStyleModel);</para>
	/// <para> WHERE</para>
	/// <para>	OnlyStyledItems : SIZEOF(QUERY(temp <* SELF\IfcRepresentation.Items | </para>
	/// <para>  (NOT('IFC4.IFCSTYLEDITEM' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStyledRepresentation : IfcStyleModel
	{
		public IfcStyledRepresentation() : base()
		{
		}
		public IfcStyledRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSubContractResource
	/// <para>ENTITY IfcSubContractResource</para>
	/// <para> SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSubContractResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcSubContractResourceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcSubContractResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSubContractResource : IfcConstructionResource
	{
		public IfcSubContractResourceTypeEnum? PredefinedType { get; set; }
		public IfcSubContractResource() : base()
		{
		}
		public IfcSubContractResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcSubContractResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSubContractResourceType
	/// <para>ENTITY IfcSubContractResourceType</para>
	/// <para> SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>	PredefinedType : IfcSubContractResourceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSubContractResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSubContractResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSubContractResourceType : IfcConstructionResourceType
	{
		public IfcSubContractResourceTypeEnum PredefinedType { get; set; }
		public IfcSubContractResourceType() : base()
		{
			PredefinedType = new IfcSubContractResourceTypeEnum();
		}
		public IfcSubContractResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcSubContractResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSubedge
	/// <para>ENTITY IfcSubedge</para>
	/// <para> SUBTYPE OF (IfcEdge);</para>
	/// <para>	ParentEdge : IfcEdge;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSubedge : IfcEdge
	{
		public IfcEdge ParentEdge { get; set; }
		public IfcSubedge() : base()
		{
			ParentEdge = new IfcEdge();
		}
		public IfcSubedge(IfcVertex EdgeStart, IfcVertex EdgeEnd, IfcEdge ParentEdge) : base (EdgeStart, EdgeEnd)
		{
			this.ParentEdge = ParentEdge;
		}
	}
	/// <summary>
	/// ENTITY IfcSurface
	/// <para>ENTITY IfcSurface</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBoundedSurface</para>
	/// <para>    ,IfcElementarySurface</para>
	/// <para>    ,IfcSweptSurface))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSurface : IfcGeometricRepresentationItem, IfcGeometricSetSelect, IfcSurfaceOrFaceSurface
	{
		public IfcSurface() : base()
		{
		}
		public IfcSurface() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceCurve
	/// <para>ENTITY IfcSurfaceCurve</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcIntersectionCurve</para>
	/// <para>    ,IfcSeamCurve))</para>
	/// <para> SUBTYPE OF (IfcCurve);</para>
	/// <para>	Curve3D : IfcCurve;</para>
	/// <para>	AssociatedGeometry : LIST [1:2] OF IfcPcurve;</para>
	/// <para>	MasterRepresentation : IfcPreferredSurfaceCurveRepresentation;</para>
	/// <para> DERIVE</para>
	/// <para>	BasisSurface : SET [1:2] OF IfcSurface := IfcGetBasisSurface(SELF);</para>
	/// <para> WHERE</para>
	/// <para>	CurveIs3D : Curve3D.Dim = 3;</para>
	/// <para>	CurveIsNotPcurve : NOT ('IFC4.IFCPCURVE' IN TYPEOF(Curve3D));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceCurve : IfcCurve, IfcCurveOnSurface
	{
		public IfcCurve Curve3D { get; set; }
		public List<IfcPcurve> AssociatedGeometry { get; set; }
		public IfcPreferredSurfaceCurveRepresentation MasterRepresentation { get; set; }
		public IfcSurfaceCurve() : base()
		{
			Curve3D = new IfcCurve();
			AssociatedGeometry = new List<IfcPcurve>();
			MasterRepresentation = new IfcPreferredSurfaceCurveRepresentation();
		}
		public IfcSurfaceCurve(IfcCurve Curve3D, List<IfcPcurve> AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation MasterRepresentation) : base ()
		{
			this.Curve3D = Curve3D;
			this.AssociatedGeometry = AssociatedGeometry;
			this.MasterRepresentation = MasterRepresentation;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceCurveSweptAreaSolid
	/// <para>ENTITY IfcSurfaceCurveSweptAreaSolid</para>
	/// <para> SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>	Directrix : IfcCurve;</para>
	/// <para>	StartParam : OPTIONAL IfcParameterValue;</para>
	/// <para>	EndParam : OPTIONAL IfcParameterValue;</para>
	/// <para>	ReferenceSurface : IfcSurface;</para>
	/// <para> WHERE</para>
	/// <para>	DirectrixBounded : (EXISTS(StartParam) AND EXISTS(EndParam)) OR </para>
	/// <para>(SIZEOF(['IFC4.IFCCONIC', 'IFC4.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceCurveSweptAreaSolid : IfcSweptAreaSolid
	{
		public IfcCurve Directrix { get; set; }
		public IfcParameterValue? StartParam { get; set; }
		public IfcParameterValue? EndParam { get; set; }
		public IfcSurface ReferenceSurface { get; set; }
		public IfcSurfaceCurveSweptAreaSolid() : base()
		{
			Directrix = new IfcCurve();
			ReferenceSurface = new IfcSurface();
		}
		public IfcSurfaceCurveSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcCurve Directrix, IfcParameterValue StartParam, IfcParameterValue EndParam, IfcSurface ReferenceSurface) : base (SweptArea, Position)
		{
			this.Directrix = Directrix;
			this.StartParam = StartParam;
			this.EndParam = EndParam;
			this.ReferenceSurface = ReferenceSurface;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceFeature
	/// <para>ENTITY IfcSurfaceFeature</para>
	/// <para> SUBTYPE OF (IfcFeatureElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSurfaceFeatureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : NOT EXISTS(PredefinedType) OR (PredefinedType <> IfcSurfaceFeatureTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceFeature : IfcFeatureElement
	{
		public IfcSurfaceFeatureTypeEnum? PredefinedType { get; set; }
		public IfcSurfaceFeature() : base()
		{
		}
		public IfcSurfaceFeature(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSurfaceFeatureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceOfLinearExtrusion
	/// <para>ENTITY IfcSurfaceOfLinearExtrusion</para>
	/// <para> SUBTYPE OF (IfcSweptSurface);</para>
	/// <para>	ExtrudedDirection : IfcDirection;</para>
	/// <para>	Depth : IfcLengthMeasure;</para>
	/// <para> DERIVE</para>
	/// <para>	ExtrusionAxis : IfcVector := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector (ExtrudedDirection, Depth);</para>
	/// <para> WHERE</para>
	/// <para>	DepthGreaterZero : Depth > 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceOfLinearExtrusion : IfcSweptSurface
	{
		public IfcDirection ExtrudedDirection { get; set; }
		public IfcLengthMeasure Depth { get; set; }
		public IfcSurfaceOfLinearExtrusion() : base()
		{
			ExtrudedDirection = new IfcDirection();
			Depth = new IfcLengthMeasure();
		}
		public IfcSurfaceOfLinearExtrusion(IfcProfileDef SweptCurve, IfcAxis2Placement3D Position, IfcDirection ExtrudedDirection, IfcLengthMeasure Depth) : base (SweptCurve, Position)
		{
			this.ExtrudedDirection = ExtrudedDirection;
			this.Depth = Depth;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceOfRevolution
	/// <para>ENTITY IfcSurfaceOfRevolution</para>
	/// <para> SUBTYPE OF (IfcSweptSurface);</para>
	/// <para>	AxisPosition : IfcAxis1Placement;</para>
	/// <para> DERIVE</para>
	/// <para>	AxisLine : IfcLine := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcCurve() || IfcLine(AxisPosition.Location, </para>
	/// <para>  IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector(AxisPosition.Z,1.0));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceOfRevolution : IfcSweptSurface
	{
		public IfcAxis1Placement AxisPosition { get; set; }
		public IfcSurfaceOfRevolution() : base()
		{
			AxisPosition = new IfcAxis1Placement();
		}
		public IfcSurfaceOfRevolution(IfcProfileDef SweptCurve, IfcAxis2Placement3D Position, IfcAxis1Placement AxisPosition) : base (SweptCurve, Position)
		{
			this.AxisPosition = AxisPosition;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceReinforcementArea
	/// <para>ENTITY IfcSurfaceReinforcementArea</para>
	/// <para> SUBTYPE OF (IfcStructuralLoadOrResult);</para>
	/// <para>	SurfaceReinforcement1 : OPTIONAL LIST [2:3] OF IfcLengthMeasure;</para>
	/// <para>	SurfaceReinforcement2 : OPTIONAL LIST [2:3] OF IfcLengthMeasure;</para>
	/// <para>	ShearReinforcement : OPTIONAL IfcRatioMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	SurfaceAndOrShearAreaSpecified : EXISTS(SurfaceReinforcement1) OR EXISTS(SurfaceReinforcement2) OR EXISTS(ShearReinforcement);</para>
	/// <para>	NonnegativeArea1 : (NOT EXISTS(SurfaceReinforcement1)) OR (</para>
	/// <para>    (SurfaceReinforcement1[1] >= 0.) AND</para>
	/// <para>    (SurfaceReinforcement1[2] >= 0.) AND</para>
	/// <para>    ((SIZEOF(SurfaceReinforcement1) = 1) OR (SurfaceReinforcement1[1] >= 0.))</para>
	/// <para>);</para>
	/// <para>	NonnegativeArea2 : (NOT EXISTS(SurfaceReinforcement2)) OR (</para>
	/// <para>    (SurfaceReinforcement2[1] >= 0.) AND</para>
	/// <para>    (SurfaceReinforcement2[2] >= 0.) AND</para>
	/// <para>    ((SIZEOF(SurfaceReinforcement2) = 1) OR (SurfaceReinforcement2[1] >= 0.))</para>
	/// <para>);</para>
	/// <para>	NonnegativeArea3 : (NOT EXISTS(ShearReinforcement)) OR (ShearReinforcement >= 0.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceReinforcementArea : IfcStructuralLoadOrResult
	{
		public List<IfcLengthMeasure>? SurfaceReinforcement1 { get; set; }
		public List<IfcLengthMeasure>? SurfaceReinforcement2 { get; set; }
		public IfcRatioMeasure? ShearReinforcement { get; set; }
		public IfcSurfaceReinforcementArea() : base()
		{
		}
		public IfcSurfaceReinforcementArea(IfcLabel Name, List<IfcLengthMeasure> SurfaceReinforcement1, List<IfcLengthMeasure> SurfaceReinforcement2, IfcRatioMeasure ShearReinforcement) : base (Name)
		{
			this.SurfaceReinforcement1 = SurfaceReinforcement1;
			this.SurfaceReinforcement2 = SurfaceReinforcement2;
			this.ShearReinforcement = ShearReinforcement;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyle
	/// <para>ENTITY IfcSurfaceStyle</para>
	/// <para> SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>	Side : IfcSurfaceSide;</para>
	/// <para>	Styles : SET [1:5] OF IfcSurfaceStyleElementSelect;</para>
	/// <para> WHERE</para>
	/// <para>	MaxOneShading : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>  'IFC4.IFCSURFACESTYLESHADING' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	MaxOneLighting : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>  'IFC4.IFCSURFACESTYLELIGHTING' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	MaxOneRefraction : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>  'IFC4.IFCSURFACESTYLEREFRACTION' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	MaxOneTextures : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>  'IFC4.IFCSURFACESTYLEWITHTEXTURES' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>	MaxOneExtDefined : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>  'IFC4.IFCEXTERNALLYDEFINEDSURFACESTYLE' IN</para>
	/// <para>   TYPEOF(Style)</para>
	/// <para>  )) <= 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyle : IfcPresentationStyle, IfcPresentationStyleSelect
	{
		public IfcSurfaceSide Side { get; set; }
		public List<IfcSurfaceStyleElementSelect> Styles { get; set; }
		public IfcSurfaceStyle() : base()
		{
			Side = new IfcSurfaceSide();
			Styles = new List<IfcSurfaceStyleElementSelect>();
		}
		public IfcSurfaceStyle(IfcLabel Name, IfcSurfaceSide Side, List<IfcSurfaceStyleElementSelect> Styles) : base (Name)
		{
			this.Side = Side;
			this.Styles = Styles;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleLighting
	/// <para>ENTITY IfcSurfaceStyleLighting</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	DiffuseTransmissionColour : IfcColourRgb;</para>
	/// <para>	DiffuseReflectionColour : IfcColourRgb;</para>
	/// <para>	TransmissionColour : IfcColourRgb;</para>
	/// <para>	ReflectanceColour : IfcColourRgb;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleLighting : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public IfcColourRgb DiffuseTransmissionColour { get; set; }
		public IfcColourRgb DiffuseReflectionColour { get; set; }
		public IfcColourRgb TransmissionColour { get; set; }
		public IfcColourRgb ReflectanceColour { get; set; }
		public IfcSurfaceStyleLighting() : base()
		{
			DiffuseTransmissionColour = new IfcColourRgb();
			DiffuseReflectionColour = new IfcColourRgb();
			TransmissionColour = new IfcColourRgb();
			ReflectanceColour = new IfcColourRgb();
		}
		public IfcSurfaceStyleLighting(IfcColourRgb DiffuseTransmissionColour, IfcColourRgb DiffuseReflectionColour, IfcColourRgb TransmissionColour, IfcColourRgb ReflectanceColour) : base ()
		{
			this.DiffuseTransmissionColour = DiffuseTransmissionColour;
			this.DiffuseReflectionColour = DiffuseReflectionColour;
			this.TransmissionColour = TransmissionColour;
			this.ReflectanceColour = ReflectanceColour;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleRefraction
	/// <para>ENTITY IfcSurfaceStyleRefraction</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	RefractionIndex : OPTIONAL IfcReal;</para>
	/// <para>	DispersionFactor : OPTIONAL IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleRefraction : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public IfcReal? RefractionIndex { get; set; }
		public IfcReal? DispersionFactor { get; set; }
		public IfcSurfaceStyleRefraction() : base()
		{
		}
		public IfcSurfaceStyleRefraction(IfcReal RefractionIndex, IfcReal DispersionFactor) : base ()
		{
			this.RefractionIndex = RefractionIndex;
			this.DispersionFactor = DispersionFactor;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleRendering
	/// <para>ENTITY IfcSurfaceStyleRendering</para>
	/// <para> SUBTYPE OF (IfcSurfaceStyleShading);</para>
	/// <para>	DiffuseColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>	TransmissionColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>	DiffuseTransmissionColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>	ReflectionColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>	SpecularColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>	SpecularHighlight : OPTIONAL IfcSpecularHighlightSelect;</para>
	/// <para>	ReflectanceMethod : IfcReflectanceMethodEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleRendering : IfcSurfaceStyleShading
	{
		public IfcColourOrFactor? DiffuseColour { get; set; }
		public IfcColourOrFactor? TransmissionColour { get; set; }
		public IfcColourOrFactor? DiffuseTransmissionColour { get; set; }
		public IfcColourOrFactor? ReflectionColour { get; set; }
		public IfcColourOrFactor? SpecularColour { get; set; }
		public IfcSpecularHighlightSelect? SpecularHighlight { get; set; }
		public IfcReflectanceMethodEnum ReflectanceMethod { get; set; }
		public IfcSurfaceStyleRendering() : base()
		{
			ReflectanceMethod = new IfcReflectanceMethodEnum();
		}
		public IfcSurfaceStyleRendering(IfcColourRgb SurfaceColour, IfcNormalisedRatioMeasure Transparency, IfcColourOrFactor DiffuseColour, IfcColourOrFactor TransmissionColour, IfcColourOrFactor DiffuseTransmissionColour, IfcColourOrFactor ReflectionColour, IfcColourOrFactor SpecularColour, IfcSpecularHighlightSelect SpecularHighlight, IfcReflectanceMethodEnum ReflectanceMethod) : base (SurfaceColour, Transparency)
		{
			this.DiffuseColour = DiffuseColour;
			this.TransmissionColour = TransmissionColour;
			this.DiffuseTransmissionColour = DiffuseTransmissionColour;
			this.ReflectionColour = ReflectionColour;
			this.SpecularColour = SpecularColour;
			this.SpecularHighlight = SpecularHighlight;
			this.ReflectanceMethod = ReflectanceMethod;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleShading
	/// <para>ENTITY IfcSurfaceStyleShading</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcSurfaceStyleRendering))</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	SurfaceColour : IfcColourRgb;</para>
	/// <para>	Transparency : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleShading : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public IfcColourRgb SurfaceColour { get; set; }
		public IfcNormalisedRatioMeasure? Transparency { get; set; }
		public IfcSurfaceStyleShading() : base()
		{
			SurfaceColour = new IfcColourRgb();
		}
		public IfcSurfaceStyleShading(IfcColourRgb SurfaceColour, IfcNormalisedRatioMeasure Transparency) : base ()
		{
			this.SurfaceColour = SurfaceColour;
			this.Transparency = Transparency;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleWithTextures
	/// <para>ENTITY IfcSurfaceStyleWithTextures</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Textures : LIST [1:?] OF IfcSurfaceTexture;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleWithTextures : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public List<IfcSurfaceTexture> Textures { get; set; }
		public IfcSurfaceStyleWithTextures() : base()
		{
			Textures = new List<IfcSurfaceTexture>();
		}
		public IfcSurfaceStyleWithTextures(List<IfcSurfaceTexture> Textures) : base ()
		{
			this.Textures = Textures;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceTexture
	/// <para>ENTITY IfcSurfaceTexture</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBlobTexture</para>
	/// <para>    ,IfcImageTexture</para>
	/// <para>    ,IfcPixelTexture))</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	RepeatS : IfcBoolean;</para>
	/// <para>	RepeatT : IfcBoolean;</para>
	/// <para>	Mode : OPTIONAL IfcIdentifier;</para>
	/// <para>	TextureTransform : OPTIONAL IfcCartesianTransformationOperator2D;</para>
	/// <para>	Parameter : OPTIONAL LIST [1:?] OF IfcIdentifier;</para>
	/// <para> INVERSE</para>
	/// <para>	IsMappedBy : SET [0:?] OF IfcTextureCoordinate FOR Maps;</para>
	/// <para>	UsedInStyles : SET [0:?] OF IfcSurfaceStyleWithTextures FOR Textures;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSurfaceTexture : IfcPresentationItem
	{
		public IfcBoolean RepeatS { get; set; }
		public IfcBoolean RepeatT { get; set; }
		public IfcIdentifier? Mode { get; set; }
		public IfcCartesianTransformationOperator2D? TextureTransform { get; set; }
		public List<IfcIdentifier>? Parameter { get; set; }
		public IfcSurfaceTexture() : base()
		{
			RepeatS = new IfcBoolean();
			RepeatT = new IfcBoolean();
		}
		public IfcSurfaceTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter) : base ()
		{
			this.RepeatS = RepeatS;
			this.RepeatT = RepeatT;
			this.Mode = Mode;
			this.TextureTransform = TextureTransform;
			this.Parameter = Parameter;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptAreaSolid
	/// <para>ENTITY IfcSweptAreaSolid</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcExtrudedAreaSolid</para>
	/// <para>    ,IfcFixedReferenceSweptAreaSolid</para>
	/// <para>    ,IfcRevolvedAreaSolid</para>
	/// <para>    ,IfcSurfaceCurveSweptAreaSolid))</para>
	/// <para> SUBTYPE OF (IfcSolidModel);</para>
	/// <para>	SweptArea : IfcProfileDef;</para>
	/// <para>	Position : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para> WHERE</para>
	/// <para>	SweptAreaType : SweptArea.ProfileType = IfcProfileTypeEnum.Area;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSweptAreaSolid : IfcSolidModel
	{
		public IfcProfileDef SweptArea { get; set; }
		public IfcAxis2Placement3D? Position { get; set; }
		public IfcSweptAreaSolid() : base()
		{
			SweptArea = new IfcProfileDef();
		}
		public IfcSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position) : base ()
		{
			this.SweptArea = SweptArea;
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptDiskSolid
	/// <para>ENTITY IfcSweptDiskSolid</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcSweptDiskSolidPolygonal))</para>
	/// <para> SUBTYPE OF (IfcSolidModel);</para>
	/// <para>	Directrix : IfcCurve;</para>
	/// <para>	Radius : IfcPositiveLengthMeasure;</para>
	/// <para>	InnerRadius : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	StartParam : OPTIONAL IfcParameterValue;</para>
	/// <para>	EndParam : OPTIONAL IfcParameterValue;</para>
	/// <para> WHERE</para>
	/// <para>	DirectrixDim : Directrix.Dim = 3;</para>
	/// <para>	InnerRadiusSize : (NOT EXISTS(InnerRadius)) OR (Radius > InnerRadius);</para>
	/// <para>	DirectrixBounded : (EXISTS(StartParam) AND EXISTS(EndParam)) OR </para>
	/// <para>(SIZEOF(['IFC4.IFCCONIC', 'IFC4.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSweptDiskSolid : IfcSolidModel
	{
		public IfcCurve Directrix { get; set; }
		public IfcPositiveLengthMeasure Radius { get; set; }
		public IfcPositiveLengthMeasure? InnerRadius { get; set; }
		public IfcParameterValue? StartParam { get; set; }
		public IfcParameterValue? EndParam { get; set; }
		public IfcSweptDiskSolid() : base()
		{
			Directrix = new IfcCurve();
			Radius = new IfcPositiveLengthMeasure();
		}
		public IfcSweptDiskSolid(IfcCurve Directrix, IfcPositiveLengthMeasure Radius, IfcPositiveLengthMeasure InnerRadius, IfcParameterValue StartParam, IfcParameterValue EndParam) : base ()
		{
			this.Directrix = Directrix;
			this.Radius = Radius;
			this.InnerRadius = InnerRadius;
			this.StartParam = StartParam;
			this.EndParam = EndParam;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptDiskSolidPolygonal
	/// <para>ENTITY IfcSweptDiskSolidPolygonal</para>
	/// <para> SUBTYPE OF (IfcSweptDiskSolid);</para>
	/// <para>	FilletRadius : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectRadii : NOT(EXISTS(FilletRadius)) OR (FilletRadius >= SELF\IfcSweptDiskSolid.Radius);</para>
	/// <para>	DirectrixIsPolyline : ('IFC4.IFCPOLYLINE' IN TYPEOF(SELF\IfcSweptDiskSolid.Directrix)) OR</para>
	/// <para>(('IFC4.IFCINDEXEDPOLYCURVE' IN TYPEOF(SELF\IfcSweptDiskSolid.Directrix)) AND NOT(EXISTS(SELF\IfcSweptDiskSolid.Directrix.Segments)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSweptDiskSolidPolygonal : IfcSweptDiskSolid
	{
		public IfcPositiveLengthMeasure? FilletRadius { get; set; }
		public IfcSweptDiskSolidPolygonal() : base()
		{
		}
		public IfcSweptDiskSolidPolygonal(IfcCurve Directrix, IfcPositiveLengthMeasure Radius, IfcPositiveLengthMeasure InnerRadius, IfcParameterValue StartParam, IfcParameterValue EndParam, IfcPositiveLengthMeasure FilletRadius) : base (Directrix, Radius, InnerRadius, StartParam, EndParam)
		{
			this.FilletRadius = FilletRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptSurface
	/// <para>ENTITY IfcSweptSurface</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcSurfaceOfLinearExtrusion</para>
	/// <para>    ,IfcSurfaceOfRevolution))</para>
	/// <para> SUBTYPE OF (IfcSurface);</para>
	/// <para>	SweptCurve : IfcProfileDef;</para>
	/// <para>	Position : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para> WHERE</para>
	/// <para>	SweptCurveType : SweptCurve.ProfileType = IfcProfileTypeEnum.Curve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSweptSurface : IfcSurface
	{
		public IfcProfileDef SweptCurve { get; set; }
		public IfcAxis2Placement3D? Position { get; set; }
		public IfcSweptSurface() : base()
		{
			SweptCurve = new IfcProfileDef();
		}
		public IfcSweptSurface(IfcProfileDef SweptCurve, IfcAxis2Placement3D Position) : base ()
		{
			this.SweptCurve = SweptCurve;
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcSwitchingDevice
	/// <para>ENTITY IfcSwitchingDevice</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSwitchingDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcSwitchingDeviceTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcSwitchingDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCSWITCHINGDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSwitchingDevice : IfcFlowController
	{
		public IfcSwitchingDeviceTypeEnum? PredefinedType { get; set; }
		public IfcSwitchingDevice() : base()
		{
		}
		public IfcSwitchingDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSwitchingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSwitchingDeviceType
	/// <para>ENTITY IfcSwitchingDeviceType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcSwitchingDeviceTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSwitchingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSwitchingDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSwitchingDeviceType : IfcFlowControllerType
	{
		public IfcSwitchingDeviceTypeEnum PredefinedType { get; set; }
		public IfcSwitchingDeviceType() : base()
		{
			PredefinedType = new IfcSwitchingDeviceTypeEnum();
		}
		public IfcSwitchingDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSwitchingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSystem
	/// <para>ENTITY IfcSystem</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcBuildingSystem</para>
	/// <para>    ,IfcDistributionSystem</para>
	/// <para>    ,IfcStructuralAnalysisModel</para>
	/// <para>    ,IfcZone))</para>
	/// <para> SUBTYPE OF (IfcGroup);</para>
	/// <para> INVERSE</para>
	/// <para>	ServicesBuildings : SET [0:1] OF IfcRelServicesBuildings FOR RelatingSystem;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSystem : IfcGroup
	{
		public IfcSystem() : base()
		{
		}
		public IfcSystem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSystemFurnitureElement
	/// <para>ENTITY IfcSystemFurnitureElement</para>
	/// <para> SUBTYPE OF (IfcFurnishingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSystemFurnitureElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcSystemFurnitureElementTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcSystemFurnitureElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>   ('IFC4.IFCSYSTEMFURNITUREELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSystemFurnitureElement : IfcFurnishingElement
	{
		public IfcSystemFurnitureElementTypeEnum? PredefinedType { get; set; }
		public IfcSystemFurnitureElement() : base()
		{
		}
		public IfcSystemFurnitureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSystemFurnitureElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSystemFurnitureElementType
	/// <para>ENTITY IfcSystemFurnitureElementType</para>
	/// <para> SUBTYPE OF (IfcFurnishingElementType);</para>
	/// <para>	PredefinedType : OPTIONAL IfcSystemFurnitureElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcSystemFurnitureElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSystemFurnitureElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSystemFurnitureElementType : IfcFurnishingElementType
	{
		public IfcSystemFurnitureElementTypeEnum? PredefinedType { get; set; }
		public IfcSystemFurnitureElementType() : base()
		{
		}
		public IfcSystemFurnitureElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSystemFurnitureElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTShapeProfileDef
	/// <para>ENTITY IfcTShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	FlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	WebEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	WebSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>	FlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidFlangeThickness : FlangeThickness < Depth;</para>
	/// <para>	ValidWebThickness : WebThickness < FlangeWidth;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcPositiveLengthMeasure FlangeWidth { get; set; }
		public IfcPositiveLengthMeasure WebThickness { get; set; }
		public IfcPositiveLengthMeasure FlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? FlangeEdgeRadius { get; set; }
		public IfcNonNegativeLengthMeasure? WebEdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? WebSlope { get; set; }
		public IfcPlaneAngleMeasure? FlangeSlope { get; set; }
		public IfcTShapeProfileDef() : base()
		{
			Depth = new IfcPositiveLengthMeasure();
			FlangeWidth = new IfcPositiveLengthMeasure();
			WebThickness = new IfcPositiveLengthMeasure();
			FlangeThickness = new IfcPositiveLengthMeasure();
		}
		public IfcTShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure FlangeWidth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure FlangeEdgeRadius, IfcNonNegativeLengthMeasure WebEdgeRadius, IfcPlaneAngleMeasure WebSlope, IfcPlaneAngleMeasure FlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.FlangeWidth = FlangeWidth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.FlangeEdgeRadius = FlangeEdgeRadius;
			this.WebEdgeRadius = WebEdgeRadius;
			this.WebSlope = WebSlope;
			this.FlangeSlope = FlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcTable;
	/// <para>ENTITY IfcTable;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Rows : OPTIONAL LIST [1:?] OF IfcTableRow;</para>
	/// <para>	Columns : OPTIONAL LIST [1:?] OF IfcTableColumn;</para>
	/// <para> DERIVE</para>
	/// <para>	NumberOfCellsInRow : IfcInteger := HIINDEX(Rows[1].RowCells);</para>
	/// <para>	NumberOfHeadings : IfcInteger := SIZEOF(QUERY( Temp <* Rows | Temp.IsHeading));</para>
	/// <para>	NumberOfDataRows : IfcInteger := SIZEOF(QUERY( Temp <* Rows | NOT(Temp.IsHeading)));</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : SIZEOF(QUERY( Temp <* Rows | HIINDEX(Temp.RowCells) <> HIINDEX(Rows[1].RowCells))) = 0;</para>
	/// <para>	WR2 : { 0 <= NumberOfHeadings <= 1 };</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTable : ENTITY, IfcMetricValueSelect, IfcObjectReferenceSelect
	{
		public IfcLabel? Name { get; set; }
		public List<IfcTableRow>? Rows { get; set; }
		public List<IfcTableColumn>? Columns { get; set; }
		public IfcTable() : base()
		{
		}
		public IfcTable(IfcLabel Name, List<IfcTableRow> Rows, List<IfcTableColumn> Columns) : base ()
		{
			this.Name = Name;
			this.Rows = Rows;
			this.Columns = Columns;
		}
	}
	/// <summary>
	/// ENTITY IfcTableColumn;
	/// <para>ENTITY IfcTableColumn;</para>
	/// <para>	Identifier : OPTIONAL IfcIdentifier;</para>
	/// <para>	Name : OPTIONAL IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para>	ReferencePath : OPTIONAL IfcReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTableColumn : ENTITY
	{
		public IfcIdentifier? Identifier { get; set; }
		public IfcLabel? Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcUnit? Unit { get; set; }
		public IfcReference? ReferencePath { get; set; }
		public IfcTableColumn() : base()
		{
		}
		public IfcTableColumn(IfcIdentifier Identifier, IfcLabel Name, IfcText Description, IfcUnit Unit, IfcReference ReferencePath) : base ()
		{
			this.Identifier = Identifier;
			this.Name = Name;
			this.Description = Description;
			this.Unit = Unit;
			this.ReferencePath = ReferencePath;
		}
	}
	/// <summary>
	/// ENTITY IfcTableRow;
	/// <para>ENTITY IfcTableRow;</para>
	/// <para>	RowCells : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>	IsHeading : OPTIONAL IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTableRow : ENTITY
	{
		public List<IfcValue>? RowCells { get; set; }
		public IfcBoolean? IsHeading { get; set; }
		public IfcTableRow() : base()
		{
		}
		public IfcTableRow(List<IfcValue> RowCells, IfcBoolean IsHeading) : base ()
		{
			this.RowCells = RowCells;
			this.IsHeading = IsHeading;
		}
	}
	/// <summary>
	/// ENTITY IfcTank
	/// <para>ENTITY IfcTank</para>
	/// <para> SUBTYPE OF (IfcFlowStorageDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTankTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcTankTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcTankTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCTANKTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTank : IfcFlowStorageDevice
	{
		public IfcTankTypeEnum? PredefinedType { get; set; }
		public IfcTank() : base()
		{
		}
		public IfcTank(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTankTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTankType
	/// <para>ENTITY IfcTankType</para>
	/// <para> SUBTYPE OF (IfcFlowStorageDeviceType);</para>
	/// <para>	PredefinedType : IfcTankTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTankTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTankTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTankType : IfcFlowStorageDeviceType
	{
		public IfcTankTypeEnum PredefinedType { get; set; }
		public IfcTankType() : base()
		{
			PredefinedType = new IfcTankTypeEnum();
		}
		public IfcTankType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTankTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTask
	/// <para>ENTITY IfcTask</para>
	/// <para> SUBTYPE OF (IfcProcess);</para>
	/// <para>	Status : OPTIONAL IfcLabel;</para>
	/// <para>	WorkMethod : OPTIONAL IfcLabel;</para>
	/// <para>	IsMilestone : IfcBoolean;</para>
	/// <para>	Priority : OPTIONAL IfcInteger;</para>
	/// <para>	TaskTime : OPTIONAL IfcTaskTime;</para>
	/// <para>	PredefinedType : OPTIONAL IfcTaskTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcTaskTypeEnum.USERDEFINED) OR ((PredefinedType = IfcTaskTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTask : IfcProcess
	{
		public IfcLabel? Status { get; set; }
		public IfcLabel? WorkMethod { get; set; }
		public IfcBoolean IsMilestone { get; set; }
		public IfcInteger? Priority { get; set; }
		public IfcTaskTime? TaskTime { get; set; }
		public IfcTaskTypeEnum? PredefinedType { get; set; }
		public IfcTask() : base()
		{
			IsMilestone = new IfcBoolean();
		}
		public IfcTask(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcLabel Status, IfcLabel WorkMethod, IfcBoolean IsMilestone, IfcInteger Priority, IfcTaskTime TaskTime, IfcTaskTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.Status = Status;
			this.WorkMethod = WorkMethod;
			this.IsMilestone = IsMilestone;
			this.Priority = Priority;
			this.TaskTime = TaskTime;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTaskTime
	/// <para>ENTITY IfcTaskTime</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcTaskTimeRecurring))</para>
	/// <para> SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>	DurationType : OPTIONAL IfcTaskDurationEnum;</para>
	/// <para>	ScheduleDuration : OPTIONAL IfcDuration;</para>
	/// <para>	ScheduleStart : OPTIONAL IfcDateTime;</para>
	/// <para>	ScheduleFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	EarlyStart : OPTIONAL IfcDateTime;</para>
	/// <para>	EarlyFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	LateStart : OPTIONAL IfcDateTime;</para>
	/// <para>	LateFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	FreeFloat : OPTIONAL IfcDuration;</para>
	/// <para>	TotalFloat : OPTIONAL IfcDuration;</para>
	/// <para>	IsCritical : OPTIONAL IfcBoolean;</para>
	/// <para>	StatusTime : OPTIONAL IfcDateTime;</para>
	/// <para>	ActualDuration : OPTIONAL IfcDuration;</para>
	/// <para>	ActualStart : OPTIONAL IfcDateTime;</para>
	/// <para>	ActualFinish : OPTIONAL IfcDateTime;</para>
	/// <para>	RemainingTime : OPTIONAL IfcDuration;</para>
	/// <para>	Completion : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTaskTime : IfcSchedulingTime
	{
		public IfcTaskDurationEnum? DurationType { get; set; }
		public IfcDuration? ScheduleDuration { get; set; }
		public IfcDateTime? ScheduleStart { get; set; }
		public IfcDateTime? ScheduleFinish { get; set; }
		public IfcDateTime? EarlyStart { get; set; }
		public IfcDateTime? EarlyFinish { get; set; }
		public IfcDateTime? LateStart { get; set; }
		public IfcDateTime? LateFinish { get; set; }
		public IfcDuration? FreeFloat { get; set; }
		public IfcDuration? TotalFloat { get; set; }
		public IfcBoolean? IsCritical { get; set; }
		public IfcDateTime? StatusTime { get; set; }
		public IfcDuration? ActualDuration { get; set; }
		public IfcDateTime? ActualStart { get; set; }
		public IfcDateTime? ActualFinish { get; set; }
		public IfcDuration? RemainingTime { get; set; }
		public IfcPositiveRatioMeasure? Completion { get; set; }
		public IfcTaskTime() : base()
		{
		}
		public IfcTaskTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcTaskDurationEnum DurationType, IfcDuration ScheduleDuration, IfcDateTime ScheduleStart, IfcDateTime ScheduleFinish, IfcDateTime EarlyStart, IfcDateTime EarlyFinish, IfcDateTime LateStart, IfcDateTime LateFinish, IfcDuration FreeFloat, IfcDuration TotalFloat, IfcBoolean IsCritical, IfcDateTime StatusTime, IfcDuration ActualDuration, IfcDateTime ActualStart, IfcDateTime ActualFinish, IfcDuration RemainingTime, IfcPositiveRatioMeasure Completion) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.DurationType = DurationType;
			this.ScheduleDuration = ScheduleDuration;
			this.ScheduleStart = ScheduleStart;
			this.ScheduleFinish = ScheduleFinish;
			this.EarlyStart = EarlyStart;
			this.EarlyFinish = EarlyFinish;
			this.LateStart = LateStart;
			this.LateFinish = LateFinish;
			this.FreeFloat = FreeFloat;
			this.TotalFloat = TotalFloat;
			this.IsCritical = IsCritical;
			this.StatusTime = StatusTime;
			this.ActualDuration = ActualDuration;
			this.ActualStart = ActualStart;
			this.ActualFinish = ActualFinish;
			this.RemainingTime = RemainingTime;
			this.Completion = Completion;
		}
	}
	/// <summary>
	/// ENTITY IfcTaskTimeRecurring
	/// <para>ENTITY IfcTaskTimeRecurring</para>
	/// <para> SUBTYPE OF (IfcTaskTime);</para>
	/// <para>	Recurrence : IfcRecurrencePattern;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTaskTimeRecurring : IfcTaskTime
	{
		public IfcRecurrencePattern Recurrence { get; set; }
		public IfcTaskTimeRecurring() : base()
		{
			Recurrence = new IfcRecurrencePattern();
		}
		public IfcTaskTimeRecurring(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcTaskDurationEnum DurationType, IfcDuration ScheduleDuration, IfcDateTime ScheduleStart, IfcDateTime ScheduleFinish, IfcDateTime EarlyStart, IfcDateTime EarlyFinish, IfcDateTime LateStart, IfcDateTime LateFinish, IfcDuration FreeFloat, IfcDuration TotalFloat, IfcBoolean IsCritical, IfcDateTime StatusTime, IfcDuration ActualDuration, IfcDateTime ActualStart, IfcDateTime ActualFinish, IfcDuration RemainingTime, IfcPositiveRatioMeasure Completion, IfcRecurrencePattern Recurrence) : base (Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion)
		{
			this.Recurrence = Recurrence;
		}
	}
	/// <summary>
	/// ENTITY IfcTaskType
	/// <para>ENTITY IfcTaskType</para>
	/// <para> SUBTYPE OF (IfcTypeProcess);</para>
	/// <para>	PredefinedType : IfcTaskTypeEnum;</para>
	/// <para>	WorkMethod : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTaskTypeEnum.USERDEFINED) OR ((PredefinedType = IfcTaskTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTaskType : IfcTypeProcess
	{
		public IfcTaskTypeEnum PredefinedType { get; set; }
		public IfcLabel? WorkMethod { get; set; }
		public IfcTaskType() : base()
		{
			PredefinedType = new IfcTaskTypeEnum();
		}
		public IfcTaskType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType, IfcTaskTypeEnum PredefinedType, IfcLabel WorkMethod) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType)
		{
			this.PredefinedType = PredefinedType;
			this.WorkMethod = WorkMethod;
		}
	}
	/// <summary>
	/// ENTITY IfcTelecomAddress
	/// <para>ENTITY IfcTelecomAddress</para>
	/// <para> SUBTYPE OF (IfcAddress);</para>
	/// <para>	TelephoneNumbers : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	FacsimileNumbers : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	PagerNumber : OPTIONAL IfcLabel;</para>
	/// <para>	ElectronicMailAddresses : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>	WWWHomePageURL : OPTIONAL IfcURIReference;</para>
	/// <para>	MessagingIDs : OPTIONAL LIST [1:?] OF IfcURIReference;</para>
	/// <para> WHERE</para>
	/// <para>	MinimumDataProvided : EXISTS (TelephoneNumbers) OR</para>
	/// <para>EXISTS (FacsimileNumbers) OR </para>
	/// <para>EXISTS (PagerNumber) OR</para>
	/// <para>EXISTS (ElectronicMailAddresses) OR </para>
	/// <para>EXISTS (WWWHomePageURL) OR</para>
	/// <para>EXISTS (MessagingIDs);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTelecomAddress : IfcAddress
	{
		public List<IfcLabel>? TelephoneNumbers { get; set; }
		public List<IfcLabel>? FacsimileNumbers { get; set; }
		public IfcLabel? PagerNumber { get; set; }
		public List<IfcLabel>? ElectronicMailAddresses { get; set; }
		public IfcURIReference? WWWHomePageURL { get; set; }
		public List<IfcURIReference>? MessagingIDs { get; set; }
		public IfcTelecomAddress() : base()
		{
		}
		public IfcTelecomAddress(IfcAddressTypeEnum Purpose, IfcText Description, IfcLabel UserDefinedPurpose, List<IfcLabel> TelephoneNumbers, List<IfcLabel> FacsimileNumbers, IfcLabel PagerNumber, List<IfcLabel> ElectronicMailAddresses, IfcURIReference WWWHomePageURL, List<IfcURIReference> MessagingIDs) : base (Purpose, Description, UserDefinedPurpose)
		{
			this.TelephoneNumbers = TelephoneNumbers;
			this.FacsimileNumbers = FacsimileNumbers;
			this.PagerNumber = PagerNumber;
			this.ElectronicMailAddresses = ElectronicMailAddresses;
			this.WWWHomePageURL = WWWHomePageURL;
			this.MessagingIDs = MessagingIDs;
		}
	}
	/// <summary>
	/// ENTITY IfcTendon
	/// <para>ENTITY IfcTendon</para>
	/// <para> SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTendonTypeEnum;</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	TensionForce : OPTIONAL IfcForceMeasure;</para>
	/// <para>	PreStress : OPTIONAL IfcPressureMeasure;</para>
	/// <para>	FrictionCoefficient : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	AnchorageSlip : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	MinCurvatureRadius : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcTendonTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTendonTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4.IFCTENDONTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendon : IfcReinforcingElement
	{
		public IfcTendonTypeEnum? PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcAreaMeasure? CrossSectionArea { get; set; }
		public IfcForceMeasure? TensionForce { get; set; }
		public IfcPressureMeasure? PreStress { get; set; }
		public IfcNormalisedRatioMeasure? FrictionCoefficient { get; set; }
		public IfcPositiveLengthMeasure? AnchorageSlip { get; set; }
		public IfcPositiveLengthMeasure? MinCurvatureRadius { get; set; }
		public IfcTendon() : base()
		{
		}
		public IfcTendon(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcTendonTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcForceMeasure TensionForce, IfcPressureMeasure PreStress, IfcNormalisedRatioMeasure FrictionCoefficient, IfcPositiveLengthMeasure AnchorageSlip, IfcPositiveLengthMeasure MinCurvatureRadius) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.TensionForce = TensionForce;
			this.PreStress = PreStress;
			this.FrictionCoefficient = FrictionCoefficient;
			this.AnchorageSlip = AnchorageSlip;
			this.MinCurvatureRadius = MinCurvatureRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonAnchor
	/// <para>ENTITY IfcTendonAnchor</para>
	/// <para> SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTendonAnchorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcTendonAnchorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTendonAnchorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4.IFCTENDONANCHORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonAnchor : IfcReinforcingElement
	{
		public IfcTendonAnchorTypeEnum? PredefinedType { get; set; }
		public IfcTendonAnchor() : base()
		{
		}
		public IfcTendonAnchor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcTendonAnchorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonAnchorType
	/// <para>ENTITY IfcTendonAnchorType</para>
	/// <para> SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>	PredefinedType : IfcTendonAnchorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTendonAnchorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTendonAnchorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonAnchorType : IfcReinforcingElementType
	{
		public IfcTendonAnchorTypeEnum PredefinedType { get; set; }
		public IfcTendonAnchorType() : base()
		{
			PredefinedType = new IfcTendonAnchorTypeEnum();
		}
		public IfcTendonAnchorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTendonAnchorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonType
	/// <para>ENTITY IfcTendonType</para>
	/// <para> SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>	PredefinedType : IfcTendonTypeEnum;</para>
	/// <para>	NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>	SheathDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTendonTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTendonTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonType : IfcReinforcingElementType
	{
		public IfcTendonTypeEnum PredefinedType { get; set; }
		public IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public IfcAreaMeasure? CrossSectionArea { get; set; }
		public IfcPositiveLengthMeasure? SheathDiameter { get; set; }
		public IfcTendonType() : base()
		{
			PredefinedType = new IfcTendonTypeEnum();
		}
		public IfcTendonType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTendonTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcPositiveLengthMeasure SheathDiameter) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.SheathDiameter = SheathDiameter;
		}
	}
	/// <summary>
	/// ENTITY IfcTessellatedFaceSet
	/// <para>ENTITY IfcTessellatedFaceSet</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcPolygonalFaceSet</para>
	/// <para>    ,IfcTriangulatedFaceSet))</para>
	/// <para> SUBTYPE OF (IfcTessellatedItem);</para>
	/// <para>	Coordinates : IfcCartesianPointList3D;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := 3;</para>
	/// <para> INVERSE</para>
	/// <para>	HasColours : SET [0:1] OF IfcIndexedColourMap FOR MappedTo;</para>
	/// <para>	HasTextures : SET [0:?] OF IfcIndexedTextureMap FOR MappedTo;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTessellatedFaceSet : IfcTessellatedItem, IfcBooleanOperand
	{
		public IfcCartesianPointList3D Coordinates { get; set; }
		public IfcTessellatedFaceSet() : base()
		{
			Coordinates = new IfcCartesianPointList3D();
		}
		public IfcTessellatedFaceSet(IfcCartesianPointList3D Coordinates) : base ()
		{
			this.Coordinates = Coordinates;
		}
	}
	/// <summary>
	/// ENTITY IfcTessellatedItem
	/// <para>ENTITY IfcTessellatedItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcIndexedPolygonalFace</para>
	/// <para>    ,IfcTessellatedFaceSet))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTessellatedItem : IfcGeometricRepresentationItem
	{
		public IfcTessellatedItem() : base()
		{
		}
		public IfcTessellatedItem() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTextLiteral
	/// <para>ENTITY IfcTextLiteral</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcTextLiteralWithExtent))</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Literal : IfcPresentableText;</para>
	/// <para>	Placement : IfcAxis2Placement;</para>
	/// <para>	Path : IfcTextPath;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextLiteral : IfcGeometricRepresentationItem
	{
		public IfcPresentableText Literal { get; set; }
		public IfcAxis2Placement Placement { get; set; }
		public IfcTextPath Path { get; set; }
		public IfcTextLiteral() : base()
		{
			Literal = new IfcPresentableText();
			Placement = new IfcAxis2Placement();
			Path = new IfcTextPath();
		}
		public IfcTextLiteral(IfcPresentableText Literal, IfcAxis2Placement Placement, IfcTextPath Path) : base ()
		{
			this.Literal = Literal;
			this.Placement = Placement;
			this.Path = Path;
		}
	}
	/// <summary>
	/// ENTITY IfcTextLiteralWithExtent
	/// <para>ENTITY IfcTextLiteralWithExtent</para>
	/// <para> SUBTYPE OF (IfcTextLiteral);</para>
	/// <para>	Extent : IfcPlanarExtent;</para>
	/// <para>	BoxAlignment : IfcBoxAlignment;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : NOT('IFC4.IFCPLANARBOX' IN TYPEOF(Extent));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextLiteralWithExtent : IfcTextLiteral
	{
		public IfcPlanarExtent Extent { get; set; }
		public IfcBoxAlignment BoxAlignment { get; set; }
		public IfcTextLiteralWithExtent() : base()
		{
			Extent = new IfcPlanarExtent();
			BoxAlignment = new IfcBoxAlignment();
		}
		public IfcTextLiteralWithExtent(IfcPresentableText Literal, IfcAxis2Placement Placement, IfcTextPath Path, IfcPlanarExtent Extent, IfcBoxAlignment BoxAlignment) : base (Literal, Placement, Path)
		{
			this.Extent = Extent;
			this.BoxAlignment = BoxAlignment;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyle
	/// <para>ENTITY IfcTextStyle</para>
	/// <para> SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>	TextCharacterAppearance : OPTIONAL IfcTextStyleForDefinedFont;</para>
	/// <para>	TextStyle : OPTIONAL IfcTextStyleTextModel;</para>
	/// <para>	TextFontStyle : IfcTextFontSelect;</para>
	/// <para>	ModelOrDraughting : OPTIONAL IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyle : IfcPresentationStyle, IfcPresentationStyleSelect
	{
		public IfcTextStyleForDefinedFont? TextCharacterAppearance { get; set; }
		public IfcTextStyleTextModel? TextStyle { get; set; }
		public IfcTextFontSelect TextFontStyle { get; set; }
		public IfcBoolean? ModelOrDraughting { get; set; }
		public IfcTextStyle() : base()
		{
			TextFontStyle = new IfcTextFontSelect();
		}
		public IfcTextStyle(IfcLabel Name, IfcTextStyleForDefinedFont TextCharacterAppearance, IfcTextStyleTextModel TextStyle, IfcTextFontSelect TextFontStyle, IfcBoolean ModelOrDraughting) : base (Name)
		{
			this.TextCharacterAppearance = TextCharacterAppearance;
			this.TextStyle = TextStyle;
			this.TextFontStyle = TextFontStyle;
			this.ModelOrDraughting = ModelOrDraughting;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyleFontModel
	/// <para>ENTITY IfcTextStyleFontModel</para>
	/// <para> SUBTYPE OF (IfcPreDefinedTextFont);</para>
	/// <para>	FontFamily : LIST [1:?] OF IfcTextFontName;</para>
	/// <para>	FontStyle : OPTIONAL IfcFontStyle;</para>
	/// <para>	FontVariant : OPTIONAL IfcFontVariant;</para>
	/// <para>	FontWeight : OPTIONAL IfcFontWeight;</para>
	/// <para>	FontSize : IfcSizeSelect;</para>
	/// <para> WHERE</para>
	/// <para>	MeasureOfFontSize : ('IFC4.IFCLENGTHMEASURE' IN TYPEOF(SELF.FontSize)) AND</para>
	/// <para>(SELF.FontSize > 0.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyleFontModel : IfcPreDefinedTextFont
	{
		public List<IfcTextFontName> FontFamily { get; set; }
		public IfcFontStyle? FontStyle { get; set; }
		public IfcFontVariant? FontVariant { get; set; }
		public IfcFontWeight? FontWeight { get; set; }
		public IfcSizeSelect FontSize { get; set; }
		public IfcTextStyleFontModel() : base()
		{
			FontFamily = new List<IfcTextFontName>();
			FontSize = new IfcSizeSelect();
		}
		public IfcTextStyleFontModel(IfcLabel Name, List<IfcTextFontName> FontFamily, IfcFontStyle FontStyle, IfcFontVariant FontVariant, IfcFontWeight FontWeight, IfcSizeSelect FontSize) : base (Name)
		{
			this.FontFamily = FontFamily;
			this.FontStyle = FontStyle;
			this.FontVariant = FontVariant;
			this.FontWeight = FontWeight;
			this.FontSize = FontSize;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyleForDefinedFont
	/// <para>ENTITY IfcTextStyleForDefinedFont</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Colour : IfcColour;</para>
	/// <para>	BackgroundColour : OPTIONAL IfcColour;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyleForDefinedFont : IfcPresentationItem
	{
		public IfcColour Colour { get; set; }
		public IfcColour? BackgroundColour { get; set; }
		public IfcTextStyleForDefinedFont() : base()
		{
			Colour = new IfcColour();
		}
		public IfcTextStyleForDefinedFont(IfcColour Colour, IfcColour BackgroundColour) : base ()
		{
			this.Colour = Colour;
			this.BackgroundColour = BackgroundColour;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyleTextModel
	/// <para>ENTITY IfcTextStyleTextModel</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	TextIndent : OPTIONAL IfcSizeSelect;</para>
	/// <para>	TextAlign : OPTIONAL IfcTextAlignment;</para>
	/// <para>	TextDecoration : OPTIONAL IfcTextDecoration;</para>
	/// <para>	LetterSpacing : OPTIONAL IfcSizeSelect;</para>
	/// <para>	WordSpacing : OPTIONAL IfcSizeSelect;</para>
	/// <para>	TextTransform : OPTIONAL IfcTextTransformation;</para>
	/// <para>	LineHeight : OPTIONAL IfcSizeSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyleTextModel : IfcPresentationItem
	{
		public IfcSizeSelect? TextIndent { get; set; }
		public IfcTextAlignment? TextAlign { get; set; }
		public IfcTextDecoration? TextDecoration { get; set; }
		public IfcSizeSelect? LetterSpacing { get; set; }
		public IfcSizeSelect? WordSpacing { get; set; }
		public IfcTextTransformation? TextTransform { get; set; }
		public IfcSizeSelect? LineHeight { get; set; }
		public IfcTextStyleTextModel() : base()
		{
		}
		public IfcTextStyleTextModel(IfcSizeSelect TextIndent, IfcTextAlignment TextAlign, IfcTextDecoration TextDecoration, IfcSizeSelect LetterSpacing, IfcSizeSelect WordSpacing, IfcTextTransformation TextTransform, IfcSizeSelect LineHeight) : base ()
		{
			this.TextIndent = TextIndent;
			this.TextAlign = TextAlign;
			this.TextDecoration = TextDecoration;
			this.LetterSpacing = LetterSpacing;
			this.WordSpacing = WordSpacing;
			this.TextTransform = TextTransform;
			this.LineHeight = LineHeight;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureCoordinate
	/// <para>ENTITY IfcTextureCoordinate</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcIndexedTextureMap</para>
	/// <para>    ,IfcTextureCoordinateGenerator</para>
	/// <para>    ,IfcTextureMap))</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Maps : LIST [1:?] OF IfcSurfaceTexture;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTextureCoordinate : IfcPresentationItem
	{
		public List<IfcSurfaceTexture> Maps { get; set; }
		public IfcTextureCoordinate() : base()
		{
			Maps = new List<IfcSurfaceTexture>();
		}
		public IfcTextureCoordinate(List<IfcSurfaceTexture> Maps) : base ()
		{
			this.Maps = Maps;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureCoordinateGenerator
	/// <para>ENTITY IfcTextureCoordinateGenerator</para>
	/// <para> SUBTYPE OF (IfcTextureCoordinate);</para>
	/// <para>	Mode : IfcLabel;</para>
	/// <para>	Parameter : OPTIONAL LIST [1:?] OF IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureCoordinateGenerator : IfcTextureCoordinate
	{
		public IfcLabel Mode { get; set; }
		public List<IfcReal>? Parameter { get; set; }
		public IfcTextureCoordinateGenerator() : base()
		{
			Mode = new IfcLabel();
		}
		public IfcTextureCoordinateGenerator(List<IfcSurfaceTexture> Maps, IfcLabel Mode, List<IfcReal> Parameter) : base (Maps)
		{
			this.Mode = Mode;
			this.Parameter = Parameter;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureMap
	/// <para>ENTITY IfcTextureMap</para>
	/// <para> SUBTYPE OF (IfcTextureCoordinate);</para>
	/// <para>	Vertices : LIST [3:?] OF IfcTextureVertex;</para>
	/// <para>	MappedTo : IfcFace;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureMap : IfcTextureCoordinate
	{
		public List<IfcTextureVertex> Vertices { get; set; }
		public IfcFace MappedTo { get; set; }
		public IfcTextureMap() : base()
		{
			Vertices = new List<IfcTextureVertex>();
			MappedTo = new IfcFace();
		}
		public IfcTextureMap(List<IfcSurfaceTexture> Maps, List<IfcTextureVertex> Vertices, IfcFace MappedTo) : base (Maps)
		{
			this.Vertices = Vertices;
			this.MappedTo = MappedTo;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureVertex
	/// <para>ENTITY IfcTextureVertex</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	Coordinates : LIST [2:2] OF IfcParameterValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureVertex : IfcPresentationItem
	{
		public List<IfcParameterValue> Coordinates { get; set; }
		public IfcTextureVertex() : base()
		{
			Coordinates = new List<IfcParameterValue>();
		}
		public IfcTextureVertex(List<IfcParameterValue> Coordinates) : base ()
		{
			this.Coordinates = Coordinates;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureVertexList
	/// <para>ENTITY IfcTextureVertexList</para>
	/// <para> SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>	TexCoordsList : LIST [1:?] OF LIST [2:2] OF IfcParameterValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureVertexList : IfcPresentationItem
	{
		public List<List<IfcParameterValue >> TexCoordsList { get; set; }
		public IfcTextureVertexList() : base()
		{
			TexCoordsList = new List<List<IfcParameterValue >>();
		}
		public IfcTextureVertexList(List<List<IfcParameterValue >> TexCoordsList) : base ()
		{
			this.TexCoordsList = TexCoordsList;
		}
	}
	/// <summary>
	/// ENTITY IfcTimePeriod;
	/// <para>ENTITY IfcTimePeriod;</para>
	/// <para>	StartTime : IfcTime;</para>
	/// <para>	EndTime : IfcTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTimePeriod : ENTITY
	{
		public IfcTime StartTime { get; set; }
		public IfcTime EndTime { get; set; }
		public IfcTimePeriod() : base()
		{
			StartTime = new IfcTime();
			EndTime = new IfcTime();
		}
		public IfcTimePeriod(IfcTime StartTime, IfcTime EndTime) : base ()
		{
			this.StartTime = StartTime;
			this.EndTime = EndTime;
		}
	}
	/// <summary>
	/// ENTITY IfcTimeSeries
	/// <para>ENTITY IfcTimeSeries</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcIrregularTimeSeries</para>
	/// <para>    ,IfcRegularTimeSeries));</para>
	/// <para>	Name : IfcLabel;</para>
	/// <para>	Description : OPTIONAL IfcText;</para>
	/// <para>	StartTime : IfcDateTime;</para>
	/// <para>	EndTime : IfcDateTime;</para>
	/// <para>	TimeSeriesDataType : IfcTimeSeriesDataTypeEnum;</para>
	/// <para>	DataOrigin : IfcDataOriginEnum;</para>
	/// <para>	UserDefinedDataOrigin : OPTIONAL IfcLabel;</para>
	/// <para>	Unit : OPTIONAL IfcUnit;</para>
	/// <para> INVERSE</para>
	/// <para>	HasExternalReference : SET [1:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTimeSeries : ENTITY, IfcMetricValueSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public IfcLabel Name { get; set; }
		public IfcText? Description { get; set; }
		public IfcDateTime StartTime { get; set; }
		public IfcDateTime EndTime { get; set; }
		public IfcTimeSeriesDataTypeEnum TimeSeriesDataType { get; set; }
		public IfcDataOriginEnum DataOrigin { get; set; }
		public IfcLabel? UserDefinedDataOrigin { get; set; }
		public IfcUnit? Unit { get; set; }
		public IfcTimeSeries() : base()
		{
			Name = new IfcLabel();
			StartTime = new IfcDateTime();
			EndTime = new IfcDateTime();
			TimeSeriesDataType = new IfcTimeSeriesDataTypeEnum();
			DataOrigin = new IfcDataOriginEnum();
		}
		public IfcTimeSeries(IfcLabel Name, IfcText Description, IfcDateTime StartTime, IfcDateTime EndTime, IfcTimeSeriesDataTypeEnum TimeSeriesDataType, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcUnit Unit) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.StartTime = StartTime;
			this.EndTime = EndTime;
			this.TimeSeriesDataType = TimeSeriesDataType;
			this.DataOrigin = DataOrigin;
			this.UserDefinedDataOrigin = UserDefinedDataOrigin;
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcTimeSeriesValue;
	/// <para>ENTITY IfcTimeSeriesValue;</para>
	/// <para>	ListValues : LIST [1:?] OF IfcValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTimeSeriesValue : ENTITY
	{
		public List<IfcValue> ListValues { get; set; }
		public IfcTimeSeriesValue() : base()
		{
			ListValues = new List<IfcValue>();
		}
		public IfcTimeSeriesValue(List<IfcValue> ListValues) : base ()
		{
			this.ListValues = ListValues;
		}
	}
	/// <summary>
	/// ENTITY IfcTopologicalRepresentationItem
	/// <para>ENTITY IfcTopologicalRepresentationItem</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcConnectedFaceSet</para>
	/// <para>    ,IfcEdge</para>
	/// <para>    ,IfcFace</para>
	/// <para>    ,IfcFaceBound</para>
	/// <para>    ,IfcLoop</para>
	/// <para>    ,IfcPath</para>
	/// <para>    ,IfcVertex))</para>
	/// <para> SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTopologicalRepresentationItem : IfcRepresentationItem
	{
		public IfcTopologicalRepresentationItem() : base()
		{
		}
		public IfcTopologicalRepresentationItem() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTopologyRepresentation
	/// <para>ENTITY IfcTopologyRepresentation</para>
	/// <para> SUBTYPE OF (IfcShapeModel);</para>
	/// <para> WHERE</para>
	/// <para>	WR21 : SIZEOF(QUERY(temp <* SELF\IfcRepresentation.Items | </para>
	/// <para>  NOT('IFC4.IFCTOPOLOGICALREPRESENTATIONITEM' IN TYPEOF(temp))</para>
	/// <para>)) = 0;</para>
	/// <para>	WR22 : EXISTS(SELF\IfcRepresentation.RepresentationType);</para>
	/// <para>	WR23 : IfcTopologyRepresentationTypes(SELF\IfcRepresentation.RepresentationType, SELF\IfcRepresentation.Items);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTopologyRepresentation : IfcShapeModel
	{
		public IfcTopologyRepresentation() : base()
		{
		}
		public IfcTopologyRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcToroidalSurface
	/// <para>ENTITY IfcToroidalSurface</para>
	/// <para> SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>	MajorRadius : IfcPositiveLengthMeasure;</para>
	/// <para>	MinorRadius : IfcPositiveLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	MajorLargerMinor : MinorRadius < MajorRadius;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcToroidalSurface : IfcElementarySurface
	{
		public IfcPositiveLengthMeasure MajorRadius { get; set; }
		public IfcPositiveLengthMeasure MinorRadius { get; set; }
		public IfcToroidalSurface() : base()
		{
			MajorRadius = new IfcPositiveLengthMeasure();
			MinorRadius = new IfcPositiveLengthMeasure();
		}
		public IfcToroidalSurface(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure MajorRadius, IfcPositiveLengthMeasure MinorRadius) : base (Position)
		{
			this.MajorRadius = MajorRadius;
			this.MinorRadius = MinorRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcTransformer
	/// <para>ENTITY IfcTransformer</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTransformerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcTransformerTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcTransformerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCTRANFORMERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransformer : IfcEnergyConversionDevice
	{
		public IfcTransformerTypeEnum? PredefinedType { get; set; }
		public IfcTransformer() : base()
		{
		}
		public IfcTransformer(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTransformerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransformerType
	/// <para>ENTITY IfcTransformerType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcTransformerTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTransformerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTransformerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransformerType : IfcEnergyConversionDeviceType
	{
		public IfcTransformerTypeEnum PredefinedType { get; set; }
		public IfcTransformerType() : base()
		{
			PredefinedType = new IfcTransformerTypeEnum();
		}
		public IfcTransformerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTransformerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransportElement
	/// <para>ENTITY IfcTransportElement</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTransportElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcTransportElementTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcTransportElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCTRANSPORTELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransportElement : IfcElement
	{
		public IfcTransportElementTypeEnum? PredefinedType { get; set; }
		public IfcTransportElement() : base()
		{
		}
		public IfcTransportElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTransportElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransportElementType
	/// <para>ENTITY IfcTransportElementType</para>
	/// <para> SUBTYPE OF (IfcElementType);</para>
	/// <para>	PredefinedType : IfcTransportElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTransportElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTransportElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransportElementType : IfcElementType
	{
		public IfcTransportElementTypeEnum PredefinedType { get; set; }
		public IfcTransportElementType() : base()
		{
			PredefinedType = new IfcTransportElementTypeEnum();
		}
		public IfcTransportElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTransportElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTrapeziumProfileDef
	/// <para>ENTITY IfcTrapeziumProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	BottomXDim : IfcPositiveLengthMeasure;</para>
	/// <para>	TopXDim : IfcPositiveLengthMeasure;</para>
	/// <para>	YDim : IfcPositiveLengthMeasure;</para>
	/// <para>	TopXOffset : IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTrapeziumProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure BottomXDim { get; set; }
		public IfcPositiveLengthMeasure TopXDim { get; set; }
		public IfcPositiveLengthMeasure YDim { get; set; }
		public IfcLengthMeasure TopXOffset { get; set; }
		public IfcTrapeziumProfileDef() : base()
		{
			BottomXDim = new IfcPositiveLengthMeasure();
			TopXDim = new IfcPositiveLengthMeasure();
			YDim = new IfcPositiveLengthMeasure();
			TopXOffset = new IfcLengthMeasure();
		}
		public IfcTrapeziumProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure BottomXDim, IfcPositiveLengthMeasure TopXDim, IfcPositiveLengthMeasure YDim, IfcLengthMeasure TopXOffset) : base (ProfileType, ProfileName, Position)
		{
			this.BottomXDim = BottomXDim;
			this.TopXDim = TopXDim;
			this.YDim = YDim;
			this.TopXOffset = TopXOffset;
		}
	}
	/// <summary>
	/// ENTITY IfcTriangulatedFaceSet
	/// <para>ENTITY IfcTriangulatedFaceSet</para>
	/// <para> SUBTYPE OF (IfcTessellatedFaceSet);</para>
	/// <para>	Normals : OPTIONAL LIST [1:?] OF LIST [3:3] OF IfcParameterValue;</para>
	/// <para>	Closed : OPTIONAL IfcBoolean;</para>
	/// <para>	CoordIndex : LIST [1:?] OF LIST [3:3] OF IfcPositiveInteger;</para>
	/// <para>	PnIndex : OPTIONAL LIST [1:?] OF IfcPositiveInteger;</para>
	/// <para> DERIVE</para>
	/// <para>	NumberOfTriangles : IfcInteger := SIZEOF(CoordIndex);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTriangulatedFaceSet : IfcTessellatedFaceSet
	{
		public List<List<IfcParameterValue >>? Normals { get; set; }
		public IfcBoolean? Closed { get; set; }
		public List<List<IfcPositiveInteger >> CoordIndex { get; set; }
		public List<IfcPositiveInteger>? PnIndex { get; set; }
		public IfcTriangulatedFaceSet() : base()
		{
			CoordIndex = new List<List<IfcPositiveInteger >>();
		}
		public IfcTriangulatedFaceSet(IfcCartesianPointList3D Coordinates, List<List<IfcParameterValue >> Normals, IfcBoolean Closed, List<List<IfcPositiveInteger >> CoordIndex, List<IfcPositiveInteger> PnIndex) : base (Coordinates)
		{
			this.Normals = Normals;
			this.Closed = Closed;
			this.CoordIndex = CoordIndex;
			this.PnIndex = PnIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcTrimmedCurve
	/// <para>ENTITY IfcTrimmedCurve</para>
	/// <para> SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>	BasisCurve : IfcCurve;</para>
	/// <para>	Trim1 : SET [1:2] OF IfcTrimmingSelect;</para>
	/// <para>	Trim2 : SET [1:2] OF IfcTrimmingSelect;</para>
	/// <para>	SenseAgreement : IfcBoolean;</para>
	/// <para>	MasterRepresentation : IfcTrimmingPreference;</para>
	/// <para> WHERE</para>
	/// <para>	Trim1ValuesConsistent : (HIINDEX(Trim1) = 1) OR (TYPEOF(Trim1[1]) <> TYPEOF(Trim1[2]));</para>
	/// <para>	Trim2ValuesConsistent : (HIINDEX(Trim2) = 1) OR (TYPEOF(Trim2[1]) <> TYPEOF(Trim2[2]));</para>
	/// <para>	NoTrimOfBoundedCurves : NOT('IFC4.IFCBOUNDEDCURVE' IN TYPEOF(BasisCurve));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTrimmedCurve : IfcBoundedCurve
	{
		public IfcCurve BasisCurve { get; set; }
		public List<IfcTrimmingSelect> Trim1 { get; set; }
		public List<IfcTrimmingSelect> Trim2 { get; set; }
		public IfcBoolean SenseAgreement { get; set; }
		public IfcTrimmingPreference MasterRepresentation { get; set; }
		public IfcTrimmedCurve() : base()
		{
			BasisCurve = new IfcCurve();
			Trim1 = new List<IfcTrimmingSelect>();
			Trim2 = new List<IfcTrimmingSelect>();
			SenseAgreement = new IfcBoolean();
			MasterRepresentation = new IfcTrimmingPreference();
		}
		public IfcTrimmedCurve(IfcCurve BasisCurve, List<IfcTrimmingSelect> Trim1, List<IfcTrimmingSelect> Trim2, IfcBoolean SenseAgreement, IfcTrimmingPreference MasterRepresentation) : base ()
		{
			this.BasisCurve = BasisCurve;
			this.Trim1 = Trim1;
			this.Trim2 = Trim2;
			this.SenseAgreement = SenseAgreement;
			this.MasterRepresentation = MasterRepresentation;
		}
	}
	/// <summary>
	/// ENTITY IfcTubeBundle
	/// <para>ENTITY IfcTubeBundle</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcTubeBundleTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcTubeBundleTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcTubeBundleTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCTUBEBUNDLETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTubeBundle : IfcEnergyConversionDevice
	{
		public IfcTubeBundleTypeEnum? PredefinedType { get; set; }
		public IfcTubeBundle() : base()
		{
		}
		public IfcTubeBundle(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTubeBundleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTubeBundleType
	/// <para>ENTITY IfcTubeBundleType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcTubeBundleTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcTubeBundleTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTubeBundleTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTubeBundleType : IfcEnergyConversionDeviceType
	{
		public IfcTubeBundleTypeEnum PredefinedType { get; set; }
		public IfcTubeBundleType() : base()
		{
			PredefinedType = new IfcTubeBundleTypeEnum();
		}
		public IfcTubeBundleType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTubeBundleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTypeObject
	/// <para>ENTITY IfcTypeObject</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcTypeProcess</para>
	/// <para>    ,IfcTypeProduct</para>
	/// <para>    ,IfcTypeResource))</para>
	/// <para> SUBTYPE OF (IfcObjectDefinition);</para>
	/// <para>	ApplicableOccurrence : OPTIONAL IfcIdentifier;</para>
	/// <para>	HasPropertySets : OPTIONAL SET [1:?] OF IfcPropertySetDefinition;</para>
	/// <para> INVERSE</para>
	/// <para>	Types : SET [0:1] OF IfcRelDefinesByType FOR RelatingType;</para>
	/// <para> WHERE</para>
	/// <para>	NameRequired : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>	UniquePropertySetNames : (NOT(EXISTS(HasPropertySets))) OR IfcUniquePropertySetNames(HasPropertySets);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTypeObject : IfcObjectDefinition
	{
		public IfcIdentifier? ApplicableOccurrence { get; set; }
		public List<IfcPropertySetDefinition>? HasPropertySets { get; set; }
		public IfcTypeObject() : base()
		{
		}
		public IfcTypeObject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ApplicableOccurrence = ApplicableOccurrence;
			this.HasPropertySets = HasPropertySets;
		}
	}
	/// <summary>
	/// ENTITY IfcTypeProcess
	/// <para>ENTITY IfcTypeProcess</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcEventType</para>
	/// <para>    ,IfcProcedureType</para>
	/// <para>    ,IfcTaskType))</para>
	/// <para> SUBTYPE OF (IfcTypeObject);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para>	ProcessType : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	OperatesOn : SET [0:?] OF IfcRelAssignsToProcess FOR RelatingProcess;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTypeProcess : IfcTypeObject, IfcProcessSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcLabel? ProcessType { get; set; }
		public IfcTypeProcess() : base()
		{
		}
		public IfcTypeProcess(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
			this.ProcessType = ProcessType;
		}
	}
	/// <summary>
	/// ENTITY IfcTypeProduct
	/// <para>ENTITY IfcTypeProduct</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcDoorStyle</para>
	/// <para>    ,IfcElementType</para>
	/// <para>    ,IfcSpatialElementType</para>
	/// <para>    ,IfcWindowStyle))</para>
	/// <para> SUBTYPE OF (IfcTypeObject);</para>
	/// <para>	RepresentationMaps : OPTIONAL LIST [1:?] OF UNIQUE IfcRepresentationMap;</para>
	/// <para>	Tag : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ReferencedBy : SET [0:?] OF IfcRelAssignsToProduct FOR RelatingProduct;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableOccurrence : NOT(EXISTS(SELF\IfcTypeObject.Types[1])) OR</para>
	/// <para>(SIZEOF(QUERY(temp <* SELF\IfcTypeObject.Types[1].RelatedObjects |</para>
	/// <para>  NOT('IFC4.IFCPRODUCT' IN TYPEOF(temp)))</para>
	/// <para>) = 0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTypeProduct : IfcTypeObject, IfcProductSelect
	{
		public IfcTypeProduct() : base()
		{
		}
		public IfcTypeProduct(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTypeResource
	/// <para>ENTITY IfcTypeResource</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcConstructionResourceType))</para>
	/// <para> SUBTYPE OF (IfcTypeObject);</para>
	/// <para>	Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>	LongDescription : OPTIONAL IfcText;</para>
	/// <para>	ResourceType : OPTIONAL IfcLabel;</para>
	/// <para> INVERSE</para>
	/// <para>	ResourceOf : SET [0:?] OF IfcRelAssignsToResource FOR RelatingResource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTypeResource : IfcTypeObject, IfcResourceSelect
	{
		public IfcIdentifier? Identification { get; set; }
		public IfcText? LongDescription { get; set; }
		public IfcLabel? ResourceType { get; set; }
		public IfcTypeResource() : base()
		{
		}
		public IfcTypeResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
			this.ResourceType = ResourceType;
		}
	}
	/// <summary>
	/// ENTITY IfcUShapeProfileDef
	/// <para>ENTITY IfcUShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	EdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	FlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidFlangeThickness : FlangeThickness < (Depth / 2.);</para>
	/// <para>	ValidWebThickness : WebThickness < FlangeWidth;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcPositiveLengthMeasure FlangeWidth { get; set; }
		public IfcPositiveLengthMeasure WebThickness { get; set; }
		public IfcPositiveLengthMeasure FlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? EdgeRadius { get; set; }
		public IfcPlaneAngleMeasure? FlangeSlope { get; set; }
		public IfcUShapeProfileDef() : base()
		{
			Depth = new IfcPositiveLengthMeasure();
			FlangeWidth = new IfcPositiveLengthMeasure();
			WebThickness = new IfcPositiveLengthMeasure();
			FlangeThickness = new IfcPositiveLengthMeasure();
		}
		public IfcUShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure FlangeWidth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure EdgeRadius, IfcPlaneAngleMeasure FlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.FlangeWidth = FlangeWidth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.EdgeRadius = EdgeRadius;
			this.FlangeSlope = FlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitAssignment;
	/// <para>ENTITY IfcUnitAssignment;</para>
	/// <para>	Units : SET [1:?] OF IfcUnit;</para>
	/// <para> WHERE</para>
	/// <para>	WR01 : IfcCorrectUnitAssignment(Units);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitAssignment : ENTITY
	{
		public List<IfcUnit> Units { get; set; }
		public IfcUnitAssignment() : base()
		{
			Units = new List<IfcUnit>();
		}
		public IfcUnitAssignment(List<IfcUnit> Units) : base ()
		{
			this.Units = Units;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryControlElement
	/// <para>ENTITY IfcUnitaryControlElement</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcUnitaryControlElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcUnitaryControlElementTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcUnitaryControlElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>('IFC4.IFCUNITARYCONTROLELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryControlElement : IfcDistributionControlElement
	{
		public IfcUnitaryControlElementTypeEnum? PredefinedType { get; set; }
		public IfcUnitaryControlElement() : base()
		{
		}
		public IfcUnitaryControlElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcUnitaryControlElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryControlElementType
	/// <para>ENTITY IfcUnitaryControlElementType</para>
	/// <para> SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>	PredefinedType : IfcUnitaryControlElementTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcUnitaryControlElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcUnitaryControlElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryControlElementType : IfcDistributionControlElementType
	{
		public IfcUnitaryControlElementTypeEnum PredefinedType { get; set; }
		public IfcUnitaryControlElementType() : base()
		{
			PredefinedType = new IfcUnitaryControlElementTypeEnum();
		}
		public IfcUnitaryControlElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcUnitaryControlElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryEquipment
	/// <para>ENTITY IfcUnitaryEquipment</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>	PredefinedType : OPTIONAL IfcUnitaryEquipmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcUnitaryEquipmentTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcUnitaryEquipmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCUNITARYEQUIPMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryEquipment : IfcEnergyConversionDevice
	{
		public IfcUnitaryEquipmentTypeEnum? PredefinedType { get; set; }
		public IfcUnitaryEquipment() : base()
		{
		}
		public IfcUnitaryEquipment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcUnitaryEquipmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryEquipmentType
	/// <para>ENTITY IfcUnitaryEquipmentType</para>
	/// <para> SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>	PredefinedType : IfcUnitaryEquipmentTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcUnitaryEquipmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcUnitaryEquipmentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryEquipmentType : IfcEnergyConversionDeviceType
	{
		public IfcUnitaryEquipmentTypeEnum PredefinedType { get; set; }
		public IfcUnitaryEquipmentType() : base()
		{
			PredefinedType = new IfcUnitaryEquipmentTypeEnum();
		}
		public IfcUnitaryEquipmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcUnitaryEquipmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcValve
	/// <para>ENTITY IfcValve</para>
	/// <para> SUBTYPE OF (IfcFlowController);</para>
	/// <para>	PredefinedType : OPTIONAL IfcValveTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcValveTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcValveTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCVALVETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcValve : IfcFlowController
	{
		public IfcValveTypeEnum? PredefinedType { get; set; }
		public IfcValve() : base()
		{
		}
		public IfcValve(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcValveTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcValveType
	/// <para>ENTITY IfcValveType</para>
	/// <para> SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>	PredefinedType : IfcValveTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcValveTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcValveTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcValveType : IfcFlowControllerType
	{
		public IfcValveTypeEnum PredefinedType { get; set; }
		public IfcValveType() : base()
		{
			PredefinedType = new IfcValveTypeEnum();
		}
		public IfcValveType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcValveTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVector
	/// <para>ENTITY IfcVector</para>
	/// <para> SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>	Orientation : IfcDirection;</para>
	/// <para>	Magnitude : IfcLengthMeasure;</para>
	/// <para> DERIVE</para>
	/// <para>	Dim : IfcDimensionCount := Orientation.Dim;</para>
	/// <para> WHERE</para>
	/// <para>	MagGreaterOrEqualZero : Magnitude >= 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVector : IfcGeometricRepresentationItem, IfcHatchLineDistanceSelect, IfcVectorOrDirection
	{
		public IfcDirection Orientation { get; set; }
		public IfcLengthMeasure Magnitude { get; set; }
		public IfcVector() : base()
		{
			Orientation = new IfcDirection();
			Magnitude = new IfcLengthMeasure();
		}
		public IfcVector(IfcDirection Orientation, IfcLengthMeasure Magnitude) : base ()
		{
			this.Orientation = Orientation;
			this.Magnitude = Magnitude;
		}
	}
	/// <summary>
	/// ENTITY IfcVertex
	/// <para>ENTITY IfcVertex</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcVertexPoint))</para>
	/// <para> SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVertex : IfcTopologicalRepresentationItem
	{
		public IfcVertex() : base()
		{
		}
		public IfcVertex() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcVertexLoop
	/// <para>ENTITY IfcVertexLoop</para>
	/// <para> SUBTYPE OF (IfcLoop);</para>
	/// <para>	LoopVertex : IfcVertex;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVertexLoop : IfcLoop
	{
		public IfcVertex LoopVertex { get; set; }
		public IfcVertexLoop() : base()
		{
			LoopVertex = new IfcVertex();
		}
		public IfcVertexLoop(IfcVertex LoopVertex) : base ()
		{
			this.LoopVertex = LoopVertex;
		}
	}
	/// <summary>
	/// ENTITY IfcVertexPoint
	/// <para>ENTITY IfcVertexPoint</para>
	/// <para> SUBTYPE OF (IfcVertex);</para>
	/// <para>	VertexGeometry : IfcPoint;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVertexPoint : IfcVertex, IfcPointOrVertexPoint
	{
		public IfcPoint VertexGeometry { get; set; }
		public IfcVertexPoint() : base()
		{
			VertexGeometry = new IfcPoint();
		}
		public IfcVertexPoint(IfcPoint VertexGeometry) : base ()
		{
			this.VertexGeometry = VertexGeometry;
		}
	}
	/// <summary>
	/// ENTITY IfcVibrationIsolator
	/// <para>ENTITY IfcVibrationIsolator</para>
	/// <para> SUBTYPE OF (IfcElementComponent);</para>
	/// <para>	PredefinedType : OPTIONAL IfcVibrationIsolatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcVibrationIsolatorTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcVibrationIsolatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCVIBRATIONISOLATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVibrationIsolator : IfcElementComponent
	{
		public IfcVibrationIsolatorTypeEnum? PredefinedType { get; set; }
		public IfcVibrationIsolator() : base()
		{
		}
		public IfcVibrationIsolator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcVibrationIsolatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVibrationIsolatorType
	/// <para>ENTITY IfcVibrationIsolatorType</para>
	/// <para> SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>	PredefinedType : IfcVibrationIsolatorTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcVibrationIsolatorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcVibrationIsolatorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVibrationIsolatorType : IfcElementComponentType
	{
		public IfcVibrationIsolatorTypeEnum PredefinedType { get; set; }
		public IfcVibrationIsolatorType() : base()
		{
			PredefinedType = new IfcVibrationIsolatorTypeEnum();
		}
		public IfcVibrationIsolatorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcVibrationIsolatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVirtualElement
	/// <para>ENTITY IfcVirtualElement</para>
	/// <para> SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVirtualElement : IfcElement
	{
		public IfcVirtualElement() : base()
		{
		}
		public IfcVirtualElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcVirtualGridIntersection;
	/// <para>ENTITY IfcVirtualGridIntersection;</para>
	/// <para>	IntersectingAxes : LIST [2:2] OF UNIQUE IfcGridAxis;</para>
	/// <para>	OffsetDistances : LIST [2:3] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVirtualGridIntersection : ENTITY, IfcGridPlacementDirectionSelect
	{
		public IfcVirtualGridIntersection() : base()
		{
		}
		public IfcVirtualGridIntersection() : base ()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcVoidingFeature
	/// <para>ENTITY IfcVoidingFeature</para>
	/// <para> SUBTYPE OF (IfcFeatureElementSubtraction);</para>
	/// <para>	PredefinedType : OPTIONAL IfcVoidingFeatureTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	HasObjectType : NOT EXISTS(PredefinedType) OR (PredefinedType <> IfcVoidingFeatureTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVoidingFeature : IfcFeatureElementSubtraction
	{
		public IfcVoidingFeatureTypeEnum? PredefinedType { get; set; }
		public IfcVoidingFeature() : base()
		{
		}
		public IfcVoidingFeature(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcVoidingFeatureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWall
	/// <para>ENTITY IfcWall</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcWallElementedCase</para>
	/// <para>    ,IfcWallStandardCase))</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	PredefinedType : OPTIONAL IfcWallTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para> (PredefinedType <> IfcWallTypeEnum.USERDEFINED) OR</para>
	/// <para> ((PredefinedType = IfcWallTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>  ('IFC4.IFCWALLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWall : IfcBuildingElement
	{
		public IfcWallTypeEnum? PredefinedType { get; set; }
		public IfcWall() : base()
		{
		}
		public IfcWall(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWallElementedCase
	/// <para>ENTITY IfcWallElementedCase</para>
	/// <para> SUBTYPE OF (IfcWall);</para>
	/// <para> WHERE</para>
	/// <para>	HasDecomposition : HIINDEX(SELF\IfcObjectDefinition.IsDecomposedBy) > 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWallElementedCase : IfcWall
	{
		public IfcWallElementedCase() : base()
		{
		}
		public IfcWallElementedCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcWallStandardCase
	/// <para>ENTITY IfcWallStandardCase</para>
	/// <para> SUBTYPE OF (IfcWall);</para>
	/// <para> WHERE</para>
	/// <para>	HasMaterialLayerSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>              ('IFC4.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>              ('IFC4.IFCMATERIALLAYERSETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>              )) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWallStandardCase : IfcWall
	{
		public IfcWallStandardCase() : base()
		{
		}
		public IfcWallStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcWallType
	/// <para>ENTITY IfcWallType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcWallTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcWallTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWallTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWallType : IfcBuildingElementType
	{
		public IfcWallTypeEnum PredefinedType { get; set; }
		public IfcWallType() : base()
		{
			PredefinedType = new IfcWallTypeEnum();
		}
		public IfcWallType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWasteTerminal
	/// <para>ENTITY IfcWasteTerminal</para>
	/// <para> SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>	PredefinedType : OPTIONAL IfcWasteTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR </para>
	/// <para> (PredefinedType <> IfcWasteTerminalTypeEnum.USERDEFINED) OR </para>
	/// <para> ((PredefinedType = IfcWasteTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>	CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR </para>
	/// <para>  ('IFC4.IFCWASTETERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWasteTerminal : IfcFlowTerminal
	{
		public IfcWasteTerminalTypeEnum? PredefinedType { get; set; }
		public IfcWasteTerminal() : base()
		{
		}
		public IfcWasteTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWasteTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWasteTerminalType
	/// <para>ENTITY IfcWasteTerminalType</para>
	/// <para> SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>	PredefinedType : IfcWasteTerminalTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcWasteTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWasteTerminalTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWasteTerminalType : IfcFlowTerminalType
	{
		public IfcWasteTerminalTypeEnum PredefinedType { get; set; }
		public IfcWasteTerminalType() : base()
		{
			PredefinedType = new IfcWasteTerminalTypeEnum();
		}
		public IfcWasteTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcWasteTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWindow
	/// <para>ENTITY IfcWindow</para>
	/// <para> SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcWindowStandardCase))</para>
	/// <para> SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>	OverallHeight : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	OverallWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	PredefinedType : OPTIONAL IfcWindowTypeEnum;</para>
	/// <para>	PartitioningType : OPTIONAL IfcWindowTypePartitioningEnum;</para>
	/// <para>	UserDefinedPartitioningType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectStyleAssigned : (SIZEOF(IsTypedBy) = 0) </para>
	/// <para>OR ('IFC4.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindow : IfcBuildingElement
	{
		public IfcPositiveLengthMeasure? OverallHeight { get; set; }
		public IfcPositiveLengthMeasure? OverallWidth { get; set; }
		public IfcWindowTypeEnum? PredefinedType { get; set; }
		public IfcWindowTypePartitioningEnum? PartitioningType { get; set; }
		public IfcLabel? UserDefinedPartitioningType { get; set; }
		public IfcWindow() : base()
		{
		}
		public IfcWindow(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure OverallHeight, IfcPositiveLengthMeasure OverallWidth, IfcWindowTypeEnum PredefinedType, IfcWindowTypePartitioningEnum PartitioningType, IfcLabel UserDefinedPartitioningType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.OverallHeight = OverallHeight;
			this.OverallWidth = OverallWidth;
			this.PredefinedType = PredefinedType;
			this.PartitioningType = PartitioningType;
			this.UserDefinedPartitioningType = UserDefinedPartitioningType;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowLiningProperties
	/// <para>ENTITY IfcWindowLiningProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	LiningDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	LiningThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	TransomThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	MullionThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	FirstTransomOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	SecondTransomOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	FirstMullionOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	SecondMullionOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>	ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>	LiningOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LiningToPanelOffsetX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>	LiningToPanelOffsetY : OPTIONAL IfcLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	WR31 : NOT(EXISTS(LiningDepth) AND NOT(EXISTS(LiningThickness)));</para>
	/// <para>	WR32 : NOT(NOT(EXISTS(FirstTransomOffset)) AND EXISTS(SecondTransomOffset));</para>
	/// <para>	WR33 : NOT(NOT(EXISTS(FirstMullionOffset)) AND EXISTS(SecondMullionOffset));</para>
	/// <para>	WR34 : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) </para>
	/// <para>AND </para>
	/// <para>(</para>
	/// <para> ('IFC4.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>  OR</para>
	/// <para> ('IFC4.IFCWINDOWSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowLiningProperties : IfcPreDefinedPropertySet
	{
		public IfcPositiveLengthMeasure? LiningDepth { get; set; }
		public IfcNonNegativeLengthMeasure? LiningThickness { get; set; }
		public IfcNonNegativeLengthMeasure? TransomThickness { get; set; }
		public IfcNonNegativeLengthMeasure? MullionThickness { get; set; }
		public IfcNormalisedRatioMeasure? FirstTransomOffset { get; set; }
		public IfcNormalisedRatioMeasure? SecondTransomOffset { get; set; }
		public IfcNormalisedRatioMeasure? FirstMullionOffset { get; set; }
		public IfcNormalisedRatioMeasure? SecondMullionOffset { get; set; }
		public IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcLengthMeasure? LiningOffset { get; set; }
		public IfcLengthMeasure? LiningToPanelOffsetX { get; set; }
		public IfcLengthMeasure? LiningToPanelOffsetY { get; set; }
		public IfcWindowLiningProperties() : base()
		{
		}
		public IfcWindowLiningProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPositiveLengthMeasure LiningDepth, IfcNonNegativeLengthMeasure LiningThickness, IfcNonNegativeLengthMeasure TransomThickness, IfcNonNegativeLengthMeasure MullionThickness, IfcNormalisedRatioMeasure FirstTransomOffset, IfcNormalisedRatioMeasure SecondTransomOffset, IfcNormalisedRatioMeasure FirstMullionOffset, IfcNormalisedRatioMeasure SecondMullionOffset, IfcShapeAspect ShapeAspectStyle, IfcLengthMeasure LiningOffset, IfcLengthMeasure LiningToPanelOffsetX, IfcLengthMeasure LiningToPanelOffsetY) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.LiningDepth = LiningDepth;
			this.LiningThickness = LiningThickness;
			this.TransomThickness = TransomThickness;
			this.MullionThickness = MullionThickness;
			this.FirstTransomOffset = FirstTransomOffset;
			this.SecondTransomOffset = SecondTransomOffset;
			this.FirstMullionOffset = FirstMullionOffset;
			this.SecondMullionOffset = SecondMullionOffset;
			this.ShapeAspectStyle = ShapeAspectStyle;
			this.LiningOffset = LiningOffset;
			this.LiningToPanelOffsetX = LiningToPanelOffsetX;
			this.LiningToPanelOffsetY = LiningToPanelOffsetY;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowPanelProperties
	/// <para>ENTITY IfcWindowPanelProperties</para>
	/// <para> SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>	OperationType : IfcWindowPanelOperationEnum;</para>
	/// <para>	PanelPosition : IfcWindowPanelPositionEnum;</para>
	/// <para>	FrameDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	FrameThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>	ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para> WHERE</para>
	/// <para>	ApplicableToType : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1])) </para>
	/// <para>AND </para>
	/// <para>(</para>
	/// <para> ('IFC4.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>  OR</para>
	/// <para> ('IFC4.IFCWINDOWSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowPanelProperties : IfcPreDefinedPropertySet
	{
		public IfcWindowPanelOperationEnum OperationType { get; set; }
		public IfcWindowPanelPositionEnum PanelPosition { get; set; }
		public IfcPositiveLengthMeasure? FrameDepth { get; set; }
		public IfcPositiveLengthMeasure? FrameThickness { get; set; }
		public IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcWindowPanelProperties() : base()
		{
			OperationType = new IfcWindowPanelOperationEnum();
			PanelPosition = new IfcWindowPanelPositionEnum();
		}
		public IfcWindowPanelProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcWindowPanelOperationEnum OperationType, IfcWindowPanelPositionEnum PanelPosition, IfcPositiveLengthMeasure FrameDepth, IfcPositiveLengthMeasure FrameThickness, IfcShapeAspect ShapeAspectStyle) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.OperationType = OperationType;
			this.PanelPosition = PanelPosition;
			this.FrameDepth = FrameDepth;
			this.FrameThickness = FrameThickness;
			this.ShapeAspectStyle = ShapeAspectStyle;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowStandardCase
	/// <para>ENTITY IfcWindowStandardCase</para>
	/// <para> SUBTYPE OF (IfcWindow);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowStandardCase : IfcWindow
	{
		public IfcWindowStandardCase() : base()
		{
		}
		public IfcWindowStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure OverallHeight, IfcPositiveLengthMeasure OverallWidth, IfcWindowTypeEnum PredefinedType, IfcWindowTypePartitioningEnum PartitioningType, IfcLabel UserDefinedPartitioningType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcWindowStyle
	/// <para>ENTITY IfcWindowStyle</para>
	/// <para> SUBTYPE OF (IfcTypeProduct);</para>
	/// <para>	ConstructionType : IfcWindowStyleConstructionEnum;</para>
	/// <para>	OperationType : IfcWindowStyleOperationEnum;</para>
	/// <para>	ParameterTakesPrecedence : IfcBoolean;</para>
	/// <para>	Sizeable : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowStyle : IfcTypeProduct
	{
		public IfcWindowStyleConstructionEnum ConstructionType { get; set; }
		public IfcWindowStyleOperationEnum OperationType { get; set; }
		public IfcBoolean ParameterTakesPrecedence { get; set; }
		public IfcBoolean Sizeable { get; set; }
		public IfcWindowStyle() : base()
		{
			ConstructionType = new IfcWindowStyleConstructionEnum();
			OperationType = new IfcWindowStyleOperationEnum();
			ParameterTakesPrecedence = new IfcBoolean();
			Sizeable = new IfcBoolean();
		}
		public IfcWindowStyle(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcWindowStyleConstructionEnum ConstructionType, IfcWindowStyleOperationEnum OperationType, IfcBoolean ParameterTakesPrecedence, IfcBoolean Sizeable) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.ConstructionType = ConstructionType;
			this.OperationType = OperationType;
			this.ParameterTakesPrecedence = ParameterTakesPrecedence;
			this.Sizeable = Sizeable;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowType
	/// <para>ENTITY IfcWindowType</para>
	/// <para> SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>	PredefinedType : IfcWindowTypeEnum;</para>
	/// <para>	PartitioningType : IfcWindowTypePartitioningEnum;</para>
	/// <para>	ParameterTakesPrecedence : OPTIONAL IfcBoolean;</para>
	/// <para>	UserDefinedPartitioningType : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : (PredefinedType <> IfcWindowTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWindowTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowType : IfcBuildingElementType
	{
		public IfcWindowTypeEnum PredefinedType { get; set; }
		public IfcWindowTypePartitioningEnum PartitioningType { get; set; }
		public IfcBoolean? ParameterTakesPrecedence { get; set; }
		public IfcLabel? UserDefinedPartitioningType { get; set; }
		public IfcWindowType() : base()
		{
			PredefinedType = new IfcWindowTypeEnum();
			PartitioningType = new IfcWindowTypePartitioningEnum();
		}
		public IfcWindowType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcWindowTypeEnum PredefinedType, IfcWindowTypePartitioningEnum PartitioningType, IfcBoolean ParameterTakesPrecedence, IfcLabel UserDefinedPartitioningType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.PartitioningType = PartitioningType;
			this.ParameterTakesPrecedence = ParameterTakesPrecedence;
			this.UserDefinedPartitioningType = UserDefinedPartitioningType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkCalendar
	/// <para>ENTITY IfcWorkCalendar</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	WorkingTimes : OPTIONAL SET [1:?] OF IfcWorkTime;</para>
	/// <para>	ExceptionTimes : OPTIONAL SET [1:?] OF IfcWorkTime;</para>
	/// <para>	PredefinedType : OPTIONAL IfcWorkCalendarTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcWorkCalendarTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWorkCalendarTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkCalendar : IfcControl
	{
		public List<IfcWorkTime>? WorkingTimes { get; set; }
		public List<IfcWorkTime>? ExceptionTimes { get; set; }
		public IfcWorkCalendarTypeEnum? PredefinedType { get; set; }
		public IfcWorkCalendar() : base()
		{
		}
		public IfcWorkCalendar(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, List<IfcWorkTime> WorkingTimes, List<IfcWorkTime> ExceptionTimes, IfcWorkCalendarTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.WorkingTimes = WorkingTimes;
			this.ExceptionTimes = ExceptionTimes;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkControl
	/// <para>ENTITY IfcWorkControl</para>
	/// <para> ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>    (IfcWorkPlan</para>
	/// <para>    ,IfcWorkSchedule))</para>
	/// <para> SUBTYPE OF (IfcControl);</para>
	/// <para>	CreationDate : IfcDateTime;</para>
	/// <para>	Creators : OPTIONAL SET [1:?] OF IfcPerson;</para>
	/// <para>	Purpose : OPTIONAL IfcLabel;</para>
	/// <para>	Duration : OPTIONAL IfcDuration;</para>
	/// <para>	TotalFloat : OPTIONAL IfcDuration;</para>
	/// <para>	StartTime : IfcDateTime;</para>
	/// <para>	FinishTime : OPTIONAL IfcDateTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcWorkControl : IfcControl
	{
		public IfcDateTime CreationDate { get; set; }
		public List<IfcPerson>? Creators { get; set; }
		public IfcLabel? Purpose { get; set; }
		public IfcDuration? Duration { get; set; }
		public IfcDuration? TotalFloat { get; set; }
		public IfcDateTime StartTime { get; set; }
		public IfcDateTime? FinishTime { get; set; }
		public IfcWorkControl() : base()
		{
			CreationDate = new IfcDateTime();
			StartTime = new IfcDateTime();
		}
		public IfcWorkControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcDateTime CreationDate, List<IfcPerson> Creators, IfcLabel Purpose, IfcDuration Duration, IfcDuration TotalFloat, IfcDateTime StartTime, IfcDateTime FinishTime) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.CreationDate = CreationDate;
			this.Creators = Creators;
			this.Purpose = Purpose;
			this.Duration = Duration;
			this.TotalFloat = TotalFloat;
			this.StartTime = StartTime;
			this.FinishTime = FinishTime;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkPlan
	/// <para>ENTITY IfcWorkPlan</para>
	/// <para> SUBTYPE OF (IfcWorkControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcWorkPlanTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcWorkPlanTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWorkPlanTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkPlan : IfcWorkControl
	{
		public IfcWorkPlanTypeEnum? PredefinedType { get; set; }
		public IfcWorkPlan() : base()
		{
		}
		public IfcWorkPlan(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcDateTime CreationDate, List<IfcPerson> Creators, IfcLabel Purpose, IfcDuration Duration, IfcDuration TotalFloat, IfcDateTime StartTime, IfcDateTime FinishTime, IfcWorkPlanTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkSchedule
	/// <para>ENTITY IfcWorkSchedule</para>
	/// <para> SUBTYPE OF (IfcWorkControl);</para>
	/// <para>	PredefinedType : OPTIONAL IfcWorkScheduleTypeEnum;</para>
	/// <para> WHERE</para>
	/// <para>	CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcWorkScheduleTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWorkScheduleTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkSchedule : IfcWorkControl
	{
		public IfcWorkScheduleTypeEnum? PredefinedType { get; set; }
		public IfcWorkSchedule() : base()
		{
		}
		public IfcWorkSchedule(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcDateTime CreationDate, List<IfcPerson> Creators, IfcLabel Purpose, IfcDuration Duration, IfcDuration TotalFloat, IfcDateTime StartTime, IfcDateTime FinishTime, IfcWorkScheduleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkTime
	/// <para>ENTITY IfcWorkTime</para>
	/// <para> SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>	RecurrencePattern : OPTIONAL IfcRecurrencePattern;</para>
	/// <para>	Start : OPTIONAL IfcDate;</para>
	/// <para>	Finish : OPTIONAL IfcDate;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkTime : IfcSchedulingTime
	{
		public IfcRecurrencePattern? RecurrencePattern { get; set; }
		public IfcDate? Start { get; set; }
		public IfcDate? Finish { get; set; }
		public IfcWorkTime() : base()
		{
		}
		public IfcWorkTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcRecurrencePattern RecurrencePattern, IfcDate Start, IfcDate Finish) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.RecurrencePattern = RecurrencePattern;
			this.Start = Start;
			this.Finish = Finish;
		}
	}
	/// <summary>
	/// ENTITY IfcZShapeProfileDef
	/// <para>ENTITY IfcZShapeProfileDef</para>
	/// <para> SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>	Depth : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>	WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>	FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>	EdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para> WHERE</para>
	/// <para>	ValidFlangeThickness : FlangeThickness < (Depth / 2.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcZShapeProfileDef : IfcParameterizedProfileDef
	{
		public IfcPositiveLengthMeasure Depth { get; set; }
		public IfcPositiveLengthMeasure FlangeWidth { get; set; }
		public IfcPositiveLengthMeasure WebThickness { get; set; }
		public IfcPositiveLengthMeasure FlangeThickness { get; set; }
		public IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public IfcNonNegativeLengthMeasure? EdgeRadius { get; set; }
		public IfcZShapeProfileDef() : base()
		{
			Depth = new IfcPositiveLengthMeasure();
			FlangeWidth = new IfcPositiveLengthMeasure();
			WebThickness = new IfcPositiveLengthMeasure();
			FlangeThickness = new IfcPositiveLengthMeasure();
		}
		public IfcZShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure FlangeWidth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure EdgeRadius) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.FlangeWidth = FlangeWidth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.EdgeRadius = EdgeRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcZone
	/// <para>ENTITY IfcZone</para>
	/// <para> SUBTYPE OF (IfcSystem);</para>
	/// <para>	LongName : OPTIONAL IfcLabel;</para>
	/// <para> WHERE</para>
	/// <para>	WR1 : (SIZEOF(SELF\IfcGroup.IsGroupedBy) = 0) OR</para>
	/// <para>	(SIZEOF (QUERY (temp <* SELF\IfcGroup.IsGroupedBy[1].RelatedObjects |  </para>
	/// <para>		NOT(('IFC4.IFCZONE' IN TYPEOF(temp)) OR </para>
	/// <para>		('IFC4.IFCSPACE' IN TYPEOF(temp)) OR</para>
	/// <para>		('IFC4.IFCSPATIALZONE' IN TYPEOF(temp))</para>
	/// <para>	))) = 0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcZone : IfcSystem
	{
		public IfcLabel? LongName { get; set; }
		public IfcZone() : base()
		{
		}
		public IfcZone(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.LongName = LongName;
		}
	}
}
