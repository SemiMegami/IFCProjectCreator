using System;
using System.Collections.Generic;
namespace IFC.IFC4x1
{
	/// <summary>
	/// TYPE IfcAbsorbedDoseMeasure = REAL;
	/// <para>TYPE IfcAbsorbedDoseMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAbsorbedDoseMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcAbsorbedDoseMeasure() : base () { }
		public IfcAbsorbedDoseMeasure(double value) : base (value) { }
		public static implicit operator IfcAbsorbedDoseMeasure(double value) { return new IfcAbsorbedDoseMeasure(value);}
		public static implicit operator double(IfcAbsorbedDoseMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAccelerationMeasure = REAL;
	/// <para>TYPE IfcAccelerationMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAccelerationMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcAccelerationMeasure() : base () { }
		public IfcAccelerationMeasure(double value) : base (value) { }
		public static implicit operator IfcAccelerationMeasure(double value) { return new IfcAccelerationMeasure(value);}
		public static implicit operator double(IfcAccelerationMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAmountOfSubstanceMeasure = REAL;
	/// <para>TYPE IfcAmountOfSubstanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAmountOfSubstanceMeasure : REAL, IfcMeasureValue
	{
		public IfcAmountOfSubstanceMeasure() : base () { }
		public IfcAmountOfSubstanceMeasure(double value) : base (value) { }
		public static implicit operator IfcAmountOfSubstanceMeasure(double value) { return new IfcAmountOfSubstanceMeasure(value);}
		public static implicit operator double(IfcAmountOfSubstanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAngularVelocityMeasure = REAL;
	/// <para>TYPE IfcAngularVelocityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAngularVelocityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcAngularVelocityMeasure() : base () { }
		public IfcAngularVelocityMeasure(double value) : base (value) { }
		public static implicit operator IfcAngularVelocityMeasure(double value) { return new IfcAngularVelocityMeasure(value);}
		public static implicit operator double(IfcAngularVelocityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAreaDensityMeasure = REAL;
	/// <para>TYPE IfcAreaDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAreaDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcAreaDensityMeasure() : base () { }
		public IfcAreaDensityMeasure(double value) : base (value) { }
		public static implicit operator IfcAreaDensityMeasure(double value) { return new IfcAreaDensityMeasure(value);}
		public static implicit operator double(IfcAreaDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAreaMeasure = REAL;
	/// <para>TYPE IfcAreaMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAreaMeasure : REAL, IfcMeasureValue
	{
		public IfcAreaMeasure() : base () { }
		public IfcAreaMeasure(double value) : base (value) { }
		public static implicit operator IfcAreaMeasure(double value) { return new IfcAreaMeasure(value);}
		public static implicit operator double(IfcAreaMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBinary = BINARY;
	/// <para>TYPE IfcBinary = BINARY;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBinary : BINARY, IfcSimpleValue
	{
		public IfcBinary() : base () { }
		public IfcBinary(int value) : base (value) { }
		public static implicit operator IfcBinary(int value) { return new IfcBinary(value);}
		public static implicit operator int(IfcBinary value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBoolean = BOOLEAN;
	/// <para>TYPE IfcBoolean = BOOLEAN;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBoolean : BOOLEAN, IfcModulusOfRotationalSubgradeReactionSelect, IfcModulusOfSubgradeReactionSelect, IfcModulusOfTranslationalSubgradeReactionSelect, IfcRotationalStiffnessSelect, IfcSimpleValue, IfcTranslationalStiffnessSelect, IfcWarpingStiffnessSelect
	{
		public IfcBoolean() : base () { }
		public IfcBoolean(bool value) : base (value) { }
		public static implicit operator IfcBoolean(bool value) { return new IfcBoolean(value);}
		public static implicit operator bool(IfcBoolean value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBoxAlignment = IfcLabel;
	/// <para>TYPE IfcBoxAlignment = IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF IN ['top-left', 'top-middle', 'top-right', 'middle-left', 'center', 'middle-right', 'bottom-left', 'bottom-middle', 'bottom-right'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBoxAlignment : IfcLabel
	{
		public IfcBoxAlignment() : base () { }
		public IfcBoxAlignment(string value) : base (value) { }
		public static implicit operator IfcBoxAlignment(string value) { return new IfcBoxAlignment(value);}
		public static implicit operator string(IfcBoxAlignment value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCardinalPointReference = INTEGER;
	/// <para>TYPE IfcCardinalPointReference = INTEGER;</para>
	/// <para>WHERE</para>
	/// <para>GreaterThanZero : SELF > 0;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCardinalPointReference : INTEGER
	{
		public IfcCardinalPointReference() : base () { }
		public IfcCardinalPointReference(int value) : base (value) { }
		public static implicit operator IfcCardinalPointReference(int value) { return new IfcCardinalPointReference(value);}
		public static implicit operator int(IfcCardinalPointReference value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcContextDependentMeasure = REAL;
	/// <para>TYPE IfcContextDependentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcContextDependentMeasure : REAL, IfcMeasureValue
	{
		public IfcContextDependentMeasure() : base () { }
		public IfcContextDependentMeasure(double value) : base (value) { }
		public static implicit operator IfcContextDependentMeasure(double value) { return new IfcContextDependentMeasure(value);}
		public static implicit operator double(IfcContextDependentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCountMeasure = NUMBER;
	/// <para>TYPE IfcCountMeasure = NUMBER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCountMeasure : NUMBER, IfcMeasureValue
	{
		public IfcCountMeasure() : base () { }
		public IfcCountMeasure(double value) : base (value) { }
		public static implicit operator IfcCountMeasure(double value) { return new IfcCountMeasure(value);}
		public static implicit operator double(IfcCountMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCurvatureMeasure = REAL;
	/// <para>TYPE IfcCurvatureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCurvatureMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcCurvatureMeasure() : base () { }
		public IfcCurvatureMeasure(double value) : base (value) { }
		public static implicit operator IfcCurvatureMeasure(double value) { return new IfcCurvatureMeasure(value);}
		public static implicit operator double(IfcCurvatureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDate = STRING;
	/// <para>TYPE IfcDate = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDate : STRING, IfcSimpleValue
	{
		public IfcDate() : base () { }
		public IfcDate(string value) : base (value) { }
		public static implicit operator IfcDate(string value) { return new IfcDate(value);}
		public static implicit operator string(IfcDate value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDateTime = STRING;
	/// <para>TYPE IfcDateTime = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDateTime : STRING, IfcSimpleValue
	{
		public IfcDateTime() : base () { }
		public IfcDateTime(string value) : base (value) { }
		public static implicit operator IfcDateTime(string value) { return new IfcDateTime(value);}
		public static implicit operator string(IfcDateTime value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDayInMonthNumber = INTEGER;
	/// <para>TYPE IfcDayInMonthNumber = INTEGER;</para>
	/// <para>WHERE</para>
	/// <para>ValidRange : {1 <= SELF <= 31};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDayInMonthNumber : INTEGER
	{
		public IfcDayInMonthNumber() : base () { }
		public IfcDayInMonthNumber(int value) : base (value) { }
		public static implicit operator IfcDayInMonthNumber(int value) { return new IfcDayInMonthNumber(value);}
		public static implicit operator int(IfcDayInMonthNumber value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDayInWeekNumber = INTEGER;
	/// <para>TYPE IfcDayInWeekNumber = INTEGER;</para>
	/// <para>WHERE</para>
	/// <para>ValidRange : {1 <= SELF <= 7};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDayInWeekNumber : INTEGER
	{
		public IfcDayInWeekNumber() : base () { }
		public IfcDayInWeekNumber(int value) : base (value) { }
		public static implicit operator IfcDayInWeekNumber(int value) { return new IfcDayInWeekNumber(value);}
		public static implicit operator int(IfcDayInWeekNumber value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDescriptiveMeasure = STRING;
	/// <para>TYPE IfcDescriptiveMeasure = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDescriptiveMeasure : STRING, IfcMeasureValue, IfcSizeSelect
	{
		public IfcDescriptiveMeasure() : base () { }
		public IfcDescriptiveMeasure(string value) : base (value) { }
		public static implicit operator IfcDescriptiveMeasure(string value) { return new IfcDescriptiveMeasure(value);}
		public static implicit operator string(IfcDescriptiveMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDimensionCount = INTEGER;
	/// <para>TYPE IfcDimensionCount = INTEGER;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : { 0 < SELF <= 3 };</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDimensionCount : INTEGER
	{
		public IfcDimensionCount() : base () { }
		public IfcDimensionCount(int value) : base (value) { }
		public static implicit operator IfcDimensionCount(int value) { return new IfcDimensionCount(value);}
		public static implicit operator int(IfcDimensionCount value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoseEquivalentMeasure = REAL;
	/// <para>TYPE IfcDoseEquivalentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoseEquivalentMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcDoseEquivalentMeasure() : base () { }
		public IfcDoseEquivalentMeasure(double value) : base (value) { }
		public static implicit operator IfcDoseEquivalentMeasure(double value) { return new IfcDoseEquivalentMeasure(value);}
		public static implicit operator double(IfcDoseEquivalentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDuration = STRING;
	/// <para>TYPE IfcDuration = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDuration : STRING, IfcSimpleValue, IfcTimeOrRatioSelect
	{
		public IfcDuration() : base () { }
		public IfcDuration(string value) : base (value) { }
		public static implicit operator IfcDuration(string value) { return new IfcDuration(value);}
		public static implicit operator string(IfcDuration value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDynamicViscosityMeasure = REAL;
	/// <para>TYPE IfcDynamicViscosityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDynamicViscosityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcDynamicViscosityMeasure() : base () { }
		public IfcDynamicViscosityMeasure(double value) : base (value) { }
		public static implicit operator IfcDynamicViscosityMeasure(double value) { return new IfcDynamicViscosityMeasure(value);}
		public static implicit operator double(IfcDynamicViscosityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricCapacitanceMeasure = REAL;
	/// <para>TYPE IfcElectricCapacitanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricCapacitanceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcElectricCapacitanceMeasure() : base () { }
		public IfcElectricCapacitanceMeasure(double value) : base (value) { }
		public static implicit operator IfcElectricCapacitanceMeasure(double value) { return new IfcElectricCapacitanceMeasure(value);}
		public static implicit operator double(IfcElectricCapacitanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricChargeMeasure = REAL;
	/// <para>TYPE IfcElectricChargeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricChargeMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcElectricChargeMeasure() : base () { }
		public IfcElectricChargeMeasure(double value) : base (value) { }
		public static implicit operator IfcElectricChargeMeasure(double value) { return new IfcElectricChargeMeasure(value);}
		public static implicit operator double(IfcElectricChargeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricConductanceMeasure = REAL;
	/// <para>TYPE IfcElectricConductanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricConductanceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcElectricConductanceMeasure() : base () { }
		public IfcElectricConductanceMeasure(double value) : base (value) { }
		public static implicit operator IfcElectricConductanceMeasure(double value) { return new IfcElectricConductanceMeasure(value);}
		public static implicit operator double(IfcElectricConductanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricCurrentMeasure = REAL;
	/// <para>TYPE IfcElectricCurrentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricCurrentMeasure : REAL, IfcMeasureValue
	{
		public IfcElectricCurrentMeasure() : base () { }
		public IfcElectricCurrentMeasure(double value) : base (value) { }
		public static implicit operator IfcElectricCurrentMeasure(double value) { return new IfcElectricCurrentMeasure(value);}
		public static implicit operator double(IfcElectricCurrentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricResistanceMeasure = REAL;
	/// <para>TYPE IfcElectricResistanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricResistanceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcElectricResistanceMeasure() : base () { }
		public IfcElectricResistanceMeasure(double value) : base (value) { }
		public static implicit operator IfcElectricResistanceMeasure(double value) { return new IfcElectricResistanceMeasure(value);}
		public static implicit operator double(IfcElectricResistanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricVoltageMeasure = REAL;
	/// <para>TYPE IfcElectricVoltageMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricVoltageMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcElectricVoltageMeasure() : base () { }
		public IfcElectricVoltageMeasure(double value) : base (value) { }
		public static implicit operator IfcElectricVoltageMeasure(double value) { return new IfcElectricVoltageMeasure(value);}
		public static implicit operator double(IfcElectricVoltageMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEnergyMeasure = REAL;
	/// <para>TYPE IfcEnergyMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEnergyMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcEnergyMeasure() : base () { }
		public IfcEnergyMeasure(double value) : base (value) { }
		public static implicit operator IfcEnergyMeasure(double value) { return new IfcEnergyMeasure(value);}
		public static implicit operator double(IfcEnergyMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFontStyle = STRING;
	/// <para>TYPE IfcFontStyle = STRING;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF IN ['normal','italic','oblique'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFontStyle : STRING
	{
		public IfcFontStyle() : base () { }
		public IfcFontStyle(string value) : base (value) { }
		public static implicit operator IfcFontStyle(string value) { return new IfcFontStyle(value);}
		public static implicit operator string(IfcFontStyle value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFontVariant = STRING;
	/// <para>TYPE IfcFontVariant = STRING;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF IN ['normal','small-caps'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFontVariant : STRING
	{
		public IfcFontVariant() : base () { }
		public IfcFontVariant(string value) : base (value) { }
		public static implicit operator IfcFontVariant(string value) { return new IfcFontVariant(value);}
		public static implicit operator string(IfcFontVariant value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFontWeight = STRING;
	/// <para>TYPE IfcFontWeight = STRING;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF IN ['normal','small-caps','100','200','300','400','500','600','700','800','900'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFontWeight : STRING
	{
		public IfcFontWeight() : base () { }
		public IfcFontWeight(string value) : base (value) { }
		public static implicit operator IfcFontWeight(string value) { return new IfcFontWeight(value);}
		public static implicit operator string(IfcFontWeight value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcForceMeasure = REAL;
	/// <para>TYPE IfcForceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcForceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcForceMeasure() : base () { }
		public IfcForceMeasure(double value) : base (value) { }
		public static implicit operator IfcForceMeasure(double value) { return new IfcForceMeasure(value);}
		public static implicit operator double(IfcForceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFrequencyMeasure = REAL;
	/// <para>TYPE IfcFrequencyMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFrequencyMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcFrequencyMeasure() : base () { }
		public IfcFrequencyMeasure(double value) : base (value) { }
		public static implicit operator IfcFrequencyMeasure(double value) { return new IfcFrequencyMeasure(value);}
		public static implicit operator double(IfcFrequencyMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGloballyUniqueId = STRING(22) FIXED;
	/// <para>TYPE IfcGloballyUniqueId = STRING(22) FIXED;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGloballyUniqueId : STRING
	{
		public IfcGloballyUniqueId() : base () { }
		public IfcGloballyUniqueId(string value) : base (value) { }
		public static implicit operator IfcGloballyUniqueId(string value) { return new IfcGloballyUniqueId(value);}
		public static implicit operator string(IfcGloballyUniqueId value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcHeatFluxDensityMeasure = REAL;
	/// <para>TYPE IfcHeatFluxDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcHeatFluxDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcHeatFluxDensityMeasure() : base () { }
		public IfcHeatFluxDensityMeasure(double value) : base (value) { }
		public static implicit operator IfcHeatFluxDensityMeasure(double value) { return new IfcHeatFluxDensityMeasure(value);}
		public static implicit operator double(IfcHeatFluxDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcHeatingValueMeasure = REAL;
	/// <para>TYPE IfcHeatingValueMeasure = REAL;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcHeatingValueMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcHeatingValueMeasure() : base () { }
		public IfcHeatingValueMeasure(double value) : base (value) { }
		public static implicit operator IfcHeatingValueMeasure(double value) { return new IfcHeatingValueMeasure(value);}
		public static implicit operator double(IfcHeatingValueMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIdentifier = STRING(255);
	/// <para>TYPE IfcIdentifier = STRING(255);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIdentifier : STRING, IfcSimpleValue
	{
		public IfcIdentifier() : base () { }
		public IfcIdentifier(string value) : base (value) { }
		public static implicit operator IfcIdentifier(string value) { return new IfcIdentifier(value);}
		public static implicit operator string(IfcIdentifier value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIlluminanceMeasure = REAL;
	/// <para>TYPE IfcIlluminanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIlluminanceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcIlluminanceMeasure() : base () { }
		public IfcIlluminanceMeasure(double value) : base (value) { }
		public static implicit operator IfcIlluminanceMeasure(double value) { return new IfcIlluminanceMeasure(value);}
		public static implicit operator double(IfcIlluminanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInductanceMeasure = REAL;
	/// <para>TYPE IfcInductanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInductanceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcInductanceMeasure() : base () { }
		public IfcInductanceMeasure(double value) : base (value) { }
		public static implicit operator IfcInductanceMeasure(double value) { return new IfcInductanceMeasure(value);}
		public static implicit operator double(IfcInductanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInteger = INTEGER;
	/// <para>TYPE IfcInteger = INTEGER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInteger : INTEGER, IfcSimpleValue
	{
		public IfcInteger() : base () { }
		public IfcInteger(int value) : base (value) { }
		public static implicit operator IfcInteger(int value) { return new IfcInteger(value);}
		public static implicit operator int(IfcInteger value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIntegerCountRateMeasure = INTEGER;
	/// <para>TYPE IfcIntegerCountRateMeasure = INTEGER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIntegerCountRateMeasure : INTEGER, IfcDerivedMeasureValue
	{
		public IfcIntegerCountRateMeasure() : base () { }
		public IfcIntegerCountRateMeasure(int value) : base (value) { }
		public static implicit operator IfcIntegerCountRateMeasure(int value) { return new IfcIntegerCountRateMeasure(value);}
		public static implicit operator int(IfcIntegerCountRateMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIonConcentrationMeasure = REAL;
	/// <para>TYPE IfcIonConcentrationMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIonConcentrationMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcIonConcentrationMeasure() : base () { }
		public IfcIonConcentrationMeasure(double value) : base (value) { }
		public static implicit operator IfcIonConcentrationMeasure(double value) { return new IfcIonConcentrationMeasure(value);}
		public static implicit operator double(IfcIonConcentrationMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcIsothermalMoistureCapacityMeasure = REAL;
	/// <para>TYPE IfcIsothermalMoistureCapacityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcIsothermalMoistureCapacityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcIsothermalMoistureCapacityMeasure() : base () { }
		public IfcIsothermalMoistureCapacityMeasure(double value) : base (value) { }
		public static implicit operator IfcIsothermalMoistureCapacityMeasure(double value) { return new IfcIsothermalMoistureCapacityMeasure(value);}
		public static implicit operator double(IfcIsothermalMoistureCapacityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcKinematicViscosityMeasure = REAL;
	/// <para>TYPE IfcKinematicViscosityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcKinematicViscosityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcKinematicViscosityMeasure() : base () { }
		public IfcKinematicViscosityMeasure(double value) : base (value) { }
		public static implicit operator IfcKinematicViscosityMeasure(double value) { return new IfcKinematicViscosityMeasure(value);}
		public static implicit operator double(IfcKinematicViscosityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLabel = STRING(255);
	/// <para>TYPE IfcLabel = STRING(255);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLabel : STRING, IfcSimpleValue
	{
		public IfcLabel() : base () { }
		public IfcLabel(string value) : base (value) { }
		public static implicit operator IfcLabel(string value) { return new IfcLabel(value);}
		public static implicit operator string(IfcLabel value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLanguageId = IfcIdentifier;
	/// <para>TYPE IfcLanguageId = IfcIdentifier;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLanguageId : IfcIdentifier
	{
		public IfcLanguageId() : base () { }
		public IfcLanguageId(string value) : base (value) { }
		public static implicit operator IfcLanguageId(string value) { return new IfcLanguageId(value);}
		public static implicit operator string(IfcLanguageId value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLengthMeasure = REAL;
	/// <para>TYPE IfcLengthMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLengthMeasure : REAL, IfcBendingParameterSelect, IfcMeasureValue, IfcSizeSelect
	{
		public IfcLengthMeasure() : base () { }
		public IfcLengthMeasure(double value) : base (value) { }
		public static implicit operator IfcLengthMeasure(double value) { return new IfcLengthMeasure(value);}
		public static implicit operator double(IfcLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearForceMeasure = REAL;
	/// <para>TYPE IfcLinearForceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearForceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcLinearForceMeasure() : base () { }
		public IfcLinearForceMeasure(double value) : base (value) { }
		public static implicit operator IfcLinearForceMeasure(double value) { return new IfcLinearForceMeasure(value);}
		public static implicit operator double(IfcLinearForceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearMomentMeasure = REAL;
	/// <para>TYPE IfcLinearMomentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearMomentMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcLinearMomentMeasure() : base () { }
		public IfcLinearMomentMeasure(double value) : base (value) { }
		public static implicit operator IfcLinearMomentMeasure(double value) { return new IfcLinearMomentMeasure(value);}
		public static implicit operator double(IfcLinearMomentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearStiffnessMeasure = REAL;
	/// <para>TYPE IfcLinearStiffnessMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearStiffnessMeasure : REAL, IfcDerivedMeasureValue, IfcTranslationalStiffnessSelect
	{
		public IfcLinearStiffnessMeasure() : base () { }
		public IfcLinearStiffnessMeasure(double value) : base (value) { }
		public static implicit operator IfcLinearStiffnessMeasure(double value) { return new IfcLinearStiffnessMeasure(value);}
		public static implicit operator double(IfcLinearStiffnessMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLinearVelocityMeasure = REAL;
	/// <para>TYPE IfcLinearVelocityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLinearVelocityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcLinearVelocityMeasure() : base () { }
		public IfcLinearVelocityMeasure(double value) : base (value) { }
		public static implicit operator IfcLinearVelocityMeasure(double value) { return new IfcLinearVelocityMeasure(value);}
		public static implicit operator double(IfcLinearVelocityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLogical = LOGICAL;
	/// <para>TYPE IfcLogical = LOGICAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLogical : LOGICAL, IfcSimpleValue
	{
		public IfcLogical() : base () { }
		public IfcLogical(bool value) : base (value) { }
		public static implicit operator IfcLogical(bool value) { return new IfcLogical(value);}
		public static implicit operator bool(IfcLogical value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLuminousFluxMeasure = REAL;
	/// <para>TYPE IfcLuminousFluxMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLuminousFluxMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcLuminousFluxMeasure() : base () { }
		public IfcLuminousFluxMeasure(double value) : base (value) { }
		public static implicit operator IfcLuminousFluxMeasure(double value) { return new IfcLuminousFluxMeasure(value);}
		public static implicit operator double(IfcLuminousFluxMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLuminousIntensityDistributionMeasure = REAL;
	/// <para>TYPE IfcLuminousIntensityDistributionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLuminousIntensityDistributionMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcLuminousIntensityDistributionMeasure() : base () { }
		public IfcLuminousIntensityDistributionMeasure(double value) : base (value) { }
		public static implicit operator IfcLuminousIntensityDistributionMeasure(double value) { return new IfcLuminousIntensityDistributionMeasure(value);}
		public static implicit operator double(IfcLuminousIntensityDistributionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLuminousIntensityMeasure = REAL;
	/// <para>TYPE IfcLuminousIntensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLuminousIntensityMeasure : REAL, IfcMeasureValue
	{
		public IfcLuminousIntensityMeasure() : base () { }
		public IfcLuminousIntensityMeasure(double value) : base (value) { }
		public static implicit operator IfcLuminousIntensityMeasure(double value) { return new IfcLuminousIntensityMeasure(value);}
		public static implicit operator double(IfcLuminousIntensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMagneticFluxDensityMeasure = REAL;
	/// <para>TYPE IfcMagneticFluxDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMagneticFluxDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcMagneticFluxDensityMeasure() : base () { }
		public IfcMagneticFluxDensityMeasure(double value) : base (value) { }
		public static implicit operator IfcMagneticFluxDensityMeasure(double value) { return new IfcMagneticFluxDensityMeasure(value);}
		public static implicit operator double(IfcMagneticFluxDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMagneticFluxMeasure = REAL;
	/// <para>TYPE IfcMagneticFluxMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMagneticFluxMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcMagneticFluxMeasure() : base () { }
		public IfcMagneticFluxMeasure(double value) : base (value) { }
		public static implicit operator IfcMagneticFluxMeasure(double value) { return new IfcMagneticFluxMeasure(value);}
		public static implicit operator double(IfcMagneticFluxMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassDensityMeasure = REAL;
	/// <para>TYPE IfcMassDensityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassDensityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcMassDensityMeasure() : base () { }
		public IfcMassDensityMeasure(double value) : base (value) { }
		public static implicit operator IfcMassDensityMeasure(double value) { return new IfcMassDensityMeasure(value);}
		public static implicit operator double(IfcMassDensityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassFlowRateMeasure = REAL;
	/// <para>TYPE IfcMassFlowRateMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassFlowRateMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcMassFlowRateMeasure() : base () { }
		public IfcMassFlowRateMeasure(double value) : base (value) { }
		public static implicit operator IfcMassFlowRateMeasure(double value) { return new IfcMassFlowRateMeasure(value);}
		public static implicit operator double(IfcMassFlowRateMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassMeasure = REAL;
	/// <para>TYPE IfcMassMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassMeasure : REAL, IfcMeasureValue
	{
		public IfcMassMeasure() : base () { }
		public IfcMassMeasure(double value) : base (value) { }
		public static implicit operator IfcMassMeasure(double value) { return new IfcMassMeasure(value);}
		public static implicit operator double(IfcMassMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMassPerLengthMeasure = REAL;
	/// <para>TYPE IfcMassPerLengthMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMassPerLengthMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcMassPerLengthMeasure() : base () { }
		public IfcMassPerLengthMeasure(double value) : base (value) { }
		public static implicit operator IfcMassPerLengthMeasure(double value) { return new IfcMassPerLengthMeasure(value);}
		public static implicit operator double(IfcMassPerLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfElasticityMeasure = REAL;
	/// <para>TYPE IfcModulusOfElasticityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfElasticityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcModulusOfElasticityMeasure() : base () { }
		public IfcModulusOfElasticityMeasure(double value) : base (value) { }
		public static implicit operator IfcModulusOfElasticityMeasure(double value) { return new IfcModulusOfElasticityMeasure(value);}
		public static implicit operator double(IfcModulusOfElasticityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfLinearSubgradeReactionMeasure = REAL;
	/// <para>TYPE IfcModulusOfLinearSubgradeReactionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfLinearSubgradeReactionMeasure : REAL, IfcDerivedMeasureValue, IfcModulusOfTranslationalSubgradeReactionSelect
	{
		public IfcModulusOfLinearSubgradeReactionMeasure() : base () { }
		public IfcModulusOfLinearSubgradeReactionMeasure(double value) : base (value) { }
		public static implicit operator IfcModulusOfLinearSubgradeReactionMeasure(double value) { return new IfcModulusOfLinearSubgradeReactionMeasure(value);}
		public static implicit operator double(IfcModulusOfLinearSubgradeReactionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfRotationalSubgradeReactionMeasure = REAL;
	/// <para>TYPE IfcModulusOfRotationalSubgradeReactionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfRotationalSubgradeReactionMeasure : REAL, IfcDerivedMeasureValue, IfcModulusOfRotationalSubgradeReactionSelect
	{
		public IfcModulusOfRotationalSubgradeReactionMeasure() : base () { }
		public IfcModulusOfRotationalSubgradeReactionMeasure(double value) : base (value) { }
		public static implicit operator IfcModulusOfRotationalSubgradeReactionMeasure(double value) { return new IfcModulusOfRotationalSubgradeReactionMeasure(value);}
		public static implicit operator double(IfcModulusOfRotationalSubgradeReactionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcModulusOfSubgradeReactionMeasure = REAL;
	/// <para>TYPE IfcModulusOfSubgradeReactionMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcModulusOfSubgradeReactionMeasure : REAL, IfcDerivedMeasureValue, IfcModulusOfSubgradeReactionSelect
	{
		public IfcModulusOfSubgradeReactionMeasure() : base () { }
		public IfcModulusOfSubgradeReactionMeasure(double value) : base (value) { }
		public static implicit operator IfcModulusOfSubgradeReactionMeasure(double value) { return new IfcModulusOfSubgradeReactionMeasure(value);}
		public static implicit operator double(IfcModulusOfSubgradeReactionMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMoistureDiffusivityMeasure = REAL;
	/// <para>TYPE IfcMoistureDiffusivityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMoistureDiffusivityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcMoistureDiffusivityMeasure() : base () { }
		public IfcMoistureDiffusivityMeasure(double value) : base (value) { }
		public static implicit operator IfcMoistureDiffusivityMeasure(double value) { return new IfcMoistureDiffusivityMeasure(value);}
		public static implicit operator double(IfcMoistureDiffusivityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMolecularWeightMeasure = REAL;
	/// <para>TYPE IfcMolecularWeightMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMolecularWeightMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcMolecularWeightMeasure() : base () { }
		public IfcMolecularWeightMeasure(double value) : base (value) { }
		public static implicit operator IfcMolecularWeightMeasure(double value) { return new IfcMolecularWeightMeasure(value);}
		public static implicit operator double(IfcMolecularWeightMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMomentOfInertiaMeasure = REAL;
	/// <para>TYPE IfcMomentOfInertiaMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMomentOfInertiaMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcMomentOfInertiaMeasure() : base () { }
		public IfcMomentOfInertiaMeasure(double value) : base (value) { }
		public static implicit operator IfcMomentOfInertiaMeasure(double value) { return new IfcMomentOfInertiaMeasure(value);}
		public static implicit operator double(IfcMomentOfInertiaMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMonetaryMeasure = REAL;
	/// <para>TYPE IfcMonetaryMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMonetaryMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcMonetaryMeasure() : base () { }
		public IfcMonetaryMeasure(double value) : base (value) { }
		public static implicit operator IfcMonetaryMeasure(double value) { return new IfcMonetaryMeasure(value);}
		public static implicit operator double(IfcMonetaryMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMonthInYearNumber = INTEGER;
	/// <para>TYPE IfcMonthInYearNumber = INTEGER;</para>
	/// <para>WHERE</para>
	/// <para>ValidRange : {1 <= SELF <= 12};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMonthInYearNumber : INTEGER
	{
		public IfcMonthInYearNumber() : base () { }
		public IfcMonthInYearNumber(int value) : base (value) { }
		public static implicit operator IfcMonthInYearNumber(int value) { return new IfcMonthInYearNumber(value);}
		public static implicit operator int(IfcMonthInYearNumber value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNonNegativeLengthMeasure = IfcLengthMeasure;
	/// <para>TYPE IfcNonNegativeLengthMeasure = IfcLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>NotNegative : SELF >= 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNonNegativeLengthMeasure : IfcLengthMeasure, IfcMeasureValue
	{
		public IfcNonNegativeLengthMeasure() : base () { }
		public IfcNonNegativeLengthMeasure(double value) : base (value) { }
		public static implicit operator IfcNonNegativeLengthMeasure(double value) { return new IfcNonNegativeLengthMeasure(value);}
		public static implicit operator double(IfcNonNegativeLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNormalisedRatioMeasure = IfcRatioMeasure;
	/// <para>TYPE IfcNormalisedRatioMeasure = IfcRatioMeasure;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : {0.0 <= SELF <= 1.0};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNormalisedRatioMeasure : IfcRatioMeasure, IfcColourOrFactor, IfcMeasureValue, IfcSizeSelect
	{
		public IfcNormalisedRatioMeasure() : base () { }
		public IfcNormalisedRatioMeasure(double value) : base (value) { }
		public static implicit operator IfcNormalisedRatioMeasure(double value) { return new IfcNormalisedRatioMeasure(value);}
		public static implicit operator double(IfcNormalisedRatioMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNumericMeasure = NUMBER;
	/// <para>TYPE IfcNumericMeasure = NUMBER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNumericMeasure : NUMBER, IfcMeasureValue
	{
		public IfcNumericMeasure() : base () { }
		public IfcNumericMeasure(double value) : base (value) { }
		public static implicit operator IfcNumericMeasure(double value) { return new IfcNumericMeasure(value);}
		public static implicit operator double(IfcNumericMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPHMeasure = REAL;
	/// <para>TYPE IfcPHMeasure = REAL;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : {0.0 <= SELF <= 14.0};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPHMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcPHMeasure() : base () { }
		public IfcPHMeasure(double value) : base (value) { }
		public static implicit operator IfcPHMeasure(double value) { return new IfcPHMeasure(value);}
		public static implicit operator double(IfcPHMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcParameterValue = REAL;
	/// <para>TYPE IfcParameterValue = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcParameterValue : REAL, IfcMeasureValue, IfcTrimmingSelect
	{
		public IfcParameterValue() : base () { }
		public IfcParameterValue(double value) : base (value) { }
		public static implicit operator IfcParameterValue(double value) { return new IfcParameterValue(value);}
		public static implicit operator double(IfcParameterValue value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPlanarForceMeasure = REAL;
	/// <para>TYPE IfcPlanarForceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPlanarForceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcPlanarForceMeasure() : base () { }
		public IfcPlanarForceMeasure(double value) : base (value) { }
		public static implicit operator IfcPlanarForceMeasure(double value) { return new IfcPlanarForceMeasure(value);}
		public static implicit operator double(IfcPlanarForceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPlaneAngleMeasure = REAL;
	/// <para>TYPE IfcPlaneAngleMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPlaneAngleMeasure : REAL, IfcBendingParameterSelect, IfcMeasureValue
	{
		public IfcPlaneAngleMeasure() : base () { }
		public IfcPlaneAngleMeasure(double value) : base (value) { }
		public static implicit operator IfcPlaneAngleMeasure(double value) { return new IfcPlaneAngleMeasure(value);}
		public static implicit operator double(IfcPlaneAngleMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositiveInteger = IfcInteger;
	/// <para>TYPE IfcPositiveInteger = IfcInteger;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF > 0;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositiveInteger : IfcInteger, IfcSimpleValue
	{
		public IfcPositiveInteger() : base () { }
		public IfcPositiveInteger(int value) : base (value) { }
		public static implicit operator IfcPositiveInteger(int value) { return new IfcPositiveInteger(value);}
		public static implicit operator int(IfcPositiveInteger value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositiveLengthMeasure = IfcLengthMeasure;
	/// <para>TYPE IfcPositiveLengthMeasure = IfcLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositiveLengthMeasure : IfcLengthMeasure, IfcHatchLineDistanceSelect, IfcMeasureValue, IfcSizeSelect
	{
		public IfcPositiveLengthMeasure() : base () { }
		public IfcPositiveLengthMeasure(double value) : base (value) { }
		public static implicit operator IfcPositiveLengthMeasure(double value) { return new IfcPositiveLengthMeasure(value);}
		public static implicit operator double(IfcPositiveLengthMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositivePlaneAngleMeasure = IfcPlaneAngleMeasure;
	/// <para>TYPE IfcPositivePlaneAngleMeasure = IfcPlaneAngleMeasure;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositivePlaneAngleMeasure : IfcPlaneAngleMeasure, IfcMeasureValue
	{
		public IfcPositivePlaneAngleMeasure() : base () { }
		public IfcPositivePlaneAngleMeasure(double value) : base (value) { }
		public static implicit operator IfcPositivePlaneAngleMeasure(double value) { return new IfcPositivePlaneAngleMeasure(value);}
		public static implicit operator double(IfcPositivePlaneAngleMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPositiveRatioMeasure = IfcRatioMeasure;
	/// <para>TYPE IfcPositiveRatioMeasure = IfcRatioMeasure;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF > 0.;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPositiveRatioMeasure : IfcRatioMeasure, IfcMeasureValue, IfcSizeSelect
	{
		public IfcPositiveRatioMeasure() : base () { }
		public IfcPositiveRatioMeasure(double value) : base (value) { }
		public static implicit operator IfcPositiveRatioMeasure(double value) { return new IfcPositiveRatioMeasure(value);}
		public static implicit operator double(IfcPositiveRatioMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPowerMeasure = REAL;
	/// <para>TYPE IfcPowerMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPowerMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcPowerMeasure() : base () { }
		public IfcPowerMeasure(double value) : base (value) { }
		public static implicit operator IfcPowerMeasure(double value) { return new IfcPowerMeasure(value);}
		public static implicit operator double(IfcPowerMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPresentableText = STRING;
	/// <para>TYPE IfcPresentableText = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPresentableText : STRING
	{
		public IfcPresentableText() : base () { }
		public IfcPresentableText(string value) : base (value) { }
		public static implicit operator IfcPresentableText(string value) { return new IfcPresentableText(value);}
		public static implicit operator string(IfcPresentableText value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPressureMeasure = REAL;
	/// <para>TYPE IfcPressureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPressureMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcPressureMeasure() : base () { }
		public IfcPressureMeasure(double value) : base (value) { }
		public static implicit operator IfcPressureMeasure(double value) { return new IfcPressureMeasure(value);}
		public static implicit operator double(IfcPressureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRadioActivityMeasure = REAL;
	/// <para>TYPE IfcRadioActivityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRadioActivityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcRadioActivityMeasure() : base () { }
		public IfcRadioActivityMeasure(double value) : base (value) { }
		public static implicit operator IfcRadioActivityMeasure(double value) { return new IfcRadioActivityMeasure(value);}
		public static implicit operator double(IfcRadioActivityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRatioMeasure = REAL;
	/// <para>TYPE IfcRatioMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRatioMeasure : REAL, IfcMeasureValue, IfcSizeSelect, IfcTimeOrRatioSelect
	{
		public IfcRatioMeasure() : base () { }
		public IfcRatioMeasure(double value) : base (value) { }
		public static implicit operator IfcRatioMeasure(double value) { return new IfcRatioMeasure(value);}
		public static implicit operator double(IfcRatioMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReal = REAL;
	/// <para>TYPE IfcReal = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReal : REAL, IfcSimpleValue
	{
		public IfcReal() : base () { }
		public IfcReal(double value) : base (value) { }
		public static implicit operator IfcReal(double value) { return new IfcReal(value);}
		public static implicit operator double(IfcReal value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRotationalFrequencyMeasure = REAL;
	/// <para>TYPE IfcRotationalFrequencyMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRotationalFrequencyMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcRotationalFrequencyMeasure() : base () { }
		public IfcRotationalFrequencyMeasure(double value) : base (value) { }
		public static implicit operator IfcRotationalFrequencyMeasure(double value) { return new IfcRotationalFrequencyMeasure(value);}
		public static implicit operator double(IfcRotationalFrequencyMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRotationalMassMeasure = REAL;
	/// <para>TYPE IfcRotationalMassMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRotationalMassMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcRotationalMassMeasure() : base () { }
		public IfcRotationalMassMeasure(double value) : base (value) { }
		public static implicit operator IfcRotationalMassMeasure(double value) { return new IfcRotationalMassMeasure(value);}
		public static implicit operator double(IfcRotationalMassMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRotationalStiffnessMeasure = REAL;
	/// <para>TYPE IfcRotationalStiffnessMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRotationalStiffnessMeasure : REAL, IfcDerivedMeasureValue, IfcRotationalStiffnessSelect
	{
		public IfcRotationalStiffnessMeasure() : base () { }
		public IfcRotationalStiffnessMeasure(double value) : base (value) { }
		public static implicit operator IfcRotationalStiffnessMeasure(double value) { return new IfcRotationalStiffnessMeasure(value);}
		public static implicit operator double(IfcRotationalStiffnessMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSectionModulusMeasure = REAL;
	/// <para>TYPE IfcSectionModulusMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSectionModulusMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcSectionModulusMeasure() : base () { }
		public IfcSectionModulusMeasure(double value) : base (value) { }
		public static implicit operator IfcSectionModulusMeasure(double value) { return new IfcSectionModulusMeasure(value);}
		public static implicit operator double(IfcSectionModulusMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSectionalAreaIntegralMeasure = REAL;
	/// <para>TYPE IfcSectionalAreaIntegralMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSectionalAreaIntegralMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcSectionalAreaIntegralMeasure() : base () { }
		public IfcSectionalAreaIntegralMeasure(double value) : base (value) { }
		public static implicit operator IfcSectionalAreaIntegralMeasure(double value) { return new IfcSectionalAreaIntegralMeasure(value);}
		public static implicit operator double(IfcSectionalAreaIntegralMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcShearModulusMeasure = REAL;
	/// <para>TYPE IfcShearModulusMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcShearModulusMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcShearModulusMeasure() : base () { }
		public IfcShearModulusMeasure(double value) : base (value) { }
		public static implicit operator IfcShearModulusMeasure(double value) { return new IfcShearModulusMeasure(value);}
		public static implicit operator double(IfcShearModulusMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSolidAngleMeasure = REAL;
	/// <para>TYPE IfcSolidAngleMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSolidAngleMeasure : REAL, IfcMeasureValue
	{
		public IfcSolidAngleMeasure() : base () { }
		public IfcSolidAngleMeasure(double value) : base (value) { }
		public static implicit operator IfcSolidAngleMeasure(double value) { return new IfcSolidAngleMeasure(value);}
		public static implicit operator double(IfcSolidAngleMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPowerLevelMeasure = REAL;
	/// <para>TYPE IfcSoundPowerLevelMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPowerLevelMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcSoundPowerLevelMeasure() : base () { }
		public IfcSoundPowerLevelMeasure(double value) : base (value) { }
		public static implicit operator IfcSoundPowerLevelMeasure(double value) { return new IfcSoundPowerLevelMeasure(value);}
		public static implicit operator double(IfcSoundPowerLevelMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPowerMeasure = REAL;
	/// <para>TYPE IfcSoundPowerMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPowerMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcSoundPowerMeasure() : base () { }
		public IfcSoundPowerMeasure(double value) : base (value) { }
		public static implicit operator IfcSoundPowerMeasure(double value) { return new IfcSoundPowerMeasure(value);}
		public static implicit operator double(IfcSoundPowerMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPressureLevelMeasure = REAL;
	/// <para>TYPE IfcSoundPressureLevelMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPressureLevelMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcSoundPressureLevelMeasure() : base () { }
		public IfcSoundPressureLevelMeasure(double value) : base (value) { }
		public static implicit operator IfcSoundPressureLevelMeasure(double value) { return new IfcSoundPressureLevelMeasure(value);}
		public static implicit operator double(IfcSoundPressureLevelMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSoundPressureMeasure = REAL;
	/// <para>TYPE IfcSoundPressureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSoundPressureMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcSoundPressureMeasure() : base () { }
		public IfcSoundPressureMeasure(double value) : base (value) { }
		public static implicit operator IfcSoundPressureMeasure(double value) { return new IfcSoundPressureMeasure(value);}
		public static implicit operator double(IfcSoundPressureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpecificHeatCapacityMeasure = REAL;
	/// <para>TYPE IfcSpecificHeatCapacityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpecificHeatCapacityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcSpecificHeatCapacityMeasure() : base () { }
		public IfcSpecificHeatCapacityMeasure(double value) : base (value) { }
		public static implicit operator IfcSpecificHeatCapacityMeasure(double value) { return new IfcSpecificHeatCapacityMeasure(value);}
		public static implicit operator double(IfcSpecificHeatCapacityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpecularExponent = REAL;
	/// <para>TYPE IfcSpecularExponent = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpecularExponent : REAL, IfcSpecularHighlightSelect
	{
		public IfcSpecularExponent() : base () { }
		public IfcSpecularExponent(double value) : base (value) { }
		public static implicit operator IfcSpecularExponent(double value) { return new IfcSpecularExponent(value);}
		public static implicit operator double(IfcSpecularExponent value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpecularRoughness = REAL;
	/// <para>TYPE IfcSpecularRoughness = REAL;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : {0.0 <= SELF <= 1.0};</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpecularRoughness : REAL, IfcSpecularHighlightSelect
	{
		public IfcSpecularRoughness() : base () { }
		public IfcSpecularRoughness(double value) : base (value) { }
		public static implicit operator IfcSpecularRoughness(double value) { return new IfcSpecularRoughness(value);}
		public static implicit operator double(IfcSpecularRoughness value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTemperatureGradientMeasure = REAL;
	/// <para>TYPE IfcTemperatureGradientMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTemperatureGradientMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcTemperatureGradientMeasure() : base () { }
		public IfcTemperatureGradientMeasure(double value) : base (value) { }
		public static implicit operator IfcTemperatureGradientMeasure(double value) { return new IfcTemperatureGradientMeasure(value);}
		public static implicit operator double(IfcTemperatureGradientMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTemperatureRateOfChangeMeasure = REAL;
	/// <para>TYPE IfcTemperatureRateOfChangeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTemperatureRateOfChangeMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcTemperatureRateOfChangeMeasure() : base () { }
		public IfcTemperatureRateOfChangeMeasure(double value) : base (value) { }
		public static implicit operator IfcTemperatureRateOfChangeMeasure(double value) { return new IfcTemperatureRateOfChangeMeasure(value);}
		public static implicit operator double(IfcTemperatureRateOfChangeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcText = STRING;
	/// <para>TYPE IfcText = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcText : STRING, IfcSimpleValue
	{
		public IfcText() : base () { }
		public IfcText(string value) : base (value) { }
		public static implicit operator IfcText(string value) { return new IfcText(value);}
		public static implicit operator string(IfcText value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextAlignment = STRING;
	/// <para>TYPE IfcTextAlignment = STRING;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF IN ['left', 'right', 'center', 'justify'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextAlignment : STRING
	{
		public IfcTextAlignment() : base () { }
		public IfcTextAlignment(string value) : base (value) { }
		public static implicit operator IfcTextAlignment(string value) { return new IfcTextAlignment(value);}
		public static implicit operator string(IfcTextAlignment value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextDecoration = STRING;
	/// <para>TYPE IfcTextDecoration = STRING;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF IN ['none', 'underline', 'overline', 'line-through', 'blink'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextDecoration : STRING
	{
		public IfcTextDecoration() : base () { }
		public IfcTextDecoration(string value) : base (value) { }
		public static implicit operator IfcTextDecoration(string value) { return new IfcTextDecoration(value);}
		public static implicit operator string(IfcTextDecoration value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextFontName = STRING;
	/// <para>TYPE IfcTextFontName = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextFontName : STRING
	{
		public IfcTextFontName() : base () { }
		public IfcTextFontName(string value) : base (value) { }
		public static implicit operator IfcTextFontName(string value) { return new IfcTextFontName(value);}
		public static implicit operator string(IfcTextFontName value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextTransformation = STRING;
	/// <para>TYPE IfcTextTransformation = STRING;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF IN ['capitalize', 'uppercase', 'lowercase', 'none'];</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextTransformation : STRING
	{
		public IfcTextTransformation() : base () { }
		public IfcTextTransformation(string value) : base (value) { }
		public static implicit operator IfcTextTransformation(string value) { return new IfcTextTransformation(value);}
		public static implicit operator string(IfcTextTransformation value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalAdmittanceMeasure = REAL;
	/// <para>TYPE IfcThermalAdmittanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalAdmittanceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcThermalAdmittanceMeasure() : base () { }
		public IfcThermalAdmittanceMeasure(double value) : base (value) { }
		public static implicit operator IfcThermalAdmittanceMeasure(double value) { return new IfcThermalAdmittanceMeasure(value);}
		public static implicit operator double(IfcThermalAdmittanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalConductivityMeasure = REAL;
	/// <para>TYPE IfcThermalConductivityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalConductivityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcThermalConductivityMeasure() : base () { }
		public IfcThermalConductivityMeasure(double value) : base (value) { }
		public static implicit operator IfcThermalConductivityMeasure(double value) { return new IfcThermalConductivityMeasure(value);}
		public static implicit operator double(IfcThermalConductivityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalExpansionCoefficientMeasure = REAL;
	/// <para>TYPE IfcThermalExpansionCoefficientMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalExpansionCoefficientMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcThermalExpansionCoefficientMeasure() : base () { }
		public IfcThermalExpansionCoefficientMeasure(double value) : base (value) { }
		public static implicit operator IfcThermalExpansionCoefficientMeasure(double value) { return new IfcThermalExpansionCoefficientMeasure(value);}
		public static implicit operator double(IfcThermalExpansionCoefficientMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalResistanceMeasure = REAL;
	/// <para>TYPE IfcThermalResistanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalResistanceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcThermalResistanceMeasure() : base () { }
		public IfcThermalResistanceMeasure(double value) : base (value) { }
		public static implicit operator IfcThermalResistanceMeasure(double value) { return new IfcThermalResistanceMeasure(value);}
		public static implicit operator double(IfcThermalResistanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermalTransmittanceMeasure = REAL;
	/// <para>TYPE IfcThermalTransmittanceMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermalTransmittanceMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcThermalTransmittanceMeasure() : base () { }
		public IfcThermalTransmittanceMeasure(double value) : base (value) { }
		public static implicit operator IfcThermalTransmittanceMeasure(double value) { return new IfcThermalTransmittanceMeasure(value);}
		public static implicit operator double(IfcThermalTransmittanceMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcThermodynamicTemperatureMeasure = REAL;
	/// <para>TYPE IfcThermodynamicTemperatureMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcThermodynamicTemperatureMeasure : REAL, IfcMeasureValue
	{
		public IfcThermodynamicTemperatureMeasure() : base () { }
		public IfcThermodynamicTemperatureMeasure(double value) : base (value) { }
		public static implicit operator IfcThermodynamicTemperatureMeasure(double value) { return new IfcThermodynamicTemperatureMeasure(value);}
		public static implicit operator double(IfcThermodynamicTemperatureMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTime = STRING;
	/// <para>TYPE IfcTime = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTime : STRING, IfcSimpleValue
	{
		public IfcTime() : base () { }
		public IfcTime(string value) : base (value) { }
		public static implicit operator IfcTime(string value) { return new IfcTime(value);}
		public static implicit operator string(IfcTime value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTimeMeasure = REAL;
	/// <para>TYPE IfcTimeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTimeMeasure : REAL, IfcMeasureValue
	{
		public IfcTimeMeasure() : base () { }
		public IfcTimeMeasure(double value) : base (value) { }
		public static implicit operator IfcTimeMeasure(double value) { return new IfcTimeMeasure(value);}
		public static implicit operator double(IfcTimeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTimeStamp = INTEGER;
	/// <para>TYPE IfcTimeStamp = INTEGER;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTimeStamp : INTEGER, IfcSimpleValue
	{
		public IfcTimeStamp() : base () { }
		public IfcTimeStamp(int value) : base (value) { }
		public static implicit operator IfcTimeStamp(int value) { return new IfcTimeStamp(value);}
		public static implicit operator int(IfcTimeStamp value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTorqueMeasure = REAL;
	/// <para>TYPE IfcTorqueMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTorqueMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcTorqueMeasure() : base () { }
		public IfcTorqueMeasure(double value) : base (value) { }
		public static implicit operator IfcTorqueMeasure(double value) { return new IfcTorqueMeasure(value);}
		public static implicit operator double(IfcTorqueMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcURIReference = STRING;
	/// <para>TYPE IfcURIReference = STRING;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcURIReference : STRING
	{
		public IfcURIReference() : base () { }
		public IfcURIReference(string value) : base (value) { }
		public static implicit operator IfcURIReference(string value) { return new IfcURIReference(value);}
		public static implicit operator string(IfcURIReference value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVaporPermeabilityMeasure = REAL;
	/// <para>TYPE IfcVaporPermeabilityMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVaporPermeabilityMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcVaporPermeabilityMeasure() : base () { }
		public IfcVaporPermeabilityMeasure(double value) : base (value) { }
		public static implicit operator IfcVaporPermeabilityMeasure(double value) { return new IfcVaporPermeabilityMeasure(value);}
		public static implicit operator double(IfcVaporPermeabilityMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVolumeMeasure = REAL;
	/// <para>TYPE IfcVolumeMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVolumeMeasure : REAL, IfcMeasureValue
	{
		public IfcVolumeMeasure() : base () { }
		public IfcVolumeMeasure(double value) : base (value) { }
		public static implicit operator IfcVolumeMeasure(double value) { return new IfcVolumeMeasure(value);}
		public static implicit operator double(IfcVolumeMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVolumetricFlowRateMeasure = REAL;
	/// <para>TYPE IfcVolumetricFlowRateMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVolumetricFlowRateMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcVolumetricFlowRateMeasure() : base () { }
		public IfcVolumetricFlowRateMeasure(double value) : base (value) { }
		public static implicit operator IfcVolumetricFlowRateMeasure(double value) { return new IfcVolumetricFlowRateMeasure(value);}
		public static implicit operator double(IfcVolumetricFlowRateMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWarpingConstantMeasure = REAL;
	/// <para>TYPE IfcWarpingConstantMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWarpingConstantMeasure : REAL, IfcDerivedMeasureValue
	{
		public IfcWarpingConstantMeasure() : base () { }
		public IfcWarpingConstantMeasure(double value) : base (value) { }
		public static implicit operator IfcWarpingConstantMeasure(double value) { return new IfcWarpingConstantMeasure(value);}
		public static implicit operator double(IfcWarpingConstantMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWarpingMomentMeasure = REAL;
	/// <para>TYPE IfcWarpingMomentMeasure = REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWarpingMomentMeasure : REAL, IfcDerivedMeasureValue, IfcWarpingStiffnessSelect
	{
		public IfcWarpingMomentMeasure() : base () { }
		public IfcWarpingMomentMeasure(double value) : base (value) { }
		public static implicit operator IfcWarpingMomentMeasure(double value) { return new IfcWarpingMomentMeasure(value);}
		public static implicit operator double(IfcWarpingMomentMeasure value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcArcIndex = LIST [3:3] OF IfcPositiveInteger;
	/// <para>TYPE IfcArcIndex = LIST [3:3] OF IfcPositiveInteger;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcArcIndex : List < IfcPositiveInteger>
	{
	}
	/// <summary>
	/// TYPE IfcComplexNumber = ARRAY [1:2] OF REAL;
	/// <para>TYPE IfcComplexNumber = ARRAY [1:2] OF REAL;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcComplexNumber : List < REAL>
	{
	}
	/// <summary>
	/// TYPE IfcCompoundPlaneAngleMeasure = LIST [3:4] OF INTEGER;
	/// <para>TYPE IfcCompoundPlaneAngleMeasure = LIST [3:4] OF INTEGER;</para>
	/// <para>WHERE</para>
	/// <para>MinutesInRange : ABS(SELF[2]) < 60;</para>
	/// <para>SecondsInRange : ABS(SELF[3]) < 60;</para>
	/// <para>MicrosecondsInRange : (SIZEOF(SELF) = 3) OR (ABS(SELF[4]) < 1000000);</para>
	/// <para>ConsistentSign : ((SELF[1] >= 0) AND (SELF[2] >= 0) AND (SELF[3] >= 0) AND ((SIZEOF(SELF) = 3) OR (SELF[4] >= 0)))</para>
	/// <para>OR</para>
	/// <para>((SELF[1] <= 0) AND (SELF[2] <= 0) AND (SELF[3] <= 0) AND ((SIZEOF(SELF) = 3) OR (SELF[4] <= 0)));</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCompoundPlaneAngleMeasure : List < INTEGER>
	{
	}
	/// <summary>
	/// TYPE IfcLineIndex = LIST [2:?] OF IfcPositiveInteger;
	/// <para>TYPE IfcLineIndex = LIST [2:?] OF IfcPositiveInteger;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLineIndex : List < IfcPositiveInteger>
	{
	}
	/// <summary>
	/// TYPE IfcPropertySetDefinitionSet = SET [1:?] OF IfcPropertySetDefinition;
	/// <para>TYPE IfcPropertySetDefinitionSet = SET [1:?] OF IfcPropertySetDefinition;</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPropertySetDefinitionSet : List < IfcPropertySetDefinition>
	{
	}
	/// <summary>
	/// TYPE IfcActionRequestTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcActionRequestTypeEnum = ENUMERATION OF</para>
	/// <para>(EMAIL</para>
	/// <para>,FAX</para>
	/// <para>,PHONE</para>
	/// <para>,POST</para>
	/// <para>,VERBAL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcActionRequestTypeEnum
	{
		public static string EMAIL { get {return ".EMAIL.";} }
		public static string FAX { get {return ".FAX.";} }
		public static string PHONE { get {return ".PHONE.";} }
		public static string POST { get {return ".POST.";} }
		public static string VERBAL { get {return ".VERBAL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcActionRequestTypeEnum() { Value = ".EMAIL.";}
		public IfcActionRequestTypeEnum(string value) { Value = value; }
		public static implicit operator IfcActionRequestTypeEnum(string value) { return new IfcActionRequestTypeEnum(value);}
		public static implicit operator string(IfcActionRequestTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcActionSourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcActionSourceTypeEnum = ENUMERATION OF</para>
	/// <para>(DEAD_LOAD_G</para>
	/// <para>,COMPLETION_G1</para>
	/// <para>,LIVE_LOAD_Q</para>
	/// <para>,SNOW_S</para>
	/// <para>,WIND_W</para>
	/// <para>,PRESTRESSING_P</para>
	/// <para>,SETTLEMENT_U</para>
	/// <para>,TEMPERATURE_T</para>
	/// <para>,EARTHQUAKE_E</para>
	/// <para>,FIRE</para>
	/// <para>,IMPULSE</para>
	/// <para>,IMPACT</para>
	/// <para>,TRANSPORT</para>
	/// <para>,ERECTION</para>
	/// <para>,PROPPING</para>
	/// <para>,SYSTEM_IMPERFECTION</para>
	/// <para>,SHRINKAGE</para>
	/// <para>,CREEP</para>
	/// <para>,LACK_OF_FIT</para>
	/// <para>,BUOYANCY</para>
	/// <para>,ICE</para>
	/// <para>,CURRENT</para>
	/// <para>,WAVE</para>
	/// <para>,RAIN</para>
	/// <para>,BRAKES</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcActionSourceTypeEnum
	{
		public static string DEAD_LOAD_G { get {return ".DEAD_LOAD_G.";} }
		public static string COMPLETION_G1 { get {return ".COMPLETION_G1.";} }
		public static string LIVE_LOAD_Q { get {return ".LIVE_LOAD_Q.";} }
		public static string SNOW_S { get {return ".SNOW_S.";} }
		public static string WIND_W { get {return ".WIND_W.";} }
		public static string PRESTRESSING_P { get {return ".PRESTRESSING_P.";} }
		public static string SETTLEMENT_U { get {return ".SETTLEMENT_U.";} }
		public static string TEMPERATURE_T { get {return ".TEMPERATURE_T.";} }
		public static string EARTHQUAKE_E { get {return ".EARTHQUAKE_E.";} }
		public static string FIRE { get {return ".FIRE.";} }
		public static string IMPULSE { get {return ".IMPULSE.";} }
		public static string IMPACT { get {return ".IMPACT.";} }
		public static string TRANSPORT { get {return ".TRANSPORT.";} }
		public static string ERECTION { get {return ".ERECTION.";} }
		public static string PROPPING { get {return ".PROPPING.";} }
		public static string SYSTEM_IMPERFECTION { get {return ".SYSTEM_IMPERFECTION.";} }
		public static string SHRINKAGE { get {return ".SHRINKAGE.";} }
		public static string CREEP { get {return ".CREEP.";} }
		public static string LACK_OF_FIT { get {return ".LACK_OF_FIT.";} }
		public static string BUOYANCY { get {return ".BUOYANCY.";} }
		public static string ICE { get {return ".ICE.";} }
		public static string CURRENT { get {return ".CURRENT.";} }
		public static string WAVE { get {return ".WAVE.";} }
		public static string RAIN { get {return ".RAIN.";} }
		public static string BRAKES { get {return ".BRAKES.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcActionSourceTypeEnum() { Value = ".DEAD_LOAD_G.";}
		public IfcActionSourceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcActionSourceTypeEnum(string value) { return new IfcActionSourceTypeEnum(value);}
		public static implicit operator string(IfcActionSourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcActionTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcActionTypeEnum = ENUMERATION OF</para>
	/// <para>(PERMANENT_G</para>
	/// <para>,VARIABLE_Q</para>
	/// <para>,EXTRAORDINARY_A</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcActionTypeEnum
	{
		public static string PERMANENT_G { get {return ".PERMANENT_G.";} }
		public static string VARIABLE_Q { get {return ".VARIABLE_Q.";} }
		public static string EXTRAORDINARY_A { get {return ".EXTRAORDINARY_A.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcActionTypeEnum() { Value = ".PERMANENT_G.";}
		public IfcActionTypeEnum(string value) { Value = value; }
		public static implicit operator IfcActionTypeEnum(string value) { return new IfcActionTypeEnum(value);}
		public static implicit operator string(IfcActionTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcActuatorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcActuatorTypeEnum = ENUMERATION OF</para>
	/// <para>(ELECTRICACTUATOR</para>
	/// <para>,HANDOPERATEDACTUATOR</para>
	/// <para>,HYDRAULICACTUATOR</para>
	/// <para>,PNEUMATICACTUATOR</para>
	/// <para>,THERMOSTATICACTUATOR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcActuatorTypeEnum
	{
		public static string ELECTRICACTUATOR { get {return ".ELECTRICACTUATOR.";} }
		public static string HANDOPERATEDACTUATOR { get {return ".HANDOPERATEDACTUATOR.";} }
		public static string HYDRAULICACTUATOR { get {return ".HYDRAULICACTUATOR.";} }
		public static string PNEUMATICACTUATOR { get {return ".PNEUMATICACTUATOR.";} }
		public static string THERMOSTATICACTUATOR { get {return ".THERMOSTATICACTUATOR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcActuatorTypeEnum() { Value = ".ELECTRICACTUATOR.";}
		public IfcActuatorTypeEnum(string value) { Value = value; }
		public static implicit operator IfcActuatorTypeEnum(string value) { return new IfcActuatorTypeEnum(value);}
		public static implicit operator string(IfcActuatorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAddressTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAddressTypeEnum = ENUMERATION OF</para>
	/// <para>(OFFICE</para>
	/// <para>,SITE</para>
	/// <para>,HOME</para>
	/// <para>,DISTRIBUTIONPOINT</para>
	/// <para>,USERDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAddressTypeEnum
	{
		public static string OFFICE { get {return ".OFFICE.";} }
		public static string SITE { get {return ".SITE.";} }
		public static string HOME { get {return ".HOME.";} }
		public static string DISTRIBUTIONPOINT { get {return ".DISTRIBUTIONPOINT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public string Value;
		public IfcAddressTypeEnum() { Value = ".OFFICE.";}
		public IfcAddressTypeEnum(string value) { Value = value; }
		public static implicit operator IfcAddressTypeEnum(string value) { return new IfcAddressTypeEnum(value);}
		public static implicit operator string(IfcAddressTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAirTerminalBoxTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAirTerminalBoxTypeEnum = ENUMERATION OF</para>
	/// <para>(CONSTANTFLOW</para>
	/// <para>,VARIABLEFLOWPRESSUREDEPENDANT</para>
	/// <para>,VARIABLEFLOWPRESSUREINDEPENDANT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAirTerminalBoxTypeEnum
	{
		public static string CONSTANTFLOW { get {return ".CONSTANTFLOW.";} }
		public static string VARIABLEFLOWPRESSUREDEPENDANT { get {return ".VARIABLEFLOWPRESSUREDEPENDANT.";} }
		public static string VARIABLEFLOWPRESSUREINDEPENDANT { get {return ".VARIABLEFLOWPRESSUREINDEPENDANT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcAirTerminalBoxTypeEnum() { Value = ".CONSTANTFLOW.";}
		public IfcAirTerminalBoxTypeEnum(string value) { Value = value; }
		public static implicit operator IfcAirTerminalBoxTypeEnum(string value) { return new IfcAirTerminalBoxTypeEnum(value);}
		public static implicit operator string(IfcAirTerminalBoxTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAirTerminalTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAirTerminalTypeEnum = ENUMERATION OF</para>
	/// <para>(DIFFUSER</para>
	/// <para>,GRILLE</para>
	/// <para>,LOUVRE</para>
	/// <para>,REGISTER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAirTerminalTypeEnum
	{
		public static string DIFFUSER { get {return ".DIFFUSER.";} }
		public static string GRILLE { get {return ".GRILLE.";} }
		public static string LOUVRE { get {return ".LOUVRE.";} }
		public static string REGISTER { get {return ".REGISTER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcAirTerminalTypeEnum() { Value = ".DIFFUSER.";}
		public IfcAirTerminalTypeEnum(string value) { Value = value; }
		public static implicit operator IfcAirTerminalTypeEnum(string value) { return new IfcAirTerminalTypeEnum(value);}
		public static implicit operator string(IfcAirTerminalTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAirToAirHeatRecoveryTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAirToAirHeatRecoveryTypeEnum = ENUMERATION OF</para>
	/// <para>(FIXEDPLATECOUNTERFLOWEXCHANGER</para>
	/// <para>,FIXEDPLATECROSSFLOWEXCHANGER</para>
	/// <para>,FIXEDPLATEPARALLELFLOWEXCHANGER</para>
	/// <para>,ROTARYWHEEL</para>
	/// <para>,RUNAROUNDCOILLOOP</para>
	/// <para>,HEATPIPE</para>
	/// <para>,TWINTOWERENTHALPYRECOVERYLOOPS</para>
	/// <para>,THERMOSIPHONSEALEDTUBEHEATEXCHANGERS</para>
	/// <para>,THERMOSIPHONCOILTYPEHEATEXCHANGERS</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAirToAirHeatRecoveryTypeEnum
	{
		public static string FIXEDPLATECOUNTERFLOWEXCHANGER { get {return ".FIXEDPLATECOUNTERFLOWEXCHANGER.";} }
		public static string FIXEDPLATECROSSFLOWEXCHANGER { get {return ".FIXEDPLATECROSSFLOWEXCHANGER.";} }
		public static string FIXEDPLATEPARALLELFLOWEXCHANGER { get {return ".FIXEDPLATEPARALLELFLOWEXCHANGER.";} }
		public static string ROTARYWHEEL { get {return ".ROTARYWHEEL.";} }
		public static string RUNAROUNDCOILLOOP { get {return ".RUNAROUNDCOILLOOP.";} }
		public static string HEATPIPE { get {return ".HEATPIPE.";} }
		public static string TWINTOWERENTHALPYRECOVERYLOOPS { get {return ".TWINTOWERENTHALPYRECOVERYLOOPS.";} }
		public static string THERMOSIPHONSEALEDTUBEHEATEXCHANGERS { get {return ".THERMOSIPHONSEALEDTUBEHEATEXCHANGERS.";} }
		public static string THERMOSIPHONCOILTYPEHEATEXCHANGERS { get {return ".THERMOSIPHONCOILTYPEHEATEXCHANGERS.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcAirToAirHeatRecoveryTypeEnum() { Value = ".FIXEDPLATECOUNTERFLOWEXCHANGER.";}
		public IfcAirToAirHeatRecoveryTypeEnum(string value) { Value = value; }
		public static implicit operator IfcAirToAirHeatRecoveryTypeEnum(string value) { return new IfcAirToAirHeatRecoveryTypeEnum(value);}
		public static implicit operator string(IfcAirToAirHeatRecoveryTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAlarmTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAlarmTypeEnum = ENUMERATION OF</para>
	/// <para>(BELL</para>
	/// <para>,BREAKGLASSBUTTON</para>
	/// <para>,LIGHT</para>
	/// <para>,MANUALPULLBOX</para>
	/// <para>,SIREN</para>
	/// <para>,WHISTLE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAlarmTypeEnum
	{
		public static string BELL { get {return ".BELL.";} }
		public static string BREAKGLASSBUTTON { get {return ".BREAKGLASSBUTTON.";} }
		public static string LIGHT { get {return ".LIGHT.";} }
		public static string MANUALPULLBOX { get {return ".MANUALPULLBOX.";} }
		public static string SIREN { get {return ".SIREN.";} }
		public static string WHISTLE { get {return ".WHISTLE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcAlarmTypeEnum() { Value = ".BELL.";}
		public IfcAlarmTypeEnum(string value) { Value = value; }
		public static implicit operator IfcAlarmTypeEnum(string value) { return new IfcAlarmTypeEnum(value);}
		public static implicit operator string(IfcAlarmTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAlignmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAlignmentTypeEnum = ENUMERATION OF</para>
	/// <para>(USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAlignmentTypeEnum
	{
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcAlignmentTypeEnum() { Value = ".USERDEFINED.";}
		public IfcAlignmentTypeEnum(string value) { Value = value; }
		public static implicit operator IfcAlignmentTypeEnum(string value) { return new IfcAlignmentTypeEnum(value);}
		public static implicit operator string(IfcAlignmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAnalysisModelTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAnalysisModelTypeEnum = ENUMERATION OF</para>
	/// <para>(IN_PLANE_LOADING_2D</para>
	/// <para>,OUT_PLANE_LOADING_2D</para>
	/// <para>,LOADING_3D</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAnalysisModelTypeEnum
	{
		public static string IN_PLANE_LOADING_2D { get {return ".IN_PLANE_LOADING_2D.";} }
		public static string OUT_PLANE_LOADING_2D { get {return ".OUT_PLANE_LOADING_2D.";} }
		public static string LOADING_3D { get {return ".LOADING_3D.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcAnalysisModelTypeEnum() { Value = ".IN_PLANE_LOADING_2D.";}
		public IfcAnalysisModelTypeEnum(string value) { Value = value; }
		public static implicit operator IfcAnalysisModelTypeEnum(string value) { return new IfcAnalysisModelTypeEnum(value);}
		public static implicit operator string(IfcAnalysisModelTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAnalysisTheoryTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAnalysisTheoryTypeEnum = ENUMERATION OF</para>
	/// <para>(FIRST_ORDER_THEORY</para>
	/// <para>,SECOND_ORDER_THEORY</para>
	/// <para>,THIRD_ORDER_THEORY</para>
	/// <para>,FULL_NONLINEAR_THEORY</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAnalysisTheoryTypeEnum
	{
		public static string FIRST_ORDER_THEORY { get {return ".FIRST_ORDER_THEORY.";} }
		public static string SECOND_ORDER_THEORY { get {return ".SECOND_ORDER_THEORY.";} }
		public static string THIRD_ORDER_THEORY { get {return ".THIRD_ORDER_THEORY.";} }
		public static string FULL_NONLINEAR_THEORY { get {return ".FULL_NONLINEAR_THEORY.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcAnalysisTheoryTypeEnum() { Value = ".FIRST_ORDER_THEORY.";}
		public IfcAnalysisTheoryTypeEnum(string value) { Value = value; }
		public static implicit operator IfcAnalysisTheoryTypeEnum(string value) { return new IfcAnalysisTheoryTypeEnum(value);}
		public static implicit operator string(IfcAnalysisTheoryTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcArithmeticOperatorEnum = ENUMERATION OF
	/// <para>TYPE IfcArithmeticOperatorEnum = ENUMERATION OF</para>
	/// <para>(ADD</para>
	/// <para>,DIVIDE</para>
	/// <para>,MULTIPLY</para>
	/// <para>,SUBTRACT);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcArithmeticOperatorEnum
	{
		public static string ADD { get {return ".ADD.";} }
		public static string DIVIDE { get {return ".DIVIDE.";} }
		public static string MULTIPLY { get {return ".MULTIPLY.";} }
		public static string SUBTRACT { get {return ".SUBTRACT.";} }
		public string Value;
		public IfcArithmeticOperatorEnum() { Value = ".ADD.";}
		public IfcArithmeticOperatorEnum(string value) { Value = value; }
		public static implicit operator IfcArithmeticOperatorEnum(string value) { return new IfcArithmeticOperatorEnum(value);}
		public static implicit operator string(IfcArithmeticOperatorEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAssemblyPlaceEnum = ENUMERATION OF
	/// <para>TYPE IfcAssemblyPlaceEnum = ENUMERATION OF</para>
	/// <para>(SITE</para>
	/// <para>,FACTORY</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAssemblyPlaceEnum
	{
		public static string SITE { get {return ".SITE.";} }
		public static string FACTORY { get {return ".FACTORY.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcAssemblyPlaceEnum() { Value = ".SITE.";}
		public IfcAssemblyPlaceEnum(string value) { Value = value; }
		public static implicit operator IfcAssemblyPlaceEnum(string value) { return new IfcAssemblyPlaceEnum(value);}
		public static implicit operator string(IfcAssemblyPlaceEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcAudioVisualApplianceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcAudioVisualApplianceTypeEnum = ENUMERATION OF</para>
	/// <para>(AMPLIFIER</para>
	/// <para>,CAMERA</para>
	/// <para>,DISPLAY</para>
	/// <para>,MICROPHONE</para>
	/// <para>,PLAYER</para>
	/// <para>,PROJECTOR</para>
	/// <para>,RECEIVER</para>
	/// <para>,SPEAKER</para>
	/// <para>,SWITCHER</para>
	/// <para>,TELEPHONE</para>
	/// <para>,TUNER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcAudioVisualApplianceTypeEnum
	{
		public static string AMPLIFIER { get {return ".AMPLIFIER.";} }
		public static string CAMERA { get {return ".CAMERA.";} }
		public static string DISPLAY { get {return ".DISPLAY.";} }
		public static string MICROPHONE { get {return ".MICROPHONE.";} }
		public static string PLAYER { get {return ".PLAYER.";} }
		public static string PROJECTOR { get {return ".PROJECTOR.";} }
		public static string RECEIVER { get {return ".RECEIVER.";} }
		public static string SPEAKER { get {return ".SPEAKER.";} }
		public static string SWITCHER { get {return ".SWITCHER.";} }
		public static string TELEPHONE { get {return ".TELEPHONE.";} }
		public static string TUNER { get {return ".TUNER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcAudioVisualApplianceTypeEnum() { Value = ".AMPLIFIER.";}
		public IfcAudioVisualApplianceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcAudioVisualApplianceTypeEnum(string value) { return new IfcAudioVisualApplianceTypeEnum(value);}
		public static implicit operator string(IfcAudioVisualApplianceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBSplineCurveForm = ENUMERATION OF
	/// <para>TYPE IfcBSplineCurveForm = ENUMERATION OF</para>
	/// <para>(POLYLINE_FORM</para>
	/// <para>,CIRCULAR_ARC</para>
	/// <para>,ELLIPTIC_ARC</para>
	/// <para>,PARABOLIC_ARC</para>
	/// <para>,HYPERBOLIC_ARC</para>
	/// <para>,UNSPECIFIED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBSplineCurveForm
	{
		public static string POLYLINE_FORM { get {return ".POLYLINE_FORM.";} }
		public static string CIRCULAR_ARC { get {return ".CIRCULAR_ARC.";} }
		public static string ELLIPTIC_ARC { get {return ".ELLIPTIC_ARC.";} }
		public static string PARABOLIC_ARC { get {return ".PARABOLIC_ARC.";} }
		public static string HYPERBOLIC_ARC { get {return ".HYPERBOLIC_ARC.";} }
		public static string UNSPECIFIED { get {return ".UNSPECIFIED.";} }
		public string Value;
		public IfcBSplineCurveForm() { Value = ".POLYLINE_FORM.";}
		public IfcBSplineCurveForm(string value) { Value = value; }
		public static implicit operator IfcBSplineCurveForm(string value) { return new IfcBSplineCurveForm(value);}
		public static implicit operator string(IfcBSplineCurveForm value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBSplineSurfaceForm = ENUMERATION OF
	/// <para>TYPE IfcBSplineSurfaceForm = ENUMERATION OF</para>
	/// <para>(PLANE_SURF</para>
	/// <para>,CYLINDRICAL_SURF</para>
	/// <para>,CONICAL_SURF</para>
	/// <para>,SPHERICAL_SURF</para>
	/// <para>,TOROIDAL_SURF</para>
	/// <para>,SURF_OF_REVOLUTION</para>
	/// <para>,RULED_SURF</para>
	/// <para>,GENERALISED_CONE</para>
	/// <para>,QUADRIC_SURF</para>
	/// <para>,SURF_OF_LINEAR_EXTRUSION</para>
	/// <para>,UNSPECIFIED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBSplineSurfaceForm
	{
		public static string PLANE_SURF { get {return ".PLANE_SURF.";} }
		public static string CYLINDRICAL_SURF { get {return ".CYLINDRICAL_SURF.";} }
		public static string CONICAL_SURF { get {return ".CONICAL_SURF.";} }
		public static string SPHERICAL_SURF { get {return ".SPHERICAL_SURF.";} }
		public static string TOROIDAL_SURF { get {return ".TOROIDAL_SURF.";} }
		public static string SURF_OF_REVOLUTION { get {return ".SURF_OF_REVOLUTION.";} }
		public static string RULED_SURF { get {return ".RULED_SURF.";} }
		public static string GENERALISED_CONE { get {return ".GENERALISED_CONE.";} }
		public static string QUADRIC_SURF { get {return ".QUADRIC_SURF.";} }
		public static string SURF_OF_LINEAR_EXTRUSION { get {return ".SURF_OF_LINEAR_EXTRUSION.";} }
		public static string UNSPECIFIED { get {return ".UNSPECIFIED.";} }
		public string Value;
		public IfcBSplineSurfaceForm() { Value = ".PLANE_SURF.";}
		public IfcBSplineSurfaceForm(string value) { Value = value; }
		public static implicit operator IfcBSplineSurfaceForm(string value) { return new IfcBSplineSurfaceForm(value);}
		public static implicit operator string(IfcBSplineSurfaceForm value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBeamTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBeamTypeEnum = ENUMERATION OF</para>
	/// <para>(BEAM</para>
	/// <para>,JOIST</para>
	/// <para>,HOLLOWCORE</para>
	/// <para>,LINTEL</para>
	/// <para>,SPANDREL</para>
	/// <para>,T_BEAM</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBeamTypeEnum
	{
		public static string BEAM { get {return ".BEAM.";} }
		public static string JOIST { get {return ".JOIST.";} }
		public static string HOLLOWCORE { get {return ".HOLLOWCORE.";} }
		public static string LINTEL { get {return ".LINTEL.";} }
		public static string SPANDREL { get {return ".SPANDREL.";} }
		public static string T_BEAM { get {return ".T_BEAM.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcBeamTypeEnum() { Value = ".BEAM.";}
		public IfcBeamTypeEnum(string value) { Value = value; }
		public static implicit operator IfcBeamTypeEnum(string value) { return new IfcBeamTypeEnum(value);}
		public static implicit operator string(IfcBeamTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBenchmarkEnum = ENUMERATION OF
	/// <para>TYPE IfcBenchmarkEnum = ENUMERATION OF</para>
	/// <para>(GREATERTHAN</para>
	/// <para>,GREATERTHANOREQUALTO</para>
	/// <para>,LESSTHAN</para>
	/// <para>,LESSTHANOREQUALTO</para>
	/// <para>,EQUALTO</para>
	/// <para>,NOTEQUALTO</para>
	/// <para>,INCLUDES</para>
	/// <para>,NOTINCLUDES</para>
	/// <para>,INCLUDEDIN</para>
	/// <para>,NOTINCLUDEDIN);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBenchmarkEnum
	{
		public static string GREATERTHAN { get {return ".GREATERTHAN.";} }
		public static string GREATERTHANOREQUALTO { get {return ".GREATERTHANOREQUALTO.";} }
		public static string LESSTHAN { get {return ".LESSTHAN.";} }
		public static string LESSTHANOREQUALTO { get {return ".LESSTHANOREQUALTO.";} }
		public static string EQUALTO { get {return ".EQUALTO.";} }
		public static string NOTEQUALTO { get {return ".NOTEQUALTO.";} }
		public static string INCLUDES { get {return ".INCLUDES.";} }
		public static string NOTINCLUDES { get {return ".NOTINCLUDES.";} }
		public static string INCLUDEDIN { get {return ".INCLUDEDIN.";} }
		public static string NOTINCLUDEDIN { get {return ".NOTINCLUDEDIN.";} }
		public string Value;
		public IfcBenchmarkEnum() { Value = ".GREATERTHAN.";}
		public IfcBenchmarkEnum(string value) { Value = value; }
		public static implicit operator IfcBenchmarkEnum(string value) { return new IfcBenchmarkEnum(value);}
		public static implicit operator string(IfcBenchmarkEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBoilerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBoilerTypeEnum = ENUMERATION OF</para>
	/// <para>(WATER</para>
	/// <para>,STEAM</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBoilerTypeEnum
	{
		public static string WATER { get {return ".WATER.";} }
		public static string STEAM { get {return ".STEAM.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcBoilerTypeEnum() { Value = ".WATER.";}
		public IfcBoilerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcBoilerTypeEnum(string value) { return new IfcBoilerTypeEnum(value);}
		public static implicit operator string(IfcBoilerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBooleanOperator = ENUMERATION OF
	/// <para>TYPE IfcBooleanOperator = ENUMERATION OF</para>
	/// <para>(UNION</para>
	/// <para>,INTERSECTION</para>
	/// <para>,DIFFERENCE);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBooleanOperator
	{
		public static string UNION { get {return ".UNION.";} }
		public static string INTERSECTION { get {return ".INTERSECTION.";} }
		public static string DIFFERENCE { get {return ".DIFFERENCE.";} }
		public string Value;
		public IfcBooleanOperator() { Value = ".UNION.";}
		public IfcBooleanOperator(string value) { Value = value; }
		public static implicit operator IfcBooleanOperator(string value) { return new IfcBooleanOperator(value);}
		public static implicit operator string(IfcBooleanOperator value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBuildingElementPartTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBuildingElementPartTypeEnum = ENUMERATION OF</para>
	/// <para>(INSULATION</para>
	/// <para>,PRECASTPANEL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBuildingElementPartTypeEnum
	{
		public static string INSULATION { get {return ".INSULATION.";} }
		public static string PRECASTPANEL { get {return ".PRECASTPANEL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcBuildingElementPartTypeEnum() { Value = ".INSULATION.";}
		public IfcBuildingElementPartTypeEnum(string value) { Value = value; }
		public static implicit operator IfcBuildingElementPartTypeEnum(string value) { return new IfcBuildingElementPartTypeEnum(value);}
		public static implicit operator string(IfcBuildingElementPartTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBuildingElementProxyTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBuildingElementProxyTypeEnum = ENUMERATION OF</para>
	/// <para>(COMPLEX</para>
	/// <para>,ELEMENT</para>
	/// <para>,PARTIAL</para>
	/// <para>,PROVISIONFORVOID</para>
	/// <para>,PROVISIONFORSPACE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBuildingElementProxyTypeEnum
	{
		public static string COMPLEX { get {return ".COMPLEX.";} }
		public static string ELEMENT { get {return ".ELEMENT.";} }
		public static string PARTIAL { get {return ".PARTIAL.";} }
		public static string PROVISIONFORVOID { get {return ".PROVISIONFORVOID.";} }
		public static string PROVISIONFORSPACE { get {return ".PROVISIONFORSPACE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcBuildingElementProxyTypeEnum() { Value = ".COMPLEX.";}
		public IfcBuildingElementProxyTypeEnum(string value) { Value = value; }
		public static implicit operator IfcBuildingElementProxyTypeEnum(string value) { return new IfcBuildingElementProxyTypeEnum(value);}
		public static implicit operator string(IfcBuildingElementProxyTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBuildingSystemTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBuildingSystemTypeEnum = ENUMERATION OF</para>
	/// <para>(FENESTRATION</para>
	/// <para>,FOUNDATION</para>
	/// <para>,LOADBEARING</para>
	/// <para>,OUTERSHELL</para>
	/// <para>,SHADING</para>
	/// <para>,TRANSPORT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBuildingSystemTypeEnum
	{
		public static string FENESTRATION { get {return ".FENESTRATION.";} }
		public static string FOUNDATION { get {return ".FOUNDATION.";} }
		public static string LOADBEARING { get {return ".LOADBEARING.";} }
		public static string OUTERSHELL { get {return ".OUTERSHELL.";} }
		public static string SHADING { get {return ".SHADING.";} }
		public static string TRANSPORT { get {return ".TRANSPORT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcBuildingSystemTypeEnum() { Value = ".FENESTRATION.";}
		public IfcBuildingSystemTypeEnum(string value) { Value = value; }
		public static implicit operator IfcBuildingSystemTypeEnum(string value) { return new IfcBuildingSystemTypeEnum(value);}
		public static implicit operator string(IfcBuildingSystemTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcBurnerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcBurnerTypeEnum = ENUMERATION OF</para>
	/// <para>(USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcBurnerTypeEnum
	{
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcBurnerTypeEnum() { Value = ".USERDEFINED.";}
		public IfcBurnerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcBurnerTypeEnum(string value) { return new IfcBurnerTypeEnum(value);}
		public static implicit operator string(IfcBurnerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCableCarrierFittingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCableCarrierFittingTypeEnum = ENUMERATION OF</para>
	/// <para>(BEND</para>
	/// <para>,CROSS</para>
	/// <para>,REDUCER</para>
	/// <para>,TEE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCableCarrierFittingTypeEnum
	{
		public static string BEND { get {return ".BEND.";} }
		public static string CROSS { get {return ".CROSS.";} }
		public static string REDUCER { get {return ".REDUCER.";} }
		public static string TEE { get {return ".TEE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCableCarrierFittingTypeEnum() { Value = ".BEND.";}
		public IfcCableCarrierFittingTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCableCarrierFittingTypeEnum(string value) { return new IfcCableCarrierFittingTypeEnum(value);}
		public static implicit operator string(IfcCableCarrierFittingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCableCarrierSegmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCableCarrierSegmentTypeEnum = ENUMERATION OF</para>
	/// <para>(CABLELADDERSEGMENT</para>
	/// <para>,CABLETRAYSEGMENT</para>
	/// <para>,CABLETRUNKINGSEGMENT</para>
	/// <para>,CONDUITSEGMENT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCableCarrierSegmentTypeEnum
	{
		public static string CABLELADDERSEGMENT { get {return ".CABLELADDERSEGMENT.";} }
		public static string CABLETRAYSEGMENT { get {return ".CABLETRAYSEGMENT.";} }
		public static string CABLETRUNKINGSEGMENT { get {return ".CABLETRUNKINGSEGMENT.";} }
		public static string CONDUITSEGMENT { get {return ".CONDUITSEGMENT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCableCarrierSegmentTypeEnum() { Value = ".CABLELADDERSEGMENT.";}
		public IfcCableCarrierSegmentTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCableCarrierSegmentTypeEnum(string value) { return new IfcCableCarrierSegmentTypeEnum(value);}
		public static implicit operator string(IfcCableCarrierSegmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCableFittingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCableFittingTypeEnum = ENUMERATION OF</para>
	/// <para>(CONNECTOR</para>
	/// <para>,ENTRY</para>
	/// <para>,EXIT</para>
	/// <para>,JUNCTION</para>
	/// <para>,TRANSITION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCableFittingTypeEnum
	{
		public static string CONNECTOR { get {return ".CONNECTOR.";} }
		public static string ENTRY { get {return ".ENTRY.";} }
		public static string EXIT { get {return ".EXIT.";} }
		public static string JUNCTION { get {return ".JUNCTION.";} }
		public static string TRANSITION { get {return ".TRANSITION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCableFittingTypeEnum() { Value = ".CONNECTOR.";}
		public IfcCableFittingTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCableFittingTypeEnum(string value) { return new IfcCableFittingTypeEnum(value);}
		public static implicit operator string(IfcCableFittingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCableSegmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCableSegmentTypeEnum = ENUMERATION OF</para>
	/// <para>(BUSBARSEGMENT</para>
	/// <para>,CABLESEGMENT</para>
	/// <para>,CONDUCTORSEGMENT</para>
	/// <para>,CORESEGMENT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCableSegmentTypeEnum
	{
		public static string BUSBARSEGMENT { get {return ".BUSBARSEGMENT.";} }
		public static string CABLESEGMENT { get {return ".CABLESEGMENT.";} }
		public static string CONDUCTORSEGMENT { get {return ".CONDUCTORSEGMENT.";} }
		public static string CORESEGMENT { get {return ".CORESEGMENT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCableSegmentTypeEnum() { Value = ".BUSBARSEGMENT.";}
		public IfcCableSegmentTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCableSegmentTypeEnum(string value) { return new IfcCableSegmentTypeEnum(value);}
		public static implicit operator string(IfcCableSegmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcChangeActionEnum = ENUMERATION OF
	/// <para>TYPE IfcChangeActionEnum = ENUMERATION OF</para>
	/// <para>(NOCHANGE</para>
	/// <para>,MODIFIED</para>
	/// <para>,ADDED</para>
	/// <para>,DELETED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcChangeActionEnum
	{
		public static string NOCHANGE { get {return ".NOCHANGE.";} }
		public static string MODIFIED { get {return ".MODIFIED.";} }
		public static string ADDED { get {return ".ADDED.";} }
		public static string DELETED { get {return ".DELETED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcChangeActionEnum() { Value = ".NOCHANGE.";}
		public IfcChangeActionEnum(string value) { Value = value; }
		public static implicit operator IfcChangeActionEnum(string value) { return new IfcChangeActionEnum(value);}
		public static implicit operator string(IfcChangeActionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcChillerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcChillerTypeEnum = ENUMERATION OF</para>
	/// <para>(AIRCOOLED</para>
	/// <para>,WATERCOOLED</para>
	/// <para>,HEATRECOVERY</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcChillerTypeEnum
	{
		public static string AIRCOOLED { get {return ".AIRCOOLED.";} }
		public static string WATERCOOLED { get {return ".WATERCOOLED.";} }
		public static string HEATRECOVERY { get {return ".HEATRECOVERY.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcChillerTypeEnum() { Value = ".AIRCOOLED.";}
		public IfcChillerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcChillerTypeEnum(string value) { return new IfcChillerTypeEnum(value);}
		public static implicit operator string(IfcChillerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcChimneyTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcChimneyTypeEnum = ENUMERATION OF</para>
	/// <para>(USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcChimneyTypeEnum
	{
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcChimneyTypeEnum() { Value = ".USERDEFINED.";}
		public IfcChimneyTypeEnum(string value) { Value = value; }
		public static implicit operator IfcChimneyTypeEnum(string value) { return new IfcChimneyTypeEnum(value);}
		public static implicit operator string(IfcChimneyTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCoilTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCoilTypeEnum = ENUMERATION OF</para>
	/// <para>(DXCOOLINGCOIL</para>
	/// <para>,ELECTRICHEATINGCOIL</para>
	/// <para>,GASHEATINGCOIL</para>
	/// <para>,HYDRONICCOIL</para>
	/// <para>,STEAMHEATINGCOIL</para>
	/// <para>,WATERCOOLINGCOIL</para>
	/// <para>,WATERHEATINGCOIL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCoilTypeEnum
	{
		public static string DXCOOLINGCOIL { get {return ".DXCOOLINGCOIL.";} }
		public static string ELECTRICHEATINGCOIL { get {return ".ELECTRICHEATINGCOIL.";} }
		public static string GASHEATINGCOIL { get {return ".GASHEATINGCOIL.";} }
		public static string HYDRONICCOIL { get {return ".HYDRONICCOIL.";} }
		public static string STEAMHEATINGCOIL { get {return ".STEAMHEATINGCOIL.";} }
		public static string WATERCOOLINGCOIL { get {return ".WATERCOOLINGCOIL.";} }
		public static string WATERHEATINGCOIL { get {return ".WATERHEATINGCOIL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCoilTypeEnum() { Value = ".DXCOOLINGCOIL.";}
		public IfcCoilTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCoilTypeEnum(string value) { return new IfcCoilTypeEnum(value);}
		public static implicit operator string(IfcCoilTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcColumnTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcColumnTypeEnum = ENUMERATION OF</para>
	/// <para>(COLUMN</para>
	/// <para>,PILASTER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcColumnTypeEnum
	{
		public static string COLUMN { get {return ".COLUMN.";} }
		public static string PILASTER { get {return ".PILASTER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcColumnTypeEnum() { Value = ".COLUMN.";}
		public IfcColumnTypeEnum(string value) { Value = value; }
		public static implicit operator IfcColumnTypeEnum(string value) { return new IfcColumnTypeEnum(value);}
		public static implicit operator string(IfcColumnTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCommunicationsApplianceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCommunicationsApplianceTypeEnum = ENUMERATION OF</para>
	/// <para>(ANTENNA</para>
	/// <para>,COMPUTER</para>
	/// <para>,FAX</para>
	/// <para>,GATEWAY</para>
	/// <para>,MODEM</para>
	/// <para>,NETWORKAPPLIANCE</para>
	/// <para>,NETWORKBRIDGE</para>
	/// <para>,NETWORKHUB</para>
	/// <para>,PRINTER</para>
	/// <para>,REPEATER</para>
	/// <para>,ROUTER</para>
	/// <para>,SCANNER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCommunicationsApplianceTypeEnum
	{
		public static string ANTENNA { get {return ".ANTENNA.";} }
		public static string COMPUTER { get {return ".COMPUTER.";} }
		public static string FAX { get {return ".FAX.";} }
		public static string GATEWAY { get {return ".GATEWAY.";} }
		public static string MODEM { get {return ".MODEM.";} }
		public static string NETWORKAPPLIANCE { get {return ".NETWORKAPPLIANCE.";} }
		public static string NETWORKBRIDGE { get {return ".NETWORKBRIDGE.";} }
		public static string NETWORKHUB { get {return ".NETWORKHUB.";} }
		public static string PRINTER { get {return ".PRINTER.";} }
		public static string REPEATER { get {return ".REPEATER.";} }
		public static string ROUTER { get {return ".ROUTER.";} }
		public static string SCANNER { get {return ".SCANNER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCommunicationsApplianceTypeEnum() { Value = ".ANTENNA.";}
		public IfcCommunicationsApplianceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCommunicationsApplianceTypeEnum(string value) { return new IfcCommunicationsApplianceTypeEnum(value);}
		public static implicit operator string(IfcCommunicationsApplianceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcComplexPropertyTemplateTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcComplexPropertyTemplateTypeEnum = ENUMERATION OF</para>
	/// <para>(P_COMPLEX</para>
	/// <para>,Q_COMPLEX);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcComplexPropertyTemplateTypeEnum
	{
		public static string P_COMPLEX { get {return ".P_COMPLEX.";} }
		public static string Q_COMPLEX { get {return ".Q_COMPLEX.";} }
		public string Value;
		public IfcComplexPropertyTemplateTypeEnum() { Value = ".P_COMPLEX.";}
		public IfcComplexPropertyTemplateTypeEnum(string value) { Value = value; }
		public static implicit operator IfcComplexPropertyTemplateTypeEnum(string value) { return new IfcComplexPropertyTemplateTypeEnum(value);}
		public static implicit operator string(IfcComplexPropertyTemplateTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCompressorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCompressorTypeEnum = ENUMERATION OF</para>
	/// <para>(DYNAMIC</para>
	/// <para>,RECIPROCATING</para>
	/// <para>,ROTARY</para>
	/// <para>,SCROLL</para>
	/// <para>,TROCHOIDAL</para>
	/// <para>,SINGLESTAGE</para>
	/// <para>,BOOSTER</para>
	/// <para>,OPENTYPE</para>
	/// <para>,HERMETIC</para>
	/// <para>,SEMIHERMETIC</para>
	/// <para>,WELDEDSHELLHERMETIC</para>
	/// <para>,ROLLINGPISTON</para>
	/// <para>,ROTARYVANE</para>
	/// <para>,SINGLESCREW</para>
	/// <para>,TWINSCREW</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCompressorTypeEnum
	{
		public static string DYNAMIC { get {return ".DYNAMIC.";} }
		public static string RECIPROCATING { get {return ".RECIPROCATING.";} }
		public static string ROTARY { get {return ".ROTARY.";} }
		public static string SCROLL { get {return ".SCROLL.";} }
		public static string TROCHOIDAL { get {return ".TROCHOIDAL.";} }
		public static string SINGLESTAGE { get {return ".SINGLESTAGE.";} }
		public static string BOOSTER { get {return ".BOOSTER.";} }
		public static string OPENTYPE { get {return ".OPENTYPE.";} }
		public static string HERMETIC { get {return ".HERMETIC.";} }
		public static string SEMIHERMETIC { get {return ".SEMIHERMETIC.";} }
		public static string WELDEDSHELLHERMETIC { get {return ".WELDEDSHELLHERMETIC.";} }
		public static string ROLLINGPISTON { get {return ".ROLLINGPISTON.";} }
		public static string ROTARYVANE { get {return ".ROTARYVANE.";} }
		public static string SINGLESCREW { get {return ".SINGLESCREW.";} }
		public static string TWINSCREW { get {return ".TWINSCREW.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCompressorTypeEnum() { Value = ".DYNAMIC.";}
		public IfcCompressorTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCompressorTypeEnum(string value) { return new IfcCompressorTypeEnum(value);}
		public static implicit operator string(IfcCompressorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCondenserTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCondenserTypeEnum = ENUMERATION OF</para>
	/// <para>(AIRCOOLED</para>
	/// <para>,EVAPORATIVECOOLED</para>
	/// <para>,WATERCOOLED</para>
	/// <para>,WATERCOOLEDBRAZEDPLATE</para>
	/// <para>,WATERCOOLEDSHELLCOIL</para>
	/// <para>,WATERCOOLEDSHELLTUBE</para>
	/// <para>,WATERCOOLEDTUBEINTUBE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCondenserTypeEnum
	{
		public static string AIRCOOLED { get {return ".AIRCOOLED.";} }
		public static string EVAPORATIVECOOLED { get {return ".EVAPORATIVECOOLED.";} }
		public static string WATERCOOLED { get {return ".WATERCOOLED.";} }
		public static string WATERCOOLEDBRAZEDPLATE { get {return ".WATERCOOLEDBRAZEDPLATE.";} }
		public static string WATERCOOLEDSHELLCOIL { get {return ".WATERCOOLEDSHELLCOIL.";} }
		public static string WATERCOOLEDSHELLTUBE { get {return ".WATERCOOLEDSHELLTUBE.";} }
		public static string WATERCOOLEDTUBEINTUBE { get {return ".WATERCOOLEDTUBEINTUBE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCondenserTypeEnum() { Value = ".AIRCOOLED.";}
		public IfcCondenserTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCondenserTypeEnum(string value) { return new IfcCondenserTypeEnum(value);}
		public static implicit operator string(IfcCondenserTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcConnectionTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcConnectionTypeEnum = ENUMERATION OF</para>
	/// <para>(ATPATH</para>
	/// <para>,ATSTART</para>
	/// <para>,ATEND</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcConnectionTypeEnum
	{
		public static string ATPATH { get {return ".ATPATH.";} }
		public static string ATSTART { get {return ".ATSTART.";} }
		public static string ATEND { get {return ".ATEND.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcConnectionTypeEnum() { Value = ".ATPATH.";}
		public IfcConnectionTypeEnum(string value) { Value = value; }
		public static implicit operator IfcConnectionTypeEnum(string value) { return new IfcConnectionTypeEnum(value);}
		public static implicit operator string(IfcConnectionTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcConstraintEnum = ENUMERATION OF
	/// <para>TYPE IfcConstraintEnum = ENUMERATION OF</para>
	/// <para>(HARD</para>
	/// <para>,SOFT</para>
	/// <para>,ADVISORY</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcConstraintEnum
	{
		public static string HARD { get {return ".HARD.";} }
		public static string SOFT { get {return ".SOFT.";} }
		public static string ADVISORY { get {return ".ADVISORY.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcConstraintEnum() { Value = ".HARD.";}
		public IfcConstraintEnum(string value) { Value = value; }
		public static implicit operator IfcConstraintEnum(string value) { return new IfcConstraintEnum(value);}
		public static implicit operator string(IfcConstraintEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcConstructionEquipmentResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcConstructionEquipmentResourceTypeEnum = ENUMERATION OF</para>
	/// <para>(DEMOLISHING</para>
	/// <para>,EARTHMOVING</para>
	/// <para>,ERECTING</para>
	/// <para>,HEATING</para>
	/// <para>,LIGHTING</para>
	/// <para>,PAVING</para>
	/// <para>,PUMPING</para>
	/// <para>,TRANSPORTING</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcConstructionEquipmentResourceTypeEnum
	{
		public static string DEMOLISHING { get {return ".DEMOLISHING.";} }
		public static string EARTHMOVING { get {return ".EARTHMOVING.";} }
		public static string ERECTING { get {return ".ERECTING.";} }
		public static string HEATING { get {return ".HEATING.";} }
		public static string LIGHTING { get {return ".LIGHTING.";} }
		public static string PAVING { get {return ".PAVING.";} }
		public static string PUMPING { get {return ".PUMPING.";} }
		public static string TRANSPORTING { get {return ".TRANSPORTING.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcConstructionEquipmentResourceTypeEnum() { Value = ".DEMOLISHING.";}
		public IfcConstructionEquipmentResourceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcConstructionEquipmentResourceTypeEnum(string value) { return new IfcConstructionEquipmentResourceTypeEnum(value);}
		public static implicit operator string(IfcConstructionEquipmentResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcConstructionMaterialResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcConstructionMaterialResourceTypeEnum = ENUMERATION OF</para>
	/// <para>(AGGREGATES</para>
	/// <para>,CONCRETE</para>
	/// <para>,DRYWALL</para>
	/// <para>,FUEL</para>
	/// <para>,GYPSUM</para>
	/// <para>,MASONRY</para>
	/// <para>,METAL</para>
	/// <para>,PLASTIC</para>
	/// <para>,WOOD</para>
	/// <para>,NOTDEFINED</para>
	/// <para>,USERDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcConstructionMaterialResourceTypeEnum
	{
		public static string AGGREGATES { get {return ".AGGREGATES.";} }
		public static string CONCRETE { get {return ".CONCRETE.";} }
		public static string DRYWALL { get {return ".DRYWALL.";} }
		public static string FUEL { get {return ".FUEL.";} }
		public static string GYPSUM { get {return ".GYPSUM.";} }
		public static string MASONRY { get {return ".MASONRY.";} }
		public static string METAL { get {return ".METAL.";} }
		public static string PLASTIC { get {return ".PLASTIC.";} }
		public static string WOOD { get {return ".WOOD.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public string Value;
		public IfcConstructionMaterialResourceTypeEnum() { Value = ".AGGREGATES.";}
		public IfcConstructionMaterialResourceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcConstructionMaterialResourceTypeEnum(string value) { return new IfcConstructionMaterialResourceTypeEnum(value);}
		public static implicit operator string(IfcConstructionMaterialResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcConstructionProductResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcConstructionProductResourceTypeEnum = ENUMERATION OF</para>
	/// <para>(ASSEMBLY</para>
	/// <para>,FORMWORK</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcConstructionProductResourceTypeEnum
	{
		public static string ASSEMBLY { get {return ".ASSEMBLY.";} }
		public static string FORMWORK { get {return ".FORMWORK.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcConstructionProductResourceTypeEnum() { Value = ".ASSEMBLY.";}
		public IfcConstructionProductResourceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcConstructionProductResourceTypeEnum(string value) { return new IfcConstructionProductResourceTypeEnum(value);}
		public static implicit operator string(IfcConstructionProductResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcControllerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcControllerTypeEnum = ENUMERATION OF</para>
	/// <para>(FLOATING</para>
	/// <para>,PROGRAMMABLE</para>
	/// <para>,PROPORTIONAL</para>
	/// <para>,MULTIPOSITION</para>
	/// <para>,TWOPOSITION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcControllerTypeEnum
	{
		public static string FLOATING { get {return ".FLOATING.";} }
		public static string PROGRAMMABLE { get {return ".PROGRAMMABLE.";} }
		public static string PROPORTIONAL { get {return ".PROPORTIONAL.";} }
		public static string MULTIPOSITION { get {return ".MULTIPOSITION.";} }
		public static string TWOPOSITION { get {return ".TWOPOSITION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcControllerTypeEnum() { Value = ".FLOATING.";}
		public IfcControllerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcControllerTypeEnum(string value) { return new IfcControllerTypeEnum(value);}
		public static implicit operator string(IfcControllerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCooledBeamTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCooledBeamTypeEnum = ENUMERATION OF</para>
	/// <para>(ACTIVE</para>
	/// <para>,PASSIVE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCooledBeamTypeEnum
	{
		public static string ACTIVE { get {return ".ACTIVE.";} }
		public static string PASSIVE { get {return ".PASSIVE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCooledBeamTypeEnum() { Value = ".ACTIVE.";}
		public IfcCooledBeamTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCooledBeamTypeEnum(string value) { return new IfcCooledBeamTypeEnum(value);}
		public static implicit operator string(IfcCooledBeamTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCoolingTowerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCoolingTowerTypeEnum = ENUMERATION OF</para>
	/// <para>(NATURALDRAFT</para>
	/// <para>,MECHANICALINDUCEDDRAFT</para>
	/// <para>,MECHANICALFORCEDDRAFT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCoolingTowerTypeEnum
	{
		public static string NATURALDRAFT { get {return ".NATURALDRAFT.";} }
		public static string MECHANICALINDUCEDDRAFT { get {return ".MECHANICALINDUCEDDRAFT.";} }
		public static string MECHANICALFORCEDDRAFT { get {return ".MECHANICALFORCEDDRAFT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCoolingTowerTypeEnum() { Value = ".NATURALDRAFT.";}
		public IfcCoolingTowerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCoolingTowerTypeEnum(string value) { return new IfcCoolingTowerTypeEnum(value);}
		public static implicit operator string(IfcCoolingTowerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCostItemTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCostItemTypeEnum = ENUMERATION OF</para>
	/// <para>(USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCostItemTypeEnum
	{
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCostItemTypeEnum() { Value = ".USERDEFINED.";}
		public IfcCostItemTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCostItemTypeEnum(string value) { return new IfcCostItemTypeEnum(value);}
		public static implicit operator string(IfcCostItemTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCostScheduleTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCostScheduleTypeEnum = ENUMERATION OF</para>
	/// <para>(BUDGET</para>
	/// <para>,COSTPLAN</para>
	/// <para>,ESTIMATE</para>
	/// <para>,TENDER</para>
	/// <para>,PRICEDBILLOFQUANTITIES</para>
	/// <para>,UNPRICEDBILLOFQUANTITIES</para>
	/// <para>,SCHEDULEOFRATES</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCostScheduleTypeEnum
	{
		public static string BUDGET { get {return ".BUDGET.";} }
		public static string COSTPLAN { get {return ".COSTPLAN.";} }
		public static string ESTIMATE { get {return ".ESTIMATE.";} }
		public static string TENDER { get {return ".TENDER.";} }
		public static string PRICEDBILLOFQUANTITIES { get {return ".PRICEDBILLOFQUANTITIES.";} }
		public static string UNPRICEDBILLOFQUANTITIES { get {return ".UNPRICEDBILLOFQUANTITIES.";} }
		public static string SCHEDULEOFRATES { get {return ".SCHEDULEOFRATES.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCostScheduleTypeEnum() { Value = ".BUDGET.";}
		public IfcCostScheduleTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCostScheduleTypeEnum(string value) { return new IfcCostScheduleTypeEnum(value);}
		public static implicit operator string(IfcCostScheduleTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCoveringTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCoveringTypeEnum = ENUMERATION OF</para>
	/// <para>(CEILING</para>
	/// <para>,FLOORING</para>
	/// <para>,CLADDING</para>
	/// <para>,ROOFING</para>
	/// <para>,MOLDING</para>
	/// <para>,SKIRTINGBOARD</para>
	/// <para>,INSULATION</para>
	/// <para>,MEMBRANE</para>
	/// <para>,SLEEVING</para>
	/// <para>,WRAPPING</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCoveringTypeEnum
	{
		public static string CEILING { get {return ".CEILING.";} }
		public static string FLOORING { get {return ".FLOORING.";} }
		public static string CLADDING { get {return ".CLADDING.";} }
		public static string ROOFING { get {return ".ROOFING.";} }
		public static string MOLDING { get {return ".MOLDING.";} }
		public static string SKIRTINGBOARD { get {return ".SKIRTINGBOARD.";} }
		public static string INSULATION { get {return ".INSULATION.";} }
		public static string MEMBRANE { get {return ".MEMBRANE.";} }
		public static string SLEEVING { get {return ".SLEEVING.";} }
		public static string WRAPPING { get {return ".WRAPPING.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCoveringTypeEnum() { Value = ".CEILING.";}
		public IfcCoveringTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCoveringTypeEnum(string value) { return new IfcCoveringTypeEnum(value);}
		public static implicit operator string(IfcCoveringTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCrewResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCrewResourceTypeEnum = ENUMERATION OF</para>
	/// <para>(OFFICE</para>
	/// <para>,SITE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCrewResourceTypeEnum
	{
		public static string OFFICE { get {return ".OFFICE.";} }
		public static string SITE { get {return ".SITE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCrewResourceTypeEnum() { Value = ".OFFICE.";}
		public IfcCrewResourceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCrewResourceTypeEnum(string value) { return new IfcCrewResourceTypeEnum(value);}
		public static implicit operator string(IfcCrewResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCurtainWallTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcCurtainWallTypeEnum = ENUMERATION OF</para>
	/// <para>(USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCurtainWallTypeEnum
	{
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCurtainWallTypeEnum() { Value = ".USERDEFINED.";}
		public IfcCurtainWallTypeEnum(string value) { Value = value; }
		public static implicit operator IfcCurtainWallTypeEnum(string value) { return new IfcCurtainWallTypeEnum(value);}
		public static implicit operator string(IfcCurtainWallTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcCurveInterpolationEnum = ENUMERATION OF
	/// <para>TYPE IfcCurveInterpolationEnum = ENUMERATION OF</para>
	/// <para>(LINEAR</para>
	/// <para>,LOG_LINEAR</para>
	/// <para>,LOG_LOG</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcCurveInterpolationEnum
	{
		public static string LINEAR { get {return ".LINEAR.";} }
		public static string LOG_LINEAR { get {return ".LOG_LINEAR.";} }
		public static string LOG_LOG { get {return ".LOG_LOG.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcCurveInterpolationEnum() { Value = ".LINEAR.";}
		public IfcCurveInterpolationEnum(string value) { Value = value; }
		public static implicit operator IfcCurveInterpolationEnum(string value) { return new IfcCurveInterpolationEnum(value);}
		public static implicit operator string(IfcCurveInterpolationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDamperTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDamperTypeEnum = ENUMERATION OF</para>
	/// <para>(BACKDRAFTDAMPER</para>
	/// <para>,BALANCINGDAMPER</para>
	/// <para>,BLASTDAMPER</para>
	/// <para>,CONTROLDAMPER</para>
	/// <para>,FIREDAMPER</para>
	/// <para>,FIRESMOKEDAMPER</para>
	/// <para>,FUMEHOODEXHAUST</para>
	/// <para>,GRAVITYDAMPER</para>
	/// <para>,GRAVITYRELIEFDAMPER</para>
	/// <para>,RELIEFDAMPER</para>
	/// <para>,SMOKEDAMPER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDamperTypeEnum
	{
		public static string BACKDRAFTDAMPER { get {return ".BACKDRAFTDAMPER.";} }
		public static string BALANCINGDAMPER { get {return ".BALANCINGDAMPER.";} }
		public static string BLASTDAMPER { get {return ".BLASTDAMPER.";} }
		public static string CONTROLDAMPER { get {return ".CONTROLDAMPER.";} }
		public static string FIREDAMPER { get {return ".FIREDAMPER.";} }
		public static string FIRESMOKEDAMPER { get {return ".FIRESMOKEDAMPER.";} }
		public static string FUMEHOODEXHAUST { get {return ".FUMEHOODEXHAUST.";} }
		public static string GRAVITYDAMPER { get {return ".GRAVITYDAMPER.";} }
		public static string GRAVITYRELIEFDAMPER { get {return ".GRAVITYRELIEFDAMPER.";} }
		public static string RELIEFDAMPER { get {return ".RELIEFDAMPER.";} }
		public static string SMOKEDAMPER { get {return ".SMOKEDAMPER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDamperTypeEnum() { Value = ".BACKDRAFTDAMPER.";}
		public IfcDamperTypeEnum(string value) { Value = value; }
		public static implicit operator IfcDamperTypeEnum(string value) { return new IfcDamperTypeEnum(value);}
		public static implicit operator string(IfcDamperTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDataOriginEnum = ENUMERATION OF
	/// <para>TYPE IfcDataOriginEnum = ENUMERATION OF</para>
	/// <para>(MEASURED</para>
	/// <para>,PREDICTED</para>
	/// <para>,SIMULATED</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDataOriginEnum
	{
		public static string MEASURED { get {return ".MEASURED.";} }
		public static string PREDICTED { get {return ".PREDICTED.";} }
		public static string SIMULATED { get {return ".SIMULATED.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDataOriginEnum() { Value = ".MEASURED.";}
		public IfcDataOriginEnum(string value) { Value = value; }
		public static implicit operator IfcDataOriginEnum(string value) { return new IfcDataOriginEnum(value);}
		public static implicit operator string(IfcDataOriginEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDerivedUnitEnum = ENUMERATION OF
	/// <para>TYPE IfcDerivedUnitEnum = ENUMERATION OF</para>
	/// <para>(ANGULARVELOCITYUNIT</para>
	/// <para>,AREADENSITYUNIT</para>
	/// <para>,COMPOUNDPLANEANGLEUNIT</para>
	/// <para>,DYNAMICVISCOSITYUNIT</para>
	/// <para>,HEATFLUXDENSITYUNIT</para>
	/// <para>,INTEGERCOUNTRATEUNIT</para>
	/// <para>,ISOTHERMALMOISTURECAPACITYUNIT</para>
	/// <para>,KINEMATICVISCOSITYUNIT</para>
	/// <para>,LINEARVELOCITYUNIT</para>
	/// <para>,MASSDENSITYUNIT</para>
	/// <para>,MASSFLOWRATEUNIT</para>
	/// <para>,MOISTUREDIFFUSIVITYUNIT</para>
	/// <para>,MOLECULARWEIGHTUNIT</para>
	/// <para>,SPECIFICHEATCAPACITYUNIT</para>
	/// <para>,THERMALADMITTANCEUNIT</para>
	/// <para>,THERMALCONDUCTANCEUNIT</para>
	/// <para>,THERMALRESISTANCEUNIT</para>
	/// <para>,THERMALTRANSMITTANCEUNIT</para>
	/// <para>,VAPORPERMEABILITYUNIT</para>
	/// <para>,VOLUMETRICFLOWRATEUNIT</para>
	/// <para>,ROTATIONALFREQUENCYUNIT</para>
	/// <para>,TORQUEUNIT</para>
	/// <para>,MOMENTOFINERTIAUNIT</para>
	/// <para>,LINEARMOMENTUNIT</para>
	/// <para>,LINEARFORCEUNIT</para>
	/// <para>,PLANARFORCEUNIT</para>
	/// <para>,MODULUSOFELASTICITYUNIT</para>
	/// <para>,SHEARMODULUSUNIT</para>
	/// <para>,LINEARSTIFFNESSUNIT</para>
	/// <para>,ROTATIONALSTIFFNESSUNIT</para>
	/// <para>,MODULUSOFSUBGRADEREACTIONUNIT</para>
	/// <para>,ACCELERATIONUNIT</para>
	/// <para>,CURVATUREUNIT</para>
	/// <para>,HEATINGVALUEUNIT</para>
	/// <para>,IONCONCENTRATIONUNIT</para>
	/// <para>,LUMINOUSINTENSITYDISTRIBUTIONUNIT</para>
	/// <para>,MASSPERLENGTHUNIT</para>
	/// <para>,MODULUSOFLINEARSUBGRADEREACTIONUNIT</para>
	/// <para>,MODULUSOFROTATIONALSUBGRADEREACTIONUNIT</para>
	/// <para>,PHUNIT</para>
	/// <para>,ROTATIONALMASSUNIT</para>
	/// <para>,SECTIONAREAINTEGRALUNIT</para>
	/// <para>,SECTIONMODULUSUNIT</para>
	/// <para>,SOUNDPOWERLEVELUNIT</para>
	/// <para>,SOUNDPOWERUNIT</para>
	/// <para>,SOUNDPRESSURELEVELUNIT</para>
	/// <para>,SOUNDPRESSUREUNIT</para>
	/// <para>,TEMPERATUREGRADIENTUNIT</para>
	/// <para>,TEMPERATURERATEOFCHANGEUNIT</para>
	/// <para>,THERMALEXPANSIONCOEFFICIENTUNIT</para>
	/// <para>,WARPINGCONSTANTUNIT</para>
	/// <para>,WARPINGMOMENTUNIT</para>
	/// <para>,USERDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDerivedUnitEnum
	{
		public static string ANGULARVELOCITYUNIT { get {return ".ANGULARVELOCITYUNIT.";} }
		public static string AREADENSITYUNIT { get {return ".AREADENSITYUNIT.";} }
		public static string COMPOUNDPLANEANGLEUNIT { get {return ".COMPOUNDPLANEANGLEUNIT.";} }
		public static string DYNAMICVISCOSITYUNIT { get {return ".DYNAMICVISCOSITYUNIT.";} }
		public static string HEATFLUXDENSITYUNIT { get {return ".HEATFLUXDENSITYUNIT.";} }
		public static string INTEGERCOUNTRATEUNIT { get {return ".INTEGERCOUNTRATEUNIT.";} }
		public static string ISOTHERMALMOISTURECAPACITYUNIT { get {return ".ISOTHERMALMOISTURECAPACITYUNIT.";} }
		public static string KINEMATICVISCOSITYUNIT { get {return ".KINEMATICVISCOSITYUNIT.";} }
		public static string LINEARVELOCITYUNIT { get {return ".LINEARVELOCITYUNIT.";} }
		public static string MASSDENSITYUNIT { get {return ".MASSDENSITYUNIT.";} }
		public static string MASSFLOWRATEUNIT { get {return ".MASSFLOWRATEUNIT.";} }
		public static string MOISTUREDIFFUSIVITYUNIT { get {return ".MOISTUREDIFFUSIVITYUNIT.";} }
		public static string MOLECULARWEIGHTUNIT { get {return ".MOLECULARWEIGHTUNIT.";} }
		public static string SPECIFICHEATCAPACITYUNIT { get {return ".SPECIFICHEATCAPACITYUNIT.";} }
		public static string THERMALADMITTANCEUNIT { get {return ".THERMALADMITTANCEUNIT.";} }
		public static string THERMALCONDUCTANCEUNIT { get {return ".THERMALCONDUCTANCEUNIT.";} }
		public static string THERMALRESISTANCEUNIT { get {return ".THERMALRESISTANCEUNIT.";} }
		public static string THERMALTRANSMITTANCEUNIT { get {return ".THERMALTRANSMITTANCEUNIT.";} }
		public static string VAPORPERMEABILITYUNIT { get {return ".VAPORPERMEABILITYUNIT.";} }
		public static string VOLUMETRICFLOWRATEUNIT { get {return ".VOLUMETRICFLOWRATEUNIT.";} }
		public static string ROTATIONALFREQUENCYUNIT { get {return ".ROTATIONALFREQUENCYUNIT.";} }
		public static string TORQUEUNIT { get {return ".TORQUEUNIT.";} }
		public static string MOMENTOFINERTIAUNIT { get {return ".MOMENTOFINERTIAUNIT.";} }
		public static string LINEARMOMENTUNIT { get {return ".LINEARMOMENTUNIT.";} }
		public static string LINEARFORCEUNIT { get {return ".LINEARFORCEUNIT.";} }
		public static string PLANARFORCEUNIT { get {return ".PLANARFORCEUNIT.";} }
		public static string MODULUSOFELASTICITYUNIT { get {return ".MODULUSOFELASTICITYUNIT.";} }
		public static string SHEARMODULUSUNIT { get {return ".SHEARMODULUSUNIT.";} }
		public static string LINEARSTIFFNESSUNIT { get {return ".LINEARSTIFFNESSUNIT.";} }
		public static string ROTATIONALSTIFFNESSUNIT { get {return ".ROTATIONALSTIFFNESSUNIT.";} }
		public static string MODULUSOFSUBGRADEREACTIONUNIT { get {return ".MODULUSOFSUBGRADEREACTIONUNIT.";} }
		public static string ACCELERATIONUNIT { get {return ".ACCELERATIONUNIT.";} }
		public static string CURVATUREUNIT { get {return ".CURVATUREUNIT.";} }
		public static string HEATINGVALUEUNIT { get {return ".HEATINGVALUEUNIT.";} }
		public static string IONCONCENTRATIONUNIT { get {return ".IONCONCENTRATIONUNIT.";} }
		public static string LUMINOUSINTENSITYDISTRIBUTIONUNIT { get {return ".LUMINOUSINTENSITYDISTRIBUTIONUNIT.";} }
		public static string MASSPERLENGTHUNIT { get {return ".MASSPERLENGTHUNIT.";} }
		public static string MODULUSOFLINEARSUBGRADEREACTIONUNIT { get {return ".MODULUSOFLINEARSUBGRADEREACTIONUNIT.";} }
		public static string MODULUSOFROTATIONALSUBGRADEREACTIONUNIT { get {return ".MODULUSOFROTATIONALSUBGRADEREACTIONUNIT.";} }
		public static string PHUNIT { get {return ".PHUNIT.";} }
		public static string ROTATIONALMASSUNIT { get {return ".ROTATIONALMASSUNIT.";} }
		public static string SECTIONAREAINTEGRALUNIT { get {return ".SECTIONAREAINTEGRALUNIT.";} }
		public static string SECTIONMODULUSUNIT { get {return ".SECTIONMODULUSUNIT.";} }
		public static string SOUNDPOWERLEVELUNIT { get {return ".SOUNDPOWERLEVELUNIT.";} }
		public static string SOUNDPOWERUNIT { get {return ".SOUNDPOWERUNIT.";} }
		public static string SOUNDPRESSURELEVELUNIT { get {return ".SOUNDPRESSURELEVELUNIT.";} }
		public static string SOUNDPRESSUREUNIT { get {return ".SOUNDPRESSUREUNIT.";} }
		public static string TEMPERATUREGRADIENTUNIT { get {return ".TEMPERATUREGRADIENTUNIT.";} }
		public static string TEMPERATURERATEOFCHANGEUNIT { get {return ".TEMPERATURERATEOFCHANGEUNIT.";} }
		public static string THERMALEXPANSIONCOEFFICIENTUNIT { get {return ".THERMALEXPANSIONCOEFFICIENTUNIT.";} }
		public static string WARPINGCONSTANTUNIT { get {return ".WARPINGCONSTANTUNIT.";} }
		public static string WARPINGMOMENTUNIT { get {return ".WARPINGMOMENTUNIT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public string Value;
		public IfcDerivedUnitEnum() { Value = ".ANGULARVELOCITYUNIT.";}
		public IfcDerivedUnitEnum(string value) { Value = value; }
		public static implicit operator IfcDerivedUnitEnum(string value) { return new IfcDerivedUnitEnum(value);}
		public static implicit operator string(IfcDerivedUnitEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDirectionSenseEnum = ENUMERATION OF
	/// <para>TYPE IfcDirectionSenseEnum = ENUMERATION OF</para>
	/// <para>(POSITIVE</para>
	/// <para>,NEGATIVE);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDirectionSenseEnum
	{
		public static string POSITIVE { get {return ".POSITIVE.";} }
		public static string NEGATIVE { get {return ".NEGATIVE.";} }
		public string Value;
		public IfcDirectionSenseEnum() { Value = ".POSITIVE.";}
		public IfcDirectionSenseEnum(string value) { Value = value; }
		public static implicit operator IfcDirectionSenseEnum(string value) { return new IfcDirectionSenseEnum(value);}
		public static implicit operator string(IfcDirectionSenseEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDiscreteAccessoryTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDiscreteAccessoryTypeEnum = ENUMERATION OF</para>
	/// <para>(ANCHORPLATE</para>
	/// <para>,BRACKET</para>
	/// <para>,SHOE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDiscreteAccessoryTypeEnum
	{
		public static string ANCHORPLATE { get {return ".ANCHORPLATE.";} }
		public static string BRACKET { get {return ".BRACKET.";} }
		public static string SHOE { get {return ".SHOE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDiscreteAccessoryTypeEnum() { Value = ".ANCHORPLATE.";}
		public IfcDiscreteAccessoryTypeEnum(string value) { Value = value; }
		public static implicit operator IfcDiscreteAccessoryTypeEnum(string value) { return new IfcDiscreteAccessoryTypeEnum(value);}
		public static implicit operator string(IfcDiscreteAccessoryTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDistributionChamberElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDistributionChamberElementTypeEnum = ENUMERATION OF</para>
	/// <para>(FORMEDDUCT</para>
	/// <para>,INSPECTIONCHAMBER</para>
	/// <para>,INSPECTIONPIT</para>
	/// <para>,MANHOLE</para>
	/// <para>,METERCHAMBER</para>
	/// <para>,SUMP</para>
	/// <para>,TRENCH</para>
	/// <para>,VALVECHAMBER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDistributionChamberElementTypeEnum
	{
		public static string FORMEDDUCT { get {return ".FORMEDDUCT.";} }
		public static string INSPECTIONCHAMBER { get {return ".INSPECTIONCHAMBER.";} }
		public static string INSPECTIONPIT { get {return ".INSPECTIONPIT.";} }
		public static string MANHOLE { get {return ".MANHOLE.";} }
		public static string METERCHAMBER { get {return ".METERCHAMBER.";} }
		public static string SUMP { get {return ".SUMP.";} }
		public static string TRENCH { get {return ".TRENCH.";} }
		public static string VALVECHAMBER { get {return ".VALVECHAMBER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDistributionChamberElementTypeEnum() { Value = ".FORMEDDUCT.";}
		public IfcDistributionChamberElementTypeEnum(string value) { Value = value; }
		public static implicit operator IfcDistributionChamberElementTypeEnum(string value) { return new IfcDistributionChamberElementTypeEnum(value);}
		public static implicit operator string(IfcDistributionChamberElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDistributionPortTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDistributionPortTypeEnum = ENUMERATION OF</para>
	/// <para>(CABLE</para>
	/// <para>,CABLECARRIER</para>
	/// <para>,DUCT</para>
	/// <para>,PIPE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDistributionPortTypeEnum
	{
		public static string CABLE { get {return ".CABLE.";} }
		public static string CABLECARRIER { get {return ".CABLECARRIER.";} }
		public static string DUCT { get {return ".DUCT.";} }
		public static string PIPE { get {return ".PIPE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDistributionPortTypeEnum() { Value = ".CABLE.";}
		public IfcDistributionPortTypeEnum(string value) { Value = value; }
		public static implicit operator IfcDistributionPortTypeEnum(string value) { return new IfcDistributionPortTypeEnum(value);}
		public static implicit operator string(IfcDistributionPortTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDistributionSystemEnum = ENUMERATION OF
	/// <para>TYPE IfcDistributionSystemEnum = ENUMERATION OF</para>
	/// <para>(AIRCONDITIONING</para>
	/// <para>,AUDIOVISUAL</para>
	/// <para>,CHEMICAL</para>
	/// <para>,CHILLEDWATER</para>
	/// <para>,COMMUNICATION</para>
	/// <para>,COMPRESSEDAIR</para>
	/// <para>,CONDENSERWATER</para>
	/// <para>,CONTROL</para>
	/// <para>,CONVEYING</para>
	/// <para>,DATA</para>
	/// <para>,DISPOSAL</para>
	/// <para>,DOMESTICCOLDWATER</para>
	/// <para>,DOMESTICHOTWATER</para>
	/// <para>,DRAINAGE</para>
	/// <para>,EARTHING</para>
	/// <para>,ELECTRICAL</para>
	/// <para>,ELECTROACOUSTIC</para>
	/// <para>,EXHAUST</para>
	/// <para>,FIREPROTECTION</para>
	/// <para>,FUEL</para>
	/// <para>,GAS</para>
	/// <para>,HAZARDOUS</para>
	/// <para>,HEATING</para>
	/// <para>,LIGHTING</para>
	/// <para>,LIGHTNINGPROTECTION</para>
	/// <para>,MUNICIPALSOLIDWASTE</para>
	/// <para>,OIL</para>
	/// <para>,OPERATIONAL</para>
	/// <para>,POWERGENERATION</para>
	/// <para>,RAINWATER</para>
	/// <para>,REFRIGERATION</para>
	/// <para>,SECURITY</para>
	/// <para>,SEWAGE</para>
	/// <para>,SIGNAL</para>
	/// <para>,STORMWATER</para>
	/// <para>,TELEPHONE</para>
	/// <para>,TV</para>
	/// <para>,VACUUM</para>
	/// <para>,VENT</para>
	/// <para>,VENTILATION</para>
	/// <para>,WASTEWATER</para>
	/// <para>,WATERSUPPLY</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDistributionSystemEnum
	{
		public static string AIRCONDITIONING { get {return ".AIRCONDITIONING.";} }
		public static string AUDIOVISUAL { get {return ".AUDIOVISUAL.";} }
		public static string CHEMICAL { get {return ".CHEMICAL.";} }
		public static string CHILLEDWATER { get {return ".CHILLEDWATER.";} }
		public static string COMMUNICATION { get {return ".COMMUNICATION.";} }
		public static string COMPRESSEDAIR { get {return ".COMPRESSEDAIR.";} }
		public static string CONDENSERWATER { get {return ".CONDENSERWATER.";} }
		public static string CONTROL { get {return ".CONTROL.";} }
		public static string CONVEYING { get {return ".CONVEYING.";} }
		public static string DATA { get {return ".DATA.";} }
		public static string DISPOSAL { get {return ".DISPOSAL.";} }
		public static string DOMESTICCOLDWATER { get {return ".DOMESTICCOLDWATER.";} }
		public static string DOMESTICHOTWATER { get {return ".DOMESTICHOTWATER.";} }
		public static string DRAINAGE { get {return ".DRAINAGE.";} }
		public static string EARTHING { get {return ".EARTHING.";} }
		public static string ELECTRICAL { get {return ".ELECTRICAL.";} }
		public static string ELECTROACOUSTIC { get {return ".ELECTROACOUSTIC.";} }
		public static string EXHAUST { get {return ".EXHAUST.";} }
		public static string FIREPROTECTION { get {return ".FIREPROTECTION.";} }
		public static string FUEL { get {return ".FUEL.";} }
		public static string GAS { get {return ".GAS.";} }
		public static string HAZARDOUS { get {return ".HAZARDOUS.";} }
		public static string HEATING { get {return ".HEATING.";} }
		public static string LIGHTING { get {return ".LIGHTING.";} }
		public static string LIGHTNINGPROTECTION { get {return ".LIGHTNINGPROTECTION.";} }
		public static string MUNICIPALSOLIDWASTE { get {return ".MUNICIPALSOLIDWASTE.";} }
		public static string OIL { get {return ".OIL.";} }
		public static string OPERATIONAL { get {return ".OPERATIONAL.";} }
		public static string POWERGENERATION { get {return ".POWERGENERATION.";} }
		public static string RAINWATER { get {return ".RAINWATER.";} }
		public static string REFRIGERATION { get {return ".REFRIGERATION.";} }
		public static string SECURITY { get {return ".SECURITY.";} }
		public static string SEWAGE { get {return ".SEWAGE.";} }
		public static string SIGNAL { get {return ".SIGNAL.";} }
		public static string STORMWATER { get {return ".STORMWATER.";} }
		public static string TELEPHONE { get {return ".TELEPHONE.";} }
		public static string TV { get {return ".TV.";} }
		public static string VACUUM { get {return ".VACUUM.";} }
		public static string VENT { get {return ".VENT.";} }
		public static string VENTILATION { get {return ".VENTILATION.";} }
		public static string WASTEWATER { get {return ".WASTEWATER.";} }
		public static string WATERSUPPLY { get {return ".WATERSUPPLY.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDistributionSystemEnum() { Value = ".AIRCONDITIONING.";}
		public IfcDistributionSystemEnum(string value) { Value = value; }
		public static implicit operator IfcDistributionSystemEnum(string value) { return new IfcDistributionSystemEnum(value);}
		public static implicit operator string(IfcDistributionSystemEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDocumentConfidentialityEnum = ENUMERATION OF
	/// <para>TYPE IfcDocumentConfidentialityEnum = ENUMERATION OF</para>
	/// <para>(PUBLIC</para>
	/// <para>,RESTRICTED</para>
	/// <para>,CONFIDENTIAL</para>
	/// <para>,PERSONAL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDocumentConfidentialityEnum
	{
		public static string PUBLIC { get {return ".PUBLIC.";} }
		public static string RESTRICTED { get {return ".RESTRICTED.";} }
		public static string CONFIDENTIAL { get {return ".CONFIDENTIAL.";} }
		public static string PERSONAL { get {return ".PERSONAL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDocumentConfidentialityEnum() { Value = ".PUBLIC.";}
		public IfcDocumentConfidentialityEnum(string value) { Value = value; }
		public static implicit operator IfcDocumentConfidentialityEnum(string value) { return new IfcDocumentConfidentialityEnum(value);}
		public static implicit operator string(IfcDocumentConfidentialityEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDocumentStatusEnum = ENUMERATION OF
	/// <para>TYPE IfcDocumentStatusEnum = ENUMERATION OF</para>
	/// <para>(DRAFT</para>
	/// <para>,FINALDRAFT</para>
	/// <para>,FINAL</para>
	/// <para>,REVISION</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDocumentStatusEnum
	{
		public static string DRAFT { get {return ".DRAFT.";} }
		public static string FINALDRAFT { get {return ".FINALDRAFT.";} }
		public static string FINAL { get {return ".FINAL.";} }
		public static string REVISION { get {return ".REVISION.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDocumentStatusEnum() { Value = ".DRAFT.";}
		public IfcDocumentStatusEnum(string value) { Value = value; }
		public static implicit operator IfcDocumentStatusEnum(string value) { return new IfcDocumentStatusEnum(value);}
		public static implicit operator string(IfcDocumentStatusEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorPanelOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorPanelOperationEnum = ENUMERATION OF</para>
	/// <para>(SWINGING</para>
	/// <para>,DOUBLE_ACTING</para>
	/// <para>,SLIDING</para>
	/// <para>,FOLDING</para>
	/// <para>,REVOLVING</para>
	/// <para>,ROLLINGUP</para>
	/// <para>,FIXEDPANEL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorPanelOperationEnum
	{
		public static string SWINGING { get {return ".SWINGING.";} }
		public static string DOUBLE_ACTING { get {return ".DOUBLE_ACTING.";} }
		public static string SLIDING { get {return ".SLIDING.";} }
		public static string FOLDING { get {return ".FOLDING.";} }
		public static string REVOLVING { get {return ".REVOLVING.";} }
		public static string ROLLINGUP { get {return ".ROLLINGUP.";} }
		public static string FIXEDPANEL { get {return ".FIXEDPANEL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDoorPanelOperationEnum() { Value = ".SWINGING.";}
		public IfcDoorPanelOperationEnum(string value) { Value = value; }
		public static implicit operator IfcDoorPanelOperationEnum(string value) { return new IfcDoorPanelOperationEnum(value);}
		public static implicit operator string(IfcDoorPanelOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorPanelPositionEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorPanelPositionEnum = ENUMERATION OF</para>
	/// <para>(LEFT</para>
	/// <para>,MIDDLE</para>
	/// <para>,RIGHT</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorPanelPositionEnum
	{
		public static string LEFT { get {return ".LEFT.";} }
		public static string MIDDLE { get {return ".MIDDLE.";} }
		public static string RIGHT { get {return ".RIGHT.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDoorPanelPositionEnum() { Value = ".LEFT.";}
		public IfcDoorPanelPositionEnum(string value) { Value = value; }
		public static implicit operator IfcDoorPanelPositionEnum(string value) { return new IfcDoorPanelPositionEnum(value);}
		public static implicit operator string(IfcDoorPanelPositionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorStyleConstructionEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorStyleConstructionEnum = ENUMERATION OF</para>
	/// <para>(ALUMINIUM</para>
	/// <para>,HIGH_GRADE_STEEL</para>
	/// <para>,STEEL</para>
	/// <para>,WOOD</para>
	/// <para>,ALUMINIUM_WOOD</para>
	/// <para>,ALUMINIUM_PLASTIC</para>
	/// <para>,PLASTIC</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorStyleConstructionEnum
	{
		public static string ALUMINIUM { get {return ".ALUMINIUM.";} }
		public static string HIGH_GRADE_STEEL { get {return ".HIGH_GRADE_STEEL.";} }
		public static string STEEL { get {return ".STEEL.";} }
		public static string WOOD { get {return ".WOOD.";} }
		public static string ALUMINIUM_WOOD { get {return ".ALUMINIUM_WOOD.";} }
		public static string ALUMINIUM_PLASTIC { get {return ".ALUMINIUM_PLASTIC.";} }
		public static string PLASTIC { get {return ".PLASTIC.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDoorStyleConstructionEnum() { Value = ".ALUMINIUM.";}
		public IfcDoorStyleConstructionEnum(string value) { Value = value; }
		public static implicit operator IfcDoorStyleConstructionEnum(string value) { return new IfcDoorStyleConstructionEnum(value);}
		public static implicit operator string(IfcDoorStyleConstructionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorStyleOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorStyleOperationEnum = ENUMERATION OF</para>
	/// <para>(SINGLE_SWING_LEFT</para>
	/// <para>,SINGLE_SWING_RIGHT</para>
	/// <para>,DOUBLE_DOOR_SINGLE_SWING</para>
	/// <para>,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT</para>
	/// <para>,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT</para>
	/// <para>,DOUBLE_SWING_LEFT</para>
	/// <para>,DOUBLE_SWING_RIGHT</para>
	/// <para>,DOUBLE_DOOR_DOUBLE_SWING</para>
	/// <para>,SLIDING_TO_LEFT</para>
	/// <para>,SLIDING_TO_RIGHT</para>
	/// <para>,DOUBLE_DOOR_SLIDING</para>
	/// <para>,FOLDING_TO_LEFT</para>
	/// <para>,FOLDING_TO_RIGHT</para>
	/// <para>,DOUBLE_DOOR_FOLDING</para>
	/// <para>,REVOLVING</para>
	/// <para>,ROLLINGUP</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorStyleOperationEnum
	{
		public static string SINGLE_SWING_LEFT { get {return ".SINGLE_SWING_LEFT.";} }
		public static string SINGLE_SWING_RIGHT { get {return ".SINGLE_SWING_RIGHT.";} }
		public static string DOUBLE_DOOR_SINGLE_SWING { get {return ".DOUBLE_DOOR_SINGLE_SWING.";} }
		public static string DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT { get {return ".DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT.";} }
		public static string DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT { get {return ".DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT.";} }
		public static string DOUBLE_SWING_LEFT { get {return ".DOUBLE_SWING_LEFT.";} }
		public static string DOUBLE_SWING_RIGHT { get {return ".DOUBLE_SWING_RIGHT.";} }
		public static string DOUBLE_DOOR_DOUBLE_SWING { get {return ".DOUBLE_DOOR_DOUBLE_SWING.";} }
		public static string SLIDING_TO_LEFT { get {return ".SLIDING_TO_LEFT.";} }
		public static string SLIDING_TO_RIGHT { get {return ".SLIDING_TO_RIGHT.";} }
		public static string DOUBLE_DOOR_SLIDING { get {return ".DOUBLE_DOOR_SLIDING.";} }
		public static string FOLDING_TO_LEFT { get {return ".FOLDING_TO_LEFT.";} }
		public static string FOLDING_TO_RIGHT { get {return ".FOLDING_TO_RIGHT.";} }
		public static string DOUBLE_DOOR_FOLDING { get {return ".DOUBLE_DOOR_FOLDING.";} }
		public static string REVOLVING { get {return ".REVOLVING.";} }
		public static string ROLLINGUP { get {return ".ROLLINGUP.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDoorStyleOperationEnum() { Value = ".SINGLE_SWING_LEFT.";}
		public IfcDoorStyleOperationEnum(string value) { Value = value; }
		public static implicit operator IfcDoorStyleOperationEnum(string value) { return new IfcDoorStyleOperationEnum(value);}
		public static implicit operator string(IfcDoorStyleOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorTypeEnum = ENUMERATION OF</para>
	/// <para>(DOOR</para>
	/// <para>,GATE</para>
	/// <para>,TRAPDOOR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorTypeEnum
	{
		public static string DOOR { get {return ".DOOR.";} }
		public static string GATE { get {return ".GATE.";} }
		public static string TRAPDOOR { get {return ".TRAPDOOR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDoorTypeEnum() { Value = ".DOOR.";}
		public IfcDoorTypeEnum(string value) { Value = value; }
		public static implicit operator IfcDoorTypeEnum(string value) { return new IfcDoorTypeEnum(value);}
		public static implicit operator string(IfcDoorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDoorTypeOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcDoorTypeOperationEnum = ENUMERATION OF</para>
	/// <para>(SINGLE_SWING_LEFT</para>
	/// <para>,SINGLE_SWING_RIGHT</para>
	/// <para>,DOUBLE_DOOR_SINGLE_SWING</para>
	/// <para>,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT</para>
	/// <para>,DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT</para>
	/// <para>,DOUBLE_SWING_LEFT</para>
	/// <para>,DOUBLE_SWING_RIGHT</para>
	/// <para>,DOUBLE_DOOR_DOUBLE_SWING</para>
	/// <para>,SLIDING_TO_LEFT</para>
	/// <para>,SLIDING_TO_RIGHT</para>
	/// <para>,DOUBLE_DOOR_SLIDING</para>
	/// <para>,FOLDING_TO_LEFT</para>
	/// <para>,FOLDING_TO_RIGHT</para>
	/// <para>,DOUBLE_DOOR_FOLDING</para>
	/// <para>,REVOLVING</para>
	/// <para>,ROLLINGUP</para>
	/// <para>,SWING_FIXED_LEFT</para>
	/// <para>,SWING_FIXED_RIGHT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDoorTypeOperationEnum
	{
		public static string SINGLE_SWING_LEFT { get {return ".SINGLE_SWING_LEFT.";} }
		public static string SINGLE_SWING_RIGHT { get {return ".SINGLE_SWING_RIGHT.";} }
		public static string DOUBLE_DOOR_SINGLE_SWING { get {return ".DOUBLE_DOOR_SINGLE_SWING.";} }
		public static string DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT { get {return ".DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT.";} }
		public static string DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT { get {return ".DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT.";} }
		public static string DOUBLE_SWING_LEFT { get {return ".DOUBLE_SWING_LEFT.";} }
		public static string DOUBLE_SWING_RIGHT { get {return ".DOUBLE_SWING_RIGHT.";} }
		public static string DOUBLE_DOOR_DOUBLE_SWING { get {return ".DOUBLE_DOOR_DOUBLE_SWING.";} }
		public static string SLIDING_TO_LEFT { get {return ".SLIDING_TO_LEFT.";} }
		public static string SLIDING_TO_RIGHT { get {return ".SLIDING_TO_RIGHT.";} }
		public static string DOUBLE_DOOR_SLIDING { get {return ".DOUBLE_DOOR_SLIDING.";} }
		public static string FOLDING_TO_LEFT { get {return ".FOLDING_TO_LEFT.";} }
		public static string FOLDING_TO_RIGHT { get {return ".FOLDING_TO_RIGHT.";} }
		public static string DOUBLE_DOOR_FOLDING { get {return ".DOUBLE_DOOR_FOLDING.";} }
		public static string REVOLVING { get {return ".REVOLVING.";} }
		public static string ROLLINGUP { get {return ".ROLLINGUP.";} }
		public static string SWING_FIXED_LEFT { get {return ".SWING_FIXED_LEFT.";} }
		public static string SWING_FIXED_RIGHT { get {return ".SWING_FIXED_RIGHT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDoorTypeOperationEnum() { Value = ".SINGLE_SWING_LEFT.";}
		public IfcDoorTypeOperationEnum(string value) { Value = value; }
		public static implicit operator IfcDoorTypeOperationEnum(string value) { return new IfcDoorTypeOperationEnum(value);}
		public static implicit operator string(IfcDoorTypeOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDuctFittingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDuctFittingTypeEnum = ENUMERATION OF</para>
	/// <para>(BEND</para>
	/// <para>,CONNECTOR</para>
	/// <para>,ENTRY</para>
	/// <para>,EXIT</para>
	/// <para>,JUNCTION</para>
	/// <para>,OBSTRUCTION</para>
	/// <para>,TRANSITION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDuctFittingTypeEnum
	{
		public static string BEND { get {return ".BEND.";} }
		public static string CONNECTOR { get {return ".CONNECTOR.";} }
		public static string ENTRY { get {return ".ENTRY.";} }
		public static string EXIT { get {return ".EXIT.";} }
		public static string JUNCTION { get {return ".JUNCTION.";} }
		public static string OBSTRUCTION { get {return ".OBSTRUCTION.";} }
		public static string TRANSITION { get {return ".TRANSITION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDuctFittingTypeEnum() { Value = ".BEND.";}
		public IfcDuctFittingTypeEnum(string value) { Value = value; }
		public static implicit operator IfcDuctFittingTypeEnum(string value) { return new IfcDuctFittingTypeEnum(value);}
		public static implicit operator string(IfcDuctFittingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDuctSegmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDuctSegmentTypeEnum = ENUMERATION OF</para>
	/// <para>(RIGIDSEGMENT</para>
	/// <para>,FLEXIBLESEGMENT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDuctSegmentTypeEnum
	{
		public static string RIGIDSEGMENT { get {return ".RIGIDSEGMENT.";} }
		public static string FLEXIBLESEGMENT { get {return ".FLEXIBLESEGMENT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDuctSegmentTypeEnum() { Value = ".RIGIDSEGMENT.";}
		public IfcDuctSegmentTypeEnum(string value) { Value = value; }
		public static implicit operator IfcDuctSegmentTypeEnum(string value) { return new IfcDuctSegmentTypeEnum(value);}
		public static implicit operator string(IfcDuctSegmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcDuctSilencerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcDuctSilencerTypeEnum = ENUMERATION OF</para>
	/// <para>(FLATOVAL</para>
	/// <para>,RECTANGULAR</para>
	/// <para>,ROUND</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcDuctSilencerTypeEnum
	{
		public static string FLATOVAL { get {return ".FLATOVAL.";} }
		public static string RECTANGULAR { get {return ".RECTANGULAR.";} }
		public static string ROUND { get {return ".ROUND.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcDuctSilencerTypeEnum() { Value = ".FLATOVAL.";}
		public IfcDuctSilencerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcDuctSilencerTypeEnum(string value) { return new IfcDuctSilencerTypeEnum(value);}
		public static implicit operator string(IfcDuctSilencerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricApplianceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricApplianceTypeEnum = ENUMERATION OF</para>
	/// <para>(DISHWASHER</para>
	/// <para>,ELECTRICCOOKER</para>
	/// <para>,FREESTANDINGELECTRICHEATER</para>
	/// <para>,FREESTANDINGFAN</para>
	/// <para>,FREESTANDINGWATERHEATER</para>
	/// <para>,FREESTANDINGWATERCOOLER</para>
	/// <para>,FREEZER</para>
	/// <para>,FRIDGE_FREEZER</para>
	/// <para>,HANDDRYER</para>
	/// <para>,KITCHENMACHINE</para>
	/// <para>,MICROWAVE</para>
	/// <para>,PHOTOCOPIER</para>
	/// <para>,REFRIGERATOR</para>
	/// <para>,TUMBLEDRYER</para>
	/// <para>,VENDINGMACHINE</para>
	/// <para>,WASHINGMACHINE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricApplianceTypeEnum
	{
		public static string DISHWASHER { get {return ".DISHWASHER.";} }
		public static string ELECTRICCOOKER { get {return ".ELECTRICCOOKER.";} }
		public static string FREESTANDINGELECTRICHEATER { get {return ".FREESTANDINGELECTRICHEATER.";} }
		public static string FREESTANDINGFAN { get {return ".FREESTANDINGFAN.";} }
		public static string FREESTANDINGWATERHEATER { get {return ".FREESTANDINGWATERHEATER.";} }
		public static string FREESTANDINGWATERCOOLER { get {return ".FREESTANDINGWATERCOOLER.";} }
		public static string FREEZER { get {return ".FREEZER.";} }
		public static string FRIDGE_FREEZER { get {return ".FRIDGE_FREEZER.";} }
		public static string HANDDRYER { get {return ".HANDDRYER.";} }
		public static string KITCHENMACHINE { get {return ".KITCHENMACHINE.";} }
		public static string MICROWAVE { get {return ".MICROWAVE.";} }
		public static string PHOTOCOPIER { get {return ".PHOTOCOPIER.";} }
		public static string REFRIGERATOR { get {return ".REFRIGERATOR.";} }
		public static string TUMBLEDRYER { get {return ".TUMBLEDRYER.";} }
		public static string VENDINGMACHINE { get {return ".VENDINGMACHINE.";} }
		public static string WASHINGMACHINE { get {return ".WASHINGMACHINE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcElectricApplianceTypeEnum() { Value = ".DISHWASHER.";}
		public IfcElectricApplianceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcElectricApplianceTypeEnum(string value) { return new IfcElectricApplianceTypeEnum(value);}
		public static implicit operator string(IfcElectricApplianceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricDistributionBoardTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricDistributionBoardTypeEnum = ENUMERATION OF</para>
	/// <para>(CONSUMERUNIT</para>
	/// <para>,DISTRIBUTIONBOARD</para>
	/// <para>,MOTORCONTROLCENTRE</para>
	/// <para>,SWITCHBOARD</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricDistributionBoardTypeEnum
	{
		public static string CONSUMERUNIT { get {return ".CONSUMERUNIT.";} }
		public static string DISTRIBUTIONBOARD { get {return ".DISTRIBUTIONBOARD.";} }
		public static string MOTORCONTROLCENTRE { get {return ".MOTORCONTROLCENTRE.";} }
		public static string SWITCHBOARD { get {return ".SWITCHBOARD.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcElectricDistributionBoardTypeEnum() { Value = ".CONSUMERUNIT.";}
		public IfcElectricDistributionBoardTypeEnum(string value) { Value = value; }
		public static implicit operator IfcElectricDistributionBoardTypeEnum(string value) { return new IfcElectricDistributionBoardTypeEnum(value);}
		public static implicit operator string(IfcElectricDistributionBoardTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricFlowStorageDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricFlowStorageDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>(BATTERY</para>
	/// <para>,CAPACITORBANK</para>
	/// <para>,HARMONICFILTER</para>
	/// <para>,INDUCTORBANK</para>
	/// <para>,UPS</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricFlowStorageDeviceTypeEnum
	{
		public static string BATTERY { get {return ".BATTERY.";} }
		public static string CAPACITORBANK { get {return ".CAPACITORBANK.";} }
		public static string HARMONICFILTER { get {return ".HARMONICFILTER.";} }
		public static string INDUCTORBANK { get {return ".INDUCTORBANK.";} }
		public static string UPS { get {return ".UPS.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcElectricFlowStorageDeviceTypeEnum() { Value = ".BATTERY.";}
		public IfcElectricFlowStorageDeviceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcElectricFlowStorageDeviceTypeEnum(string value) { return new IfcElectricFlowStorageDeviceTypeEnum(value);}
		public static implicit operator string(IfcElectricFlowStorageDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricGeneratorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricGeneratorTypeEnum = ENUMERATION OF</para>
	/// <para>(CHP</para>
	/// <para>,ENGINEGENERATOR</para>
	/// <para>,STANDALONE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricGeneratorTypeEnum
	{
		public static string CHP { get {return ".CHP.";} }
		public static string ENGINEGENERATOR { get {return ".ENGINEGENERATOR.";} }
		public static string STANDALONE { get {return ".STANDALONE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcElectricGeneratorTypeEnum() { Value = ".CHP.";}
		public IfcElectricGeneratorTypeEnum(string value) { Value = value; }
		public static implicit operator IfcElectricGeneratorTypeEnum(string value) { return new IfcElectricGeneratorTypeEnum(value);}
		public static implicit operator string(IfcElectricGeneratorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricMotorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricMotorTypeEnum = ENUMERATION OF</para>
	/// <para>(DC</para>
	/// <para>,INDUCTION</para>
	/// <para>,POLYPHASE</para>
	/// <para>,RELUCTANCESYNCHRONOUS</para>
	/// <para>,SYNCHRONOUS</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricMotorTypeEnum
	{
		public static string DC { get {return ".DC.";} }
		public static string INDUCTION { get {return ".INDUCTION.";} }
		public static string POLYPHASE { get {return ".POLYPHASE.";} }
		public static string RELUCTANCESYNCHRONOUS { get {return ".RELUCTANCESYNCHRONOUS.";} }
		public static string SYNCHRONOUS { get {return ".SYNCHRONOUS.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcElectricMotorTypeEnum() { Value = ".DC.";}
		public IfcElectricMotorTypeEnum(string value) { Value = value; }
		public static implicit operator IfcElectricMotorTypeEnum(string value) { return new IfcElectricMotorTypeEnum(value);}
		public static implicit operator string(IfcElectricMotorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElectricTimeControlTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElectricTimeControlTypeEnum = ENUMERATION OF</para>
	/// <para>(TIMECLOCK</para>
	/// <para>,TIMEDELAY</para>
	/// <para>,RELAY</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElectricTimeControlTypeEnum
	{
		public static string TIMECLOCK { get {return ".TIMECLOCK.";} }
		public static string TIMEDELAY { get {return ".TIMEDELAY.";} }
		public static string RELAY { get {return ".RELAY.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcElectricTimeControlTypeEnum() { Value = ".TIMECLOCK.";}
		public IfcElectricTimeControlTypeEnum(string value) { Value = value; }
		public static implicit operator IfcElectricTimeControlTypeEnum(string value) { return new IfcElectricTimeControlTypeEnum(value);}
		public static implicit operator string(IfcElectricTimeControlTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElementAssemblyTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcElementAssemblyTypeEnum = ENUMERATION OF</para>
	/// <para>(ACCESSORY_ASSEMBLY</para>
	/// <para>,ARCH</para>
	/// <para>,BEAM_GRID</para>
	/// <para>,BRACED_FRAME</para>
	/// <para>,GIRDER</para>
	/// <para>,REINFORCEMENT_UNIT</para>
	/// <para>,RIGID_FRAME</para>
	/// <para>,SLAB_FIELD</para>
	/// <para>,TRUSS</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElementAssemblyTypeEnum
	{
		public static string ACCESSORY_ASSEMBLY { get {return ".ACCESSORY_ASSEMBLY.";} }
		public static string ARCH { get {return ".ARCH.";} }
		public static string BEAM_GRID { get {return ".BEAM_GRID.";} }
		public static string BRACED_FRAME { get {return ".BRACED_FRAME.";} }
		public static string GIRDER { get {return ".GIRDER.";} }
		public static string REINFORCEMENT_UNIT { get {return ".REINFORCEMENT_UNIT.";} }
		public static string RIGID_FRAME { get {return ".RIGID_FRAME.";} }
		public static string SLAB_FIELD { get {return ".SLAB_FIELD.";} }
		public static string TRUSS { get {return ".TRUSS.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcElementAssemblyTypeEnum() { Value = ".ACCESSORY_ASSEMBLY.";}
		public IfcElementAssemblyTypeEnum(string value) { Value = value; }
		public static implicit operator IfcElementAssemblyTypeEnum(string value) { return new IfcElementAssemblyTypeEnum(value);}
		public static implicit operator string(IfcElementAssemblyTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcElementCompositionEnum = ENUMERATION OF
	/// <para>TYPE IfcElementCompositionEnum = ENUMERATION OF</para>
	/// <para>(COMPLEX</para>
	/// <para>,ELEMENT</para>
	/// <para>,PARTIAL);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcElementCompositionEnum
	{
		public static string COMPLEX { get {return ".COMPLEX.";} }
		public static string ELEMENT { get {return ".ELEMENT.";} }
		public static string PARTIAL { get {return ".PARTIAL.";} }
		public string Value;
		public IfcElementCompositionEnum() { Value = ".COMPLEX.";}
		public IfcElementCompositionEnum(string value) { Value = value; }
		public static implicit operator IfcElementCompositionEnum(string value) { return new IfcElementCompositionEnum(value);}
		public static implicit operator string(IfcElementCompositionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEngineTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcEngineTypeEnum = ENUMERATION OF</para>
	/// <para>(EXTERNALCOMBUSTION</para>
	/// <para>,INTERNALCOMBUSTION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEngineTypeEnum
	{
		public static string EXTERNALCOMBUSTION { get {return ".EXTERNALCOMBUSTION.";} }
		public static string INTERNALCOMBUSTION { get {return ".INTERNALCOMBUSTION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcEngineTypeEnum() { Value = ".EXTERNALCOMBUSTION.";}
		public IfcEngineTypeEnum(string value) { Value = value; }
		public static implicit operator IfcEngineTypeEnum(string value) { return new IfcEngineTypeEnum(value);}
		public static implicit operator string(IfcEngineTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEvaporativeCoolerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcEvaporativeCoolerTypeEnum = ENUMERATION OF</para>
	/// <para>(DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER</para>
	/// <para>,DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER</para>
	/// <para>,DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER</para>
	/// <para>,DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER</para>
	/// <para>,DIRECTEVAPORATIVEAIRWASHER</para>
	/// <para>,INDIRECTEVAPORATIVEPACKAGEAIRCOOLER</para>
	/// <para>,INDIRECTEVAPORATIVEWETCOIL</para>
	/// <para>,INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER</para>
	/// <para>,INDIRECTDIRECTCOMBINATION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEvaporativeCoolerTypeEnum
	{
		public static string DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER { get {return ".DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER.";} }
		public static string DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER { get {return ".DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER.";} }
		public static string DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER { get {return ".DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER.";} }
		public static string DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER { get {return ".DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER.";} }
		public static string DIRECTEVAPORATIVEAIRWASHER { get {return ".DIRECTEVAPORATIVEAIRWASHER.";} }
		public static string INDIRECTEVAPORATIVEPACKAGEAIRCOOLER { get {return ".INDIRECTEVAPORATIVEPACKAGEAIRCOOLER.";} }
		public static string INDIRECTEVAPORATIVEWETCOIL { get {return ".INDIRECTEVAPORATIVEWETCOIL.";} }
		public static string INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER { get {return ".INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER.";} }
		public static string INDIRECTDIRECTCOMBINATION { get {return ".INDIRECTDIRECTCOMBINATION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcEvaporativeCoolerTypeEnum() { Value = ".DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER.";}
		public IfcEvaporativeCoolerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcEvaporativeCoolerTypeEnum(string value) { return new IfcEvaporativeCoolerTypeEnum(value);}
		public static implicit operator string(IfcEvaporativeCoolerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEvaporatorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcEvaporatorTypeEnum = ENUMERATION OF</para>
	/// <para>(DIRECTEXPANSION</para>
	/// <para>,DIRECTEXPANSIONSHELLANDTUBE</para>
	/// <para>,DIRECTEXPANSIONTUBEINTUBE</para>
	/// <para>,DIRECTEXPANSIONBRAZEDPLATE</para>
	/// <para>,FLOODEDSHELLANDTUBE</para>
	/// <para>,SHELLANDCOIL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEvaporatorTypeEnum
	{
		public static string DIRECTEXPANSION { get {return ".DIRECTEXPANSION.";} }
		public static string DIRECTEXPANSIONSHELLANDTUBE { get {return ".DIRECTEXPANSIONSHELLANDTUBE.";} }
		public static string DIRECTEXPANSIONTUBEINTUBE { get {return ".DIRECTEXPANSIONTUBEINTUBE.";} }
		public static string DIRECTEXPANSIONBRAZEDPLATE { get {return ".DIRECTEXPANSIONBRAZEDPLATE.";} }
		public static string FLOODEDSHELLANDTUBE { get {return ".FLOODEDSHELLANDTUBE.";} }
		public static string SHELLANDCOIL { get {return ".SHELLANDCOIL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcEvaporatorTypeEnum() { Value = ".DIRECTEXPANSION.";}
		public IfcEvaporatorTypeEnum(string value) { Value = value; }
		public static implicit operator IfcEvaporatorTypeEnum(string value) { return new IfcEvaporatorTypeEnum(value);}
		public static implicit operator string(IfcEvaporatorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEventTriggerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcEventTriggerTypeEnum = ENUMERATION OF</para>
	/// <para>(EVENTRULE</para>
	/// <para>,EVENTMESSAGE</para>
	/// <para>,EVENTTIME</para>
	/// <para>,EVENTCOMPLEX</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEventTriggerTypeEnum
	{
		public static string EVENTRULE { get {return ".EVENTRULE.";} }
		public static string EVENTMESSAGE { get {return ".EVENTMESSAGE.";} }
		public static string EVENTTIME { get {return ".EVENTTIME.";} }
		public static string EVENTCOMPLEX { get {return ".EVENTCOMPLEX.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcEventTriggerTypeEnum() { Value = ".EVENTRULE.";}
		public IfcEventTriggerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcEventTriggerTypeEnum(string value) { return new IfcEventTriggerTypeEnum(value);}
		public static implicit operator string(IfcEventTriggerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcEventTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcEventTypeEnum = ENUMERATION OF</para>
	/// <para>(STARTEVENT</para>
	/// <para>,ENDEVENT</para>
	/// <para>,INTERMEDIATEEVENT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcEventTypeEnum
	{
		public static string STARTEVENT { get {return ".STARTEVENT.";} }
		public static string ENDEVENT { get {return ".ENDEVENT.";} }
		public static string INTERMEDIATEEVENT { get {return ".INTERMEDIATEEVENT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcEventTypeEnum() { Value = ".STARTEVENT.";}
		public IfcEventTypeEnum(string value) { Value = value; }
		public static implicit operator IfcEventTypeEnum(string value) { return new IfcEventTypeEnum(value);}
		public static implicit operator string(IfcEventTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcExternalSpatialElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcExternalSpatialElementTypeEnum = ENUMERATION OF</para>
	/// <para>(EXTERNAL</para>
	/// <para>,EXTERNAL_EARTH</para>
	/// <para>,EXTERNAL_WATER</para>
	/// <para>,EXTERNAL_FIRE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcExternalSpatialElementTypeEnum
	{
		public static string EXTERNAL { get {return ".EXTERNAL.";} }
		public static string EXTERNAL_EARTH { get {return ".EXTERNAL_EARTH.";} }
		public static string EXTERNAL_WATER { get {return ".EXTERNAL_WATER.";} }
		public static string EXTERNAL_FIRE { get {return ".EXTERNAL_FIRE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcExternalSpatialElementTypeEnum() { Value = ".EXTERNAL.";}
		public IfcExternalSpatialElementTypeEnum(string value) { Value = value; }
		public static implicit operator IfcExternalSpatialElementTypeEnum(string value) { return new IfcExternalSpatialElementTypeEnum(value);}
		public static implicit operator string(IfcExternalSpatialElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFanTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFanTypeEnum = ENUMERATION OF</para>
	/// <para>(CENTRIFUGALFORWARDCURVED</para>
	/// <para>,CENTRIFUGALRADIAL</para>
	/// <para>,CENTRIFUGALBACKWARDINCLINEDCURVED</para>
	/// <para>,CENTRIFUGALAIRFOIL</para>
	/// <para>,TUBEAXIAL</para>
	/// <para>,VANEAXIAL</para>
	/// <para>,PROPELLORAXIAL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFanTypeEnum
	{
		public static string CENTRIFUGALFORWARDCURVED { get {return ".CENTRIFUGALFORWARDCURVED.";} }
		public static string CENTRIFUGALRADIAL { get {return ".CENTRIFUGALRADIAL.";} }
		public static string CENTRIFUGALBACKWARDINCLINEDCURVED { get {return ".CENTRIFUGALBACKWARDINCLINEDCURVED.";} }
		public static string CENTRIFUGALAIRFOIL { get {return ".CENTRIFUGALAIRFOIL.";} }
		public static string TUBEAXIAL { get {return ".TUBEAXIAL.";} }
		public static string VANEAXIAL { get {return ".VANEAXIAL.";} }
		public static string PROPELLORAXIAL { get {return ".PROPELLORAXIAL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcFanTypeEnum() { Value = ".CENTRIFUGALFORWARDCURVED.";}
		public IfcFanTypeEnum(string value) { Value = value; }
		public static implicit operator IfcFanTypeEnum(string value) { return new IfcFanTypeEnum(value);}
		public static implicit operator string(IfcFanTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFastenerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFastenerTypeEnum = ENUMERATION OF</para>
	/// <para>(GLUE</para>
	/// <para>,MORTAR</para>
	/// <para>,WELD</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFastenerTypeEnum
	{
		public static string GLUE { get {return ".GLUE.";} }
		public static string MORTAR { get {return ".MORTAR.";} }
		public static string WELD { get {return ".WELD.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcFastenerTypeEnum() { Value = ".GLUE.";}
		public IfcFastenerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcFastenerTypeEnum(string value) { return new IfcFastenerTypeEnum(value);}
		public static implicit operator string(IfcFastenerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFilterTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFilterTypeEnum = ENUMERATION OF</para>
	/// <para>(AIRPARTICLEFILTER</para>
	/// <para>,COMPRESSEDAIRFILTER</para>
	/// <para>,ODORFILTER</para>
	/// <para>,OILFILTER</para>
	/// <para>,STRAINER</para>
	/// <para>,WATERFILTER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFilterTypeEnum
	{
		public static string AIRPARTICLEFILTER { get {return ".AIRPARTICLEFILTER.";} }
		public static string COMPRESSEDAIRFILTER { get {return ".COMPRESSEDAIRFILTER.";} }
		public static string ODORFILTER { get {return ".ODORFILTER.";} }
		public static string OILFILTER { get {return ".OILFILTER.";} }
		public static string STRAINER { get {return ".STRAINER.";} }
		public static string WATERFILTER { get {return ".WATERFILTER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcFilterTypeEnum() { Value = ".AIRPARTICLEFILTER.";}
		public IfcFilterTypeEnum(string value) { Value = value; }
		public static implicit operator IfcFilterTypeEnum(string value) { return new IfcFilterTypeEnum(value);}
		public static implicit operator string(IfcFilterTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFireSuppressionTerminalTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFireSuppressionTerminalTypeEnum = ENUMERATION OF</para>
	/// <para>(BREECHINGINLET</para>
	/// <para>,FIREHYDRANT</para>
	/// <para>,HOSEREEL</para>
	/// <para>,SPRINKLER</para>
	/// <para>,SPRINKLERDEFLECTOR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFireSuppressionTerminalTypeEnum
	{
		public static string BREECHINGINLET { get {return ".BREECHINGINLET.";} }
		public static string FIREHYDRANT { get {return ".FIREHYDRANT.";} }
		public static string HOSEREEL { get {return ".HOSEREEL.";} }
		public static string SPRINKLER { get {return ".SPRINKLER.";} }
		public static string SPRINKLERDEFLECTOR { get {return ".SPRINKLERDEFLECTOR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcFireSuppressionTerminalTypeEnum() { Value = ".BREECHINGINLET.";}
		public IfcFireSuppressionTerminalTypeEnum(string value) { Value = value; }
		public static implicit operator IfcFireSuppressionTerminalTypeEnum(string value) { return new IfcFireSuppressionTerminalTypeEnum(value);}
		public static implicit operator string(IfcFireSuppressionTerminalTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFlowDirectionEnum = ENUMERATION OF
	/// <para>TYPE IfcFlowDirectionEnum = ENUMERATION OF</para>
	/// <para>(SOURCE</para>
	/// <para>,SINK</para>
	/// <para>,SOURCEANDSINK</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFlowDirectionEnum
	{
		public static string SOURCE { get {return ".SOURCE.";} }
		public static string SINK { get {return ".SINK.";} }
		public static string SOURCEANDSINK { get {return ".SOURCEANDSINK.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcFlowDirectionEnum() { Value = ".SOURCE.";}
		public IfcFlowDirectionEnum(string value) { Value = value; }
		public static implicit operator IfcFlowDirectionEnum(string value) { return new IfcFlowDirectionEnum(value);}
		public static implicit operator string(IfcFlowDirectionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFlowInstrumentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFlowInstrumentTypeEnum = ENUMERATION OF</para>
	/// <para>(PRESSUREGAUGE</para>
	/// <para>,THERMOMETER</para>
	/// <para>,AMMETER</para>
	/// <para>,FREQUENCYMETER</para>
	/// <para>,POWERFACTORMETER</para>
	/// <para>,PHASEANGLEMETER</para>
	/// <para>,VOLTMETER_PEAK</para>
	/// <para>,VOLTMETER_RMS</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFlowInstrumentTypeEnum
	{
		public static string PRESSUREGAUGE { get {return ".PRESSUREGAUGE.";} }
		public static string THERMOMETER { get {return ".THERMOMETER.";} }
		public static string AMMETER { get {return ".AMMETER.";} }
		public static string FREQUENCYMETER { get {return ".FREQUENCYMETER.";} }
		public static string POWERFACTORMETER { get {return ".POWERFACTORMETER.";} }
		public static string PHASEANGLEMETER { get {return ".PHASEANGLEMETER.";} }
		public static string VOLTMETER_PEAK { get {return ".VOLTMETER_PEAK.";} }
		public static string VOLTMETER_RMS { get {return ".VOLTMETER_RMS.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcFlowInstrumentTypeEnum() { Value = ".PRESSUREGAUGE.";}
		public IfcFlowInstrumentTypeEnum(string value) { Value = value; }
		public static implicit operator IfcFlowInstrumentTypeEnum(string value) { return new IfcFlowInstrumentTypeEnum(value);}
		public static implicit operator string(IfcFlowInstrumentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFlowMeterTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFlowMeterTypeEnum = ENUMERATION OF</para>
	/// <para>(ENERGYMETER</para>
	/// <para>,GASMETER</para>
	/// <para>,OILMETER</para>
	/// <para>,WATERMETER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFlowMeterTypeEnum
	{
		public static string ENERGYMETER { get {return ".ENERGYMETER.";} }
		public static string GASMETER { get {return ".GASMETER.";} }
		public static string OILMETER { get {return ".OILMETER.";} }
		public static string WATERMETER { get {return ".WATERMETER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcFlowMeterTypeEnum() { Value = ".ENERGYMETER.";}
		public IfcFlowMeterTypeEnum(string value) { Value = value; }
		public static implicit operator IfcFlowMeterTypeEnum(string value) { return new IfcFlowMeterTypeEnum(value);}
		public static implicit operator string(IfcFlowMeterTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFootingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFootingTypeEnum = ENUMERATION OF</para>
	/// <para>(CAISSON_FOUNDATION</para>
	/// <para>,FOOTING_BEAM</para>
	/// <para>,PAD_FOOTING</para>
	/// <para>,PILE_CAP</para>
	/// <para>,STRIP_FOOTING</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFootingTypeEnum
	{
		public static string CAISSON_FOUNDATION { get {return ".CAISSON_FOUNDATION.";} }
		public static string FOOTING_BEAM { get {return ".FOOTING_BEAM.";} }
		public static string PAD_FOOTING { get {return ".PAD_FOOTING.";} }
		public static string PILE_CAP { get {return ".PILE_CAP.";} }
		public static string STRIP_FOOTING { get {return ".STRIP_FOOTING.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcFootingTypeEnum() { Value = ".CAISSON_FOUNDATION.";}
		public IfcFootingTypeEnum(string value) { Value = value; }
		public static implicit operator IfcFootingTypeEnum(string value) { return new IfcFootingTypeEnum(value);}
		public static implicit operator string(IfcFootingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcFurnitureTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcFurnitureTypeEnum = ENUMERATION OF</para>
	/// <para>(CHAIR</para>
	/// <para>,TABLE</para>
	/// <para>,DESK</para>
	/// <para>,BED</para>
	/// <para>,FILECABINET</para>
	/// <para>,SHELF</para>
	/// <para>,SOFA</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcFurnitureTypeEnum
	{
		public static string CHAIR { get {return ".CHAIR.";} }
		public static string TABLE { get {return ".TABLE.";} }
		public static string DESK { get {return ".DESK.";} }
		public static string BED { get {return ".BED.";} }
		public static string FILECABINET { get {return ".FILECABINET.";} }
		public static string SHELF { get {return ".SHELF.";} }
		public static string SOFA { get {return ".SOFA.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcFurnitureTypeEnum() { Value = ".CHAIR.";}
		public IfcFurnitureTypeEnum(string value) { Value = value; }
		public static implicit operator IfcFurnitureTypeEnum(string value) { return new IfcFurnitureTypeEnum(value);}
		public static implicit operator string(IfcFurnitureTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGeographicElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcGeographicElementTypeEnum = ENUMERATION OF</para>
	/// <para>(TERRAIN</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGeographicElementTypeEnum
	{
		public static string TERRAIN { get {return ".TERRAIN.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcGeographicElementTypeEnum() { Value = ".TERRAIN.";}
		public IfcGeographicElementTypeEnum(string value) { Value = value; }
		public static implicit operator IfcGeographicElementTypeEnum(string value) { return new IfcGeographicElementTypeEnum(value);}
		public static implicit operator string(IfcGeographicElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGeometricProjectionEnum = ENUMERATION OF
	/// <para>TYPE IfcGeometricProjectionEnum = ENUMERATION OF</para>
	/// <para>(GRAPH_VIEW</para>
	/// <para>,SKETCH_VIEW</para>
	/// <para>,MODEL_VIEW</para>
	/// <para>,PLAN_VIEW</para>
	/// <para>,REFLECTED_PLAN_VIEW</para>
	/// <para>,SECTION_VIEW</para>
	/// <para>,ELEVATION_VIEW</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGeometricProjectionEnum
	{
		public static string GRAPH_VIEW { get {return ".GRAPH_VIEW.";} }
		public static string SKETCH_VIEW { get {return ".SKETCH_VIEW.";} }
		public static string MODEL_VIEW { get {return ".MODEL_VIEW.";} }
		public static string PLAN_VIEW { get {return ".PLAN_VIEW.";} }
		public static string REFLECTED_PLAN_VIEW { get {return ".REFLECTED_PLAN_VIEW.";} }
		public static string SECTION_VIEW { get {return ".SECTION_VIEW.";} }
		public static string ELEVATION_VIEW { get {return ".ELEVATION_VIEW.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcGeometricProjectionEnum() { Value = ".GRAPH_VIEW.";}
		public IfcGeometricProjectionEnum(string value) { Value = value; }
		public static implicit operator IfcGeometricProjectionEnum(string value) { return new IfcGeometricProjectionEnum(value);}
		public static implicit operator string(IfcGeometricProjectionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGlobalOrLocalEnum = ENUMERATION OF
	/// <para>TYPE IfcGlobalOrLocalEnum = ENUMERATION OF</para>
	/// <para>(GLOBAL_COORDS</para>
	/// <para>,LOCAL_COORDS);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGlobalOrLocalEnum
	{
		public static string GLOBAL_COORDS { get {return ".GLOBAL_COORDS.";} }
		public static string LOCAL_COORDS { get {return ".LOCAL_COORDS.";} }
		public string Value;
		public IfcGlobalOrLocalEnum() { Value = ".GLOBAL_COORDS.";}
		public IfcGlobalOrLocalEnum(string value) { Value = value; }
		public static implicit operator IfcGlobalOrLocalEnum(string value) { return new IfcGlobalOrLocalEnum(value);}
		public static implicit operator string(IfcGlobalOrLocalEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcGridTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcGridTypeEnum = ENUMERATION OF</para>
	/// <para>(RECTANGULAR</para>
	/// <para>,RADIAL</para>
	/// <para>,TRIANGULAR</para>
	/// <para>,IRREGULAR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcGridTypeEnum
	{
		public static string RECTANGULAR { get {return ".RECTANGULAR.";} }
		public static string RADIAL { get {return ".RADIAL.";} }
		public static string TRIANGULAR { get {return ".TRIANGULAR.";} }
		public static string IRREGULAR { get {return ".IRREGULAR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcGridTypeEnum() { Value = ".RECTANGULAR.";}
		public IfcGridTypeEnum(string value) { Value = value; }
		public static implicit operator IfcGridTypeEnum(string value) { return new IfcGridTypeEnum(value);}
		public static implicit operator string(IfcGridTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcHeatExchangerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcHeatExchangerTypeEnum = ENUMERATION OF</para>
	/// <para>(PLATE</para>
	/// <para>,SHELLANDTUBE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcHeatExchangerTypeEnum
	{
		public static string PLATE { get {return ".PLATE.";} }
		public static string SHELLANDTUBE { get {return ".SHELLANDTUBE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcHeatExchangerTypeEnum() { Value = ".PLATE.";}
		public IfcHeatExchangerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcHeatExchangerTypeEnum(string value) { return new IfcHeatExchangerTypeEnum(value);}
		public static implicit operator string(IfcHeatExchangerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcHumidifierTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcHumidifierTypeEnum = ENUMERATION OF</para>
	/// <para>(STEAMINJECTION</para>
	/// <para>,ADIABATICAIRWASHER</para>
	/// <para>,ADIABATICPAN</para>
	/// <para>,ADIABATICWETTEDELEMENT</para>
	/// <para>,ADIABATICATOMIZING</para>
	/// <para>,ADIABATICULTRASONIC</para>
	/// <para>,ADIABATICRIGIDMEDIA</para>
	/// <para>,ADIABATICCOMPRESSEDAIRNOZZLE</para>
	/// <para>,ASSISTEDELECTRIC</para>
	/// <para>,ASSISTEDNATURALGAS</para>
	/// <para>,ASSISTEDPROPANE</para>
	/// <para>,ASSISTEDBUTANE</para>
	/// <para>,ASSISTEDSTEAM</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcHumidifierTypeEnum
	{
		public static string STEAMINJECTION { get {return ".STEAMINJECTION.";} }
		public static string ADIABATICAIRWASHER { get {return ".ADIABATICAIRWASHER.";} }
		public static string ADIABATICPAN { get {return ".ADIABATICPAN.";} }
		public static string ADIABATICWETTEDELEMENT { get {return ".ADIABATICWETTEDELEMENT.";} }
		public static string ADIABATICATOMIZING { get {return ".ADIABATICATOMIZING.";} }
		public static string ADIABATICULTRASONIC { get {return ".ADIABATICULTRASONIC.";} }
		public static string ADIABATICRIGIDMEDIA { get {return ".ADIABATICRIGIDMEDIA.";} }
		public static string ADIABATICCOMPRESSEDAIRNOZZLE { get {return ".ADIABATICCOMPRESSEDAIRNOZZLE.";} }
		public static string ASSISTEDELECTRIC { get {return ".ASSISTEDELECTRIC.";} }
		public static string ASSISTEDNATURALGAS { get {return ".ASSISTEDNATURALGAS.";} }
		public static string ASSISTEDPROPANE { get {return ".ASSISTEDPROPANE.";} }
		public static string ASSISTEDBUTANE { get {return ".ASSISTEDBUTANE.";} }
		public static string ASSISTEDSTEAM { get {return ".ASSISTEDSTEAM.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcHumidifierTypeEnum() { Value = ".STEAMINJECTION.";}
		public IfcHumidifierTypeEnum(string value) { Value = value; }
		public static implicit operator IfcHumidifierTypeEnum(string value) { return new IfcHumidifierTypeEnum(value);}
		public static implicit operator string(IfcHumidifierTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInterceptorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcInterceptorTypeEnum = ENUMERATION OF</para>
	/// <para>(CYCLONIC</para>
	/// <para>,GREASE</para>
	/// <para>,OIL</para>
	/// <para>,PETROL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInterceptorTypeEnum
	{
		public static string CYCLONIC { get {return ".CYCLONIC.";} }
		public static string GREASE { get {return ".GREASE.";} }
		public static string OIL { get {return ".OIL.";} }
		public static string PETROL { get {return ".PETROL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcInterceptorTypeEnum() { Value = ".CYCLONIC.";}
		public IfcInterceptorTypeEnum(string value) { Value = value; }
		public static implicit operator IfcInterceptorTypeEnum(string value) { return new IfcInterceptorTypeEnum(value);}
		public static implicit operator string(IfcInterceptorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInternalOrExternalEnum = ENUMERATION OF
	/// <para>TYPE IfcInternalOrExternalEnum = ENUMERATION OF</para>
	/// <para>(INTERNAL</para>
	/// <para>,EXTERNAL</para>
	/// <para>,EXTERNAL_EARTH</para>
	/// <para>,EXTERNAL_WATER</para>
	/// <para>,EXTERNAL_FIRE</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInternalOrExternalEnum
	{
		public static string INTERNAL { get {return ".INTERNAL.";} }
		public static string EXTERNAL { get {return ".EXTERNAL.";} }
		public static string EXTERNAL_EARTH { get {return ".EXTERNAL_EARTH.";} }
		public static string EXTERNAL_WATER { get {return ".EXTERNAL_WATER.";} }
		public static string EXTERNAL_FIRE { get {return ".EXTERNAL_FIRE.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcInternalOrExternalEnum() { Value = ".INTERNAL.";}
		public IfcInternalOrExternalEnum(string value) { Value = value; }
		public static implicit operator IfcInternalOrExternalEnum(string value) { return new IfcInternalOrExternalEnum(value);}
		public static implicit operator string(IfcInternalOrExternalEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcInventoryTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcInventoryTypeEnum = ENUMERATION OF</para>
	/// <para>(ASSETINVENTORY</para>
	/// <para>,SPACEINVENTORY</para>
	/// <para>,FURNITUREINVENTORY</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcInventoryTypeEnum
	{
		public static string ASSETINVENTORY { get {return ".ASSETINVENTORY.";} }
		public static string SPACEINVENTORY { get {return ".SPACEINVENTORY.";} }
		public static string FURNITUREINVENTORY { get {return ".FURNITUREINVENTORY.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcInventoryTypeEnum() { Value = ".ASSETINVENTORY.";}
		public IfcInventoryTypeEnum(string value) { Value = value; }
		public static implicit operator IfcInventoryTypeEnum(string value) { return new IfcInventoryTypeEnum(value);}
		public static implicit operator string(IfcInventoryTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcJunctionBoxTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcJunctionBoxTypeEnum = ENUMERATION OF</para>
	/// <para>(DATA</para>
	/// <para>,POWER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcJunctionBoxTypeEnum
	{
		public static string DATA { get {return ".DATA.";} }
		public static string POWER { get {return ".POWER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcJunctionBoxTypeEnum() { Value = ".DATA.";}
		public IfcJunctionBoxTypeEnum(string value) { Value = value; }
		public static implicit operator IfcJunctionBoxTypeEnum(string value) { return new IfcJunctionBoxTypeEnum(value);}
		public static implicit operator string(IfcJunctionBoxTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcKnotType = ENUMERATION OF
	/// <para>TYPE IfcKnotType = ENUMERATION OF</para>
	/// <para>(UNIFORM_KNOTS</para>
	/// <para>,QUASI_UNIFORM_KNOTS</para>
	/// <para>,PIECEWISE_BEZIER_KNOTS</para>
	/// <para>,UNSPECIFIED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcKnotType
	{
		public static string UNIFORM_KNOTS { get {return ".UNIFORM_KNOTS.";} }
		public static string QUASI_UNIFORM_KNOTS { get {return ".QUASI_UNIFORM_KNOTS.";} }
		public static string PIECEWISE_BEZIER_KNOTS { get {return ".PIECEWISE_BEZIER_KNOTS.";} }
		public static string UNSPECIFIED { get {return ".UNSPECIFIED.";} }
		public string Value;
		public IfcKnotType() { Value = ".UNIFORM_KNOTS.";}
		public IfcKnotType(string value) { Value = value; }
		public static implicit operator IfcKnotType(string value) { return new IfcKnotType(value);}
		public static implicit operator string(IfcKnotType value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLaborResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcLaborResourceTypeEnum = ENUMERATION OF</para>
	/// <para>(ADMINISTRATION</para>
	/// <para>,CARPENTRY</para>
	/// <para>,CLEANING</para>
	/// <para>,CONCRETE</para>
	/// <para>,DRYWALL</para>
	/// <para>,ELECTRIC</para>
	/// <para>,FINISHING</para>
	/// <para>,FLOORING</para>
	/// <para>,GENERAL</para>
	/// <para>,HVAC</para>
	/// <para>,LANDSCAPING</para>
	/// <para>,MASONRY</para>
	/// <para>,PAINTING</para>
	/// <para>,PAVING</para>
	/// <para>,PLUMBING</para>
	/// <para>,ROOFING</para>
	/// <para>,SITEGRADING</para>
	/// <para>,STEELWORK</para>
	/// <para>,SURVEYING</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLaborResourceTypeEnum
	{
		public static string ADMINISTRATION { get {return ".ADMINISTRATION.";} }
		public static string CARPENTRY { get {return ".CARPENTRY.";} }
		public static string CLEANING { get {return ".CLEANING.";} }
		public static string CONCRETE { get {return ".CONCRETE.";} }
		public static string DRYWALL { get {return ".DRYWALL.";} }
		public static string ELECTRIC { get {return ".ELECTRIC.";} }
		public static string FINISHING { get {return ".FINISHING.";} }
		public static string FLOORING { get {return ".FLOORING.";} }
		public static string GENERAL { get {return ".GENERAL.";} }
		public static string HVAC { get {return ".HVAC.";} }
		public static string LANDSCAPING { get {return ".LANDSCAPING.";} }
		public static string MASONRY { get {return ".MASONRY.";} }
		public static string PAINTING { get {return ".PAINTING.";} }
		public static string PAVING { get {return ".PAVING.";} }
		public static string PLUMBING { get {return ".PLUMBING.";} }
		public static string ROOFING { get {return ".ROOFING.";} }
		public static string SITEGRADING { get {return ".SITEGRADING.";} }
		public static string STEELWORK { get {return ".STEELWORK.";} }
		public static string SURVEYING { get {return ".SURVEYING.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcLaborResourceTypeEnum() { Value = ".ADMINISTRATION.";}
		public IfcLaborResourceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcLaborResourceTypeEnum(string value) { return new IfcLaborResourceTypeEnum(value);}
		public static implicit operator string(IfcLaborResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLampTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcLampTypeEnum = ENUMERATION OF</para>
	/// <para>(COMPACTFLUORESCENT</para>
	/// <para>,FLUORESCENT</para>
	/// <para>,HALOGEN</para>
	/// <para>,HIGHPRESSUREMERCURY</para>
	/// <para>,HIGHPRESSURESODIUM</para>
	/// <para>,LED</para>
	/// <para>,METALHALIDE</para>
	/// <para>,OLED</para>
	/// <para>,TUNGSTENFILAMENT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLampTypeEnum
	{
		public static string COMPACTFLUORESCENT { get {return ".COMPACTFLUORESCENT.";} }
		public static string FLUORESCENT { get {return ".FLUORESCENT.";} }
		public static string HALOGEN { get {return ".HALOGEN.";} }
		public static string HIGHPRESSUREMERCURY { get {return ".HIGHPRESSUREMERCURY.";} }
		public static string HIGHPRESSURESODIUM { get {return ".HIGHPRESSURESODIUM.";} }
		public static string LED { get {return ".LED.";} }
		public static string METALHALIDE { get {return ".METALHALIDE.";} }
		public static string OLED { get {return ".OLED.";} }
		public static string TUNGSTENFILAMENT { get {return ".TUNGSTENFILAMENT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcLampTypeEnum() { Value = ".COMPACTFLUORESCENT.";}
		public IfcLampTypeEnum(string value) { Value = value; }
		public static implicit operator IfcLampTypeEnum(string value) { return new IfcLampTypeEnum(value);}
		public static implicit operator string(IfcLampTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLayerSetDirectionEnum = ENUMERATION OF
	/// <para>TYPE IfcLayerSetDirectionEnum = ENUMERATION OF</para>
	/// <para>(AXIS1</para>
	/// <para>,AXIS2</para>
	/// <para>,AXIS3);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLayerSetDirectionEnum
	{
		public static string AXIS1 { get {return ".AXIS1.";} }
		public static string AXIS2 { get {return ".AXIS2.";} }
		public static string AXIS3 { get {return ".AXIS3.";} }
		public string Value;
		public IfcLayerSetDirectionEnum() { Value = ".AXIS1.";}
		public IfcLayerSetDirectionEnum(string value) { Value = value; }
		public static implicit operator IfcLayerSetDirectionEnum(string value) { return new IfcLayerSetDirectionEnum(value);}
		public static implicit operator string(IfcLayerSetDirectionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLightDistributionCurveEnum = ENUMERATION OF
	/// <para>TYPE IfcLightDistributionCurveEnum = ENUMERATION OF</para>
	/// <para>(TYPE_A</para>
	/// <para>,TYPE_B</para>
	/// <para>,TYPE_C</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLightDistributionCurveEnum
	{
		public static string TYPE_A { get {return ".TYPE_A.";} }
		public static string TYPE_B { get {return ".TYPE_B.";} }
		public static string TYPE_C { get {return ".TYPE_C.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcLightDistributionCurveEnum() { Value = ".TYPE_A.";}
		public IfcLightDistributionCurveEnum(string value) { Value = value; }
		public static implicit operator IfcLightDistributionCurveEnum(string value) { return new IfcLightDistributionCurveEnum(value);}
		public static implicit operator string(IfcLightDistributionCurveEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLightEmissionSourceEnum = ENUMERATION OF
	/// <para>TYPE IfcLightEmissionSourceEnum = ENUMERATION OF</para>
	/// <para>(COMPACTFLUORESCENT</para>
	/// <para>,FLUORESCENT</para>
	/// <para>,HIGHPRESSUREMERCURY</para>
	/// <para>,HIGHPRESSURESODIUM</para>
	/// <para>,LIGHTEMITTINGDIODE</para>
	/// <para>,LOWPRESSURESODIUM</para>
	/// <para>,LOWVOLTAGEHALOGEN</para>
	/// <para>,MAINVOLTAGEHALOGEN</para>
	/// <para>,METALHALIDE</para>
	/// <para>,TUNGSTENFILAMENT</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLightEmissionSourceEnum
	{
		public static string COMPACTFLUORESCENT { get {return ".COMPACTFLUORESCENT.";} }
		public static string FLUORESCENT { get {return ".FLUORESCENT.";} }
		public static string HIGHPRESSUREMERCURY { get {return ".HIGHPRESSUREMERCURY.";} }
		public static string HIGHPRESSURESODIUM { get {return ".HIGHPRESSURESODIUM.";} }
		public static string LIGHTEMITTINGDIODE { get {return ".LIGHTEMITTINGDIODE.";} }
		public static string LOWPRESSURESODIUM { get {return ".LOWPRESSURESODIUM.";} }
		public static string LOWVOLTAGEHALOGEN { get {return ".LOWVOLTAGEHALOGEN.";} }
		public static string MAINVOLTAGEHALOGEN { get {return ".MAINVOLTAGEHALOGEN.";} }
		public static string METALHALIDE { get {return ".METALHALIDE.";} }
		public static string TUNGSTENFILAMENT { get {return ".TUNGSTENFILAMENT.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcLightEmissionSourceEnum() { Value = ".COMPACTFLUORESCENT.";}
		public IfcLightEmissionSourceEnum(string value) { Value = value; }
		public static implicit operator IfcLightEmissionSourceEnum(string value) { return new IfcLightEmissionSourceEnum(value);}
		public static implicit operator string(IfcLightEmissionSourceEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLightFixtureTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcLightFixtureTypeEnum = ENUMERATION OF</para>
	/// <para>(POINTSOURCE</para>
	/// <para>,DIRECTIONSOURCE</para>
	/// <para>,SECURITYLIGHTING</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLightFixtureTypeEnum
	{
		public static string POINTSOURCE { get {return ".POINTSOURCE.";} }
		public static string DIRECTIONSOURCE { get {return ".DIRECTIONSOURCE.";} }
		public static string SECURITYLIGHTING { get {return ".SECURITYLIGHTING.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcLightFixtureTypeEnum() { Value = ".POINTSOURCE.";}
		public IfcLightFixtureTypeEnum(string value) { Value = value; }
		public static implicit operator IfcLightFixtureTypeEnum(string value) { return new IfcLightFixtureTypeEnum(value);}
		public static implicit operator string(IfcLightFixtureTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLoadGroupTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcLoadGroupTypeEnum = ENUMERATION OF</para>
	/// <para>(LOAD_GROUP</para>
	/// <para>,LOAD_CASE</para>
	/// <para>,LOAD_COMBINATION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLoadGroupTypeEnum
	{
		public static string LOAD_GROUP { get {return ".LOAD_GROUP.";} }
		public static string LOAD_CASE { get {return ".LOAD_CASE.";} }
		public static string LOAD_COMBINATION { get {return ".LOAD_COMBINATION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcLoadGroupTypeEnum() { Value = ".LOAD_GROUP.";}
		public IfcLoadGroupTypeEnum(string value) { Value = value; }
		public static implicit operator IfcLoadGroupTypeEnum(string value) { return new IfcLoadGroupTypeEnum(value);}
		public static implicit operator string(IfcLoadGroupTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcLogicalOperatorEnum = ENUMERATION OF
	/// <para>TYPE IfcLogicalOperatorEnum = ENUMERATION OF</para>
	/// <para>(LOGICALAND</para>
	/// <para>,LOGICALOR</para>
	/// <para>,LOGICALXOR</para>
	/// <para>,LOGICALNOTAND</para>
	/// <para>,LOGICALNOTOR);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcLogicalOperatorEnum
	{
		public static string LOGICALAND { get {return ".LOGICALAND.";} }
		public static string LOGICALOR { get {return ".LOGICALOR.";} }
		public static string LOGICALXOR { get {return ".LOGICALXOR.";} }
		public static string LOGICALNOTAND { get {return ".LOGICALNOTAND.";} }
		public static string LOGICALNOTOR { get {return ".LOGICALNOTOR.";} }
		public string Value;
		public IfcLogicalOperatorEnum() { Value = ".LOGICALAND.";}
		public IfcLogicalOperatorEnum(string value) { Value = value; }
		public static implicit operator IfcLogicalOperatorEnum(string value) { return new IfcLogicalOperatorEnum(value);}
		public static implicit operator string(IfcLogicalOperatorEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMechanicalFastenerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcMechanicalFastenerTypeEnum = ENUMERATION OF</para>
	/// <para>(ANCHORBOLT</para>
	/// <para>,BOLT</para>
	/// <para>,DOWEL</para>
	/// <para>,NAIL</para>
	/// <para>,NAILPLATE</para>
	/// <para>,RIVET</para>
	/// <para>,SCREW</para>
	/// <para>,SHEARCONNECTOR</para>
	/// <para>,STAPLE</para>
	/// <para>,STUDSHEARCONNECTOR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMechanicalFastenerTypeEnum
	{
		public static string ANCHORBOLT { get {return ".ANCHORBOLT.";} }
		public static string BOLT { get {return ".BOLT.";} }
		public static string DOWEL { get {return ".DOWEL.";} }
		public static string NAIL { get {return ".NAIL.";} }
		public static string NAILPLATE { get {return ".NAILPLATE.";} }
		public static string RIVET { get {return ".RIVET.";} }
		public static string SCREW { get {return ".SCREW.";} }
		public static string SHEARCONNECTOR { get {return ".SHEARCONNECTOR.";} }
		public static string STAPLE { get {return ".STAPLE.";} }
		public static string STUDSHEARCONNECTOR { get {return ".STUDSHEARCONNECTOR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcMechanicalFastenerTypeEnum() { Value = ".ANCHORBOLT.";}
		public IfcMechanicalFastenerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcMechanicalFastenerTypeEnum(string value) { return new IfcMechanicalFastenerTypeEnum(value);}
		public static implicit operator string(IfcMechanicalFastenerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMedicalDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcMedicalDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>(AIRSTATION</para>
	/// <para>,FEEDAIRUNIT</para>
	/// <para>,OXYGENGENERATOR</para>
	/// <para>,OXYGENPLANT</para>
	/// <para>,VACUUMSTATION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMedicalDeviceTypeEnum
	{
		public static string AIRSTATION { get {return ".AIRSTATION.";} }
		public static string FEEDAIRUNIT { get {return ".FEEDAIRUNIT.";} }
		public static string OXYGENGENERATOR { get {return ".OXYGENGENERATOR.";} }
		public static string OXYGENPLANT { get {return ".OXYGENPLANT.";} }
		public static string VACUUMSTATION { get {return ".VACUUMSTATION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcMedicalDeviceTypeEnum() { Value = ".AIRSTATION.";}
		public IfcMedicalDeviceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcMedicalDeviceTypeEnum(string value) { return new IfcMedicalDeviceTypeEnum(value);}
		public static implicit operator string(IfcMedicalDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMemberTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcMemberTypeEnum = ENUMERATION OF</para>
	/// <para>(BRACE</para>
	/// <para>,CHORD</para>
	/// <para>,COLLAR</para>
	/// <para>,MEMBER</para>
	/// <para>,MULLION</para>
	/// <para>,PLATE</para>
	/// <para>,POST</para>
	/// <para>,PURLIN</para>
	/// <para>,RAFTER</para>
	/// <para>,STRINGER</para>
	/// <para>,STRUT</para>
	/// <para>,STUD</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMemberTypeEnum
	{
		public static string BRACE { get {return ".BRACE.";} }
		public static string CHORD { get {return ".CHORD.";} }
		public static string COLLAR { get {return ".COLLAR.";} }
		public static string MEMBER { get {return ".MEMBER.";} }
		public static string MULLION { get {return ".MULLION.";} }
		public static string PLATE { get {return ".PLATE.";} }
		public static string POST { get {return ".POST.";} }
		public static string PURLIN { get {return ".PURLIN.";} }
		public static string RAFTER { get {return ".RAFTER.";} }
		public static string STRINGER { get {return ".STRINGER.";} }
		public static string STRUT { get {return ".STRUT.";} }
		public static string STUD { get {return ".STUD.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcMemberTypeEnum() { Value = ".BRACE.";}
		public IfcMemberTypeEnum(string value) { Value = value; }
		public static implicit operator IfcMemberTypeEnum(string value) { return new IfcMemberTypeEnum(value);}
		public static implicit operator string(IfcMemberTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcMotorConnectionTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcMotorConnectionTypeEnum = ENUMERATION OF</para>
	/// <para>(BELTDRIVE</para>
	/// <para>,COUPLING</para>
	/// <para>,DIRECTDRIVE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcMotorConnectionTypeEnum
	{
		public static string BELTDRIVE { get {return ".BELTDRIVE.";} }
		public static string COUPLING { get {return ".COUPLING.";} }
		public static string DIRECTDRIVE { get {return ".DIRECTDRIVE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcMotorConnectionTypeEnum() { Value = ".BELTDRIVE.";}
		public IfcMotorConnectionTypeEnum(string value) { Value = value; }
		public static implicit operator IfcMotorConnectionTypeEnum(string value) { return new IfcMotorConnectionTypeEnum(value);}
		public static implicit operator string(IfcMotorConnectionTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcNullStyle = ENUMERATION OF
	/// <para>TYPE IfcNullStyle = ENUMERATION OF</para>
	/// <para>(NULL);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcNullStyle: IfcPresentationStyleSelect
	{
		public static string NULL { get {return ".NULL.";} }
		public virtual IfcLabel? Name { get; set;  }
		public string Value;
		public IfcNullStyle() { Value = ".NULL.";}
		public IfcNullStyle(string value) { Value = value; }
		public static implicit operator IfcNullStyle(string value) { return new IfcNullStyle(value);}
		public static implicit operator string(IfcNullStyle value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcObjectTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcObjectTypeEnum = ENUMERATION OF</para>
	/// <para>(PRODUCT</para>
	/// <para>,PROCESS</para>
	/// <para>,CONTROL</para>
	/// <para>,RESOURCE</para>
	/// <para>,ACTOR</para>
	/// <para>,GROUP</para>
	/// <para>,PROJECT</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcObjectTypeEnum
	{
		public static string PRODUCT { get {return ".PRODUCT.";} }
		public static string PROCESS { get {return ".PROCESS.";} }
		public static string CONTROL { get {return ".CONTROL.";} }
		public static string RESOURCE { get {return ".RESOURCE.";} }
		public static string ACTOR { get {return ".ACTOR.";} }
		public static string GROUP { get {return ".GROUP.";} }
		public static string PROJECT { get {return ".PROJECT.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcObjectTypeEnum() { Value = ".PRODUCT.";}
		public IfcObjectTypeEnum(string value) { Value = value; }
		public static implicit operator IfcObjectTypeEnum(string value) { return new IfcObjectTypeEnum(value);}
		public static implicit operator string(IfcObjectTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcObjectiveEnum = ENUMERATION OF
	/// <para>TYPE IfcObjectiveEnum = ENUMERATION OF</para>
	/// <para>(CODECOMPLIANCE</para>
	/// <para>,CODEWAIVER</para>
	/// <para>,DESIGNINTENT</para>
	/// <para>,EXTERNAL</para>
	/// <para>,HEALTHANDSAFETY</para>
	/// <para>,MERGECONFLICT</para>
	/// <para>,MODELVIEW</para>
	/// <para>,PARAMETER</para>
	/// <para>,REQUIREMENT</para>
	/// <para>,SPECIFICATION</para>
	/// <para>,TRIGGERCONDITION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcObjectiveEnum
	{
		public static string CODECOMPLIANCE { get {return ".CODECOMPLIANCE.";} }
		public static string CODEWAIVER { get {return ".CODEWAIVER.";} }
		public static string DESIGNINTENT { get {return ".DESIGNINTENT.";} }
		public static string EXTERNAL { get {return ".EXTERNAL.";} }
		public static string HEALTHANDSAFETY { get {return ".HEALTHANDSAFETY.";} }
		public static string MERGECONFLICT { get {return ".MERGECONFLICT.";} }
		public static string MODELVIEW { get {return ".MODELVIEW.";} }
		public static string PARAMETER { get {return ".PARAMETER.";} }
		public static string REQUIREMENT { get {return ".REQUIREMENT.";} }
		public static string SPECIFICATION { get {return ".SPECIFICATION.";} }
		public static string TRIGGERCONDITION { get {return ".TRIGGERCONDITION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcObjectiveEnum() { Value = ".CODECOMPLIANCE.";}
		public IfcObjectiveEnum(string value) { Value = value; }
		public static implicit operator IfcObjectiveEnum(string value) { return new IfcObjectiveEnum(value);}
		public static implicit operator string(IfcObjectiveEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcOccupantTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcOccupantTypeEnum = ENUMERATION OF</para>
	/// <para>(ASSIGNEE</para>
	/// <para>,ASSIGNOR</para>
	/// <para>,LESSEE</para>
	/// <para>,LESSOR</para>
	/// <para>,LETTINGAGENT</para>
	/// <para>,OWNER</para>
	/// <para>,TENANT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcOccupantTypeEnum
	{
		public static string ASSIGNEE { get {return ".ASSIGNEE.";} }
		public static string ASSIGNOR { get {return ".ASSIGNOR.";} }
		public static string LESSEE { get {return ".LESSEE.";} }
		public static string LESSOR { get {return ".LESSOR.";} }
		public static string LETTINGAGENT { get {return ".LETTINGAGENT.";} }
		public static string OWNER { get {return ".OWNER.";} }
		public static string TENANT { get {return ".TENANT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcOccupantTypeEnum() { Value = ".ASSIGNEE.";}
		public IfcOccupantTypeEnum(string value) { Value = value; }
		public static implicit operator IfcOccupantTypeEnum(string value) { return new IfcOccupantTypeEnum(value);}
		public static implicit operator string(IfcOccupantTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcOpeningElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcOpeningElementTypeEnum = ENUMERATION OF</para>
	/// <para>(OPENING</para>
	/// <para>,RECESS</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcOpeningElementTypeEnum
	{
		public static string OPENING { get {return ".OPENING.";} }
		public static string RECESS { get {return ".RECESS.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcOpeningElementTypeEnum() { Value = ".OPENING.";}
		public IfcOpeningElementTypeEnum(string value) { Value = value; }
		public static implicit operator IfcOpeningElementTypeEnum(string value) { return new IfcOpeningElementTypeEnum(value);}
		public static implicit operator string(IfcOpeningElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcOutletTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcOutletTypeEnum = ENUMERATION OF</para>
	/// <para>(AUDIOVISUALOUTLET</para>
	/// <para>,COMMUNICATIONSOUTLET</para>
	/// <para>,POWEROUTLET</para>
	/// <para>,DATAOUTLET</para>
	/// <para>,TELEPHONEOUTLET</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcOutletTypeEnum
	{
		public static string AUDIOVISUALOUTLET { get {return ".AUDIOVISUALOUTLET.";} }
		public static string COMMUNICATIONSOUTLET { get {return ".COMMUNICATIONSOUTLET.";} }
		public static string POWEROUTLET { get {return ".POWEROUTLET.";} }
		public static string DATAOUTLET { get {return ".DATAOUTLET.";} }
		public static string TELEPHONEOUTLET { get {return ".TELEPHONEOUTLET.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcOutletTypeEnum() { Value = ".AUDIOVISUALOUTLET.";}
		public IfcOutletTypeEnum(string value) { Value = value; }
		public static implicit operator IfcOutletTypeEnum(string value) { return new IfcOutletTypeEnum(value);}
		public static implicit operator string(IfcOutletTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPerformanceHistoryTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPerformanceHistoryTypeEnum = ENUMERATION OF</para>
	/// <para>(USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPerformanceHistoryTypeEnum
	{
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPerformanceHistoryTypeEnum() { Value = ".USERDEFINED.";}
		public IfcPerformanceHistoryTypeEnum(string value) { Value = value; }
		public static implicit operator IfcPerformanceHistoryTypeEnum(string value) { return new IfcPerformanceHistoryTypeEnum(value);}
		public static implicit operator string(IfcPerformanceHistoryTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPermeableCoveringOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcPermeableCoveringOperationEnum = ENUMERATION OF</para>
	/// <para>(GRILL</para>
	/// <para>,LOUVER</para>
	/// <para>,SCREEN</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPermeableCoveringOperationEnum
	{
		public static string GRILL { get {return ".GRILL.";} }
		public static string LOUVER { get {return ".LOUVER.";} }
		public static string SCREEN { get {return ".SCREEN.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPermeableCoveringOperationEnum() { Value = ".GRILL.";}
		public IfcPermeableCoveringOperationEnum(string value) { Value = value; }
		public static implicit operator IfcPermeableCoveringOperationEnum(string value) { return new IfcPermeableCoveringOperationEnum(value);}
		public static implicit operator string(IfcPermeableCoveringOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPermitTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPermitTypeEnum = ENUMERATION OF</para>
	/// <para>(ACCESS</para>
	/// <para>,BUILDING</para>
	/// <para>,WORK</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPermitTypeEnum
	{
		public static string ACCESS { get {return ".ACCESS.";} }
		public static string BUILDING { get {return ".BUILDING.";} }
		public static string WORK { get {return ".WORK.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPermitTypeEnum() { Value = ".ACCESS.";}
		public IfcPermitTypeEnum(string value) { Value = value; }
		public static implicit operator IfcPermitTypeEnum(string value) { return new IfcPermitTypeEnum(value);}
		public static implicit operator string(IfcPermitTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPhysicalOrVirtualEnum = ENUMERATION OF
	/// <para>TYPE IfcPhysicalOrVirtualEnum = ENUMERATION OF</para>
	/// <para>(PHYSICAL</para>
	/// <para>,VIRTUAL</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPhysicalOrVirtualEnum
	{
		public static string PHYSICAL { get {return ".PHYSICAL.";} }
		public static string VIRTUAL { get {return ".VIRTUAL.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPhysicalOrVirtualEnum() { Value = ".PHYSICAL.";}
		public IfcPhysicalOrVirtualEnum(string value) { Value = value; }
		public static implicit operator IfcPhysicalOrVirtualEnum(string value) { return new IfcPhysicalOrVirtualEnum(value);}
		public static implicit operator string(IfcPhysicalOrVirtualEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPileConstructionEnum = ENUMERATION OF
	/// <para>TYPE IfcPileConstructionEnum = ENUMERATION OF</para>
	/// <para>(CAST_IN_PLACE</para>
	/// <para>,COMPOSITE</para>
	/// <para>,PRECAST_CONCRETE</para>
	/// <para>,PREFAB_STEEL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPileConstructionEnum
	{
		public static string CAST_IN_PLACE { get {return ".CAST_IN_PLACE.";} }
		public static string COMPOSITE { get {return ".COMPOSITE.";} }
		public static string PRECAST_CONCRETE { get {return ".PRECAST_CONCRETE.";} }
		public static string PREFAB_STEEL { get {return ".PREFAB_STEEL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPileConstructionEnum() { Value = ".CAST_IN_PLACE.";}
		public IfcPileConstructionEnum(string value) { Value = value; }
		public static implicit operator IfcPileConstructionEnum(string value) { return new IfcPileConstructionEnum(value);}
		public static implicit operator string(IfcPileConstructionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPileTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPileTypeEnum = ENUMERATION OF</para>
	/// <para>(BORED</para>
	/// <para>,DRIVEN</para>
	/// <para>,JETGROUTING</para>
	/// <para>,COHESION</para>
	/// <para>,FRICTION</para>
	/// <para>,SUPPORT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPileTypeEnum
	{
		public static string BORED { get {return ".BORED.";} }
		public static string DRIVEN { get {return ".DRIVEN.";} }
		public static string JETGROUTING { get {return ".JETGROUTING.";} }
		public static string COHESION { get {return ".COHESION.";} }
		public static string FRICTION { get {return ".FRICTION.";} }
		public static string SUPPORT { get {return ".SUPPORT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPileTypeEnum() { Value = ".BORED.";}
		public IfcPileTypeEnum(string value) { Value = value; }
		public static implicit operator IfcPileTypeEnum(string value) { return new IfcPileTypeEnum(value);}
		public static implicit operator string(IfcPileTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPipeFittingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPipeFittingTypeEnum = ENUMERATION OF</para>
	/// <para>(BEND</para>
	/// <para>,CONNECTOR</para>
	/// <para>,ENTRY</para>
	/// <para>,EXIT</para>
	/// <para>,JUNCTION</para>
	/// <para>,OBSTRUCTION</para>
	/// <para>,TRANSITION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPipeFittingTypeEnum
	{
		public static string BEND { get {return ".BEND.";} }
		public static string CONNECTOR { get {return ".CONNECTOR.";} }
		public static string ENTRY { get {return ".ENTRY.";} }
		public static string EXIT { get {return ".EXIT.";} }
		public static string JUNCTION { get {return ".JUNCTION.";} }
		public static string OBSTRUCTION { get {return ".OBSTRUCTION.";} }
		public static string TRANSITION { get {return ".TRANSITION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPipeFittingTypeEnum() { Value = ".BEND.";}
		public IfcPipeFittingTypeEnum(string value) { Value = value; }
		public static implicit operator IfcPipeFittingTypeEnum(string value) { return new IfcPipeFittingTypeEnum(value);}
		public static implicit operator string(IfcPipeFittingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPipeSegmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPipeSegmentTypeEnum = ENUMERATION OF</para>
	/// <para>(CULVERT</para>
	/// <para>,FLEXIBLESEGMENT</para>
	/// <para>,RIGIDSEGMENT</para>
	/// <para>,GUTTER</para>
	/// <para>,SPOOL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPipeSegmentTypeEnum
	{
		public static string CULVERT { get {return ".CULVERT.";} }
		public static string FLEXIBLESEGMENT { get {return ".FLEXIBLESEGMENT.";} }
		public static string RIGIDSEGMENT { get {return ".RIGIDSEGMENT.";} }
		public static string GUTTER { get {return ".GUTTER.";} }
		public static string SPOOL { get {return ".SPOOL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPipeSegmentTypeEnum() { Value = ".CULVERT.";}
		public IfcPipeSegmentTypeEnum(string value) { Value = value; }
		public static implicit operator IfcPipeSegmentTypeEnum(string value) { return new IfcPipeSegmentTypeEnum(value);}
		public static implicit operator string(IfcPipeSegmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPlateTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPlateTypeEnum = ENUMERATION OF</para>
	/// <para>(CURTAIN_PANEL</para>
	/// <para>,SHEET</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPlateTypeEnum
	{
		public static string CURTAIN_PANEL { get {return ".CURTAIN_PANEL.";} }
		public static string SHEET { get {return ".SHEET.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPlateTypeEnum() { Value = ".CURTAIN_PANEL.";}
		public IfcPlateTypeEnum(string value) { Value = value; }
		public static implicit operator IfcPlateTypeEnum(string value) { return new IfcPlateTypeEnum(value);}
		public static implicit operator string(IfcPlateTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPreferredSurfaceCurveRepresentation = ENUMERATION OF
	/// <para>TYPE IfcPreferredSurfaceCurveRepresentation = ENUMERATION OF</para>
	/// <para>(CURVE3D</para>
	/// <para>,PCURVE_S1</para>
	/// <para>,PCURVE_S2);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPreferredSurfaceCurveRepresentation
	{
		public static string CURVE3D { get {return ".CURVE3D.";} }
		public static string PCURVE_S1 { get {return ".PCURVE_S1.";} }
		public static string PCURVE_S2 { get {return ".PCURVE_S2.";} }
		public string Value;
		public IfcPreferredSurfaceCurveRepresentation() { Value = ".CURVE3D.";}
		public IfcPreferredSurfaceCurveRepresentation(string value) { Value = value; }
		public static implicit operator IfcPreferredSurfaceCurveRepresentation(string value) { return new IfcPreferredSurfaceCurveRepresentation(value);}
		public static implicit operator string(IfcPreferredSurfaceCurveRepresentation value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProcedureTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProcedureTypeEnum = ENUMERATION OF</para>
	/// <para>(ADVICE_CAUTION</para>
	/// <para>,ADVICE_NOTE</para>
	/// <para>,ADVICE_WARNING</para>
	/// <para>,CALIBRATION</para>
	/// <para>,DIAGNOSTIC</para>
	/// <para>,SHUTDOWN</para>
	/// <para>,STARTUP</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProcedureTypeEnum
	{
		public static string ADVICE_CAUTION { get {return ".ADVICE_CAUTION.";} }
		public static string ADVICE_NOTE { get {return ".ADVICE_NOTE.";} }
		public static string ADVICE_WARNING { get {return ".ADVICE_WARNING.";} }
		public static string CALIBRATION { get {return ".CALIBRATION.";} }
		public static string DIAGNOSTIC { get {return ".DIAGNOSTIC.";} }
		public static string SHUTDOWN { get {return ".SHUTDOWN.";} }
		public static string STARTUP { get {return ".STARTUP.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcProcedureTypeEnum() { Value = ".ADVICE_CAUTION.";}
		public IfcProcedureTypeEnum(string value) { Value = value; }
		public static implicit operator IfcProcedureTypeEnum(string value) { return new IfcProcedureTypeEnum(value);}
		public static implicit operator string(IfcProcedureTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProfileTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProfileTypeEnum = ENUMERATION OF</para>
	/// <para>(CURVE</para>
	/// <para>,AREA);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProfileTypeEnum
	{
		public static string CURVE { get {return ".CURVE.";} }
		public static string AREA { get {return ".AREA.";} }
		public string Value;
		public IfcProfileTypeEnum() { Value = ".CURVE.";}
		public IfcProfileTypeEnum(string value) { Value = value; }
		public static implicit operator IfcProfileTypeEnum(string value) { return new IfcProfileTypeEnum(value);}
		public static implicit operator string(IfcProfileTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProjectOrderTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProjectOrderTypeEnum = ENUMERATION OF</para>
	/// <para>(CHANGEORDER</para>
	/// <para>,MAINTENANCEWORKORDER</para>
	/// <para>,MOVEORDER</para>
	/// <para>,PURCHASEORDER</para>
	/// <para>,WORKORDER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProjectOrderTypeEnum
	{
		public static string CHANGEORDER { get {return ".CHANGEORDER.";} }
		public static string MAINTENANCEWORKORDER { get {return ".MAINTENANCEWORKORDER.";} }
		public static string MOVEORDER { get {return ".MOVEORDER.";} }
		public static string PURCHASEORDER { get {return ".PURCHASEORDER.";} }
		public static string WORKORDER { get {return ".WORKORDER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcProjectOrderTypeEnum() { Value = ".CHANGEORDER.";}
		public IfcProjectOrderTypeEnum(string value) { Value = value; }
		public static implicit operator IfcProjectOrderTypeEnum(string value) { return new IfcProjectOrderTypeEnum(value);}
		public static implicit operator string(IfcProjectOrderTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProjectedOrTrueLengthEnum = ENUMERATION OF
	/// <para>TYPE IfcProjectedOrTrueLengthEnum = ENUMERATION OF</para>
	/// <para>(PROJECTED_LENGTH</para>
	/// <para>,TRUE_LENGTH);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProjectedOrTrueLengthEnum
	{
		public static string PROJECTED_LENGTH { get {return ".PROJECTED_LENGTH.";} }
		public static string TRUE_LENGTH { get {return ".TRUE_LENGTH.";} }
		public string Value;
		public IfcProjectedOrTrueLengthEnum() { Value = ".PROJECTED_LENGTH.";}
		public IfcProjectedOrTrueLengthEnum(string value) { Value = value; }
		public static implicit operator IfcProjectedOrTrueLengthEnum(string value) { return new IfcProjectedOrTrueLengthEnum(value);}
		public static implicit operator string(IfcProjectedOrTrueLengthEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProjectionElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProjectionElementTypeEnum = ENUMERATION OF</para>
	/// <para>(USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProjectionElementTypeEnum
	{
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcProjectionElementTypeEnum() { Value = ".USERDEFINED.";}
		public IfcProjectionElementTypeEnum(string value) { Value = value; }
		public static implicit operator IfcProjectionElementTypeEnum(string value) { return new IfcProjectionElementTypeEnum(value);}
		public static implicit operator string(IfcProjectionElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPropertySetTemplateTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPropertySetTemplateTypeEnum = ENUMERATION OF</para>
	/// <para>(PSET_TYPEDRIVENONLY</para>
	/// <para>,PSET_TYPEDRIVENOVERRIDE</para>
	/// <para>,PSET_OCCURRENCEDRIVEN</para>
	/// <para>,PSET_PERFORMANCEDRIVEN</para>
	/// <para>,QTO_TYPEDRIVENONLY</para>
	/// <para>,QTO_TYPEDRIVENOVERRIDE</para>
	/// <para>,QTO_OCCURRENCEDRIVEN</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPropertySetTemplateTypeEnum
	{
		public static string PSET_TYPEDRIVENONLY { get {return ".PSET_TYPEDRIVENONLY.";} }
		public static string PSET_TYPEDRIVENOVERRIDE { get {return ".PSET_TYPEDRIVENOVERRIDE.";} }
		public static string PSET_OCCURRENCEDRIVEN { get {return ".PSET_OCCURRENCEDRIVEN.";} }
		public static string PSET_PERFORMANCEDRIVEN { get {return ".PSET_PERFORMANCEDRIVEN.";} }
		public static string QTO_TYPEDRIVENONLY { get {return ".QTO_TYPEDRIVENONLY.";} }
		public static string QTO_TYPEDRIVENOVERRIDE { get {return ".QTO_TYPEDRIVENOVERRIDE.";} }
		public static string QTO_OCCURRENCEDRIVEN { get {return ".QTO_OCCURRENCEDRIVEN.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPropertySetTemplateTypeEnum() { Value = ".PSET_TYPEDRIVENONLY.";}
		public IfcPropertySetTemplateTypeEnum(string value) { Value = value; }
		public static implicit operator IfcPropertySetTemplateTypeEnum(string value) { return new IfcPropertySetTemplateTypeEnum(value);}
		public static implicit operator string(IfcPropertySetTemplateTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProtectiveDeviceTrippingUnitTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProtectiveDeviceTrippingUnitTypeEnum = ENUMERATION OF</para>
	/// <para>(ELECTRONIC</para>
	/// <para>,ELECTROMAGNETIC</para>
	/// <para>,RESIDUALCURRENT</para>
	/// <para>,THERMAL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProtectiveDeviceTrippingUnitTypeEnum
	{
		public static string ELECTRONIC { get {return ".ELECTRONIC.";} }
		public static string ELECTROMAGNETIC { get {return ".ELECTROMAGNETIC.";} }
		public static string RESIDUALCURRENT { get {return ".RESIDUALCURRENT.";} }
		public static string THERMAL { get {return ".THERMAL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcProtectiveDeviceTrippingUnitTypeEnum() { Value = ".ELECTRONIC.";}
		public IfcProtectiveDeviceTrippingUnitTypeEnum(string value) { Value = value; }
		public static implicit operator IfcProtectiveDeviceTrippingUnitTypeEnum(string value) { return new IfcProtectiveDeviceTrippingUnitTypeEnum(value);}
		public static implicit operator string(IfcProtectiveDeviceTrippingUnitTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcProtectiveDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcProtectiveDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>(CIRCUITBREAKER</para>
	/// <para>,EARTHLEAKAGECIRCUITBREAKER</para>
	/// <para>,EARTHINGSWITCH</para>
	/// <para>,FUSEDISCONNECTOR</para>
	/// <para>,RESIDUALCURRENTCIRCUITBREAKER</para>
	/// <para>,RESIDUALCURRENTSWITCH</para>
	/// <para>,VARISTOR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcProtectiveDeviceTypeEnum
	{
		public static string CIRCUITBREAKER { get {return ".CIRCUITBREAKER.";} }
		public static string EARTHLEAKAGECIRCUITBREAKER { get {return ".EARTHLEAKAGECIRCUITBREAKER.";} }
		public static string EARTHINGSWITCH { get {return ".EARTHINGSWITCH.";} }
		public static string FUSEDISCONNECTOR { get {return ".FUSEDISCONNECTOR.";} }
		public static string RESIDUALCURRENTCIRCUITBREAKER { get {return ".RESIDUALCURRENTCIRCUITBREAKER.";} }
		public static string RESIDUALCURRENTSWITCH { get {return ".RESIDUALCURRENTSWITCH.";} }
		public static string VARISTOR { get {return ".VARISTOR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcProtectiveDeviceTypeEnum() { Value = ".CIRCUITBREAKER.";}
		public IfcProtectiveDeviceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcProtectiveDeviceTypeEnum(string value) { return new IfcProtectiveDeviceTypeEnum(value);}
		public static implicit operator string(IfcProtectiveDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcPumpTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcPumpTypeEnum = ENUMERATION OF</para>
	/// <para>(CIRCULATOR</para>
	/// <para>,ENDSUCTION</para>
	/// <para>,SPLITCASE</para>
	/// <para>,SUBMERSIBLEPUMP</para>
	/// <para>,SUMPPUMP</para>
	/// <para>,VERTICALINLINE</para>
	/// <para>,VERTICALTURBINE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcPumpTypeEnum
	{
		public static string CIRCULATOR { get {return ".CIRCULATOR.";} }
		public static string ENDSUCTION { get {return ".ENDSUCTION.";} }
		public static string SPLITCASE { get {return ".SPLITCASE.";} }
		public static string SUBMERSIBLEPUMP { get {return ".SUBMERSIBLEPUMP.";} }
		public static string SUMPPUMP { get {return ".SUMPPUMP.";} }
		public static string VERTICALINLINE { get {return ".VERTICALINLINE.";} }
		public static string VERTICALTURBINE { get {return ".VERTICALTURBINE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcPumpTypeEnum() { Value = ".CIRCULATOR.";}
		public IfcPumpTypeEnum(string value) { Value = value; }
		public static implicit operator IfcPumpTypeEnum(string value) { return new IfcPumpTypeEnum(value);}
		public static implicit operator string(IfcPumpTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRailingTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcRailingTypeEnum = ENUMERATION OF</para>
	/// <para>(HANDRAIL</para>
	/// <para>,GUARDRAIL</para>
	/// <para>,BALUSTRADE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRailingTypeEnum
	{
		public static string HANDRAIL { get {return ".HANDRAIL.";} }
		public static string GUARDRAIL { get {return ".GUARDRAIL.";} }
		public static string BALUSTRADE { get {return ".BALUSTRADE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcRailingTypeEnum() { Value = ".HANDRAIL.";}
		public IfcRailingTypeEnum(string value) { Value = value; }
		public static implicit operator IfcRailingTypeEnum(string value) { return new IfcRailingTypeEnum(value);}
		public static implicit operator string(IfcRailingTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRampFlightTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcRampFlightTypeEnum = ENUMERATION OF</para>
	/// <para>(STRAIGHT</para>
	/// <para>,SPIRAL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRampFlightTypeEnum
	{
		public static string STRAIGHT { get {return ".STRAIGHT.";} }
		public static string SPIRAL { get {return ".SPIRAL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcRampFlightTypeEnum() { Value = ".STRAIGHT.";}
		public IfcRampFlightTypeEnum(string value) { Value = value; }
		public static implicit operator IfcRampFlightTypeEnum(string value) { return new IfcRampFlightTypeEnum(value);}
		public static implicit operator string(IfcRampFlightTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRampTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcRampTypeEnum = ENUMERATION OF</para>
	/// <para>(STRAIGHT_RUN_RAMP</para>
	/// <para>,TWO_STRAIGHT_RUN_RAMP</para>
	/// <para>,QUARTER_TURN_RAMP</para>
	/// <para>,TWO_QUARTER_TURN_RAMP</para>
	/// <para>,HALF_TURN_RAMP</para>
	/// <para>,SPIRAL_RAMP</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRampTypeEnum
	{
		public static string STRAIGHT_RUN_RAMP { get {return ".STRAIGHT_RUN_RAMP.";} }
		public static string TWO_STRAIGHT_RUN_RAMP { get {return ".TWO_STRAIGHT_RUN_RAMP.";} }
		public static string QUARTER_TURN_RAMP { get {return ".QUARTER_TURN_RAMP.";} }
		public static string TWO_QUARTER_TURN_RAMP { get {return ".TWO_QUARTER_TURN_RAMP.";} }
		public static string HALF_TURN_RAMP { get {return ".HALF_TURN_RAMP.";} }
		public static string SPIRAL_RAMP { get {return ".SPIRAL_RAMP.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcRampTypeEnum() { Value = ".STRAIGHT_RUN_RAMP.";}
		public IfcRampTypeEnum(string value) { Value = value; }
		public static implicit operator IfcRampTypeEnum(string value) { return new IfcRampTypeEnum(value);}
		public static implicit operator string(IfcRampTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRecurrenceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcRecurrenceTypeEnum = ENUMERATION OF</para>
	/// <para>(DAILY</para>
	/// <para>,WEEKLY</para>
	/// <para>,MONTHLY_BY_DAY_OF_MONTH</para>
	/// <para>,MONTHLY_BY_POSITION</para>
	/// <para>,BY_DAY_COUNT</para>
	/// <para>,BY_WEEKDAY_COUNT</para>
	/// <para>,YEARLY_BY_DAY_OF_MONTH</para>
	/// <para>,YEARLY_BY_POSITION);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRecurrenceTypeEnum
	{
		public static string DAILY { get {return ".DAILY.";} }
		public static string WEEKLY { get {return ".WEEKLY.";} }
		public static string MONTHLY_BY_DAY_OF_MONTH { get {return ".MONTHLY_BY_DAY_OF_MONTH.";} }
		public static string MONTHLY_BY_POSITION { get {return ".MONTHLY_BY_POSITION.";} }
		public static string BY_DAY_COUNT { get {return ".BY_DAY_COUNT.";} }
		public static string BY_WEEKDAY_COUNT { get {return ".BY_WEEKDAY_COUNT.";} }
		public static string YEARLY_BY_DAY_OF_MONTH { get {return ".YEARLY_BY_DAY_OF_MONTH.";} }
		public static string YEARLY_BY_POSITION { get {return ".YEARLY_BY_POSITION.";} }
		public string Value;
		public IfcRecurrenceTypeEnum() { Value = ".DAILY.";}
		public IfcRecurrenceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcRecurrenceTypeEnum(string value) { return new IfcRecurrenceTypeEnum(value);}
		public static implicit operator string(IfcRecurrenceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReferentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcReferentTypeEnum = ENUMERATION OF</para>
	/// <para>(KILOPOINT</para>
	/// <para>,MILEPOINT</para>
	/// <para>,STATION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReferentTypeEnum
	{
		public static string KILOPOINT { get {return ".KILOPOINT.";} }
		public static string MILEPOINT { get {return ".MILEPOINT.";} }
		public static string STATION { get {return ".STATION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcReferentTypeEnum() { Value = ".KILOPOINT.";}
		public IfcReferentTypeEnum(string value) { Value = value; }
		public static implicit operator IfcReferentTypeEnum(string value) { return new IfcReferentTypeEnum(value);}
		public static implicit operator string(IfcReferentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReflectanceMethodEnum = ENUMERATION OF
	/// <para>TYPE IfcReflectanceMethodEnum = ENUMERATION OF</para>
	/// <para>(BLINN</para>
	/// <para>,FLAT</para>
	/// <para>,GLASS</para>
	/// <para>,MATT</para>
	/// <para>,METAL</para>
	/// <para>,MIRROR</para>
	/// <para>,PHONG</para>
	/// <para>,PLASTIC</para>
	/// <para>,STRAUSS</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReflectanceMethodEnum
	{
		public static string BLINN { get {return ".BLINN.";} }
		public static string FLAT { get {return ".FLAT.";} }
		public static string GLASS { get {return ".GLASS.";} }
		public static string MATT { get {return ".MATT.";} }
		public static string METAL { get {return ".METAL.";} }
		public static string MIRROR { get {return ".MIRROR.";} }
		public static string PHONG { get {return ".PHONG.";} }
		public static string PLASTIC { get {return ".PLASTIC.";} }
		public static string STRAUSS { get {return ".STRAUSS.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcReflectanceMethodEnum() { Value = ".BLINN.";}
		public IfcReflectanceMethodEnum(string value) { Value = value; }
		public static implicit operator IfcReflectanceMethodEnum(string value) { return new IfcReflectanceMethodEnum(value);}
		public static implicit operator string(IfcReflectanceMethodEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReinforcingBarRoleEnum = ENUMERATION OF
	/// <para>TYPE IfcReinforcingBarRoleEnum = ENUMERATION OF</para>
	/// <para>(MAIN</para>
	/// <para>,SHEAR</para>
	/// <para>,LIGATURE</para>
	/// <para>,STUD</para>
	/// <para>,PUNCHING</para>
	/// <para>,EDGE</para>
	/// <para>,RING</para>
	/// <para>,ANCHORING</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReinforcingBarRoleEnum
	{
		public static string MAIN { get {return ".MAIN.";} }
		public static string SHEAR { get {return ".SHEAR.";} }
		public static string LIGATURE { get {return ".LIGATURE.";} }
		public static string STUD { get {return ".STUD.";} }
		public static string PUNCHING { get {return ".PUNCHING.";} }
		public static string EDGE { get {return ".EDGE.";} }
		public static string RING { get {return ".RING.";} }
		public static string ANCHORING { get {return ".ANCHORING.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcReinforcingBarRoleEnum() { Value = ".MAIN.";}
		public IfcReinforcingBarRoleEnum(string value) { Value = value; }
		public static implicit operator IfcReinforcingBarRoleEnum(string value) { return new IfcReinforcingBarRoleEnum(value);}
		public static implicit operator string(IfcReinforcingBarRoleEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReinforcingBarSurfaceEnum = ENUMERATION OF
	/// <para>TYPE IfcReinforcingBarSurfaceEnum = ENUMERATION OF</para>
	/// <para>(PLAIN</para>
	/// <para>,TEXTURED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReinforcingBarSurfaceEnum
	{
		public static string PLAIN { get {return ".PLAIN.";} }
		public static string TEXTURED { get {return ".TEXTURED.";} }
		public string Value;
		public IfcReinforcingBarSurfaceEnum() { Value = ".PLAIN.";}
		public IfcReinforcingBarSurfaceEnum(string value) { Value = value; }
		public static implicit operator IfcReinforcingBarSurfaceEnum(string value) { return new IfcReinforcingBarSurfaceEnum(value);}
		public static implicit operator string(IfcReinforcingBarSurfaceEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReinforcingBarTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcReinforcingBarTypeEnum = ENUMERATION OF</para>
	/// <para>(ANCHORING</para>
	/// <para>,EDGE</para>
	/// <para>,LIGATURE</para>
	/// <para>,MAIN</para>
	/// <para>,PUNCHING</para>
	/// <para>,RING</para>
	/// <para>,SHEAR</para>
	/// <para>,STUD</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReinforcingBarTypeEnum
	{
		public static string ANCHORING { get {return ".ANCHORING.";} }
		public static string EDGE { get {return ".EDGE.";} }
		public static string LIGATURE { get {return ".LIGATURE.";} }
		public static string MAIN { get {return ".MAIN.";} }
		public static string PUNCHING { get {return ".PUNCHING.";} }
		public static string RING { get {return ".RING.";} }
		public static string SHEAR { get {return ".SHEAR.";} }
		public static string STUD { get {return ".STUD.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcReinforcingBarTypeEnum() { Value = ".ANCHORING.";}
		public IfcReinforcingBarTypeEnum(string value) { Value = value; }
		public static implicit operator IfcReinforcingBarTypeEnum(string value) { return new IfcReinforcingBarTypeEnum(value);}
		public static implicit operator string(IfcReinforcingBarTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcReinforcingMeshTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcReinforcingMeshTypeEnum = ENUMERATION OF</para>
	/// <para>(USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcReinforcingMeshTypeEnum
	{
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcReinforcingMeshTypeEnum() { Value = ".USERDEFINED.";}
		public IfcReinforcingMeshTypeEnum(string value) { Value = value; }
		public static implicit operator IfcReinforcingMeshTypeEnum(string value) { return new IfcReinforcingMeshTypeEnum(value);}
		public static implicit operator string(IfcReinforcingMeshTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRoleEnum = ENUMERATION OF
	/// <para>TYPE IfcRoleEnum = ENUMERATION OF</para>
	/// <para>(SUPPLIER</para>
	/// <para>,MANUFACTURER</para>
	/// <para>,CONTRACTOR</para>
	/// <para>,SUBCONTRACTOR</para>
	/// <para>,ARCHITECT</para>
	/// <para>,STRUCTURALENGINEER</para>
	/// <para>,COSTENGINEER</para>
	/// <para>,CLIENT</para>
	/// <para>,BUILDINGOWNER</para>
	/// <para>,BUILDINGOPERATOR</para>
	/// <para>,MECHANICALENGINEER</para>
	/// <para>,ELECTRICALENGINEER</para>
	/// <para>,PROJECTMANAGER</para>
	/// <para>,FACILITIESMANAGER</para>
	/// <para>,CIVILENGINEER</para>
	/// <para>,COMMISSIONINGENGINEER</para>
	/// <para>,ENGINEER</para>
	/// <para>,OWNER</para>
	/// <para>,CONSULTANT</para>
	/// <para>,CONSTRUCTIONMANAGER</para>
	/// <para>,FIELDCONSTRUCTIONMANAGER</para>
	/// <para>,RESELLER</para>
	/// <para>,USERDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRoleEnum
	{
		public static string SUPPLIER { get {return ".SUPPLIER.";} }
		public static string MANUFACTURER { get {return ".MANUFACTURER.";} }
		public static string CONTRACTOR { get {return ".CONTRACTOR.";} }
		public static string SUBCONTRACTOR { get {return ".SUBCONTRACTOR.";} }
		public static string ARCHITECT { get {return ".ARCHITECT.";} }
		public static string STRUCTURALENGINEER { get {return ".STRUCTURALENGINEER.";} }
		public static string COSTENGINEER { get {return ".COSTENGINEER.";} }
		public static string CLIENT { get {return ".CLIENT.";} }
		public static string BUILDINGOWNER { get {return ".BUILDINGOWNER.";} }
		public static string BUILDINGOPERATOR { get {return ".BUILDINGOPERATOR.";} }
		public static string MECHANICALENGINEER { get {return ".MECHANICALENGINEER.";} }
		public static string ELECTRICALENGINEER { get {return ".ELECTRICALENGINEER.";} }
		public static string PROJECTMANAGER { get {return ".PROJECTMANAGER.";} }
		public static string FACILITIESMANAGER { get {return ".FACILITIESMANAGER.";} }
		public static string CIVILENGINEER { get {return ".CIVILENGINEER.";} }
		public static string COMMISSIONINGENGINEER { get {return ".COMMISSIONINGENGINEER.";} }
		public static string ENGINEER { get {return ".ENGINEER.";} }
		public static string OWNER { get {return ".OWNER.";} }
		public static string CONSULTANT { get {return ".CONSULTANT.";} }
		public static string CONSTRUCTIONMANAGER { get {return ".CONSTRUCTIONMANAGER.";} }
		public static string FIELDCONSTRUCTIONMANAGER { get {return ".FIELDCONSTRUCTIONMANAGER.";} }
		public static string RESELLER { get {return ".RESELLER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public string Value;
		public IfcRoleEnum() { Value = ".SUPPLIER.";}
		public IfcRoleEnum(string value) { Value = value; }
		public static implicit operator IfcRoleEnum(string value) { return new IfcRoleEnum(value);}
		public static implicit operator string(IfcRoleEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcRoofTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcRoofTypeEnum = ENUMERATION OF</para>
	/// <para>(FLAT_ROOF</para>
	/// <para>,SHED_ROOF</para>
	/// <para>,GABLE_ROOF</para>
	/// <para>,HIP_ROOF</para>
	/// <para>,HIPPED_GABLE_ROOF</para>
	/// <para>,GAMBREL_ROOF</para>
	/// <para>,MANSARD_ROOF</para>
	/// <para>,BARREL_ROOF</para>
	/// <para>,RAINBOW_ROOF</para>
	/// <para>,BUTTERFLY_ROOF</para>
	/// <para>,PAVILION_ROOF</para>
	/// <para>,DOME_ROOF</para>
	/// <para>,FREEFORM</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcRoofTypeEnum
	{
		public static string FLAT_ROOF { get {return ".FLAT_ROOF.";} }
		public static string SHED_ROOF { get {return ".SHED_ROOF.";} }
		public static string GABLE_ROOF { get {return ".GABLE_ROOF.";} }
		public static string HIP_ROOF { get {return ".HIP_ROOF.";} }
		public static string HIPPED_GABLE_ROOF { get {return ".HIPPED_GABLE_ROOF.";} }
		public static string GAMBREL_ROOF { get {return ".GAMBREL_ROOF.";} }
		public static string MANSARD_ROOF { get {return ".MANSARD_ROOF.";} }
		public static string BARREL_ROOF { get {return ".BARREL_ROOF.";} }
		public static string RAINBOW_ROOF { get {return ".RAINBOW_ROOF.";} }
		public static string BUTTERFLY_ROOF { get {return ".BUTTERFLY_ROOF.";} }
		public static string PAVILION_ROOF { get {return ".PAVILION_ROOF.";} }
		public static string DOME_ROOF { get {return ".DOME_ROOF.";} }
		public static string FREEFORM { get {return ".FREEFORM.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcRoofTypeEnum() { Value = ".FLAT_ROOF.";}
		public IfcRoofTypeEnum(string value) { Value = value; }
		public static implicit operator IfcRoofTypeEnum(string value) { return new IfcRoofTypeEnum(value);}
		public static implicit operator string(IfcRoofTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSIPrefix = ENUMERATION OF
	/// <para>TYPE IfcSIPrefix = ENUMERATION OF</para>
	/// <para>(EXA</para>
	/// <para>,PETA</para>
	/// <para>,TERA</para>
	/// <para>,GIGA</para>
	/// <para>,MEGA</para>
	/// <para>,KILO</para>
	/// <para>,HECTO</para>
	/// <para>,DECA</para>
	/// <para>,DECI</para>
	/// <para>,CENTI</para>
	/// <para>,MILLI</para>
	/// <para>,MICRO</para>
	/// <para>,NANO</para>
	/// <para>,PICO</para>
	/// <para>,FEMTO</para>
	/// <para>,ATTO);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSIPrefix
	{
		public static string EXA { get {return ".EXA.";} }
		public static string PETA { get {return ".PETA.";} }
		public static string TERA { get {return ".TERA.";} }
		public static string GIGA { get {return ".GIGA.";} }
		public static string MEGA { get {return ".MEGA.";} }
		public static string KILO { get {return ".KILO.";} }
		public static string HECTO { get {return ".HECTO.";} }
		public static string DECA { get {return ".DECA.";} }
		public static string DECI { get {return ".DECI.";} }
		public static string CENTI { get {return ".CENTI.";} }
		public static string MILLI { get {return ".MILLI.";} }
		public static string MICRO { get {return ".MICRO.";} }
		public static string NANO { get {return ".NANO.";} }
		public static string PICO { get {return ".PICO.";} }
		public static string FEMTO { get {return ".FEMTO.";} }
		public static string ATTO { get {return ".ATTO.";} }
		public string Value;
		public IfcSIPrefix() { Value = ".EXA.";}
		public IfcSIPrefix(string value) { Value = value; }
		public static implicit operator IfcSIPrefix(string value) { return new IfcSIPrefix(value);}
		public static implicit operator string(IfcSIPrefix value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSIUnitName = ENUMERATION OF
	/// <para>TYPE IfcSIUnitName = ENUMERATION OF</para>
	/// <para>(AMPERE</para>
	/// <para>,BECQUEREL</para>
	/// <para>,CANDELA</para>
	/// <para>,COULOMB</para>
	/// <para>,CUBIC_METRE</para>
	/// <para>,DEGREE_CELSIUS</para>
	/// <para>,FARAD</para>
	/// <para>,GRAM</para>
	/// <para>,GRAY</para>
	/// <para>,HENRY</para>
	/// <para>,HERTZ</para>
	/// <para>,JOULE</para>
	/// <para>,KELVIN</para>
	/// <para>,LUMEN</para>
	/// <para>,LUX</para>
	/// <para>,METRE</para>
	/// <para>,MOLE</para>
	/// <para>,NEWTON</para>
	/// <para>,OHM</para>
	/// <para>,PASCAL</para>
	/// <para>,RADIAN</para>
	/// <para>,SECOND</para>
	/// <para>,SIEMENS</para>
	/// <para>,SIEVERT</para>
	/// <para>,SQUARE_METRE</para>
	/// <para>,STERADIAN</para>
	/// <para>,TESLA</para>
	/// <para>,VOLT</para>
	/// <para>,WATT</para>
	/// <para>,WEBER);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSIUnitName
	{
		public static string AMPERE { get {return ".AMPERE.";} }
		public static string BECQUEREL { get {return ".BECQUEREL.";} }
		public static string CANDELA { get {return ".CANDELA.";} }
		public static string COULOMB { get {return ".COULOMB.";} }
		public static string CUBIC_METRE { get {return ".CUBIC_METRE.";} }
		public static string DEGREE_CELSIUS { get {return ".DEGREE_CELSIUS.";} }
		public static string FARAD { get {return ".FARAD.";} }
		public static string GRAM { get {return ".GRAM.";} }
		public static string GRAY { get {return ".GRAY.";} }
		public static string HENRY { get {return ".HENRY.";} }
		public static string HERTZ { get {return ".HERTZ.";} }
		public static string JOULE { get {return ".JOULE.";} }
		public static string KELVIN { get {return ".KELVIN.";} }
		public static string LUMEN { get {return ".LUMEN.";} }
		public static string LUX { get {return ".LUX.";} }
		public static string METRE { get {return ".METRE.";} }
		public static string MOLE { get {return ".MOLE.";} }
		public static string NEWTON { get {return ".NEWTON.";} }
		public static string OHM { get {return ".OHM.";} }
		public static string PASCAL { get {return ".PASCAL.";} }
		public static string RADIAN { get {return ".RADIAN.";} }
		public static string SECOND { get {return ".SECOND.";} }
		public static string SIEMENS { get {return ".SIEMENS.";} }
		public static string SIEVERT { get {return ".SIEVERT.";} }
		public static string SQUARE_METRE { get {return ".SQUARE_METRE.";} }
		public static string STERADIAN { get {return ".STERADIAN.";} }
		public static string TESLA { get {return ".TESLA.";} }
		public static string VOLT { get {return ".VOLT.";} }
		public static string WATT { get {return ".WATT.";} }
		public static string WEBER { get {return ".WEBER.";} }
		public string Value;
		public IfcSIUnitName() { Value = ".AMPERE.";}
		public IfcSIUnitName(string value) { Value = value; }
		public static implicit operator IfcSIUnitName(string value) { return new IfcSIUnitName(value);}
		public static implicit operator string(IfcSIUnitName value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSanitaryTerminalTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSanitaryTerminalTypeEnum = ENUMERATION OF</para>
	/// <para>(BATH</para>
	/// <para>,BIDET</para>
	/// <para>,CISTERN</para>
	/// <para>,SHOWER</para>
	/// <para>,SINK</para>
	/// <para>,SANITARYFOUNTAIN</para>
	/// <para>,TOILETPAN</para>
	/// <para>,URINAL</para>
	/// <para>,WASHHANDBASIN</para>
	/// <para>,WCSEAT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSanitaryTerminalTypeEnum
	{
		public static string BATH { get {return ".BATH.";} }
		public static string BIDET { get {return ".BIDET.";} }
		public static string CISTERN { get {return ".CISTERN.";} }
		public static string SHOWER { get {return ".SHOWER.";} }
		public static string SINK { get {return ".SINK.";} }
		public static string SANITARYFOUNTAIN { get {return ".SANITARYFOUNTAIN.";} }
		public static string TOILETPAN { get {return ".TOILETPAN.";} }
		public static string URINAL { get {return ".URINAL.";} }
		public static string WASHHANDBASIN { get {return ".WASHHANDBASIN.";} }
		public static string WCSEAT { get {return ".WCSEAT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSanitaryTerminalTypeEnum() { Value = ".BATH.";}
		public IfcSanitaryTerminalTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSanitaryTerminalTypeEnum(string value) { return new IfcSanitaryTerminalTypeEnum(value);}
		public static implicit operator string(IfcSanitaryTerminalTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSectionTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSectionTypeEnum = ENUMERATION OF</para>
	/// <para>(UNIFORM</para>
	/// <para>,TAPERED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSectionTypeEnum
	{
		public static string UNIFORM { get {return ".UNIFORM.";} }
		public static string TAPERED { get {return ".TAPERED.";} }
		public string Value;
		public IfcSectionTypeEnum() { Value = ".UNIFORM.";}
		public IfcSectionTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSectionTypeEnum(string value) { return new IfcSectionTypeEnum(value);}
		public static implicit operator string(IfcSectionTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSensorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSensorTypeEnum = ENUMERATION OF</para>
	/// <para>(COSENSOR</para>
	/// <para>,CO2SENSOR</para>
	/// <para>,CONDUCTANCESENSOR</para>
	/// <para>,CONTACTSENSOR</para>
	/// <para>,FIRESENSOR</para>
	/// <para>,FLOWSENSOR</para>
	/// <para>,FROSTSENSOR</para>
	/// <para>,GASSENSOR</para>
	/// <para>,HEATSENSOR</para>
	/// <para>,HUMIDITYSENSOR</para>
	/// <para>,IDENTIFIERSENSOR</para>
	/// <para>,IONCONCENTRATIONSENSOR</para>
	/// <para>,LEVELSENSOR</para>
	/// <para>,LIGHTSENSOR</para>
	/// <para>,MOISTURESENSOR</para>
	/// <para>,MOVEMENTSENSOR</para>
	/// <para>,PHSENSOR</para>
	/// <para>,PRESSURESENSOR</para>
	/// <para>,RADIATIONSENSOR</para>
	/// <para>,RADIOACTIVITYSENSOR</para>
	/// <para>,SMOKESENSOR</para>
	/// <para>,SOUNDSENSOR</para>
	/// <para>,TEMPERATURESENSOR</para>
	/// <para>,WINDSENSOR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSensorTypeEnum
	{
		public static string COSENSOR { get {return ".COSENSOR.";} }
		public static string CO2SENSOR { get {return ".CO2SENSOR.";} }
		public static string CONDUCTANCESENSOR { get {return ".CONDUCTANCESENSOR.";} }
		public static string CONTACTSENSOR { get {return ".CONTACTSENSOR.";} }
		public static string FIRESENSOR { get {return ".FIRESENSOR.";} }
		public static string FLOWSENSOR { get {return ".FLOWSENSOR.";} }
		public static string FROSTSENSOR { get {return ".FROSTSENSOR.";} }
		public static string GASSENSOR { get {return ".GASSENSOR.";} }
		public static string HEATSENSOR { get {return ".HEATSENSOR.";} }
		public static string HUMIDITYSENSOR { get {return ".HUMIDITYSENSOR.";} }
		public static string IDENTIFIERSENSOR { get {return ".IDENTIFIERSENSOR.";} }
		public static string IONCONCENTRATIONSENSOR { get {return ".IONCONCENTRATIONSENSOR.";} }
		public static string LEVELSENSOR { get {return ".LEVELSENSOR.";} }
		public static string LIGHTSENSOR { get {return ".LIGHTSENSOR.";} }
		public static string MOISTURESENSOR { get {return ".MOISTURESENSOR.";} }
		public static string MOVEMENTSENSOR { get {return ".MOVEMENTSENSOR.";} }
		public static string PHSENSOR { get {return ".PHSENSOR.";} }
		public static string PRESSURESENSOR { get {return ".PRESSURESENSOR.";} }
		public static string RADIATIONSENSOR { get {return ".RADIATIONSENSOR.";} }
		public static string RADIOACTIVITYSENSOR { get {return ".RADIOACTIVITYSENSOR.";} }
		public static string SMOKESENSOR { get {return ".SMOKESENSOR.";} }
		public static string SOUNDSENSOR { get {return ".SOUNDSENSOR.";} }
		public static string TEMPERATURESENSOR { get {return ".TEMPERATURESENSOR.";} }
		public static string WINDSENSOR { get {return ".WINDSENSOR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSensorTypeEnum() { Value = ".COSENSOR.";}
		public IfcSensorTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSensorTypeEnum(string value) { return new IfcSensorTypeEnum(value);}
		public static implicit operator string(IfcSensorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSequenceEnum = ENUMERATION OF
	/// <para>TYPE IfcSequenceEnum = ENUMERATION OF</para>
	/// <para>(START_START</para>
	/// <para>,START_FINISH</para>
	/// <para>,FINISH_START</para>
	/// <para>,FINISH_FINISH</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSequenceEnum
	{
		public static string START_START { get {return ".START_START.";} }
		public static string START_FINISH { get {return ".START_FINISH.";} }
		public static string FINISH_START { get {return ".FINISH_START.";} }
		public static string FINISH_FINISH { get {return ".FINISH_FINISH.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSequenceEnum() { Value = ".START_START.";}
		public IfcSequenceEnum(string value) { Value = value; }
		public static implicit operator IfcSequenceEnum(string value) { return new IfcSequenceEnum(value);}
		public static implicit operator string(IfcSequenceEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcShadingDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcShadingDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>(JALOUSIE</para>
	/// <para>,SHUTTER</para>
	/// <para>,AWNING</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcShadingDeviceTypeEnum
	{
		public static string JALOUSIE { get {return ".JALOUSIE.";} }
		public static string SHUTTER { get {return ".SHUTTER.";} }
		public static string AWNING { get {return ".AWNING.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcShadingDeviceTypeEnum() { Value = ".JALOUSIE.";}
		public IfcShadingDeviceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcShadingDeviceTypeEnum(string value) { return new IfcShadingDeviceTypeEnum(value);}
		public static implicit operator string(IfcShadingDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSimplePropertyTemplateTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSimplePropertyTemplateTypeEnum = ENUMERATION OF</para>
	/// <para>(P_SINGLEVALUE</para>
	/// <para>,P_ENUMERATEDVALUE</para>
	/// <para>,P_BOUNDEDVALUE</para>
	/// <para>,P_LISTVALUE</para>
	/// <para>,P_TABLEVALUE</para>
	/// <para>,P_REFERENCEVALUE</para>
	/// <para>,Q_LENGTH</para>
	/// <para>,Q_AREA</para>
	/// <para>,Q_VOLUME</para>
	/// <para>,Q_COUNT</para>
	/// <para>,Q_WEIGHT</para>
	/// <para>,Q_TIME);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSimplePropertyTemplateTypeEnum
	{
		public static string P_SINGLEVALUE { get {return ".P_SINGLEVALUE.";} }
		public static string P_ENUMERATEDVALUE { get {return ".P_ENUMERATEDVALUE.";} }
		public static string P_BOUNDEDVALUE { get {return ".P_BOUNDEDVALUE.";} }
		public static string P_LISTVALUE { get {return ".P_LISTVALUE.";} }
		public static string P_TABLEVALUE { get {return ".P_TABLEVALUE.";} }
		public static string P_REFERENCEVALUE { get {return ".P_REFERENCEVALUE.";} }
		public static string Q_LENGTH { get {return ".Q_LENGTH.";} }
		public static string Q_AREA { get {return ".Q_AREA.";} }
		public static string Q_VOLUME { get {return ".Q_VOLUME.";} }
		public static string Q_COUNT { get {return ".Q_COUNT.";} }
		public static string Q_WEIGHT { get {return ".Q_WEIGHT.";} }
		public static string Q_TIME { get {return ".Q_TIME.";} }
		public string Value;
		public IfcSimplePropertyTemplateTypeEnum() { Value = ".P_SINGLEVALUE.";}
		public IfcSimplePropertyTemplateTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSimplePropertyTemplateTypeEnum(string value) { return new IfcSimplePropertyTemplateTypeEnum(value);}
		public static implicit operator string(IfcSimplePropertyTemplateTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSlabTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSlabTypeEnum = ENUMERATION OF</para>
	/// <para>(FLOOR</para>
	/// <para>,ROOF</para>
	/// <para>,LANDING</para>
	/// <para>,BASESLAB</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSlabTypeEnum
	{
		public static string FLOOR { get {return ".FLOOR.";} }
		public static string ROOF { get {return ".ROOF.";} }
		public static string LANDING { get {return ".LANDING.";} }
		public static string BASESLAB { get {return ".BASESLAB.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSlabTypeEnum() { Value = ".FLOOR.";}
		public IfcSlabTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSlabTypeEnum(string value) { return new IfcSlabTypeEnum(value);}
		public static implicit operator string(IfcSlabTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSolarDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSolarDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>(SOLARCOLLECTOR</para>
	/// <para>,SOLARPANEL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSolarDeviceTypeEnum
	{
		public static string SOLARCOLLECTOR { get {return ".SOLARCOLLECTOR.";} }
		public static string SOLARPANEL { get {return ".SOLARPANEL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSolarDeviceTypeEnum() { Value = ".SOLARCOLLECTOR.";}
		public IfcSolarDeviceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSolarDeviceTypeEnum(string value) { return new IfcSolarDeviceTypeEnum(value);}
		public static implicit operator string(IfcSolarDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpaceHeaterTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSpaceHeaterTypeEnum = ENUMERATION OF</para>
	/// <para>(CONVECTOR</para>
	/// <para>,RADIATOR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpaceHeaterTypeEnum
	{
		public static string CONVECTOR { get {return ".CONVECTOR.";} }
		public static string RADIATOR { get {return ".RADIATOR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSpaceHeaterTypeEnum() { Value = ".CONVECTOR.";}
		public IfcSpaceHeaterTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSpaceHeaterTypeEnum(string value) { return new IfcSpaceHeaterTypeEnum(value);}
		public static implicit operator string(IfcSpaceHeaterTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpaceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSpaceTypeEnum = ENUMERATION OF</para>
	/// <para>(SPACE</para>
	/// <para>,PARKING</para>
	/// <para>,GFA</para>
	/// <para>,INTERNAL</para>
	/// <para>,EXTERNAL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpaceTypeEnum
	{
		public static string SPACE { get {return ".SPACE.";} }
		public static string PARKING { get {return ".PARKING.";} }
		public static string GFA { get {return ".GFA.";} }
		public static string INTERNAL { get {return ".INTERNAL.";} }
		public static string EXTERNAL { get {return ".EXTERNAL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSpaceTypeEnum() { Value = ".SPACE.";}
		public IfcSpaceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSpaceTypeEnum(string value) { return new IfcSpaceTypeEnum(value);}
		public static implicit operator string(IfcSpaceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSpatialZoneTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSpatialZoneTypeEnum = ENUMERATION OF</para>
	/// <para>(CONSTRUCTION</para>
	/// <para>,FIRESAFETY</para>
	/// <para>,LIGHTING</para>
	/// <para>,OCCUPANCY</para>
	/// <para>,SECURITY</para>
	/// <para>,THERMAL</para>
	/// <para>,TRANSPORT</para>
	/// <para>,VENTILATION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSpatialZoneTypeEnum
	{
		public static string CONSTRUCTION { get {return ".CONSTRUCTION.";} }
		public static string FIRESAFETY { get {return ".FIRESAFETY.";} }
		public static string LIGHTING { get {return ".LIGHTING.";} }
		public static string OCCUPANCY { get {return ".OCCUPANCY.";} }
		public static string SECURITY { get {return ".SECURITY.";} }
		public static string THERMAL { get {return ".THERMAL.";} }
		public static string TRANSPORT { get {return ".TRANSPORT.";} }
		public static string VENTILATION { get {return ".VENTILATION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSpatialZoneTypeEnum() { Value = ".CONSTRUCTION.";}
		public IfcSpatialZoneTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSpatialZoneTypeEnum(string value) { return new IfcSpatialZoneTypeEnum(value);}
		public static implicit operator string(IfcSpatialZoneTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStackTerminalTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStackTerminalTypeEnum = ENUMERATION OF</para>
	/// <para>(BIRDCAGE</para>
	/// <para>,COWL</para>
	/// <para>,RAINWATERHOPPER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStackTerminalTypeEnum
	{
		public static string BIRDCAGE { get {return ".BIRDCAGE.";} }
		public static string COWL { get {return ".COWL.";} }
		public static string RAINWATERHOPPER { get {return ".RAINWATERHOPPER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcStackTerminalTypeEnum() { Value = ".BIRDCAGE.";}
		public IfcStackTerminalTypeEnum(string value) { Value = value; }
		public static implicit operator IfcStackTerminalTypeEnum(string value) { return new IfcStackTerminalTypeEnum(value);}
		public static implicit operator string(IfcStackTerminalTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStairFlightTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStairFlightTypeEnum = ENUMERATION OF</para>
	/// <para>(STRAIGHT</para>
	/// <para>,WINDER</para>
	/// <para>,SPIRAL</para>
	/// <para>,CURVED</para>
	/// <para>,FREEFORM</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStairFlightTypeEnum
	{
		public static string STRAIGHT { get {return ".STRAIGHT.";} }
		public static string WINDER { get {return ".WINDER.";} }
		public static string SPIRAL { get {return ".SPIRAL.";} }
		public static string CURVED { get {return ".CURVED.";} }
		public static string FREEFORM { get {return ".FREEFORM.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcStairFlightTypeEnum() { Value = ".STRAIGHT.";}
		public IfcStairFlightTypeEnum(string value) { Value = value; }
		public static implicit operator IfcStairFlightTypeEnum(string value) { return new IfcStairFlightTypeEnum(value);}
		public static implicit operator string(IfcStairFlightTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStairTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStairTypeEnum = ENUMERATION OF</para>
	/// <para>(STRAIGHT_RUN_STAIR</para>
	/// <para>,TWO_STRAIGHT_RUN_STAIR</para>
	/// <para>,QUARTER_WINDING_STAIR</para>
	/// <para>,QUARTER_TURN_STAIR</para>
	/// <para>,HALF_WINDING_STAIR</para>
	/// <para>,HALF_TURN_STAIR</para>
	/// <para>,TWO_QUARTER_WINDING_STAIR</para>
	/// <para>,TWO_QUARTER_TURN_STAIR</para>
	/// <para>,THREE_QUARTER_WINDING_STAIR</para>
	/// <para>,THREE_QUARTER_TURN_STAIR</para>
	/// <para>,SPIRAL_STAIR</para>
	/// <para>,DOUBLE_RETURN_STAIR</para>
	/// <para>,CURVED_RUN_STAIR</para>
	/// <para>,TWO_CURVED_RUN_STAIR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStairTypeEnum
	{
		public static string STRAIGHT_RUN_STAIR { get {return ".STRAIGHT_RUN_STAIR.";} }
		public static string TWO_STRAIGHT_RUN_STAIR { get {return ".TWO_STRAIGHT_RUN_STAIR.";} }
		public static string QUARTER_WINDING_STAIR { get {return ".QUARTER_WINDING_STAIR.";} }
		public static string QUARTER_TURN_STAIR { get {return ".QUARTER_TURN_STAIR.";} }
		public static string HALF_WINDING_STAIR { get {return ".HALF_WINDING_STAIR.";} }
		public static string HALF_TURN_STAIR { get {return ".HALF_TURN_STAIR.";} }
		public static string TWO_QUARTER_WINDING_STAIR { get {return ".TWO_QUARTER_WINDING_STAIR.";} }
		public static string TWO_QUARTER_TURN_STAIR { get {return ".TWO_QUARTER_TURN_STAIR.";} }
		public static string THREE_QUARTER_WINDING_STAIR { get {return ".THREE_QUARTER_WINDING_STAIR.";} }
		public static string THREE_QUARTER_TURN_STAIR { get {return ".THREE_QUARTER_TURN_STAIR.";} }
		public static string SPIRAL_STAIR { get {return ".SPIRAL_STAIR.";} }
		public static string DOUBLE_RETURN_STAIR { get {return ".DOUBLE_RETURN_STAIR.";} }
		public static string CURVED_RUN_STAIR { get {return ".CURVED_RUN_STAIR.";} }
		public static string TWO_CURVED_RUN_STAIR { get {return ".TWO_CURVED_RUN_STAIR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcStairTypeEnum() { Value = ".STRAIGHT_RUN_STAIR.";}
		public IfcStairTypeEnum(string value) { Value = value; }
		public static implicit operator IfcStairTypeEnum(string value) { return new IfcStairTypeEnum(value);}
		public static implicit operator string(IfcStairTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStateEnum = ENUMERATION OF
	/// <para>TYPE IfcStateEnum = ENUMERATION OF</para>
	/// <para>(READWRITE</para>
	/// <para>,READONLY</para>
	/// <para>,LOCKED</para>
	/// <para>,READWRITELOCKED</para>
	/// <para>,READONLYLOCKED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStateEnum
	{
		public static string READWRITE { get {return ".READWRITE.";} }
		public static string READONLY { get {return ".READONLY.";} }
		public static string LOCKED { get {return ".LOCKED.";} }
		public static string READWRITELOCKED { get {return ".READWRITELOCKED.";} }
		public static string READONLYLOCKED { get {return ".READONLYLOCKED.";} }
		public string Value;
		public IfcStateEnum() { Value = ".READWRITE.";}
		public IfcStateEnum(string value) { Value = value; }
		public static implicit operator IfcStateEnum(string value) { return new IfcStateEnum(value);}
		public static implicit operator string(IfcStateEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStructuralCurveActivityTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStructuralCurveActivityTypeEnum = ENUMERATION OF</para>
	/// <para>(CONST</para>
	/// <para>,LINEAR</para>
	/// <para>,POLYGONAL</para>
	/// <para>,EQUIDISTANT</para>
	/// <para>,SINUS</para>
	/// <para>,PARABOLA</para>
	/// <para>,DISCRETE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStructuralCurveActivityTypeEnum
	{
		public static string CONST { get {return ".CONST.";} }
		public static string LINEAR { get {return ".LINEAR.";} }
		public static string POLYGONAL { get {return ".POLYGONAL.";} }
		public static string EQUIDISTANT { get {return ".EQUIDISTANT.";} }
		public static string SINUS { get {return ".SINUS.";} }
		public static string PARABOLA { get {return ".PARABOLA.";} }
		public static string DISCRETE { get {return ".DISCRETE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcStructuralCurveActivityTypeEnum() { Value = ".CONST.";}
		public IfcStructuralCurveActivityTypeEnum(string value) { Value = value; }
		public static implicit operator IfcStructuralCurveActivityTypeEnum(string value) { return new IfcStructuralCurveActivityTypeEnum(value);}
		public static implicit operator string(IfcStructuralCurveActivityTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStructuralCurveMemberTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStructuralCurveMemberTypeEnum = ENUMERATION OF</para>
	/// <para>(RIGID_JOINED_MEMBER</para>
	/// <para>,PIN_JOINED_MEMBER</para>
	/// <para>,CABLE</para>
	/// <para>,TENSION_MEMBER</para>
	/// <para>,COMPRESSION_MEMBER</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStructuralCurveMemberTypeEnum
	{
		public static string RIGID_JOINED_MEMBER { get {return ".RIGID_JOINED_MEMBER.";} }
		public static string PIN_JOINED_MEMBER { get {return ".PIN_JOINED_MEMBER.";} }
		public static string CABLE { get {return ".CABLE.";} }
		public static string TENSION_MEMBER { get {return ".TENSION_MEMBER.";} }
		public static string COMPRESSION_MEMBER { get {return ".COMPRESSION_MEMBER.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcStructuralCurveMemberTypeEnum() { Value = ".RIGID_JOINED_MEMBER.";}
		public IfcStructuralCurveMemberTypeEnum(string value) { Value = value; }
		public static implicit operator IfcStructuralCurveMemberTypeEnum(string value) { return new IfcStructuralCurveMemberTypeEnum(value);}
		public static implicit operator string(IfcStructuralCurveMemberTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStructuralSurfaceActivityTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStructuralSurfaceActivityTypeEnum = ENUMERATION OF</para>
	/// <para>(CONST</para>
	/// <para>,BILINEAR</para>
	/// <para>,DISCRETE</para>
	/// <para>,ISOCONTOUR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStructuralSurfaceActivityTypeEnum
	{
		public static string CONST { get {return ".CONST.";} }
		public static string BILINEAR { get {return ".BILINEAR.";} }
		public static string DISCRETE { get {return ".DISCRETE.";} }
		public static string ISOCONTOUR { get {return ".ISOCONTOUR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcStructuralSurfaceActivityTypeEnum() { Value = ".CONST.";}
		public IfcStructuralSurfaceActivityTypeEnum(string value) { Value = value; }
		public static implicit operator IfcStructuralSurfaceActivityTypeEnum(string value) { return new IfcStructuralSurfaceActivityTypeEnum(value);}
		public static implicit operator string(IfcStructuralSurfaceActivityTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcStructuralSurfaceMemberTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcStructuralSurfaceMemberTypeEnum = ENUMERATION OF</para>
	/// <para>(BENDING_ELEMENT</para>
	/// <para>,MEMBRANE_ELEMENT</para>
	/// <para>,SHELL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcStructuralSurfaceMemberTypeEnum
	{
		public static string BENDING_ELEMENT { get {return ".BENDING_ELEMENT.";} }
		public static string MEMBRANE_ELEMENT { get {return ".MEMBRANE_ELEMENT.";} }
		public static string SHELL { get {return ".SHELL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcStructuralSurfaceMemberTypeEnum() { Value = ".BENDING_ELEMENT.";}
		public IfcStructuralSurfaceMemberTypeEnum(string value) { Value = value; }
		public static implicit operator IfcStructuralSurfaceMemberTypeEnum(string value) { return new IfcStructuralSurfaceMemberTypeEnum(value);}
		public static implicit operator string(IfcStructuralSurfaceMemberTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSubContractResourceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSubContractResourceTypeEnum = ENUMERATION OF</para>
	/// <para>(PURCHASE</para>
	/// <para>,WORK</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSubContractResourceTypeEnum
	{
		public static string PURCHASE { get {return ".PURCHASE.";} }
		public static string WORK { get {return ".WORK.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSubContractResourceTypeEnum() { Value = ".PURCHASE.";}
		public IfcSubContractResourceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSubContractResourceTypeEnum(string value) { return new IfcSubContractResourceTypeEnum(value);}
		public static implicit operator string(IfcSubContractResourceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSurfaceFeatureTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSurfaceFeatureTypeEnum = ENUMERATION OF</para>
	/// <para>(MARK</para>
	/// <para>,TAG</para>
	/// <para>,TREATMENT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSurfaceFeatureTypeEnum
	{
		public static string MARK { get {return ".MARK.";} }
		public static string TAG { get {return ".TAG.";} }
		public static string TREATMENT { get {return ".TREATMENT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSurfaceFeatureTypeEnum() { Value = ".MARK.";}
		public IfcSurfaceFeatureTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSurfaceFeatureTypeEnum(string value) { return new IfcSurfaceFeatureTypeEnum(value);}
		public static implicit operator string(IfcSurfaceFeatureTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSurfaceSide = ENUMERATION OF
	/// <para>TYPE IfcSurfaceSide = ENUMERATION OF</para>
	/// <para>(POSITIVE</para>
	/// <para>,NEGATIVE</para>
	/// <para>,BOTH);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSurfaceSide
	{
		public static string POSITIVE { get {return ".POSITIVE.";} }
		public static string NEGATIVE { get {return ".NEGATIVE.";} }
		public static string BOTH { get {return ".BOTH.";} }
		public string Value;
		public IfcSurfaceSide() { Value = ".POSITIVE.";}
		public IfcSurfaceSide(string value) { Value = value; }
		public static implicit operator IfcSurfaceSide(string value) { return new IfcSurfaceSide(value);}
		public static implicit operator string(IfcSurfaceSide value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSwitchingDeviceTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSwitchingDeviceTypeEnum = ENUMERATION OF</para>
	/// <para>(CONTACTOR</para>
	/// <para>,DIMMERSWITCH</para>
	/// <para>,EMERGENCYSTOP</para>
	/// <para>,KEYPAD</para>
	/// <para>,MOMENTARYSWITCH</para>
	/// <para>,SELECTORSWITCH</para>
	/// <para>,STARTER</para>
	/// <para>,SWITCHDISCONNECTOR</para>
	/// <para>,TOGGLESWITCH</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSwitchingDeviceTypeEnum
	{
		public static string CONTACTOR { get {return ".CONTACTOR.";} }
		public static string DIMMERSWITCH { get {return ".DIMMERSWITCH.";} }
		public static string EMERGENCYSTOP { get {return ".EMERGENCYSTOP.";} }
		public static string KEYPAD { get {return ".KEYPAD.";} }
		public static string MOMENTARYSWITCH { get {return ".MOMENTARYSWITCH.";} }
		public static string SELECTORSWITCH { get {return ".SELECTORSWITCH.";} }
		public static string STARTER { get {return ".STARTER.";} }
		public static string SWITCHDISCONNECTOR { get {return ".SWITCHDISCONNECTOR.";} }
		public static string TOGGLESWITCH { get {return ".TOGGLESWITCH.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSwitchingDeviceTypeEnum() { Value = ".CONTACTOR.";}
		public IfcSwitchingDeviceTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSwitchingDeviceTypeEnum(string value) { return new IfcSwitchingDeviceTypeEnum(value);}
		public static implicit operator string(IfcSwitchingDeviceTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcSystemFurnitureElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcSystemFurnitureElementTypeEnum = ENUMERATION OF</para>
	/// <para>(PANEL</para>
	/// <para>,WORKSURFACE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcSystemFurnitureElementTypeEnum
	{
		public static string PANEL { get {return ".PANEL.";} }
		public static string WORKSURFACE { get {return ".WORKSURFACE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcSystemFurnitureElementTypeEnum() { Value = ".PANEL.";}
		public IfcSystemFurnitureElementTypeEnum(string value) { Value = value; }
		public static implicit operator IfcSystemFurnitureElementTypeEnum(string value) { return new IfcSystemFurnitureElementTypeEnum(value);}
		public static implicit operator string(IfcSystemFurnitureElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTankTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTankTypeEnum = ENUMERATION OF</para>
	/// <para>(BASIN</para>
	/// <para>,BREAKPRESSURE</para>
	/// <para>,EXPANSION</para>
	/// <para>,FEEDANDEXPANSION</para>
	/// <para>,PRESSUREVESSEL</para>
	/// <para>,STORAGE</para>
	/// <para>,VESSEL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTankTypeEnum
	{
		public static string BASIN { get {return ".BASIN.";} }
		public static string BREAKPRESSURE { get {return ".BREAKPRESSURE.";} }
		public static string EXPANSION { get {return ".EXPANSION.";} }
		public static string FEEDANDEXPANSION { get {return ".FEEDANDEXPANSION.";} }
		public static string PRESSUREVESSEL { get {return ".PRESSUREVESSEL.";} }
		public static string STORAGE { get {return ".STORAGE.";} }
		public static string VESSEL { get {return ".VESSEL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcTankTypeEnum() { Value = ".BASIN.";}
		public IfcTankTypeEnum(string value) { Value = value; }
		public static implicit operator IfcTankTypeEnum(string value) { return new IfcTankTypeEnum(value);}
		public static implicit operator string(IfcTankTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTaskDurationEnum = ENUMERATION OF
	/// <para>TYPE IfcTaskDurationEnum = ENUMERATION OF</para>
	/// <para>(ELAPSEDTIME</para>
	/// <para>,WORKTIME</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTaskDurationEnum
	{
		public static string ELAPSEDTIME { get {return ".ELAPSEDTIME.";} }
		public static string WORKTIME { get {return ".WORKTIME.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcTaskDurationEnum() { Value = ".ELAPSEDTIME.";}
		public IfcTaskDurationEnum(string value) { Value = value; }
		public static implicit operator IfcTaskDurationEnum(string value) { return new IfcTaskDurationEnum(value);}
		public static implicit operator string(IfcTaskDurationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTaskTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTaskTypeEnum = ENUMERATION OF</para>
	/// <para>(ATTENDANCE</para>
	/// <para>,CONSTRUCTION</para>
	/// <para>,DEMOLITION</para>
	/// <para>,DISMANTLE</para>
	/// <para>,DISPOSAL</para>
	/// <para>,INSTALLATION</para>
	/// <para>,LOGISTIC</para>
	/// <para>,MAINTENANCE</para>
	/// <para>,MOVE</para>
	/// <para>,OPERATION</para>
	/// <para>,REMOVAL</para>
	/// <para>,RENOVATION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTaskTypeEnum
	{
		public static string ATTENDANCE { get {return ".ATTENDANCE.";} }
		public static string CONSTRUCTION { get {return ".CONSTRUCTION.";} }
		public static string DEMOLITION { get {return ".DEMOLITION.";} }
		public static string DISMANTLE { get {return ".DISMANTLE.";} }
		public static string DISPOSAL { get {return ".DISPOSAL.";} }
		public static string INSTALLATION { get {return ".INSTALLATION.";} }
		public static string LOGISTIC { get {return ".LOGISTIC.";} }
		public static string MAINTENANCE { get {return ".MAINTENANCE.";} }
		public static string MOVE { get {return ".MOVE.";} }
		public static string OPERATION { get {return ".OPERATION.";} }
		public static string REMOVAL { get {return ".REMOVAL.";} }
		public static string RENOVATION { get {return ".RENOVATION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcTaskTypeEnum() { Value = ".ATTENDANCE.";}
		public IfcTaskTypeEnum(string value) { Value = value; }
		public static implicit operator IfcTaskTypeEnum(string value) { return new IfcTaskTypeEnum(value);}
		public static implicit operator string(IfcTaskTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTendonAnchorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTendonAnchorTypeEnum = ENUMERATION OF</para>
	/// <para>(COUPLER</para>
	/// <para>,FIXED_END</para>
	/// <para>,TENSIONING_END</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTendonAnchorTypeEnum
	{
		public static string COUPLER { get {return ".COUPLER.";} }
		public static string FIXED_END { get {return ".FIXED_END.";} }
		public static string TENSIONING_END { get {return ".TENSIONING_END.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcTendonAnchorTypeEnum() { Value = ".COUPLER.";}
		public IfcTendonAnchorTypeEnum(string value) { Value = value; }
		public static implicit operator IfcTendonAnchorTypeEnum(string value) { return new IfcTendonAnchorTypeEnum(value);}
		public static implicit operator string(IfcTendonAnchorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTendonTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTendonTypeEnum = ENUMERATION OF</para>
	/// <para>(BAR</para>
	/// <para>,COATED</para>
	/// <para>,STRAND</para>
	/// <para>,WIRE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTendonTypeEnum
	{
		public static string BAR { get {return ".BAR.";} }
		public static string COATED { get {return ".COATED.";} }
		public static string STRAND { get {return ".STRAND.";} }
		public static string WIRE { get {return ".WIRE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcTendonTypeEnum() { Value = ".BAR.";}
		public IfcTendonTypeEnum(string value) { Value = value; }
		public static implicit operator IfcTendonTypeEnum(string value) { return new IfcTendonTypeEnum(value);}
		public static implicit operator string(IfcTendonTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTextPath = ENUMERATION OF
	/// <para>TYPE IfcTextPath = ENUMERATION OF</para>
	/// <para>(LEFT</para>
	/// <para>,RIGHT</para>
	/// <para>,UP</para>
	/// <para>,DOWN);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTextPath
	{
		public static string LEFT { get {return ".LEFT.";} }
		public static string RIGHT { get {return ".RIGHT.";} }
		public static string UP { get {return ".UP.";} }
		public static string DOWN { get {return ".DOWN.";} }
		public string Value;
		public IfcTextPath() { Value = ".LEFT.";}
		public IfcTextPath(string value) { Value = value; }
		public static implicit operator IfcTextPath(string value) { return new IfcTextPath(value);}
		public static implicit operator string(IfcTextPath value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTimeSeriesDataTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTimeSeriesDataTypeEnum = ENUMERATION OF</para>
	/// <para>(CONTINUOUS</para>
	/// <para>,DISCRETE</para>
	/// <para>,DISCRETEBINARY</para>
	/// <para>,PIECEWISEBINARY</para>
	/// <para>,PIECEWISECONSTANT</para>
	/// <para>,PIECEWISECONTINUOUS</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTimeSeriesDataTypeEnum
	{
		public static string CONTINUOUS { get {return ".CONTINUOUS.";} }
		public static string DISCRETE { get {return ".DISCRETE.";} }
		public static string DISCRETEBINARY { get {return ".DISCRETEBINARY.";} }
		public static string PIECEWISEBINARY { get {return ".PIECEWISEBINARY.";} }
		public static string PIECEWISECONSTANT { get {return ".PIECEWISECONSTANT.";} }
		public static string PIECEWISECONTINUOUS { get {return ".PIECEWISECONTINUOUS.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcTimeSeriesDataTypeEnum() { Value = ".CONTINUOUS.";}
		public IfcTimeSeriesDataTypeEnum(string value) { Value = value; }
		public static implicit operator IfcTimeSeriesDataTypeEnum(string value) { return new IfcTimeSeriesDataTypeEnum(value);}
		public static implicit operator string(IfcTimeSeriesDataTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTransformerTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTransformerTypeEnum = ENUMERATION OF</para>
	/// <para>(CURRENT</para>
	/// <para>,FREQUENCY</para>
	/// <para>,INVERTER</para>
	/// <para>,RECTIFIER</para>
	/// <para>,VOLTAGE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTransformerTypeEnum
	{
		public static string CURRENT { get {return ".CURRENT.";} }
		public static string FREQUENCY { get {return ".FREQUENCY.";} }
		public static string INVERTER { get {return ".INVERTER.";} }
		public static string RECTIFIER { get {return ".RECTIFIER.";} }
		public static string VOLTAGE { get {return ".VOLTAGE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcTransformerTypeEnum() { Value = ".CURRENT.";}
		public IfcTransformerTypeEnum(string value) { Value = value; }
		public static implicit operator IfcTransformerTypeEnum(string value) { return new IfcTransformerTypeEnum(value);}
		public static implicit operator string(IfcTransformerTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTransitionCode = ENUMERATION OF
	/// <para>TYPE IfcTransitionCode = ENUMERATION OF</para>
	/// <para>(DISCONTINUOUS</para>
	/// <para>,CONTINUOUS</para>
	/// <para>,CONTSAMEGRADIENT</para>
	/// <para>,CONTSAMEGRADIENTSAMECURVATURE);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTransitionCode
	{
		public static string DISCONTINUOUS { get {return ".DISCONTINUOUS.";} }
		public static string CONTINUOUS { get {return ".CONTINUOUS.";} }
		public static string CONTSAMEGRADIENT { get {return ".CONTSAMEGRADIENT.";} }
		public static string CONTSAMEGRADIENTSAMECURVATURE { get {return ".CONTSAMEGRADIENTSAMECURVATURE.";} }
		public string Value;
		public IfcTransitionCode() { Value = ".DISCONTINUOUS.";}
		public IfcTransitionCode(string value) { Value = value; }
		public static implicit operator IfcTransitionCode(string value) { return new IfcTransitionCode(value);}
		public static implicit operator string(IfcTransitionCode value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTransitionCurveType = ENUMERATION OF
	/// <para>TYPE IfcTransitionCurveType = ENUMERATION OF</para>
	/// <para>(BIQUADRATICPARABOLA</para>
	/// <para>,BLOSSCURVE</para>
	/// <para>,CLOTHOIDCURVE</para>
	/// <para>,COSINECURVE</para>
	/// <para>,CUBICPARABOLA</para>
	/// <para>,SINECURVE);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTransitionCurveType
	{
		public static string BIQUADRATICPARABOLA { get {return ".BIQUADRATICPARABOLA.";} }
		public static string BLOSSCURVE { get {return ".BLOSSCURVE.";} }
		public static string CLOTHOIDCURVE { get {return ".CLOTHOIDCURVE.";} }
		public static string COSINECURVE { get {return ".COSINECURVE.";} }
		public static string CUBICPARABOLA { get {return ".CUBICPARABOLA.";} }
		public static string SINECURVE { get {return ".SINECURVE.";} }
		public string Value;
		public IfcTransitionCurveType() { Value = ".BIQUADRATICPARABOLA.";}
		public IfcTransitionCurveType(string value) { Value = value; }
		public static implicit operator IfcTransitionCurveType(string value) { return new IfcTransitionCurveType(value);}
		public static implicit operator string(IfcTransitionCurveType value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTransportElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTransportElementTypeEnum = ENUMERATION OF</para>
	/// <para>(ELEVATOR</para>
	/// <para>,ESCALATOR</para>
	/// <para>,MOVINGWALKWAY</para>
	/// <para>,CRANEWAY</para>
	/// <para>,LIFTINGGEAR</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTransportElementTypeEnum
	{
		public static string ELEVATOR { get {return ".ELEVATOR.";} }
		public static string ESCALATOR { get {return ".ESCALATOR.";} }
		public static string MOVINGWALKWAY { get {return ".MOVINGWALKWAY.";} }
		public static string CRANEWAY { get {return ".CRANEWAY.";} }
		public static string LIFTINGGEAR { get {return ".LIFTINGGEAR.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcTransportElementTypeEnum() { Value = ".ELEVATOR.";}
		public IfcTransportElementTypeEnum(string value) { Value = value; }
		public static implicit operator IfcTransportElementTypeEnum(string value) { return new IfcTransportElementTypeEnum(value);}
		public static implicit operator string(IfcTransportElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTrimmingPreference = ENUMERATION OF
	/// <para>TYPE IfcTrimmingPreference = ENUMERATION OF</para>
	/// <para>(CARTESIAN</para>
	/// <para>,PARAMETER</para>
	/// <para>,UNSPECIFIED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTrimmingPreference
	{
		public static string CARTESIAN { get {return ".CARTESIAN.";} }
		public static string PARAMETER { get {return ".PARAMETER.";} }
		public static string UNSPECIFIED { get {return ".UNSPECIFIED.";} }
		public string Value;
		public IfcTrimmingPreference() { Value = ".CARTESIAN.";}
		public IfcTrimmingPreference(string value) { Value = value; }
		public static implicit operator IfcTrimmingPreference(string value) { return new IfcTrimmingPreference(value);}
		public static implicit operator string(IfcTrimmingPreference value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcTubeBundleTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcTubeBundleTypeEnum = ENUMERATION OF</para>
	/// <para>(FINNED</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcTubeBundleTypeEnum
	{
		public static string FINNED { get {return ".FINNED.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcTubeBundleTypeEnum() { Value = ".FINNED.";}
		public IfcTubeBundleTypeEnum(string value) { Value = value; }
		public static implicit operator IfcTubeBundleTypeEnum(string value) { return new IfcTubeBundleTypeEnum(value);}
		public static implicit operator string(IfcTubeBundleTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcUnitEnum = ENUMERATION OF
	/// <para>TYPE IfcUnitEnum = ENUMERATION OF</para>
	/// <para>(ABSORBEDDOSEUNIT</para>
	/// <para>,AMOUNTOFSUBSTANCEUNIT</para>
	/// <para>,AREAUNIT</para>
	/// <para>,DOSEEQUIVALENTUNIT</para>
	/// <para>,ELECTRICCAPACITANCEUNIT</para>
	/// <para>,ELECTRICCHARGEUNIT</para>
	/// <para>,ELECTRICCONDUCTANCEUNIT</para>
	/// <para>,ELECTRICCURRENTUNIT</para>
	/// <para>,ELECTRICRESISTANCEUNIT</para>
	/// <para>,ELECTRICVOLTAGEUNIT</para>
	/// <para>,ENERGYUNIT</para>
	/// <para>,FORCEUNIT</para>
	/// <para>,FREQUENCYUNIT</para>
	/// <para>,ILLUMINANCEUNIT</para>
	/// <para>,INDUCTANCEUNIT</para>
	/// <para>,LENGTHUNIT</para>
	/// <para>,LUMINOUSFLUXUNIT</para>
	/// <para>,LUMINOUSINTENSITYUNIT</para>
	/// <para>,MAGNETICFLUXDENSITYUNIT</para>
	/// <para>,MAGNETICFLUXUNIT</para>
	/// <para>,MASSUNIT</para>
	/// <para>,PLANEANGLEUNIT</para>
	/// <para>,POWERUNIT</para>
	/// <para>,PRESSUREUNIT</para>
	/// <para>,RADIOACTIVITYUNIT</para>
	/// <para>,SOLIDANGLEUNIT</para>
	/// <para>,THERMODYNAMICTEMPERATUREUNIT</para>
	/// <para>,TIMEUNIT</para>
	/// <para>,VOLUMEUNIT</para>
	/// <para>,USERDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcUnitEnum
	{
		public static string ABSORBEDDOSEUNIT { get {return ".ABSORBEDDOSEUNIT.";} }
		public static string AMOUNTOFSUBSTANCEUNIT { get {return ".AMOUNTOFSUBSTANCEUNIT.";} }
		public static string AREAUNIT { get {return ".AREAUNIT.";} }
		public static string DOSEEQUIVALENTUNIT { get {return ".DOSEEQUIVALENTUNIT.";} }
		public static string ELECTRICCAPACITANCEUNIT { get {return ".ELECTRICCAPACITANCEUNIT.";} }
		public static string ELECTRICCHARGEUNIT { get {return ".ELECTRICCHARGEUNIT.";} }
		public static string ELECTRICCONDUCTANCEUNIT { get {return ".ELECTRICCONDUCTANCEUNIT.";} }
		public static string ELECTRICCURRENTUNIT { get {return ".ELECTRICCURRENTUNIT.";} }
		public static string ELECTRICRESISTANCEUNIT { get {return ".ELECTRICRESISTANCEUNIT.";} }
		public static string ELECTRICVOLTAGEUNIT { get {return ".ELECTRICVOLTAGEUNIT.";} }
		public static string ENERGYUNIT { get {return ".ENERGYUNIT.";} }
		public static string FORCEUNIT { get {return ".FORCEUNIT.";} }
		public static string FREQUENCYUNIT { get {return ".FREQUENCYUNIT.";} }
		public static string ILLUMINANCEUNIT { get {return ".ILLUMINANCEUNIT.";} }
		public static string INDUCTANCEUNIT { get {return ".INDUCTANCEUNIT.";} }
		public static string LENGTHUNIT { get {return ".LENGTHUNIT.";} }
		public static string LUMINOUSFLUXUNIT { get {return ".LUMINOUSFLUXUNIT.";} }
		public static string LUMINOUSINTENSITYUNIT { get {return ".LUMINOUSINTENSITYUNIT.";} }
		public static string MAGNETICFLUXDENSITYUNIT { get {return ".MAGNETICFLUXDENSITYUNIT.";} }
		public static string MAGNETICFLUXUNIT { get {return ".MAGNETICFLUXUNIT.";} }
		public static string MASSUNIT { get {return ".MASSUNIT.";} }
		public static string PLANEANGLEUNIT { get {return ".PLANEANGLEUNIT.";} }
		public static string POWERUNIT { get {return ".POWERUNIT.";} }
		public static string PRESSUREUNIT { get {return ".PRESSUREUNIT.";} }
		public static string RADIOACTIVITYUNIT { get {return ".RADIOACTIVITYUNIT.";} }
		public static string SOLIDANGLEUNIT { get {return ".SOLIDANGLEUNIT.";} }
		public static string THERMODYNAMICTEMPERATUREUNIT { get {return ".THERMODYNAMICTEMPERATUREUNIT.";} }
		public static string TIMEUNIT { get {return ".TIMEUNIT.";} }
		public static string VOLUMEUNIT { get {return ".VOLUMEUNIT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public string Value;
		public IfcUnitEnum() { Value = ".ABSORBEDDOSEUNIT.";}
		public IfcUnitEnum(string value) { Value = value; }
		public static implicit operator IfcUnitEnum(string value) { return new IfcUnitEnum(value);}
		public static implicit operator string(IfcUnitEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcUnitaryControlElementTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcUnitaryControlElementTypeEnum = ENUMERATION OF</para>
	/// <para>(ALARMPANEL</para>
	/// <para>,CONTROLPANEL</para>
	/// <para>,GASDETECTIONPANEL</para>
	/// <para>,INDICATORPANEL</para>
	/// <para>,MIMICPANEL</para>
	/// <para>,HUMIDISTAT</para>
	/// <para>,THERMOSTAT</para>
	/// <para>,WEATHERSTATION</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcUnitaryControlElementTypeEnum
	{
		public static string ALARMPANEL { get {return ".ALARMPANEL.";} }
		public static string CONTROLPANEL { get {return ".CONTROLPANEL.";} }
		public static string GASDETECTIONPANEL { get {return ".GASDETECTIONPANEL.";} }
		public static string INDICATORPANEL { get {return ".INDICATORPANEL.";} }
		public static string MIMICPANEL { get {return ".MIMICPANEL.";} }
		public static string HUMIDISTAT { get {return ".HUMIDISTAT.";} }
		public static string THERMOSTAT { get {return ".THERMOSTAT.";} }
		public static string WEATHERSTATION { get {return ".WEATHERSTATION.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcUnitaryControlElementTypeEnum() { Value = ".ALARMPANEL.";}
		public IfcUnitaryControlElementTypeEnum(string value) { Value = value; }
		public static implicit operator IfcUnitaryControlElementTypeEnum(string value) { return new IfcUnitaryControlElementTypeEnum(value);}
		public static implicit operator string(IfcUnitaryControlElementTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcUnitaryEquipmentTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcUnitaryEquipmentTypeEnum = ENUMERATION OF</para>
	/// <para>(AIRHANDLER</para>
	/// <para>,AIRCONDITIONINGUNIT</para>
	/// <para>,DEHUMIDIFIER</para>
	/// <para>,SPLITSYSTEM</para>
	/// <para>,ROOFTOPUNIT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcUnitaryEquipmentTypeEnum
	{
		public static string AIRHANDLER { get {return ".AIRHANDLER.";} }
		public static string AIRCONDITIONINGUNIT { get {return ".AIRCONDITIONINGUNIT.";} }
		public static string DEHUMIDIFIER { get {return ".DEHUMIDIFIER.";} }
		public static string SPLITSYSTEM { get {return ".SPLITSYSTEM.";} }
		public static string ROOFTOPUNIT { get {return ".ROOFTOPUNIT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcUnitaryEquipmentTypeEnum() { Value = ".AIRHANDLER.";}
		public IfcUnitaryEquipmentTypeEnum(string value) { Value = value; }
		public static implicit operator IfcUnitaryEquipmentTypeEnum(string value) { return new IfcUnitaryEquipmentTypeEnum(value);}
		public static implicit operator string(IfcUnitaryEquipmentTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcValveTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcValveTypeEnum = ENUMERATION OF</para>
	/// <para>(AIRRELEASE</para>
	/// <para>,ANTIVACUUM</para>
	/// <para>,CHANGEOVER</para>
	/// <para>,CHECK</para>
	/// <para>,COMMISSIONING</para>
	/// <para>,DIVERTING</para>
	/// <para>,DRAWOFFCOCK</para>
	/// <para>,DOUBLECHECK</para>
	/// <para>,DOUBLEREGULATING</para>
	/// <para>,FAUCET</para>
	/// <para>,FLUSHING</para>
	/// <para>,GASCOCK</para>
	/// <para>,GASTAP</para>
	/// <para>,ISOLATING</para>
	/// <para>,MIXING</para>
	/// <para>,PRESSUREREDUCING</para>
	/// <para>,PRESSURERELIEF</para>
	/// <para>,REGULATING</para>
	/// <para>,SAFETYCUTOFF</para>
	/// <para>,STEAMTRAP</para>
	/// <para>,STOPCOCK</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcValveTypeEnum
	{
		public static string AIRRELEASE { get {return ".AIRRELEASE.";} }
		public static string ANTIVACUUM { get {return ".ANTIVACUUM.";} }
		public static string CHANGEOVER { get {return ".CHANGEOVER.";} }
		public static string CHECK { get {return ".CHECK.";} }
		public static string COMMISSIONING { get {return ".COMMISSIONING.";} }
		public static string DIVERTING { get {return ".DIVERTING.";} }
		public static string DRAWOFFCOCK { get {return ".DRAWOFFCOCK.";} }
		public static string DOUBLECHECK { get {return ".DOUBLECHECK.";} }
		public static string DOUBLEREGULATING { get {return ".DOUBLEREGULATING.";} }
		public static string FAUCET { get {return ".FAUCET.";} }
		public static string FLUSHING { get {return ".FLUSHING.";} }
		public static string GASCOCK { get {return ".GASCOCK.";} }
		public static string GASTAP { get {return ".GASTAP.";} }
		public static string ISOLATING { get {return ".ISOLATING.";} }
		public static string MIXING { get {return ".MIXING.";} }
		public static string PRESSUREREDUCING { get {return ".PRESSUREREDUCING.";} }
		public static string PRESSURERELIEF { get {return ".PRESSURERELIEF.";} }
		public static string REGULATING { get {return ".REGULATING.";} }
		public static string SAFETYCUTOFF { get {return ".SAFETYCUTOFF.";} }
		public static string STEAMTRAP { get {return ".STEAMTRAP.";} }
		public static string STOPCOCK { get {return ".STOPCOCK.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcValveTypeEnum() { Value = ".AIRRELEASE.";}
		public IfcValveTypeEnum(string value) { Value = value; }
		public static implicit operator IfcValveTypeEnum(string value) { return new IfcValveTypeEnum(value);}
		public static implicit operator string(IfcValveTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVibrationIsolatorTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcVibrationIsolatorTypeEnum = ENUMERATION OF</para>
	/// <para>(COMPRESSION</para>
	/// <para>,SPRING</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVibrationIsolatorTypeEnum
	{
		public static string COMPRESSION { get {return ".COMPRESSION.";} }
		public static string SPRING { get {return ".SPRING.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcVibrationIsolatorTypeEnum() { Value = ".COMPRESSION.";}
		public IfcVibrationIsolatorTypeEnum(string value) { Value = value; }
		public static implicit operator IfcVibrationIsolatorTypeEnum(string value) { return new IfcVibrationIsolatorTypeEnum(value);}
		public static implicit operator string(IfcVibrationIsolatorTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcVoidingFeatureTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcVoidingFeatureTypeEnum = ENUMERATION OF</para>
	/// <para>(CUTOUT</para>
	/// <para>,NOTCH</para>
	/// <para>,HOLE</para>
	/// <para>,MITER</para>
	/// <para>,CHAMFER</para>
	/// <para>,EDGE</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcVoidingFeatureTypeEnum
	{
		public static string CUTOUT { get {return ".CUTOUT.";} }
		public static string NOTCH { get {return ".NOTCH.";} }
		public static string HOLE { get {return ".HOLE.";} }
		public static string MITER { get {return ".MITER.";} }
		public static string CHAMFER { get {return ".CHAMFER.";} }
		public static string EDGE { get {return ".EDGE.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcVoidingFeatureTypeEnum() { Value = ".CUTOUT.";}
		public IfcVoidingFeatureTypeEnum(string value) { Value = value; }
		public static implicit operator IfcVoidingFeatureTypeEnum(string value) { return new IfcVoidingFeatureTypeEnum(value);}
		public static implicit operator string(IfcVoidingFeatureTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWallTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWallTypeEnum = ENUMERATION OF</para>
	/// <para>(MOVABLE</para>
	/// <para>,PARAPET</para>
	/// <para>,PARTITIONING</para>
	/// <para>,PLUMBINGWALL</para>
	/// <para>,SHEAR</para>
	/// <para>,SOLIDWALL</para>
	/// <para>,STANDARD</para>
	/// <para>,POLYGONAL</para>
	/// <para>,ELEMENTEDWALL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWallTypeEnum
	{
		public static string MOVABLE { get {return ".MOVABLE.";} }
		public static string PARAPET { get {return ".PARAPET.";} }
		public static string PARTITIONING { get {return ".PARTITIONING.";} }
		public static string PLUMBINGWALL { get {return ".PLUMBINGWALL.";} }
		public static string SHEAR { get {return ".SHEAR.";} }
		public static string SOLIDWALL { get {return ".SOLIDWALL.";} }
		public static string STANDARD { get {return ".STANDARD.";} }
		public static string POLYGONAL { get {return ".POLYGONAL.";} }
		public static string ELEMENTEDWALL { get {return ".ELEMENTEDWALL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWallTypeEnum() { Value = ".MOVABLE.";}
		public IfcWallTypeEnum(string value) { Value = value; }
		public static implicit operator IfcWallTypeEnum(string value) { return new IfcWallTypeEnum(value);}
		public static implicit operator string(IfcWallTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWasteTerminalTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWasteTerminalTypeEnum = ENUMERATION OF</para>
	/// <para>(FLOORTRAP</para>
	/// <para>,FLOORWASTE</para>
	/// <para>,GULLYSUMP</para>
	/// <para>,GULLYTRAP</para>
	/// <para>,ROOFDRAIN</para>
	/// <para>,WASTEDISPOSALUNIT</para>
	/// <para>,WASTETRAP</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWasteTerminalTypeEnum
	{
		public static string FLOORTRAP { get {return ".FLOORTRAP.";} }
		public static string FLOORWASTE { get {return ".FLOORWASTE.";} }
		public static string GULLYSUMP { get {return ".GULLYSUMP.";} }
		public static string GULLYTRAP { get {return ".GULLYTRAP.";} }
		public static string ROOFDRAIN { get {return ".ROOFDRAIN.";} }
		public static string WASTEDISPOSALUNIT { get {return ".WASTEDISPOSALUNIT.";} }
		public static string WASTETRAP { get {return ".WASTETRAP.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWasteTerminalTypeEnum() { Value = ".FLOORTRAP.";}
		public IfcWasteTerminalTypeEnum(string value) { Value = value; }
		public static implicit operator IfcWasteTerminalTypeEnum(string value) { return new IfcWasteTerminalTypeEnum(value);}
		public static implicit operator string(IfcWasteTerminalTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowPanelOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowPanelOperationEnum = ENUMERATION OF</para>
	/// <para>(SIDEHUNGRIGHTHAND</para>
	/// <para>,SIDEHUNGLEFTHAND</para>
	/// <para>,TILTANDTURNRIGHTHAND</para>
	/// <para>,TILTANDTURNLEFTHAND</para>
	/// <para>,TOPHUNG</para>
	/// <para>,BOTTOMHUNG</para>
	/// <para>,PIVOTHORIZONTAL</para>
	/// <para>,PIVOTVERTICAL</para>
	/// <para>,SLIDINGHORIZONTAL</para>
	/// <para>,SLIDINGVERTICAL</para>
	/// <para>,REMOVABLECASEMENT</para>
	/// <para>,FIXEDCASEMENT</para>
	/// <para>,OTHEROPERATION</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowPanelOperationEnum
	{
		public static string SIDEHUNGRIGHTHAND { get {return ".SIDEHUNGRIGHTHAND.";} }
		public static string SIDEHUNGLEFTHAND { get {return ".SIDEHUNGLEFTHAND.";} }
		public static string TILTANDTURNRIGHTHAND { get {return ".TILTANDTURNRIGHTHAND.";} }
		public static string TILTANDTURNLEFTHAND { get {return ".TILTANDTURNLEFTHAND.";} }
		public static string TOPHUNG { get {return ".TOPHUNG.";} }
		public static string BOTTOMHUNG { get {return ".BOTTOMHUNG.";} }
		public static string PIVOTHORIZONTAL { get {return ".PIVOTHORIZONTAL.";} }
		public static string PIVOTVERTICAL { get {return ".PIVOTVERTICAL.";} }
		public static string SLIDINGHORIZONTAL { get {return ".SLIDINGHORIZONTAL.";} }
		public static string SLIDINGVERTICAL { get {return ".SLIDINGVERTICAL.";} }
		public static string REMOVABLECASEMENT { get {return ".REMOVABLECASEMENT.";} }
		public static string FIXEDCASEMENT { get {return ".FIXEDCASEMENT.";} }
		public static string OTHEROPERATION { get {return ".OTHEROPERATION.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWindowPanelOperationEnum() { Value = ".SIDEHUNGRIGHTHAND.";}
		public IfcWindowPanelOperationEnum(string value) { Value = value; }
		public static implicit operator IfcWindowPanelOperationEnum(string value) { return new IfcWindowPanelOperationEnum(value);}
		public static implicit operator string(IfcWindowPanelOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowPanelPositionEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowPanelPositionEnum = ENUMERATION OF</para>
	/// <para>(LEFT</para>
	/// <para>,MIDDLE</para>
	/// <para>,RIGHT</para>
	/// <para>,BOTTOM</para>
	/// <para>,TOP</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowPanelPositionEnum
	{
		public static string LEFT { get {return ".LEFT.";} }
		public static string MIDDLE { get {return ".MIDDLE.";} }
		public static string RIGHT { get {return ".RIGHT.";} }
		public static string BOTTOM { get {return ".BOTTOM.";} }
		public static string TOP { get {return ".TOP.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWindowPanelPositionEnum() { Value = ".LEFT.";}
		public IfcWindowPanelPositionEnum(string value) { Value = value; }
		public static implicit operator IfcWindowPanelPositionEnum(string value) { return new IfcWindowPanelPositionEnum(value);}
		public static implicit operator string(IfcWindowPanelPositionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowStyleConstructionEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowStyleConstructionEnum = ENUMERATION OF</para>
	/// <para>(ALUMINIUM</para>
	/// <para>,HIGH_GRADE_STEEL</para>
	/// <para>,STEEL</para>
	/// <para>,WOOD</para>
	/// <para>,ALUMINIUM_WOOD</para>
	/// <para>,PLASTIC</para>
	/// <para>,OTHER_CONSTRUCTION</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowStyleConstructionEnum
	{
		public static string ALUMINIUM { get {return ".ALUMINIUM.";} }
		public static string HIGH_GRADE_STEEL { get {return ".HIGH_GRADE_STEEL.";} }
		public static string STEEL { get {return ".STEEL.";} }
		public static string WOOD { get {return ".WOOD.";} }
		public static string ALUMINIUM_WOOD { get {return ".ALUMINIUM_WOOD.";} }
		public static string PLASTIC { get {return ".PLASTIC.";} }
		public static string OTHER_CONSTRUCTION { get {return ".OTHER_CONSTRUCTION.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWindowStyleConstructionEnum() { Value = ".ALUMINIUM.";}
		public IfcWindowStyleConstructionEnum(string value) { Value = value; }
		public static implicit operator IfcWindowStyleConstructionEnum(string value) { return new IfcWindowStyleConstructionEnum(value);}
		public static implicit operator string(IfcWindowStyleConstructionEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowStyleOperationEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowStyleOperationEnum = ENUMERATION OF</para>
	/// <para>(SINGLE_PANEL</para>
	/// <para>,DOUBLE_PANEL_VERTICAL</para>
	/// <para>,DOUBLE_PANEL_HORIZONTAL</para>
	/// <para>,TRIPLE_PANEL_VERTICAL</para>
	/// <para>,TRIPLE_PANEL_BOTTOM</para>
	/// <para>,TRIPLE_PANEL_TOP</para>
	/// <para>,TRIPLE_PANEL_LEFT</para>
	/// <para>,TRIPLE_PANEL_RIGHT</para>
	/// <para>,TRIPLE_PANEL_HORIZONTAL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowStyleOperationEnum
	{
		public static string SINGLE_PANEL { get {return ".SINGLE_PANEL.";} }
		public static string DOUBLE_PANEL_VERTICAL { get {return ".DOUBLE_PANEL_VERTICAL.";} }
		public static string DOUBLE_PANEL_HORIZONTAL { get {return ".DOUBLE_PANEL_HORIZONTAL.";} }
		public static string TRIPLE_PANEL_VERTICAL { get {return ".TRIPLE_PANEL_VERTICAL.";} }
		public static string TRIPLE_PANEL_BOTTOM { get {return ".TRIPLE_PANEL_BOTTOM.";} }
		public static string TRIPLE_PANEL_TOP { get {return ".TRIPLE_PANEL_TOP.";} }
		public static string TRIPLE_PANEL_LEFT { get {return ".TRIPLE_PANEL_LEFT.";} }
		public static string TRIPLE_PANEL_RIGHT { get {return ".TRIPLE_PANEL_RIGHT.";} }
		public static string TRIPLE_PANEL_HORIZONTAL { get {return ".TRIPLE_PANEL_HORIZONTAL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWindowStyleOperationEnum() { Value = ".SINGLE_PANEL.";}
		public IfcWindowStyleOperationEnum(string value) { Value = value; }
		public static implicit operator IfcWindowStyleOperationEnum(string value) { return new IfcWindowStyleOperationEnum(value);}
		public static implicit operator string(IfcWindowStyleOperationEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowTypeEnum = ENUMERATION OF</para>
	/// <para>(WINDOW</para>
	/// <para>,SKYLIGHT</para>
	/// <para>,LIGHTDOME</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowTypeEnum
	{
		public static string WINDOW { get {return ".WINDOW.";} }
		public static string SKYLIGHT { get {return ".SKYLIGHT.";} }
		public static string LIGHTDOME { get {return ".LIGHTDOME.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWindowTypeEnum() { Value = ".WINDOW.";}
		public IfcWindowTypeEnum(string value) { Value = value; }
		public static implicit operator IfcWindowTypeEnum(string value) { return new IfcWindowTypeEnum(value);}
		public static implicit operator string(IfcWindowTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWindowTypePartitioningEnum = ENUMERATION OF
	/// <para>TYPE IfcWindowTypePartitioningEnum = ENUMERATION OF</para>
	/// <para>(SINGLE_PANEL</para>
	/// <para>,DOUBLE_PANEL_VERTICAL</para>
	/// <para>,DOUBLE_PANEL_HORIZONTAL</para>
	/// <para>,TRIPLE_PANEL_VERTICAL</para>
	/// <para>,TRIPLE_PANEL_BOTTOM</para>
	/// <para>,TRIPLE_PANEL_TOP</para>
	/// <para>,TRIPLE_PANEL_LEFT</para>
	/// <para>,TRIPLE_PANEL_RIGHT</para>
	/// <para>,TRIPLE_PANEL_HORIZONTAL</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWindowTypePartitioningEnum
	{
		public static string SINGLE_PANEL { get {return ".SINGLE_PANEL.";} }
		public static string DOUBLE_PANEL_VERTICAL { get {return ".DOUBLE_PANEL_VERTICAL.";} }
		public static string DOUBLE_PANEL_HORIZONTAL { get {return ".DOUBLE_PANEL_HORIZONTAL.";} }
		public static string TRIPLE_PANEL_VERTICAL { get {return ".TRIPLE_PANEL_VERTICAL.";} }
		public static string TRIPLE_PANEL_BOTTOM { get {return ".TRIPLE_PANEL_BOTTOM.";} }
		public static string TRIPLE_PANEL_TOP { get {return ".TRIPLE_PANEL_TOP.";} }
		public static string TRIPLE_PANEL_LEFT { get {return ".TRIPLE_PANEL_LEFT.";} }
		public static string TRIPLE_PANEL_RIGHT { get {return ".TRIPLE_PANEL_RIGHT.";} }
		public static string TRIPLE_PANEL_HORIZONTAL { get {return ".TRIPLE_PANEL_HORIZONTAL.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWindowTypePartitioningEnum() { Value = ".SINGLE_PANEL.";}
		public IfcWindowTypePartitioningEnum(string value) { Value = value; }
		public static implicit operator IfcWindowTypePartitioningEnum(string value) { return new IfcWindowTypePartitioningEnum(value);}
		public static implicit operator string(IfcWindowTypePartitioningEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWorkCalendarTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWorkCalendarTypeEnum = ENUMERATION OF</para>
	/// <para>(FIRSTSHIFT</para>
	/// <para>,SECONDSHIFT</para>
	/// <para>,THIRDSHIFT</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWorkCalendarTypeEnum
	{
		public static string FIRSTSHIFT { get {return ".FIRSTSHIFT.";} }
		public static string SECONDSHIFT { get {return ".SECONDSHIFT.";} }
		public static string THIRDSHIFT { get {return ".THIRDSHIFT.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWorkCalendarTypeEnum() { Value = ".FIRSTSHIFT.";}
		public IfcWorkCalendarTypeEnum(string value) { Value = value; }
		public static implicit operator IfcWorkCalendarTypeEnum(string value) { return new IfcWorkCalendarTypeEnum(value);}
		public static implicit operator string(IfcWorkCalendarTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWorkPlanTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWorkPlanTypeEnum = ENUMERATION OF</para>
	/// <para>(ACTUAL</para>
	/// <para>,BASELINE</para>
	/// <para>,PLANNED</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWorkPlanTypeEnum
	{
		public static string ACTUAL { get {return ".ACTUAL.";} }
		public static string BASELINE { get {return ".BASELINE.";} }
		public static string PLANNED { get {return ".PLANNED.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWorkPlanTypeEnum() { Value = ".ACTUAL.";}
		public IfcWorkPlanTypeEnum(string value) { Value = value; }
		public static implicit operator IfcWorkPlanTypeEnum(string value) { return new IfcWorkPlanTypeEnum(value);}
		public static implicit operator string(IfcWorkPlanTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcWorkScheduleTypeEnum = ENUMERATION OF
	/// <para>TYPE IfcWorkScheduleTypeEnum = ENUMERATION OF</para>
	/// <para>(ACTUAL</para>
	/// <para>,BASELINE</para>
	/// <para>,PLANNED</para>
	/// <para>,USERDEFINED</para>
	/// <para>,NOTDEFINED);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public class IfcWorkScheduleTypeEnum
	{
		public static string ACTUAL { get {return ".ACTUAL.";} }
		public static string BASELINE { get {return ".BASELINE.";} }
		public static string PLANNED { get {return ".PLANNED.";} }
		public static string USERDEFINED { get {return ".USERDEFINED.";} }
		public static string NOTDEFINED { get {return ".NOTDEFINED.";} }
		public string Value;
		public IfcWorkScheduleTypeEnum() { Value = ".ACTUAL.";}
		public IfcWorkScheduleTypeEnum(string value) { Value = value; }
		public static implicit operator IfcWorkScheduleTypeEnum(string value) { return new IfcWorkScheduleTypeEnum(value);}
		public static implicit operator string(IfcWorkScheduleTypeEnum value) { return value.Value;}
	}
	/// <summary>
	/// TYPE IfcActorSelect = SELECT
	/// <para>TYPE IfcActorSelect = SELECT</para>
	/// <para>(IfcOrganization</para>
	/// <para>,IfcPerson</para>
	/// <para>,IfcPersonAndOrganization);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcActorSelect
	{
		public List<IfcActorRole>? Roles { get;  }
	}
	/// <summary>
	/// TYPE IfcAppliedValueSelect = SELECT
	/// <para>TYPE IfcAppliedValueSelect = SELECT</para>
	/// <para>(IfcMeasureWithUnit</para>
	/// <para>,IfcReference</para>
	/// <para>,IfcValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcAppliedValueSelect
	{
	}
	/// <summary>
	/// TYPE IfcAxis2Placement = SELECT
	/// <para>TYPE IfcAxis2Placement = SELECT</para>
	/// <para>(IfcAxis2Placement2D</para>
	/// <para>,IfcAxis2Placement3D);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcAxis2Placement
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
		public IfcCartesianPoint? Location { get;  }
		public IfcDimensionCount? Dim { get;  }
		public IfcDirection? RefDirection { get;  }
		public List<IfcDirection>? P { get;  }
	}
	/// <summary>
	/// TYPE IfcBendingParameterSelect = SELECT
	/// <para>TYPE IfcBendingParameterSelect = SELECT</para>
	/// <para>(IfcLengthMeasure</para>
	/// <para>,IfcPlaneAngleMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcBendingParameterSelect
	{
	}
	/// <summary>
	/// TYPE IfcBooleanOperand = SELECT
	/// <para>TYPE IfcBooleanOperand = SELECT</para>
	/// <para>(IfcBooleanResult</para>
	/// <para>,IfcCsgPrimitive3D</para>
	/// <para>,IfcHalfSpaceSolid</para>
	/// <para>,IfcSolidModel</para>
	/// <para>,IfcTessellatedFaceSet);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcBooleanOperand
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
		public IfcDimensionCount? Dim { get;  }
	}
	/// <summary>
	/// TYPE IfcClassificationReferenceSelect = SELECT
	/// <para>TYPE IfcClassificationReferenceSelect = SELECT</para>
	/// <para>(IfcClassification</para>
	/// <para>,IfcClassificationReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcClassificationReferenceSelect
	{
		public IfcLabel? Name { get;  }
		public IfcText? Description { get;  }
		public IfcURIReference? Location { get;  }
		public List<IfcClassificationReference>? HasReferences { get;  }
	}
	/// <summary>
	/// TYPE IfcClassificationSelect = SELECT
	/// <para>TYPE IfcClassificationSelect = SELECT</para>
	/// <para>(IfcClassification</para>
	/// <para>,IfcClassificationReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcClassificationSelect
	{
		public IfcLabel? Name { get;  }
		public IfcText? Description { get;  }
		public IfcURIReference? Location { get;  }
		public List<IfcClassificationReference>? HasReferences { get;  }
	}
	/// <summary>
	/// TYPE IfcColour = SELECT
	/// <para>TYPE IfcColour = SELECT</para>
	/// <para>(IfcColourSpecification</para>
	/// <para>,IfcPreDefinedColour);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcColour: IfcFillStyleSelect
	{
		public IfcLabel? Name { get;  }
	}
	/// <summary>
	/// TYPE IfcColourOrFactor = SELECT
	/// <para>TYPE IfcColourOrFactor = SELECT</para>
	/// <para>(IfcColourRgb</para>
	/// <para>,IfcNormalisedRatioMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcColourOrFactor
	{
	}
	/// <summary>
	/// TYPE IfcCoordinateReferenceSystemSelect = SELECT
	/// <para>TYPE IfcCoordinateReferenceSystemSelect = SELECT</para>
	/// <para>(IfcCoordinateReferenceSystem</para>
	/// <para>,IfcGeometricRepresentationContext);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCoordinateReferenceSystemSelect
	{
		public List<IfcCoordinateOperation>? HasCoordinateOperation { get;  }
	}
	/// <summary>
	/// TYPE IfcCsgSelect = SELECT
	/// <para>TYPE IfcCsgSelect = SELECT</para>
	/// <para>(IfcBooleanResult</para>
	/// <para>,IfcCsgPrimitive3D);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCsgSelect
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
		public IfcDimensionCount? Dim { get;  }
	}
	/// <summary>
	/// TYPE IfcCurveFontOrScaledCurveFontSelect = SELECT
	/// <para>TYPE IfcCurveFontOrScaledCurveFontSelect = SELECT</para>
	/// <para>(IfcCurveStyleFontAndScaling</para>
	/// <para>,IfcCurveStyleFontSelect);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveFontOrScaledCurveFontSelect
	{
		public IfcLabel? Name { get;  }
	}
	/// <summary>
	/// TYPE IfcCurveOnSurface = SELECT
	/// <para>TYPE IfcCurveOnSurface = SELECT</para>
	/// <para>(IfcCompositeCurveOnSurface</para>
	/// <para>,IfcPcurve</para>
	/// <para>,IfcSurfaceCurve);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveOnSurface
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
		public IfcDimensionCount? Dim { get;  }
	}
	/// <summary>
	/// TYPE IfcCurveOrEdgeCurve = SELECT
	/// <para>TYPE IfcCurveOrEdgeCurve = SELECT</para>
	/// <para>(IfcBoundedCurve</para>
	/// <para>,IfcEdgeCurve);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveOrEdgeCurve
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
	}
	/// <summary>
	/// TYPE IfcCurveStyleFontSelect = SELECT
	/// <para>TYPE IfcCurveStyleFontSelect = SELECT</para>
	/// <para>(IfcCurveStyleFont</para>
	/// <para>,IfcPreDefinedCurveFont);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcCurveStyleFontSelect: IfcCurveFontOrScaledCurveFontSelect
	{
	}
	/// <summary>
	/// TYPE IfcDefinitionSelect = SELECT
	/// <para>TYPE IfcDefinitionSelect = SELECT</para>
	/// <para>(IfcObjectDefinition</para>
	/// <para>,IfcPropertyDefinition);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcDefinitionSelect
	{
		public IfcGloballyUniqueId? GlobalId { get;  }
		public IfcOwnerHistory? OwnerHistory { get;  }
		public IfcLabel? Name { get;  }
		public IfcText? Description { get;  }
		public List<IfcRelDeclares>? HasContext { get;  }
		public List<IfcRelAssociates>? HasAssociations { get;  }
	}
	/// <summary>
	/// TYPE IfcDerivedMeasureValue = SELECT
	/// <para>TYPE IfcDerivedMeasureValue = SELECT</para>
	/// <para>(IfcAbsorbedDoseMeasure</para>
	/// <para>,IfcAccelerationMeasure</para>
	/// <para>,IfcAngularVelocityMeasure</para>
	/// <para>,IfcAreaDensityMeasure</para>
	/// <para>,IfcCompoundPlaneAngleMeasure</para>
	/// <para>,IfcCurvatureMeasure</para>
	/// <para>,IfcDoseEquivalentMeasure</para>
	/// <para>,IfcDynamicViscosityMeasure</para>
	/// <para>,IfcElectricCapacitanceMeasure</para>
	/// <para>,IfcElectricChargeMeasure</para>
	/// <para>,IfcElectricConductanceMeasure</para>
	/// <para>,IfcElectricResistanceMeasure</para>
	/// <para>,IfcElectricVoltageMeasure</para>
	/// <para>,IfcEnergyMeasure</para>
	/// <para>,IfcForceMeasure</para>
	/// <para>,IfcFrequencyMeasure</para>
	/// <para>,IfcHeatFluxDensityMeasure</para>
	/// <para>,IfcHeatingValueMeasure</para>
	/// <para>,IfcIlluminanceMeasure</para>
	/// <para>,IfcInductanceMeasure</para>
	/// <para>,IfcIntegerCountRateMeasure</para>
	/// <para>,IfcIonConcentrationMeasure</para>
	/// <para>,IfcIsothermalMoistureCapacityMeasure</para>
	/// <para>,IfcKinematicViscosityMeasure</para>
	/// <para>,IfcLinearForceMeasure</para>
	/// <para>,IfcLinearMomentMeasure</para>
	/// <para>,IfcLinearStiffnessMeasure</para>
	/// <para>,IfcLinearVelocityMeasure</para>
	/// <para>,IfcLuminousFluxMeasure</para>
	/// <para>,IfcLuminousIntensityDistributionMeasure</para>
	/// <para>,IfcMagneticFluxDensityMeasure</para>
	/// <para>,IfcMagneticFluxMeasure</para>
	/// <para>,IfcMassDensityMeasure</para>
	/// <para>,IfcMassFlowRateMeasure</para>
	/// <para>,IfcMassPerLengthMeasure</para>
	/// <para>,IfcModulusOfElasticityMeasure</para>
	/// <para>,IfcModulusOfLinearSubgradeReactionMeasure</para>
	/// <para>,IfcModulusOfRotationalSubgradeReactionMeasure</para>
	/// <para>,IfcModulusOfSubgradeReactionMeasure</para>
	/// <para>,IfcMoistureDiffusivityMeasure</para>
	/// <para>,IfcMolecularWeightMeasure</para>
	/// <para>,IfcMomentOfInertiaMeasure</para>
	/// <para>,IfcMonetaryMeasure</para>
	/// <para>,IfcPHMeasure</para>
	/// <para>,IfcPlanarForceMeasure</para>
	/// <para>,IfcPowerMeasure</para>
	/// <para>,IfcPressureMeasure</para>
	/// <para>,IfcRadioActivityMeasure</para>
	/// <para>,IfcRotationalFrequencyMeasure</para>
	/// <para>,IfcRotationalMassMeasure</para>
	/// <para>,IfcRotationalStiffnessMeasure</para>
	/// <para>,IfcSectionModulusMeasure</para>
	/// <para>,IfcSectionalAreaIntegralMeasure</para>
	/// <para>,IfcShearModulusMeasure</para>
	/// <para>,IfcSoundPowerLevelMeasure</para>
	/// <para>,IfcSoundPowerMeasure</para>
	/// <para>,IfcSoundPressureLevelMeasure</para>
	/// <para>,IfcSoundPressureMeasure</para>
	/// <para>,IfcSpecificHeatCapacityMeasure</para>
	/// <para>,IfcTemperatureGradientMeasure</para>
	/// <para>,IfcTemperatureRateOfChangeMeasure</para>
	/// <para>,IfcThermalAdmittanceMeasure</para>
	/// <para>,IfcThermalConductivityMeasure</para>
	/// <para>,IfcThermalExpansionCoefficientMeasure</para>
	/// <para>,IfcThermalResistanceMeasure</para>
	/// <para>,IfcThermalTransmittanceMeasure</para>
	/// <para>,IfcTorqueMeasure</para>
	/// <para>,IfcVaporPermeabilityMeasure</para>
	/// <para>,IfcVolumetricFlowRateMeasure</para>
	/// <para>,IfcWarpingConstantMeasure</para>
	/// <para>,IfcWarpingMomentMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcDerivedMeasureValue: IfcValue
	{
	}
	/// <summary>
	/// TYPE IfcDocumentSelect = SELECT
	/// <para>TYPE IfcDocumentSelect = SELECT</para>
	/// <para>(IfcDocumentInformation</para>
	/// <para>,IfcDocumentReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcDocumentSelect
	{
		public IfcIdentifier? Identification { get;  }
		public IfcLabel? Name { get;  }
		public IfcText? Description { get;  }
		public IfcURIReference? Location { get;  }
	}
	/// <summary>
	/// TYPE IfcFillStyleSelect = SELECT
	/// <para>TYPE IfcFillStyleSelect = SELECT</para>
	/// <para>(IfcColour</para>
	/// <para>,IfcExternallyDefinedHatchStyle</para>
	/// <para>,IfcFillAreaStyleHatching</para>
	/// <para>,IfcFillAreaStyleTiles);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcFillStyleSelect
	{
	}
	/// <summary>
	/// TYPE IfcGeometricSetSelect = SELECT
	/// <para>TYPE IfcGeometricSetSelect = SELECT</para>
	/// <para>(IfcCurve</para>
	/// <para>,IfcPoint</para>
	/// <para>,IfcSurface);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcGeometricSetSelect
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
		public IfcDimensionCount? Dim { get;  }
	}
	/// <summary>
	/// TYPE IfcGridPlacementDirectionSelect = SELECT
	/// <para>TYPE IfcGridPlacementDirectionSelect = SELECT</para>
	/// <para>(IfcDirection</para>
	/// <para>,IfcVirtualGridIntersection);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcGridPlacementDirectionSelect
	{
	}
	/// <summary>
	/// TYPE IfcHatchLineDistanceSelect = SELECT
	/// <para>TYPE IfcHatchLineDistanceSelect = SELECT</para>
	/// <para>(IfcPositiveLengthMeasure</para>
	/// <para>,IfcVector);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcHatchLineDistanceSelect
	{
	}
	/// <summary>
	/// TYPE IfcLayeredItem = SELECT
	/// <para>TYPE IfcLayeredItem = SELECT</para>
	/// <para>(IfcRepresentation</para>
	/// <para>,IfcRepresentationItem);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcLayeredItem
	{
	}
	/// <summary>
	/// TYPE IfcLibrarySelect = SELECT
	/// <para>TYPE IfcLibrarySelect = SELECT</para>
	/// <para>(IfcLibraryInformation</para>
	/// <para>,IfcLibraryReference);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcLibrarySelect
	{
		public IfcLabel? Name { get;  }
		public IfcURIReference? Location { get;  }
		public IfcText? Description { get;  }
	}
	/// <summary>
	/// TYPE IfcLightDistributionDataSourceSelect = SELECT
	/// <para>TYPE IfcLightDistributionDataSourceSelect = SELECT</para>
	/// <para>(IfcExternalReference</para>
	/// <para>,IfcLightIntensityDistribution);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcLightDistributionDataSourceSelect
	{
	}
	/// <summary>
	/// TYPE IfcMaterialSelect = SELECT
	/// <para>TYPE IfcMaterialSelect = SELECT</para>
	/// <para>(IfcMaterialDefinition</para>
	/// <para>,IfcMaterialList</para>
	/// <para>,IfcMaterialUsageDefinition);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcMaterialSelect
	{
	}
	/// <summary>
	/// TYPE IfcMeasureValue = SELECT
	/// <para>TYPE IfcMeasureValue = SELECT</para>
	/// <para>(IfcAmountOfSubstanceMeasure</para>
	/// <para>,IfcAreaMeasure</para>
	/// <para>,IfcComplexNumber</para>
	/// <para>,IfcContextDependentMeasure</para>
	/// <para>,IfcCountMeasure</para>
	/// <para>,IfcDescriptiveMeasure</para>
	/// <para>,IfcElectricCurrentMeasure</para>
	/// <para>,IfcLengthMeasure</para>
	/// <para>,IfcLuminousIntensityMeasure</para>
	/// <para>,IfcMassMeasure</para>
	/// <para>,IfcNonNegativeLengthMeasure</para>
	/// <para>,IfcNormalisedRatioMeasure</para>
	/// <para>,IfcNumericMeasure</para>
	/// <para>,IfcParameterValue</para>
	/// <para>,IfcPlaneAngleMeasure</para>
	/// <para>,IfcPositiveLengthMeasure</para>
	/// <para>,IfcPositivePlaneAngleMeasure</para>
	/// <para>,IfcPositiveRatioMeasure</para>
	/// <para>,IfcRatioMeasure</para>
	/// <para>,IfcSolidAngleMeasure</para>
	/// <para>,IfcThermodynamicTemperatureMeasure</para>
	/// <para>,IfcTimeMeasure</para>
	/// <para>,IfcVolumeMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcMeasureValue: IfcValue
	{
	}
	/// <summary>
	/// TYPE IfcMetricValueSelect = SELECT
	/// <para>TYPE IfcMetricValueSelect = SELECT</para>
	/// <para>(IfcAppliedValue</para>
	/// <para>,IfcMeasureWithUnit</para>
	/// <para>,IfcReference</para>
	/// <para>,IfcTable</para>
	/// <para>,IfcTimeSeries</para>
	/// <para>,IfcValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcMetricValueSelect
	{
	}
	/// <summary>
	/// TYPE IfcModulusOfRotationalSubgradeReactionSelect = SELECT
	/// <para>TYPE IfcModulusOfRotationalSubgradeReactionSelect = SELECT</para>
	/// <para>(IfcBoolean</para>
	/// <para>,IfcModulusOfRotationalSubgradeReactionMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcModulusOfRotationalSubgradeReactionSelect
	{
	}
	/// <summary>
	/// TYPE IfcModulusOfSubgradeReactionSelect = SELECT
	/// <para>TYPE IfcModulusOfSubgradeReactionSelect = SELECT</para>
	/// <para>(IfcBoolean</para>
	/// <para>,IfcModulusOfSubgradeReactionMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcModulusOfSubgradeReactionSelect
	{
	}
	/// <summary>
	/// TYPE IfcModulusOfTranslationalSubgradeReactionSelect = SELECT
	/// <para>TYPE IfcModulusOfTranslationalSubgradeReactionSelect = SELECT</para>
	/// <para>(IfcBoolean</para>
	/// <para>,IfcModulusOfLinearSubgradeReactionMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcModulusOfTranslationalSubgradeReactionSelect
	{
	}
	/// <summary>
	/// TYPE IfcObjectReferenceSelect = SELECT
	/// <para>TYPE IfcObjectReferenceSelect = SELECT</para>
	/// <para>(IfcAddress</para>
	/// <para>,IfcAppliedValue</para>
	/// <para>,IfcExternalReference</para>
	/// <para>,IfcMaterialDefinition</para>
	/// <para>,IfcOrganization</para>
	/// <para>,IfcPerson</para>
	/// <para>,IfcPersonAndOrganization</para>
	/// <para>,IfcTable</para>
	/// <para>,IfcTimeSeries);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcObjectReferenceSelect
	{
	}
	/// <summary>
	/// TYPE IfcPointOrVertexPoint = SELECT
	/// <para>TYPE IfcPointOrVertexPoint = SELECT</para>
	/// <para>(IfcPoint</para>
	/// <para>,IfcVertexPoint);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcPointOrVertexPoint
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
	}
	/// <summary>
	/// TYPE IfcPresentationStyleSelect = SELECT
	/// <para>TYPE IfcPresentationStyleSelect = SELECT</para>
	/// <para>(IfcCurveStyle</para>
	/// <para>,IfcFillAreaStyle</para>
	/// <para>,IfcNullStyle</para>
	/// <para>,IfcSurfaceStyle</para>
	/// <para>,IfcTextStyle);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcPresentationStyleSelect
	{
		public IfcLabel? Name { get;  }
	}
	/// <summary>
	/// TYPE IfcProcessSelect = SELECT
	/// <para>TYPE IfcProcessSelect = SELECT</para>
	/// <para>(IfcProcess</para>
	/// <para>,IfcTypeProcess);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcProcessSelect
	{
		public IfcGloballyUniqueId? GlobalId { get;  }
		public IfcOwnerHistory? OwnerHistory { get;  }
		public IfcLabel? Name { get;  }
		public IfcText? Description { get;  }
		public List<IfcRelAssigns>? HasAssignments { get;  }
		public List<IfcRelNests>? Nests { get;  }
		public List<IfcRelNests>? IsNestedBy { get;  }
		public List<IfcRelDeclares>? HasContext { get;  }
		public List<IfcRelAggregates>? IsDecomposedBy { get;  }
		public List<IfcRelAggregates>? Decomposes { get;  }
		public List<IfcRelAssociates>? HasAssociations { get;  }
		public IfcIdentifier? Identification { get;  }
		public IfcText? LongDescription { get;  }
		public List<IfcRelAssignsToProcess>? OperatesOn { get;  }
	}
	/// <summary>
	/// TYPE IfcProductRepresentationSelect = SELECT
	/// <para>TYPE IfcProductRepresentationSelect = SELECT</para>
	/// <para>(IfcProductDefinitionShape</para>
	/// <para>,IfcRepresentationMap);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcProductRepresentationSelect
	{
		public List<IfcShapeAspect>? HasShapeAspects { get;  }
	}
	/// <summary>
	/// TYPE IfcProductSelect = SELECT
	/// <para>TYPE IfcProductSelect = SELECT</para>
	/// <para>(IfcProduct</para>
	/// <para>,IfcTypeProduct);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcProductSelect
	{
		public IfcGloballyUniqueId? GlobalId { get;  }
		public IfcOwnerHistory? OwnerHistory { get;  }
		public IfcLabel? Name { get;  }
		public IfcText? Description { get;  }
		public List<IfcRelAssigns>? HasAssignments { get;  }
		public List<IfcRelNests>? Nests { get;  }
		public List<IfcRelNests>? IsNestedBy { get;  }
		public List<IfcRelDeclares>? HasContext { get;  }
		public List<IfcRelAggregates>? IsDecomposedBy { get;  }
		public List<IfcRelAggregates>? Decomposes { get;  }
		public List<IfcRelAssociates>? HasAssociations { get;  }
		public List<IfcRelAssignsToProduct>? ReferencedBy { get;  }
	}
	/// <summary>
	/// TYPE IfcPropertySetDefinitionSelect = SELECT
	/// <para>TYPE IfcPropertySetDefinitionSelect = SELECT</para>
	/// <para>(IfcPropertySetDefinition</para>
	/// <para>,IfcPropertySetDefinitionSet);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcPropertySetDefinitionSelect
	{
	}
	/// <summary>
	/// TYPE IfcResourceObjectSelect = SELECT
	/// <para>TYPE IfcResourceObjectSelect = SELECT</para>
	/// <para>(IfcActorRole</para>
	/// <para>,IfcAppliedValue</para>
	/// <para>,IfcApproval</para>
	/// <para>,IfcConstraint</para>
	/// <para>,IfcContextDependentUnit</para>
	/// <para>,IfcConversionBasedUnit</para>
	/// <para>,IfcExternalInformation</para>
	/// <para>,IfcExternalReference</para>
	/// <para>,IfcMaterialDefinition</para>
	/// <para>,IfcOrganization</para>
	/// <para>,IfcPerson</para>
	/// <para>,IfcPersonAndOrganization</para>
	/// <para>,IfcPhysicalQuantity</para>
	/// <para>,IfcProfileDef</para>
	/// <para>,IfcPropertyAbstraction</para>
	/// <para>,IfcShapeAspect</para>
	/// <para>,IfcTimeSeries);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcResourceObjectSelect
	{
	}
	/// <summary>
	/// TYPE IfcResourceSelect = SELECT
	/// <para>TYPE IfcResourceSelect = SELECT</para>
	/// <para>(IfcResource</para>
	/// <para>,IfcTypeResource);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcResourceSelect
	{
		public IfcGloballyUniqueId? GlobalId { get;  }
		public IfcOwnerHistory? OwnerHistory { get;  }
		public IfcLabel? Name { get;  }
		public IfcText? Description { get;  }
		public List<IfcRelAssigns>? HasAssignments { get;  }
		public List<IfcRelNests>? Nests { get;  }
		public List<IfcRelNests>? IsNestedBy { get;  }
		public List<IfcRelDeclares>? HasContext { get;  }
		public List<IfcRelAggregates>? IsDecomposedBy { get;  }
		public List<IfcRelAggregates>? Decomposes { get;  }
		public List<IfcRelAssociates>? HasAssociations { get;  }
		public IfcIdentifier? Identification { get;  }
		public IfcText? LongDescription { get;  }
		public List<IfcRelAssignsToResource>? ResourceOf { get;  }
		public List<IfcAppliedValue>? BaseCosts { get;  }
		public IfcPhysicalQuantity? BaseQuantity { get;  }
	}
	/// <summary>
	/// TYPE IfcRotationalStiffnessSelect = SELECT
	/// <para>TYPE IfcRotationalStiffnessSelect = SELECT</para>
	/// <para>(IfcBoolean</para>
	/// <para>,IfcRotationalStiffnessMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcRotationalStiffnessSelect
	{
	}
	/// <summary>
	/// TYPE IfcSegmentIndexSelect = SELECT
	/// <para>TYPE IfcSegmentIndexSelect = SELECT</para>
	/// <para>(IfcArcIndex</para>
	/// <para>,IfcLineIndex);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSegmentIndexSelect
	{
	}
	/// <summary>
	/// TYPE IfcShell = SELECT
	/// <para>TYPE IfcShell = SELECT</para>
	/// <para>(IfcClosedShell</para>
	/// <para>,IfcOpenShell);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcShell
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
		public List<IfcFace>? CfsFaces { get;  }
	}
	/// <summary>
	/// TYPE IfcSimpleValue = SELECT
	/// <para>TYPE IfcSimpleValue = SELECT</para>
	/// <para>(IfcBinary</para>
	/// <para>,IfcBoolean</para>
	/// <para>,IfcDate</para>
	/// <para>,IfcDateTime</para>
	/// <para>,IfcDuration</para>
	/// <para>,IfcIdentifier</para>
	/// <para>,IfcInteger</para>
	/// <para>,IfcLabel</para>
	/// <para>,IfcLogical</para>
	/// <para>,IfcPositiveInteger</para>
	/// <para>,IfcReal</para>
	/// <para>,IfcText</para>
	/// <para>,IfcTime</para>
	/// <para>,IfcTimeStamp);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSimpleValue: IfcValue
	{
	}
	/// <summary>
	/// TYPE IfcSizeSelect = SELECT
	/// <para>TYPE IfcSizeSelect = SELECT</para>
	/// <para>(IfcDescriptiveMeasure</para>
	/// <para>,IfcLengthMeasure</para>
	/// <para>,IfcNormalisedRatioMeasure</para>
	/// <para>,IfcPositiveLengthMeasure</para>
	/// <para>,IfcPositiveRatioMeasure</para>
	/// <para>,IfcRatioMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSizeSelect
	{
	}
	/// <summary>
	/// TYPE IfcSolidOrShell = SELECT
	/// <para>TYPE IfcSolidOrShell = SELECT</para>
	/// <para>(IfcClosedShell</para>
	/// <para>,IfcSolidModel);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSolidOrShell
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
	}
	/// <summary>
	/// TYPE IfcSpaceBoundarySelect = SELECT
	/// <para>TYPE IfcSpaceBoundarySelect = SELECT</para>
	/// <para>(IfcExternalSpatialElement</para>
	/// <para>,IfcSpace);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSpaceBoundarySelect
	{
		public IfcGloballyUniqueId? GlobalId { get;  }
		public IfcOwnerHistory? OwnerHistory { get;  }
		public IfcLabel? Name { get;  }
		public IfcText? Description { get;  }
		public List<IfcRelAssigns>? HasAssignments { get;  }
		public List<IfcRelNests>? Nests { get;  }
		public List<IfcRelNests>? IsNestedBy { get;  }
		public List<IfcRelDeclares>? HasContext { get;  }
		public List<IfcRelAggregates>? IsDecomposedBy { get;  }
		public List<IfcRelAggregates>? Decomposes { get;  }
		public List<IfcRelAssociates>? HasAssociations { get;  }
		public IfcLabel? ObjectType { get;  }
		public List<IfcRelDefinesByObject>? IsDeclaredBy { get;  }
		public List<IfcRelDefinesByObject>? Declares { get;  }
		public List<IfcRelDefinesByType>? IsTypedBy { get;  }
		public List<IfcRelDefinesByProperties>? IsDefinedBy { get;  }
		public IfcObjectPlacement? ObjectPlacement { get;  }
		public IfcProductRepresentation? Representation { get;  }
		public List<IfcRelAssignsToProduct>? ReferencedBy { get;  }
		public IfcLabel? LongName { get;  }
		public List<IfcRelContainedInSpatialStructure>? ContainsElements { get;  }
		public List<IfcRelServicesBuildings>? ServicedBySystems { get;  }
		public List<IfcRelReferencedInSpatialStructure>? ReferencesElements { get;  }
		public List<IfcRelSpaceBoundary>? BoundedBy { get;  }
	}
	/// <summary>
	/// TYPE IfcSpecularHighlightSelect = SELECT
	/// <para>TYPE IfcSpecularHighlightSelect = SELECT</para>
	/// <para>(IfcSpecularExponent</para>
	/// <para>,IfcSpecularRoughness);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSpecularHighlightSelect
	{
	}
	/// <summary>
	/// TYPE IfcStructuralActivityAssignmentSelect = SELECT
	/// <para>TYPE IfcStructuralActivityAssignmentSelect = SELECT</para>
	/// <para>(IfcElement</para>
	/// <para>,IfcStructuralItem);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcStructuralActivityAssignmentSelect
	{
		public IfcGloballyUniqueId? GlobalId { get;  }
		public IfcOwnerHistory? OwnerHistory { get;  }
		public IfcLabel? Name { get;  }
		public IfcText? Description { get;  }
		public List<IfcRelAssigns>? HasAssignments { get;  }
		public List<IfcRelNests>? Nests { get;  }
		public List<IfcRelNests>? IsNestedBy { get;  }
		public List<IfcRelDeclares>? HasContext { get;  }
		public List<IfcRelAggregates>? IsDecomposedBy { get;  }
		public List<IfcRelAggregates>? Decomposes { get;  }
		public List<IfcRelAssociates>? HasAssociations { get;  }
		public IfcLabel? ObjectType { get;  }
		public List<IfcRelDefinesByObject>? IsDeclaredBy { get;  }
		public List<IfcRelDefinesByObject>? Declares { get;  }
		public List<IfcRelDefinesByType>? IsTypedBy { get;  }
		public List<IfcRelDefinesByProperties>? IsDefinedBy { get;  }
		public IfcObjectPlacement? ObjectPlacement { get;  }
		public IfcProductRepresentation? Representation { get;  }
		public List<IfcRelAssignsToProduct>? ReferencedBy { get;  }
	}
	/// <summary>
	/// TYPE IfcStyleAssignmentSelect = SELECT
	/// <para>TYPE IfcStyleAssignmentSelect = SELECT</para>
	/// <para>(IfcPresentationStyle</para>
	/// <para>,IfcPresentationStyleAssignment);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcStyleAssignmentSelect
	{
	}
	/// <summary>
	/// TYPE IfcSurfaceOrFaceSurface = SELECT
	/// <para>TYPE IfcSurfaceOrFaceSurface = SELECT</para>
	/// <para>(IfcFaceBasedSurfaceModel</para>
	/// <para>,IfcFaceSurface</para>
	/// <para>,IfcSurface);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSurfaceOrFaceSurface
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
	}
	/// <summary>
	/// TYPE IfcSurfaceStyleElementSelect = SELECT
	/// <para>TYPE IfcSurfaceStyleElementSelect = SELECT</para>
	/// <para>(IfcExternallyDefinedSurfaceStyle</para>
	/// <para>,IfcSurfaceStyleLighting</para>
	/// <para>,IfcSurfaceStyleRefraction</para>
	/// <para>,IfcSurfaceStyleShading</para>
	/// <para>,IfcSurfaceStyleWithTextures);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcSurfaceStyleElementSelect
	{
	}
	/// <summary>
	/// TYPE IfcTextFontSelect = SELECT
	/// <para>TYPE IfcTextFontSelect = SELECT</para>
	/// <para>(IfcExternallyDefinedTextFont</para>
	/// <para>,IfcPreDefinedTextFont);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTextFontSelect
	{
		public IfcLabel? Name { get;  }
	}
	/// <summary>
	/// TYPE IfcTimeOrRatioSelect = SELECT
	/// <para>TYPE IfcTimeOrRatioSelect = SELECT</para>
	/// <para>(IfcDuration</para>
	/// <para>,IfcRatioMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTimeOrRatioSelect
	{
	}
	/// <summary>
	/// TYPE IfcTranslationalStiffnessSelect = SELECT
	/// <para>TYPE IfcTranslationalStiffnessSelect = SELECT</para>
	/// <para>(IfcBoolean</para>
	/// <para>,IfcLinearStiffnessMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTranslationalStiffnessSelect
	{
	}
	/// <summary>
	/// TYPE IfcTrimmingSelect = SELECT
	/// <para>TYPE IfcTrimmingSelect = SELECT</para>
	/// <para>(IfcCartesianPoint</para>
	/// <para>,IfcParameterValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcTrimmingSelect
	{
	}
	/// <summary>
	/// TYPE IfcUnit = SELECT
	/// <para>TYPE IfcUnit = SELECT</para>
	/// <para>(IfcDerivedUnit</para>
	/// <para>,IfcMonetaryUnit</para>
	/// <para>,IfcNamedUnit);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcUnit
	{
	}
	/// <summary>
	/// TYPE IfcValue = SELECT
	/// <para>TYPE IfcValue = SELECT</para>
	/// <para>(IfcDerivedMeasureValue</para>
	/// <para>,IfcMeasureValue</para>
	/// <para>,IfcSimpleValue);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcValue: IfcAppliedValueSelect, IfcMetricValueSelect
	{
	}
	/// <summary>
	/// TYPE IfcVectorOrDirection = SELECT
	/// <para>TYPE IfcVectorOrDirection = SELECT</para>
	/// <para>(IfcDirection</para>
	/// <para>,IfcVector);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcVectorOrDirection
	{
		public List<IfcPresentationLayerAssignment>? LayerAssignment { get;  }
		public List<IfcStyledItem>? StyledByItem { get;  }
		public IfcDimensionCount? Dim { get;  }
	}
	/// <summary>
	/// TYPE IfcWarpingStiffnessSelect = SELECT
	/// <para>TYPE IfcWarpingStiffnessSelect = SELECT</para>
	/// <para>(IfcBoolean</para>
	/// <para>,IfcWarpingMomentMeasure);</para>
	/// <para>END_TYPE;</para>
	/// <summary>
	public interface IfcWarpingStiffnessSelect
	{
	}
	/// <summary>
	/// ENTITY IfcActionRequest
	/// <para>ENTITY IfcActionRequest</para>
	/// <para>SUBTYPE OF (IfcControl);</para>
	/// <para>PredefinedType : OPTIONAL IfcActionRequestTypeEnum;</para>
	/// <para>Status : OPTIONAL IfcLabel;</para>
	/// <para>LongDescription : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActionRequest : IfcControl
	{
		public virtual IfcActionRequestTypeEnum? PredefinedType { get; set; }
		public virtual IfcLabel? Status { get; set; }
		public virtual IfcText? LongDescription { get; set; }
		public IfcActionRequest() : base()
		{
		}
		public IfcActionRequest(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcActionRequestTypeEnum PredefinedType, IfcLabel Status, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcActor
	/// <para>ENTITY IfcActor</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcOccupant))</para>
	/// <para>SUBTYPE OF (IfcObject);</para>
	/// <para>TheActor : IfcActorSelect;</para>
	/// <para>INVERSE</para>
	/// <para>IsActingUpon : SET [0:?] OF IfcRelAssignsToActor FOR RelatingActor;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActor : IfcObject
	{
		public virtual IfcActorSelect? TheActor { get; set; }
		//TODO INVERSE
		public List<IfcRelAssignsToActor>? IsActingUpon => Model?.GetItems<IfcRelAssignsToActor>().Where(x => x.RelatingActor != null && x.RelatingActor == this).ToList();
		public IfcActor() : base()
		{
		}
		public IfcActor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcActorSelect TheActor) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.TheActor = TheActor;
		}
	}
	/// <summary>
	/// ENTITY IfcActorRole;
	/// <para>ENTITY IfcActorRole;</para>
	/// <para>Role : IfcRoleEnum;</para>
	/// <para>UserDefinedRole : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : (Role <> IfcRoleEnum.USERDEFINED) OR</para>
	/// <para>((Role = IfcRoleEnum.USERDEFINED) AND</para>
	/// <para>EXISTS(SELF.UserDefinedRole));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActorRole : Entity, IfcResourceObjectSelect
	{
		public virtual IfcRoleEnum? Role { get; set; }
		public virtual IfcLabel? UserDefinedRole { get; set; }
		public virtual IfcText? Description { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReference => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		public IfcActorRole() : base()
		{
		}
		public IfcActorRole(IfcRoleEnum Role, IfcLabel UserDefinedRole, IfcText Description) : base ()
		{
			this.Role = Role;
			this.UserDefinedRole = UserDefinedRole;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcActuator
	/// <para>ENTITY IfcActuator</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcActuatorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcActuatorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcActuatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCACTUATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActuator : IfcDistributionControlElement
	{
		public virtual IfcActuatorTypeEnum? PredefinedType { get; set; }
		public IfcActuator() : base()
		{
		}
		public IfcActuator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcActuatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcActuatorType
	/// <para>ENTITY IfcActuatorType</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>PredefinedType : IfcActuatorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcActuatorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcActuatorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcActuatorType : IfcDistributionControlElementType
	{
		public virtual IfcActuatorTypeEnum? PredefinedType { get; set; }
		public IfcActuatorType() : base()
		{
		}
		public IfcActuatorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcActuatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAddress
	/// <para>ENTITY IfcAddress</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPostalAddress</para>
	/// <para>,IfcTelecomAddress));</para>
	/// <para>Purpose : OPTIONAL IfcAddressTypeEnum;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>UserDefinedPurpose : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>OfPerson : SET [0:?] OF IfcPerson FOR Addresses;</para>
	/// <para>OfOrganization : SET [0:?] OF IfcOrganization FOR Addresses;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : (NOT(EXISTS(Purpose))) OR</para>
	/// <para>((Purpose <> IfcAddressTypeEnum.USERDEFINED) OR</para>
	/// <para>((Purpose = IfcAddressTypeEnum.USERDEFINED) AND</para>
	/// <para>EXISTS(SELF.UserDefinedPurpose)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcAddress : Entity, IfcObjectReferenceSelect
	{
		public virtual IfcAddressTypeEnum? Purpose { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcLabel? UserDefinedPurpose { get; set; }
		//TODO INVERSE
		public List<IfcPerson>? OfPerson => Model?.GetItems<IfcPerson>().Where(x => x.Addresses != null && x.Addresses.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcOrganization>? OfOrganization => Model?.GetItems<IfcOrganization>().Where(x => x.Addresses != null && x.Addresses.Contains(this)).ToList();
		public IfcAddress() : base()
		{
		}
		public IfcAddress(IfcAddressTypeEnum Purpose, IfcText Description, IfcLabel UserDefinedPurpose) : base ()
		{
			this.Purpose = Purpose;
			this.Description = Description;
			this.UserDefinedPurpose = UserDefinedPurpose;
		}
	}
	/// <summary>
	/// ENTITY IfcAdvancedBrep
	/// <para>ENTITY IfcAdvancedBrep</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAdvancedBrepWithVoids))</para>
	/// <para>SUBTYPE OF (IfcManifoldSolidBrep);</para>
	/// <para>WHERE</para>
	/// <para>HasAdvancedFaces : SIZEOF(QUERY(Afs <* SELF\IfcManifoldSolidBrep.Outer.CfsFaces |</para>
	/// <para>(NOT ('IFC4X1.IFCADVANCEDFACE' IN TYPEOF(Afs)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAdvancedBrep : IfcManifoldSolidBrep
	{
		public IfcAdvancedBrep() : base()
		{
		}
		public IfcAdvancedBrep(IfcClosedShell Outer) : base (Outer)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAdvancedBrepWithVoids
	/// <para>ENTITY IfcAdvancedBrepWithVoids</para>
	/// <para>SUBTYPE OF (IfcAdvancedBrep);</para>
	/// <para>Voids : SET [1:?] OF IfcClosedShell;</para>
	/// <para>WHERE</para>
	/// <para>VoidsHaveAdvancedFaces : SIZEOF (QUERY (Vsh <* Voids |</para>
	/// <para>SIZEOF (QUERY (Afs <* Vsh.CfsFaces |</para>
	/// <para>(NOT ('IFC4X1.IFCADVANCEDFACE' IN TYPEOF(Afs)))</para>
	/// <para>)) = 0</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAdvancedBrepWithVoids : IfcAdvancedBrep
	{
		public virtual List<IfcClosedShell>? Voids { get; set; }
		public IfcAdvancedBrepWithVoids() : base()
		{
		}
		public IfcAdvancedBrepWithVoids(IfcClosedShell Outer, List<IfcClosedShell> Voids) : base (Outer)
		{
			this.Voids = Voids;
		}
	}
	/// <summary>
	/// ENTITY IfcAdvancedFace
	/// <para>ENTITY IfcAdvancedFace</para>
	/// <para>SUBTYPE OF (IfcFaceSurface);</para>
	/// <para>WHERE</para>
	/// <para>ApplicableSurface : SIZEOF (</para>
	/// <para>['IFC4X1.IFCELEMENTARYSURFACE',</para>
	/// <para>'IFC4X1.IFCSWEPTSURFACE',</para>
	/// <para>'IFC4X1.IFCBSPLINESURFACE'] *</para>
	/// <para>TYPEOF(SELF\IfcFaceSurface.FaceSurface)) = 1;</para>
	/// <para>RequiresEdgeCurve : SIZEOF(QUERY (ElpFbnds <*</para>
	/// <para>QUERY (Bnds <* SELF\IfcFace.Bounds |</para>
	/// <para>'IFC4X1.IFCEDGELOOP' IN TYPEOF(Bnds.Bound)) |</para>
	/// <para>NOT (SIZEOF (QUERY (Oe <* ElpFbnds.Bound\IfcEdgeLoop.EdgeList |</para>
	/// <para>NOT('IFC4X1.IFCEDGECURVE' IN</para>
	/// <para>TYPEOF(Oe\IfcOrientedEdge.EdgeElement)</para>
	/// <para>))) = 0</para>
	/// <para>))) = 0;</para>
	/// <para>ApplicableEdgeCurves : SIZEOF(QUERY (ElpFbnds <*</para>
	/// <para>QUERY (Bnds <* SELF\IfcFace.Bounds |</para>
	/// <para>'IFC4X1.IFCEDGELOOP' IN TYPEOF(Bnds.Bound)) |</para>
	/// <para>NOT (SIZEOF (QUERY (Oe <* ElpFbnds.Bound\IfcEdgeLoop.EdgeList |</para>
	/// <para>NOT (SIZEOF (['IFC4X1.IFCLINE',</para>
	/// <para>'IFC4X1.IFCCONIC',</para>
	/// <para>'IFC4X1.IFCPOLYLINE',</para>
	/// <para>'IFC4X1.IFCBSPLINECURVE'] *</para>
	/// <para>TYPEOF(Oe\IfcOrientedEdge.EdgeElement\IfcEdgeCurve.EdgeGeometry)) = 1 )</para>
	/// <para>)) = 0</para>
	/// <para>))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAdvancedFace : IfcFaceSurface
	{
		public IfcAdvancedFace() : base()
		{
		}
		public IfcAdvancedFace(List<IfcFaceBound> Bounds, IfcSurface FaceSurface, IfcBoolean SameSense) : base (Bounds, FaceSurface, SameSense)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminal
	/// <para>ENTITY IfcAirTerminal</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcAirTerminalTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcAirTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAirTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCAIRTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminal : IfcFlowTerminal
	{
		public virtual IfcAirTerminalTypeEnum? PredefinedType { get; set; }
		public IfcAirTerminal() : base()
		{
		}
		public IfcAirTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAirTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminalBox
	/// <para>ENTITY IfcAirTerminalBox</para>
	/// <para>SUBTYPE OF (IfcFlowController);</para>
	/// <para>PredefinedType : OPTIONAL IfcAirTerminalBoxTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcAirTerminalBoxTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAirTerminalBoxTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCAIRTERMINALBOXTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminalBox : IfcFlowController
	{
		public virtual IfcAirTerminalBoxTypeEnum? PredefinedType { get; set; }
		public IfcAirTerminalBox() : base()
		{
		}
		public IfcAirTerminalBox(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAirTerminalBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminalBoxType
	/// <para>ENTITY IfcAirTerminalBoxType</para>
	/// <para>SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>PredefinedType : IfcAirTerminalBoxTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcAirTerminalBoxTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAirTerminalBoxTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminalBoxType : IfcFlowControllerType
	{
		public virtual IfcAirTerminalBoxTypeEnum? PredefinedType { get; set; }
		public IfcAirTerminalBoxType() : base()
		{
		}
		public IfcAirTerminalBoxType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAirTerminalBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirTerminalType
	/// <para>ENTITY IfcAirTerminalType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcAirTerminalTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcAirTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAirTerminalTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirTerminalType : IfcFlowTerminalType
	{
		public virtual IfcAirTerminalTypeEnum? PredefinedType { get; set; }
		public IfcAirTerminalType() : base()
		{
		}
		public IfcAirTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAirTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirToAirHeatRecovery
	/// <para>ENTITY IfcAirToAirHeatRecovery</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcAirToAirHeatRecoveryTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCAIRTOAIRHEATRECOVERYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirToAirHeatRecovery : IfcEnergyConversionDevice
	{
		public virtual IfcAirToAirHeatRecoveryTypeEnum? PredefinedType { get; set; }
		public IfcAirToAirHeatRecovery() : base()
		{
		}
		public IfcAirToAirHeatRecovery(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAirToAirHeatRecoveryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAirToAirHeatRecoveryType
	/// <para>ENTITY IfcAirToAirHeatRecoveryType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcAirToAirHeatRecoveryTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAirToAirHeatRecoveryType : IfcEnergyConversionDeviceType
	{
		public virtual IfcAirToAirHeatRecoveryTypeEnum? PredefinedType { get; set; }
		public IfcAirToAirHeatRecoveryType() : base()
		{
		}
		public IfcAirToAirHeatRecoveryType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAirToAirHeatRecoveryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlarm
	/// <para>ENTITY IfcAlarm</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcAlarmTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcAlarmTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAlarmTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCALARMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlarm : IfcDistributionControlElement
	{
		public virtual IfcAlarmTypeEnum? PredefinedType { get; set; }
		public IfcAlarm() : base()
		{
		}
		public IfcAlarm(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAlarmTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlarmType
	/// <para>ENTITY IfcAlarmType</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>PredefinedType : IfcAlarmTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcAlarmTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAlarmTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlarmType : IfcDistributionControlElementType
	{
		public virtual IfcAlarmTypeEnum? PredefinedType { get; set; }
		public IfcAlarmType() : base()
		{
		}
		public IfcAlarmType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAlarmTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignment
	/// <para>ENTITY IfcAlignment</para>
	/// <para>SUBTYPE OF (IfcLinearPositioningElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcAlignmentTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignment : IfcLinearPositioningElement
	{
		public virtual IfcAlignmentTypeEnum? PredefinedType { get; set; }
		public IfcAlignment() : base()
		{
		}
		public IfcAlignment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcCurve Axis, IfcAlignmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignment2DHorizontal
	/// <para>ENTITY IfcAlignment2DHorizontal</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>StartDistAlong : OPTIONAL IfcLengthMeasure;</para>
	/// <para>Segments : LIST [1:?] OF IfcAlignment2DHorizontalSegment;</para>
	/// <para>INVERSE</para>
	/// <para>ToAlignmentCurve : SET [1:?] OF IfcAlignmentCurve FOR Horizontal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignment2DHorizontal : IfcGeometricRepresentationItem
	{
		public virtual IfcLengthMeasure? StartDistAlong { get; set; }
		public virtual List<IfcAlignment2DHorizontalSegment>? Segments { get; set; }
		//TODO INVERSE
		public List<IfcAlignmentCurve>? ToAlignmentCurve => Model?.GetItems<IfcAlignmentCurve>().Where(x => x.Horizontal != null && x.Horizontal == this).ToList();
		public IfcAlignment2DHorizontal() : base()
		{
		}
		public IfcAlignment2DHorizontal(IfcLengthMeasure StartDistAlong, List<IfcAlignment2DHorizontalSegment> Segments) : base ()
		{
			this.StartDistAlong = StartDistAlong;
			this.Segments = Segments;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignment2DHorizontalSegment
	/// <para>ENTITY IfcAlignment2DHorizontalSegment</para>
	/// <para>SUBTYPE OF (IfcAlignment2DSegment);</para>
	/// <para>CurveGeometry : IfcCurveSegment2D;</para>
	/// <para>INVERSE</para>
	/// <para>ToHorizontal : SET [1:1] OF IfcAlignment2DHorizontal FOR Segments;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignment2DHorizontalSegment : IfcAlignment2DSegment
	{
		public virtual IfcCurveSegment2D? CurveGeometry { get; set; }
		//TODO INVERSE
		public List<IfcAlignment2DHorizontal>? ToHorizontal => Model?.GetItems<IfcAlignment2DHorizontal>().Where(x => x.Segments != null && x.Segments.Contains(this)).ToList();
		public IfcAlignment2DHorizontalSegment() : base()
		{
		}
		public IfcAlignment2DHorizontalSegment(IfcBoolean TangentialContinuity, IfcLabel StartTag, IfcLabel EndTag, IfcCurveSegment2D CurveGeometry) : base (TangentialContinuity, StartTag, EndTag)
		{
			this.CurveGeometry = CurveGeometry;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignment2DSegment
	/// <para>ENTITY IfcAlignment2DSegment</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAlignment2DHorizontalSegment</para>
	/// <para>,IfcAlignment2DVerticalSegment))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>TangentialContinuity : OPTIONAL IfcBoolean;</para>
	/// <para>StartTag : OPTIONAL IfcLabel;</para>
	/// <para>EndTag : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcAlignment2DSegment : IfcGeometricRepresentationItem
	{
		public virtual IfcBoolean? TangentialContinuity { get; set; }
		public virtual IfcLabel? StartTag { get; set; }
		public virtual IfcLabel? EndTag { get; set; }
		public IfcAlignment2DSegment() : base()
		{
		}
		public IfcAlignment2DSegment(IfcBoolean TangentialContinuity, IfcLabel StartTag, IfcLabel EndTag) : base ()
		{
			this.TangentialContinuity = TangentialContinuity;
			this.StartTag = StartTag;
			this.EndTag = EndTag;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignment2DVerSegCircularArc
	/// <para>ENTITY IfcAlignment2DVerSegCircularArc</para>
	/// <para>SUBTYPE OF (IfcAlignment2DVerticalSegment);</para>
	/// <para>Radius : IfcPositiveLengthMeasure;</para>
	/// <para>IsConvex : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignment2DVerSegCircularArc : IfcAlignment2DVerticalSegment
	{
		public virtual IfcPositiveLengthMeasure? Radius { get; set; }
		public virtual IfcBoolean? IsConvex { get; set; }
		public IfcAlignment2DVerSegCircularArc() : base()
		{
		}
		public IfcAlignment2DVerSegCircularArc(IfcBoolean TangentialContinuity, IfcLabel StartTag, IfcLabel EndTag, IfcLengthMeasure StartDistAlong, IfcPositiveLengthMeasure HorizontalLength, IfcLengthMeasure StartHeight, IfcRatioMeasure StartGradient, IfcPositiveLengthMeasure Radius, IfcBoolean IsConvex) : base (TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient)
		{
			this.Radius = Radius;
			this.IsConvex = IsConvex;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignment2DVerSegLine
	/// <para>ENTITY IfcAlignment2DVerSegLine</para>
	/// <para>SUBTYPE OF (IfcAlignment2DVerticalSegment);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignment2DVerSegLine : IfcAlignment2DVerticalSegment
	{
		public IfcAlignment2DVerSegLine() : base()
		{
		}
		public IfcAlignment2DVerSegLine(IfcBoolean TangentialContinuity, IfcLabel StartTag, IfcLabel EndTag, IfcLengthMeasure StartDistAlong, IfcPositiveLengthMeasure HorizontalLength, IfcLengthMeasure StartHeight, IfcRatioMeasure StartGradient) : base (TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAlignment2DVerSegParabolicArc
	/// <para>ENTITY IfcAlignment2DVerSegParabolicArc</para>
	/// <para>SUBTYPE OF (IfcAlignment2DVerticalSegment);</para>
	/// <para>ParabolaConstant : IfcPositiveLengthMeasure;</para>
	/// <para>IsConvex : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignment2DVerSegParabolicArc : IfcAlignment2DVerticalSegment
	{
		public virtual IfcPositiveLengthMeasure? ParabolaConstant { get; set; }
		public virtual IfcBoolean? IsConvex { get; set; }
		public IfcAlignment2DVerSegParabolicArc() : base()
		{
		}
		public IfcAlignment2DVerSegParabolicArc(IfcBoolean TangentialContinuity, IfcLabel StartTag, IfcLabel EndTag, IfcLengthMeasure StartDistAlong, IfcPositiveLengthMeasure HorizontalLength, IfcLengthMeasure StartHeight, IfcRatioMeasure StartGradient, IfcPositiveLengthMeasure ParabolaConstant, IfcBoolean IsConvex) : base (TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient)
		{
			this.ParabolaConstant = ParabolaConstant;
			this.IsConvex = IsConvex;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignment2DVertical
	/// <para>ENTITY IfcAlignment2DVertical</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Segments : LIST [1:?] OF IfcAlignment2DVerticalSegment;</para>
	/// <para>INVERSE</para>
	/// <para>ToAlignmentCurve : SET [1:1] OF IfcAlignmentCurve FOR Vertical;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignment2DVertical : IfcGeometricRepresentationItem
	{
		public virtual List<IfcAlignment2DVerticalSegment>? Segments { get; set; }
		//TODO INVERSE
		public List<IfcAlignmentCurve>? ToAlignmentCurve => Model?.GetItems<IfcAlignmentCurve>().Where(x => x.Vertical != null && x.Vertical == this).ToList();
		public IfcAlignment2DVertical() : base()
		{
		}
		public IfcAlignment2DVertical(List<IfcAlignment2DVerticalSegment> Segments) : base ()
		{
			this.Segments = Segments;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignment2DVerticalSegment
	/// <para>ENTITY IfcAlignment2DVerticalSegment</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAlignment2DVerSegCircularArc</para>
	/// <para>,IfcAlignment2DVerSegLine</para>
	/// <para>,IfcAlignment2DVerSegParabolicArc))</para>
	/// <para>SUBTYPE OF (IfcAlignment2DSegment);</para>
	/// <para>StartDistAlong : IfcLengthMeasure;</para>
	/// <para>HorizontalLength : IfcPositiveLengthMeasure;</para>
	/// <para>StartHeight : IfcLengthMeasure;</para>
	/// <para>StartGradient : IfcRatioMeasure;</para>
	/// <para>INVERSE</para>
	/// <para>ToVertical : SET [1:1] OF IfcAlignment2DVertical FOR Segments;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcAlignment2DVerticalSegment : IfcAlignment2DSegment
	{
		public virtual IfcLengthMeasure? StartDistAlong { get; set; }
		public virtual IfcPositiveLengthMeasure? HorizontalLength { get; set; }
		public virtual IfcLengthMeasure? StartHeight { get; set; }
		public virtual IfcRatioMeasure? StartGradient { get; set; }
		//TODO INVERSE
		public List<IfcAlignment2DVertical>? ToVertical => Model?.GetItems<IfcAlignment2DVertical>().Where(x => x.Segments != null && x.Segments.Contains(this)).ToList();
		public IfcAlignment2DVerticalSegment() : base()
		{
		}
		public IfcAlignment2DVerticalSegment(IfcBoolean TangentialContinuity, IfcLabel StartTag, IfcLabel EndTag, IfcLengthMeasure StartDistAlong, IfcPositiveLengthMeasure HorizontalLength, IfcLengthMeasure StartHeight, IfcRatioMeasure StartGradient) : base (TangentialContinuity, StartTag, EndTag)
		{
			this.StartDistAlong = StartDistAlong;
			this.HorizontalLength = HorizontalLength;
			this.StartHeight = StartHeight;
			this.StartGradient = StartGradient;
		}
	}
	/// <summary>
	/// ENTITY IfcAlignmentCurve
	/// <para>ENTITY IfcAlignmentCurve</para>
	/// <para>SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>Horizontal : IfcAlignment2DHorizontal;</para>
	/// <para>Vertical : OPTIONAL IfcAlignment2DVertical;</para>
	/// <para>Tag : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAlignmentCurve : IfcBoundedCurve
	{
		public virtual IfcAlignment2DHorizontal? Horizontal { get; set; }
		public virtual IfcAlignment2DVertical? Vertical { get; set; }
		public virtual IfcLabel? Tag { get; set; }
		public IfcAlignmentCurve() : base()
		{
		}
		public IfcAlignmentCurve(IfcAlignment2DHorizontal Horizontal, IfcAlignment2DVertical Vertical, IfcLabel Tag) : base ()
		{
			this.Horizontal = Horizontal;
			this.Vertical = Vertical;
			this.Tag = Tag;
		}
	}
	/// <summary>
	/// ENTITY IfcAnnotation
	/// <para>ENTITY IfcAnnotation</para>
	/// <para>SUBTYPE OF (IfcProduct);</para>
	/// <para>INVERSE</para>
	/// <para>ContainedInStructure : SET [0:1] OF IfcRelContainedInSpatialStructure FOR RelatedElements;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAnnotation : IfcProduct
	{
		//TODO INVERSE
		public List<IfcRelContainedInSpatialStructure>? ContainedInStructure => Model?.GetItems<IfcRelContainedInSpatialStructure>().Where(x => x.RelatedElements != null && x.RelatedElements.Contains(this)).ToList();
		public IfcAnnotation() : base()
		{
		}
		public IfcAnnotation(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcAnnotationFillArea
	/// <para>ENTITY IfcAnnotationFillArea</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>OuterBoundary : IfcCurve;</para>
	/// <para>InnerBoundaries : OPTIONAL SET [1:?] OF IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAnnotationFillArea : IfcGeometricRepresentationItem
	{
		public virtual IfcCurve? OuterBoundary { get; set; }
		public virtual List<IfcCurve>? InnerBoundaries { get; set; }
		public IfcAnnotationFillArea() : base()
		{
		}
		public IfcAnnotationFillArea(IfcCurve OuterBoundary, List<IfcCurve> InnerBoundaries) : base ()
		{
			this.OuterBoundary = OuterBoundary;
			this.InnerBoundaries = InnerBoundaries;
		}
	}
	/// <summary>
	/// ENTITY IfcApplication;
	/// <para>ENTITY IfcApplication;</para>
	/// <para>ApplicationDeveloper : IfcOrganization;</para>
	/// <para>Version : IfcLabel;</para>
	/// <para>ApplicationFullName : IfcLabel;</para>
	/// <para>ApplicationIdentifier : IfcIdentifier;</para>
	/// <para>UNIQUE</para>
	/// <para>UR1 : ApplicationIdentifier;</para>
	/// <para>UR2 : ApplicationFullName, Version;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcApplication : Entity
	{
		public virtual IfcOrganization? ApplicationDeveloper { get; set; }
		public virtual IfcLabel? Version { get; set; }
		public virtual IfcLabel? ApplicationFullName { get; set; }
		public virtual IfcIdentifier? ApplicationIdentifier { get; set; }
		public IfcApplication() : base()
		{
		}
		public IfcApplication(IfcOrganization ApplicationDeveloper, IfcLabel Version, IfcLabel ApplicationFullName, IfcIdentifier ApplicationIdentifier) : base ()
		{
			this.ApplicationDeveloper = ApplicationDeveloper;
			this.Version = Version;
			this.ApplicationFullName = ApplicationFullName;
			this.ApplicationIdentifier = ApplicationIdentifier;
		}
	}
	/// <summary>
	/// ENTITY IfcAppliedValue
	/// <para>ENTITY IfcAppliedValue</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCostValue));</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>AppliedValue : OPTIONAL IfcAppliedValueSelect;</para>
	/// <para>UnitBasis : OPTIONAL IfcMeasureWithUnit;</para>
	/// <para>ApplicableDate : OPTIONAL IfcDate;</para>
	/// <para>FixedUntilDate : OPTIONAL IfcDate;</para>
	/// <para>Category : OPTIONAL IfcLabel;</para>
	/// <para>Condition : OPTIONAL IfcLabel;</para>
	/// <para>ArithmeticOperator : OPTIONAL IfcArithmeticOperatorEnum;</para>
	/// <para>Components : OPTIONAL LIST [1:?] OF IfcAppliedValue;</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAppliedValue : Entity, IfcMetricValueSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcAppliedValueSelect? AppliedValue { get; set; }
		public virtual IfcMeasureWithUnit? UnitBasis { get; set; }
		public virtual IfcDate? ApplicableDate { get; set; }
		public virtual IfcDate? FixedUntilDate { get; set; }
		public virtual IfcLabel? Category { get; set; }
		public virtual IfcLabel? Condition { get; set; }
		public virtual IfcArithmeticOperatorEnum? ArithmeticOperator { get; set; }
		public virtual List<IfcAppliedValue>? Components { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReference => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		public IfcAppliedValue() : base()
		{
		}
		public IfcAppliedValue(IfcLabel Name, IfcText Description, IfcAppliedValueSelect AppliedValue, IfcMeasureWithUnit UnitBasis, IfcDate ApplicableDate, IfcDate FixedUntilDate, IfcLabel Category, IfcLabel Condition, IfcArithmeticOperatorEnum ArithmeticOperator, List<IfcAppliedValue> Components) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.AppliedValue = AppliedValue;
			this.UnitBasis = UnitBasis;
			this.ApplicableDate = ApplicableDate;
			this.FixedUntilDate = FixedUntilDate;
			this.Category = Category;
			this.Condition = Condition;
			this.ArithmeticOperator = ArithmeticOperator;
			this.Components = Components;
		}
	}
	/// <summary>
	/// ENTITY IfcApproval;
	/// <para>ENTITY IfcApproval;</para>
	/// <para>Identifier : OPTIONAL IfcIdentifier;</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>TimeOfApproval : OPTIONAL IfcDateTime;</para>
	/// <para>Status : OPTIONAL IfcLabel;</para>
	/// <para>Level : OPTIONAL IfcLabel;</para>
	/// <para>Qualifier : OPTIONAL IfcText;</para>
	/// <para>RequestingApproval : OPTIONAL IfcActorSelect;</para>
	/// <para>GivingApproval : OPTIONAL IfcActorSelect;</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>ApprovedObjects : SET [0:?] OF IfcRelAssociatesApproval FOR RelatingApproval;</para>
	/// <para>ApprovedResources : SET [0:?] OF IfcResourceApprovalRelationship FOR RelatingApproval;</para>
	/// <para>IsRelatedWith : SET [0:?] OF IfcApprovalRelationship FOR RelatedApprovals;</para>
	/// <para>Relates : SET [0:?] OF IfcApprovalRelationship FOR RelatingApproval;</para>
	/// <para>WHERE</para>
	/// <para>HasIdentifierOrName : EXISTS (Identifier) OR EXISTS (Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcApproval : Entity, IfcResourceObjectSelect
	{
		public virtual IfcIdentifier? Identifier { get; set; }
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcDateTime? TimeOfApproval { get; set; }
		public virtual IfcLabel? Status { get; set; }
		public virtual IfcLabel? Level { get; set; }
		public virtual IfcText? Qualifier { get; set; }
		public virtual IfcActorSelect? RequestingApproval { get; set; }
		public virtual IfcActorSelect? GivingApproval { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReferences => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelAssociatesApproval>? ApprovedObjects => Model?.GetItems<IfcRelAssociatesApproval>().Where(x => x.RelatingApproval != null && x.RelatingApproval == this).ToList();
		//TODO INVERSE
		public List<IfcResourceApprovalRelationship>? ApprovedResources => Model?.GetItems<IfcResourceApprovalRelationship>().Where(x => x.RelatingApproval != null && x.RelatingApproval == this).ToList();
		//TODO INVERSE
		public List<IfcApprovalRelationship>? IsRelatedWith => Model?.GetItems<IfcApprovalRelationship>().Where(x => x.RelatedApprovals != null && x.RelatedApprovals.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcApprovalRelationship>? Relates => Model?.GetItems<IfcApprovalRelationship>().Where(x => x.RelatingApproval != null && x.RelatingApproval == this).ToList();
		public IfcApproval() : base()
		{
		}
		public IfcApproval(IfcIdentifier Identifier, IfcLabel Name, IfcText Description, IfcDateTime TimeOfApproval, IfcLabel Status, IfcLabel Level, IfcText Qualifier, IfcActorSelect RequestingApproval, IfcActorSelect GivingApproval) : base ()
		{
			this.Identifier = Identifier;
			this.Name = Name;
			this.Description = Description;
			this.TimeOfApproval = TimeOfApproval;
			this.Status = Status;
			this.Level = Level;
			this.Qualifier = Qualifier;
			this.RequestingApproval = RequestingApproval;
			this.GivingApproval = GivingApproval;
		}
	}
	/// <summary>
	/// ENTITY IfcApprovalRelationship
	/// <para>ENTITY IfcApprovalRelationship</para>
	/// <para>SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>RelatingApproval : IfcApproval;</para>
	/// <para>RelatedApprovals : SET [1:?] OF IfcApproval;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcApprovalRelationship : IfcResourceLevelRelationship
	{
		public virtual IfcApproval? RelatingApproval { get; set; }
		public virtual List<IfcApproval>? RelatedApprovals { get; set; }
		public IfcApprovalRelationship() : base()
		{
		}
		public IfcApprovalRelationship(IfcLabel Name, IfcText Description, IfcApproval RelatingApproval, List<IfcApproval> RelatedApprovals) : base (Name, Description)
		{
			this.RelatingApproval = RelatingApproval;
			this.RelatedApprovals = RelatedApprovals;
		}
	}
	/// <summary>
	/// ENTITY IfcArbitraryClosedProfileDef
	/// <para>ENTITY IfcArbitraryClosedProfileDef</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcArbitraryProfileDefWithVoids))</para>
	/// <para>SUBTYPE OF (IfcProfileDef);</para>
	/// <para>OuterCurve : IfcCurve;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : OuterCurve.Dim = 2;</para>
	/// <para>WR2 : NOT('IFC4X1.IFCLINE' IN TYPEOF(OuterCurve));</para>
	/// <para>WR3 : NOT('IFC4X1.IFCOFFSETCURVE2D' IN TYPEOF(OuterCurve));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcArbitraryClosedProfileDef : IfcProfileDef
	{
		public virtual IfcCurve? OuterCurve { get; set; }
		public IfcArbitraryClosedProfileDef() : base()
		{
		}
		public IfcArbitraryClosedProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcCurve OuterCurve) : base (ProfileType, ProfileName)
		{
			this.OuterCurve = OuterCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcArbitraryOpenProfileDef
	/// <para>ENTITY IfcArbitraryOpenProfileDef</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCenterLineProfileDef))</para>
	/// <para>SUBTYPE OF (IfcProfileDef);</para>
	/// <para>Curve : IfcBoundedCurve;</para>
	/// <para>WHERE</para>
	/// <para>WR11 : ('IFC4X1.IFCCENTERLINEPROFILEDEF' IN TYPEOF(SELF)) OR</para>
	/// <para>(SELF\IfcProfileDef.ProfileType = IfcProfileTypeEnum.CURVE);</para>
	/// <para>WR12 : Curve.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcArbitraryOpenProfileDef : IfcProfileDef
	{
		public virtual IfcBoundedCurve? Curve { get; set; }
		public IfcArbitraryOpenProfileDef() : base()
		{
		}
		public IfcArbitraryOpenProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcBoundedCurve Curve) : base (ProfileType, ProfileName)
		{
			this.Curve = Curve;
		}
	}
	/// <summary>
	/// ENTITY IfcArbitraryProfileDefWithVoids
	/// <para>ENTITY IfcArbitraryProfileDefWithVoids</para>
	/// <para>SUBTYPE OF (IfcArbitraryClosedProfileDef);</para>
	/// <para>InnerCurves : SET [1:?] OF IfcCurve;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SELF\IfcProfileDef.ProfileType = AREA;</para>
	/// <para>WR2 : SIZEOF(QUERY(temp <* InnerCurves | temp.Dim <> 2)) = 0;</para>
	/// <para>WR3 : SIZEOF(QUERY(temp <* InnerCurves | 'IFC4X1.IFCLINE' IN TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcArbitraryProfileDefWithVoids : IfcArbitraryClosedProfileDef
	{
		public virtual List<IfcCurve>? InnerCurves { get; set; }
		public IfcArbitraryProfileDefWithVoids() : base()
		{
		}
		public IfcArbitraryProfileDefWithVoids(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcCurve OuterCurve, List<IfcCurve> InnerCurves) : base (ProfileType, ProfileName, OuterCurve)
		{
			this.InnerCurves = InnerCurves;
		}
	}
	/// <summary>
	/// ENTITY IfcAsset
	/// <para>ENTITY IfcAsset</para>
	/// <para>SUBTYPE OF (IfcGroup);</para>
	/// <para>Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>OriginalValue : OPTIONAL IfcCostValue;</para>
	/// <para>CurrentValue : OPTIONAL IfcCostValue;</para>
	/// <para>TotalReplacementCost : OPTIONAL IfcCostValue;</para>
	/// <para>Owner : OPTIONAL IfcActorSelect;</para>
	/// <para>User : OPTIONAL IfcActorSelect;</para>
	/// <para>ResponsiblePerson : OPTIONAL IfcPerson;</para>
	/// <para>IncorporationDate : OPTIONAL IfcDate;</para>
	/// <para>DepreciatedValue : OPTIONAL IfcCostValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAsset : IfcGroup
	{
		public virtual IfcIdentifier? Identification { get; set; }
		public virtual IfcCostValue? OriginalValue { get; set; }
		public virtual IfcCostValue? CurrentValue { get; set; }
		public virtual IfcCostValue? TotalReplacementCost { get; set; }
		public virtual IfcActorSelect? Owner { get; set; }
		public virtual IfcActorSelect? User { get; set; }
		public virtual IfcPerson? ResponsiblePerson { get; set; }
		public virtual IfcDate? IncorporationDate { get; set; }
		public virtual IfcCostValue? DepreciatedValue { get; set; }
		public IfcAsset() : base()
		{
		}
		public IfcAsset(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcCostValue OriginalValue, IfcCostValue CurrentValue, IfcCostValue TotalReplacementCost, IfcActorSelect Owner, IfcActorSelect User, IfcPerson ResponsiblePerson, IfcDate IncorporationDate, IfcCostValue DepreciatedValue) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
			this.OriginalValue = OriginalValue;
			this.CurrentValue = CurrentValue;
			this.TotalReplacementCost = TotalReplacementCost;
			this.Owner = Owner;
			this.User = User;
			this.ResponsiblePerson = ResponsiblePerson;
			this.IncorporationDate = IncorporationDate;
			this.DepreciatedValue = DepreciatedValue;
		}
	}
	/// <summary>
	/// ENTITY IfcAsymmetricIShapeProfileDef
	/// <para>ENTITY IfcAsymmetricIShapeProfileDef</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>BottomFlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>OverallDepth : IfcPositiveLengthMeasure;</para>
	/// <para>WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>BottomFlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>BottomFlangeFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>TopFlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>TopFlangeThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>TopFlangeFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>BottomFlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>BottomFlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>TopFlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>TopFlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidFlangeThickness : NOT(EXISTS(TopFlangeThickness)) OR ((BottomFlangeThickness + TopFlangeThickness) < OverallDepth);</para>
	/// <para>ValidWebThickness : (WebThickness < BottomFlangeWidth) AND (WebThickness < TopFlangeWidth);</para>
	/// <para>ValidBottomFilletRadius : (NOT(EXISTS(BottomFlangeFilletRadius))) OR</para>
	/// <para>(BottomFlangeFilletRadius <= (BottomFlangeWidth - WebThickness)/2.);</para>
	/// <para>ValidTopFilletRadius : (NOT(EXISTS(TopFlangeFilletRadius))) OR</para>
	/// <para>(TopFlangeFilletRadius <= (TopFlangeWidth - WebThickness)/2.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAsymmetricIShapeProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? BottomFlangeWidth { get; set; }
		public virtual IfcPositiveLengthMeasure? OverallDepth { get; set; }
		public virtual IfcPositiveLengthMeasure? WebThickness { get; set; }
		public virtual IfcPositiveLengthMeasure? BottomFlangeThickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? BottomFlangeFilletRadius { get; set; }
		public virtual IfcPositiveLengthMeasure? TopFlangeWidth { get; set; }
		public virtual IfcPositiveLengthMeasure? TopFlangeThickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? TopFlangeFilletRadius { get; set; }
		public virtual IfcNonNegativeLengthMeasure? BottomFlangeEdgeRadius { get; set; }
		public virtual IfcPlaneAngleMeasure? BottomFlangeSlope { get; set; }
		public virtual IfcNonNegativeLengthMeasure? TopFlangeEdgeRadius { get; set; }
		public virtual IfcPlaneAngleMeasure? TopFlangeSlope { get; set; }
		public IfcAsymmetricIShapeProfileDef() : base()
		{
		}
		public IfcAsymmetricIShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure BottomFlangeWidth, IfcPositiveLengthMeasure OverallDepth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure BottomFlangeThickness, IfcNonNegativeLengthMeasure BottomFlangeFilletRadius, IfcPositiveLengthMeasure TopFlangeWidth, IfcPositiveLengthMeasure TopFlangeThickness, IfcNonNegativeLengthMeasure TopFlangeFilletRadius, IfcNonNegativeLengthMeasure BottomFlangeEdgeRadius, IfcPlaneAngleMeasure BottomFlangeSlope, IfcNonNegativeLengthMeasure TopFlangeEdgeRadius, IfcPlaneAngleMeasure TopFlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.BottomFlangeWidth = BottomFlangeWidth;
			this.OverallDepth = OverallDepth;
			this.WebThickness = WebThickness;
			this.BottomFlangeThickness = BottomFlangeThickness;
			this.BottomFlangeFilletRadius = BottomFlangeFilletRadius;
			this.TopFlangeWidth = TopFlangeWidth;
			this.TopFlangeThickness = TopFlangeThickness;
			this.TopFlangeFilletRadius = TopFlangeFilletRadius;
			this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius;
			this.BottomFlangeSlope = BottomFlangeSlope;
			this.TopFlangeEdgeRadius = TopFlangeEdgeRadius;
			this.TopFlangeSlope = TopFlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcAudioVisualAppliance
	/// <para>ENTITY IfcAudioVisualAppliance</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcAudioVisualApplianceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcAudioVisualApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAudioVisualApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCAUDIOVISUALAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAudioVisualAppliance : IfcFlowTerminal
	{
		public virtual IfcAudioVisualApplianceTypeEnum? PredefinedType { get; set; }
		public IfcAudioVisualAppliance() : base()
		{
		}
		public IfcAudioVisualAppliance(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAudioVisualApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAudioVisualApplianceType
	/// <para>ENTITY IfcAudioVisualApplianceType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcAudioVisualApplianceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcAudioVisualApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcAudioVisualApplianceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAudioVisualApplianceType : IfcFlowTerminalType
	{
		public virtual IfcAudioVisualApplianceTypeEnum? PredefinedType { get; set; }
		public IfcAudioVisualApplianceType() : base()
		{
		}
		public IfcAudioVisualApplianceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAudioVisualApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcAxis1Placement
	/// <para>ENTITY IfcAxis1Placement</para>
	/// <para>SUBTYPE OF (IfcPlacement);</para>
	/// <para>Axis : OPTIONAL IfcDirection;</para>
	/// <para>DERIVE</para>
	/// <para>Z : IfcDirection := NVL (IfcNormalise(Axis), IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcDirection([0.0,0.0,1.0]));</para>
	/// <para>WHERE</para>
	/// <para>AxisIs3D : (NOT (EXISTS (Axis))) OR (Axis.Dim = 3);</para>
	/// <para>LocationIs3D : SELF\IfcPlacement.Location.Dim = 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAxis1Placement : IfcPlacement
	{
		public virtual IfcDirection? Axis { get; set; }
		//TODO DERIVE
		public virtual IfcDirection? Z {get {return null;}}
		public IfcAxis1Placement() : base()
		{
		}
		public IfcAxis1Placement(IfcCartesianPoint Location, IfcDirection Axis) : base (Location)
		{
			this.Axis = Axis;
		}
	}
	/// <summary>
	/// ENTITY IfcAxis2Placement2D
	/// <para>ENTITY IfcAxis2Placement2D</para>
	/// <para>SUBTYPE OF (IfcPlacement);</para>
	/// <para>RefDirection : OPTIONAL IfcDirection;</para>
	/// <para>DERIVE</para>
	/// <para>P : LIST [2:2] OF IfcDirection := IfcBuild2Axes(RefDirection);</para>
	/// <para>WHERE</para>
	/// <para>RefDirIs2D : (NOT (EXISTS (RefDirection))) OR (RefDirection.Dim = 2);</para>
	/// <para>LocationIs2D : SELF\IfcPlacement.Location.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAxis2Placement2D : IfcPlacement, IfcAxis2Placement
	{
		public virtual IfcDirection? RefDirection { get; set; }
		//TODO DERIVE
		public virtual List<IfcDirection>? P {get {return null;}}
		public IfcAxis2Placement2D() : base()
		{
		}
		public IfcAxis2Placement2D(IfcCartesianPoint Location, IfcDirection RefDirection) : base (Location)
		{
			this.RefDirection = RefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcAxis2Placement3D
	/// <para>ENTITY IfcAxis2Placement3D</para>
	/// <para>SUBTYPE OF (IfcPlacement);</para>
	/// <para>Axis : OPTIONAL IfcDirection;</para>
	/// <para>RefDirection : OPTIONAL IfcDirection;</para>
	/// <para>DERIVE</para>
	/// <para>P : LIST [3:3] OF IfcDirection := IfcBuildAxes(Axis, RefDirection);</para>
	/// <para>WHERE</para>
	/// <para>LocationIs3D : SELF\IfcPlacement.Location.Dim = 3;</para>
	/// <para>AxisIs3D : (NOT (EXISTS (Axis))) OR (Axis.Dim = 3);</para>
	/// <para>RefDirIs3D : (NOT (EXISTS (RefDirection))) OR (RefDirection.Dim = 3);</para>
	/// <para>AxisToRefDirPosition : (NOT (EXISTS (Axis))) OR (NOT (EXISTS (RefDirection))) OR (IfcCrossProduct(Axis,RefDirection).Magnitude > 0.0);</para>
	/// <para>AxisAndRefDirProvision : NOT ((EXISTS (Axis)) XOR (EXISTS (RefDirection)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcAxis2Placement3D : IfcPlacement, IfcAxis2Placement
	{
		public virtual IfcDirection? Axis { get; set; }
		public virtual IfcDirection? RefDirection { get; set; }
		//TODO DERIVE
		public virtual List<IfcDirection>? P {get {return null;}}
		public IfcAxis2Placement3D() : base()
		{
		}
		public IfcAxis2Placement3D(IfcCartesianPoint Location, IfcDirection Axis, IfcDirection RefDirection) : base (Location)
		{
			this.Axis = Axis;
			this.RefDirection = RefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineCurve
	/// <para>ENTITY IfcBSplineCurve</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBSplineCurveWithKnots))</para>
	/// <para>SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>Degree : IfcInteger;</para>
	/// <para>ControlPointsList : LIST [2:?] OF IfcCartesianPoint;</para>
	/// <para>CurveForm : IfcBSplineCurveForm;</para>
	/// <para>ClosedCurve : IfcLogical;</para>
	/// <para>SelfIntersect : IfcLogical;</para>
	/// <para>DERIVE</para>
	/// <para>UpperIndexOnControlPoints : IfcInteger := (SIZEOF(ControlPointsList) - 1);</para>
	/// <para>ControlPoints : ARRAY [0:UpperIndexOnControlPoints] OF IfcCartesianPoint := IfcListToArray(ControlPointsList,0,UpperIndexOnControlPoints);</para>
	/// <para>WHERE</para>
	/// <para>SameDim : SIZEOF(QUERY(Temp <* ControlPointsList |</para>
	/// <para>Temp.Dim <> ControlPointsList[1].Dim))</para>
	/// <para>= 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBSplineCurve : IfcBoundedCurve
	{
		public virtual IfcInteger? Degree { get; set; }
		public virtual List<IfcCartesianPoint>? ControlPointsList { get; set; }
		public virtual IfcBSplineCurveForm? CurveForm { get; set; }
		public virtual IfcLogical? ClosedCurve { get; set; }
		public virtual IfcLogical? SelfIntersect { get; set; }
		//TODO DERIVE
		public virtual IfcInteger? UpperIndexOnControlPoints {get {return null;}}
		//TODO DERIVE
		public virtual List<IfcCartesianPoint>? ControlPoints {get {return null;}}
		public IfcBSplineCurve() : base()
		{
		}
		public IfcBSplineCurve(IfcInteger Degree, List<IfcCartesianPoint> ControlPointsList, IfcBSplineCurveForm CurveForm, IfcLogical ClosedCurve, IfcLogical SelfIntersect) : base ()
		{
			this.Degree = Degree;
			this.ControlPointsList = ControlPointsList;
			this.CurveForm = CurveForm;
			this.ClosedCurve = ClosedCurve;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineCurveWithKnots
	/// <para>ENTITY IfcBSplineCurveWithKnots</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRationalBSplineCurveWithKnots))</para>
	/// <para>SUBTYPE OF (IfcBSplineCurve);</para>
	/// <para>KnotMultiplicities : LIST [2:?] OF IfcInteger;</para>
	/// <para>Knots : LIST [2:?] OF IfcParameterValue;</para>
	/// <para>KnotSpec : IfcKnotType;</para>
	/// <para>DERIVE</para>
	/// <para>UpperIndexOnKnots : IfcInteger := SIZEOF(Knots);</para>
	/// <para>WHERE</para>
	/// <para>ConsistentBSpline : IfcConstraintsParamBSpline(Degree, UpperIndexOnKnots,</para>
	/// <para>UpperIndexOnControlPoints, KnotMultiplicities, Knots);</para>
	/// <para>CorrespondingKnotLists : SIZEOF(KnotMultiplicities) = UpperIndexOnKnots;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBSplineCurveWithKnots : IfcBSplineCurve
	{
		public virtual List<IfcInteger>? KnotMultiplicities { get; set; }
		public virtual List<IfcParameterValue>? Knots { get; set; }
		public virtual IfcKnotType? KnotSpec { get; set; }
		//TODO DERIVE
		public virtual IfcInteger? UpperIndexOnKnots {get {return null;}}
		public IfcBSplineCurveWithKnots() : base()
		{
		}
		public IfcBSplineCurveWithKnots(IfcInteger Degree, List<IfcCartesianPoint> ControlPointsList, IfcBSplineCurveForm CurveForm, IfcLogical ClosedCurve, IfcLogical SelfIntersect, List<IfcInteger> KnotMultiplicities, List<IfcParameterValue> Knots, IfcKnotType KnotSpec) : base (Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect)
		{
			this.KnotMultiplicities = KnotMultiplicities;
			this.Knots = Knots;
			this.KnotSpec = KnotSpec;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineSurface
	/// <para>ENTITY IfcBSplineSurface</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBSplineSurfaceWithKnots))</para>
	/// <para>SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>UDegree : IfcInteger;</para>
	/// <para>VDegree : IfcInteger;</para>
	/// <para>ControlPointsList : LIST [2:?] OF LIST [2:?] OF IfcCartesianPoint;</para>
	/// <para>SurfaceForm : IfcBSplineSurfaceForm;</para>
	/// <para>UClosed : IfcLogical;</para>
	/// <para>VClosed : IfcLogical;</para>
	/// <para>SelfIntersect : IfcLogical;</para>
	/// <para>DERIVE</para>
	/// <para>UUpper : IfcInteger := SIZEOF(ControlPointsList) - 1;</para>
	/// <para>VUpper : IfcInteger := SIZEOF(ControlPointsList[1]) - 1;</para>
	/// <para>ControlPoints : ARRAY [0:UUpper] OF ARRAY [0:VUpper] OF IfcCartesianPoint := IfcMakeArrayOfArray(ControlPointsList,</para>
	/// <para>0,UUpper,0,VUpper);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBSplineSurface : IfcBoundedSurface
	{
		public virtual IfcInteger? UDegree { get; set; }
		public virtual IfcInteger? VDegree { get; set; }
		public virtual List<List<IfcCartesianPoint >>? ControlPointsList { get; set; }
		public virtual IfcBSplineSurfaceForm? SurfaceForm { get; set; }
		public virtual IfcLogical? UClosed { get; set; }
		public virtual IfcLogical? VClosed { get; set; }
		public virtual IfcLogical? SelfIntersect { get; set; }
		//TODO DERIVE
		public virtual IfcInteger? UUpper {get {return null;}}
		//TODO DERIVE
		public virtual IfcInteger? VUpper {get {return null;}}
		//TODO DERIVE
		public virtual List<List<IfcCartesianPoint >>? ControlPoints {get {return null;}}
		public IfcBSplineSurface() : base()
		{
		}
		public IfcBSplineSurface(IfcInteger UDegree, IfcInteger VDegree, List<List<IfcCartesianPoint >> ControlPointsList, IfcBSplineSurfaceForm SurfaceForm, IfcLogical UClosed, IfcLogical VClosed, IfcLogical SelfIntersect) : base ()
		{
			this.UDegree = UDegree;
			this.VDegree = VDegree;
			this.ControlPointsList = ControlPointsList;
			this.SurfaceForm = SurfaceForm;
			this.UClosed = UClosed;
			this.VClosed = VClosed;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcBSplineSurfaceWithKnots
	/// <para>ENTITY IfcBSplineSurfaceWithKnots</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRationalBSplineSurfaceWithKnots))</para>
	/// <para>SUBTYPE OF (IfcBSplineSurface);</para>
	/// <para>UMultiplicities : LIST [2:?] OF IfcInteger;</para>
	/// <para>VMultiplicities : LIST [2:?] OF IfcInteger;</para>
	/// <para>UKnots : LIST [2:?] OF IfcParameterValue;</para>
	/// <para>VKnots : LIST [2:?] OF IfcParameterValue;</para>
	/// <para>KnotSpec : IfcKnotType;</para>
	/// <para>DERIVE</para>
	/// <para>KnotVUpper : IfcInteger := SIZEOF(VKnots);</para>
	/// <para>KnotUUpper : IfcInteger := SIZEOF(UKnots);</para>
	/// <para>WHERE</para>
	/// <para>UDirectionConstraints : IfcConstraintsParamBSpline (</para>
	/// <para>SELF\IfcBSplineSurface.UDegree, KnotUUpper,</para>
	/// <para>SELF\IfcBSplineSurface.UUpper, UMultiplicities, UKnots);</para>
	/// <para>VDirectionConstraints : IfcConstraintsParamBSpline (</para>
	/// <para>SELF\IfcBSplineSurface.VDegree, KnotVUpper,</para>
	/// <para>SELF\IfcBSplineSurface.VUpper, VMultiplicities, VKnots);</para>
	/// <para>CorrespondingULists : SIZEOF(UMultiplicities) = KnotUUpper;</para>
	/// <para>CorrespondingVLists : SIZEOF(VMultiplicities) = KnotVUpper;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBSplineSurfaceWithKnots : IfcBSplineSurface
	{
		public virtual List<IfcInteger>? UMultiplicities { get; set; }
		public virtual List<IfcInteger>? VMultiplicities { get; set; }
		public virtual List<IfcParameterValue>? UKnots { get; set; }
		public virtual List<IfcParameterValue>? VKnots { get; set; }
		public virtual IfcKnotType? KnotSpec { get; set; }
		//TODO DERIVE
		public virtual IfcInteger? KnotVUpper {get {return null;}}
		//TODO DERIVE
		public virtual IfcInteger? KnotUUpper {get {return null;}}
		public IfcBSplineSurfaceWithKnots() : base()
		{
		}
		public IfcBSplineSurfaceWithKnots(IfcInteger UDegree, IfcInteger VDegree, List<List<IfcCartesianPoint >> ControlPointsList, IfcBSplineSurfaceForm SurfaceForm, IfcLogical UClosed, IfcLogical VClosed, IfcLogical SelfIntersect, List<IfcInteger> UMultiplicities, List<IfcInteger> VMultiplicities, List<IfcParameterValue> UKnots, List<IfcParameterValue> VKnots, IfcKnotType KnotSpec) : base (UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect)
		{
			this.UMultiplicities = UMultiplicities;
			this.VMultiplicities = VMultiplicities;
			this.UKnots = UKnots;
			this.VKnots = VKnots;
			this.KnotSpec = KnotSpec;
		}
	}
	/// <summary>
	/// ENTITY IfcBeam
	/// <para>ENTITY IfcBeam</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBeamStandardCase))</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcBeamTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcBeamTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBeamTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCBEAMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBeam : IfcBuildingElement
	{
		public virtual IfcBeamTypeEnum? PredefinedType { get; set; }
		public IfcBeam() : base()
		{
		}
		public IfcBeam(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBeamStandardCase
	/// <para>ENTITY IfcBeamStandardCase</para>
	/// <para>SUBTYPE OF (IfcBeam);</para>
	/// <para>WHERE</para>
	/// <para>HasMaterialProfileSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4X1.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>('IFC4X1.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>('IFC4X1.IFCMATERIALPROFILESETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBeamStandardCase : IfcBeam
	{
		public IfcBeamStandardCase() : base()
		{
		}
		public IfcBeamStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBeamType
	/// <para>ENTITY IfcBeamType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcBeamTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcBeamTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBeamTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBeamType : IfcBuildingElementType
	{
		public virtual IfcBeamTypeEnum? PredefinedType { get; set; }
		public IfcBeamType() : base()
		{
		}
		public IfcBeamType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBlobTexture
	/// <para>ENTITY IfcBlobTexture</para>
	/// <para>SUBTYPE OF (IfcSurfaceTexture);</para>
	/// <para>RasterFormat : IfcIdentifier;</para>
	/// <para>RasterCode : IfcBinary;</para>
	/// <para>WHERE</para>
	/// <para>SupportedRasterFormat : SELF.RasterFormat IN ['BMP', 'JPG', 'GIF', 'PNG'];</para>
	/// <para>RasterCodeByteStream : BLENGTH(RasterCode) MOD 8 = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBlobTexture : IfcSurfaceTexture
	{
		public virtual IfcIdentifier? RasterFormat { get; set; }
		public virtual IfcBinary? RasterCode { get; set; }
		public IfcBlobTexture() : base()
		{
		}
		public IfcBlobTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter, IfcIdentifier RasterFormat, IfcBinary RasterCode) : base (RepeatS, RepeatT, Mode, TextureTransform, Parameter)
		{
			this.RasterFormat = RasterFormat;
			this.RasterCode = RasterCode;
		}
	}
	/// <summary>
	/// ENTITY IfcBlock
	/// <para>ENTITY IfcBlock</para>
	/// <para>SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>XLength : IfcPositiveLengthMeasure;</para>
	/// <para>YLength : IfcPositiveLengthMeasure;</para>
	/// <para>ZLength : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBlock : IfcCsgPrimitive3D
	{
		public virtual IfcPositiveLengthMeasure? XLength { get; set; }
		public virtual IfcPositiveLengthMeasure? YLength { get; set; }
		public virtual IfcPositiveLengthMeasure? ZLength { get; set; }
		public IfcBlock() : base()
		{
		}
		public IfcBlock(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure XLength, IfcPositiveLengthMeasure YLength, IfcPositiveLengthMeasure ZLength) : base (Position)
		{
			this.XLength = XLength;
			this.YLength = YLength;
			this.ZLength = ZLength;
		}
	}
	/// <summary>
	/// ENTITY IfcBoiler
	/// <para>ENTITY IfcBoiler</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcBoilerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcBoilerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBoilerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCBOILERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoiler : IfcEnergyConversionDevice
	{
		public virtual IfcBoilerTypeEnum? PredefinedType { get; set; }
		public IfcBoiler() : base()
		{
		}
		public IfcBoiler(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBoilerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBoilerType
	/// <para>ENTITY IfcBoilerType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcBoilerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcBoilerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBoilerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoilerType : IfcEnergyConversionDeviceType
	{
		public virtual IfcBoilerTypeEnum? PredefinedType { get; set; }
		public IfcBoilerType() : base()
		{
		}
		public IfcBoilerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBoilerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBooleanClippingResult
	/// <para>ENTITY IfcBooleanClippingResult</para>
	/// <para>SUBTYPE OF (IfcBooleanResult);</para>
	/// <para>WHERE</para>
	/// <para>FirstOperandType : ('IFC4X1.IFCSWEPTAREASOLID' IN TYPEOF(FirstOperand)) OR</para>
	/// <para>('IFC4X1.IFCSWEPTDISCSOLID' IN TYPEOF(FirstOperand)) OR</para>
	/// <para>('IFC4X1.IFCBOOLEANCLIPPINGRESULT' IN TYPEOF(FirstOperand));</para>
	/// <para>SecondOperandType : ('IFC4X1.IFCHALFSPACESOLID' IN TYPEOF(SecondOperand));</para>
	/// <para>OperatorType : Operator = DIFFERENCE;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBooleanClippingResult : IfcBooleanResult
	{
		public IfcBooleanClippingResult() : base()
		{
		}
		public IfcBooleanClippingResult(IfcBooleanOperator Operator, IfcBooleanOperand FirstOperand, IfcBooleanOperand SecondOperand) : base (Operator, FirstOperand, SecondOperand)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBooleanResult
	/// <para>ENTITY IfcBooleanResult</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBooleanClippingResult))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Operator : IfcBooleanOperator;</para>
	/// <para>FirstOperand : IfcBooleanOperand;</para>
	/// <para>SecondOperand : IfcBooleanOperand;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := FirstOperand.Dim;</para>
	/// <para>WHERE</para>
	/// <para>SameDim : FirstOperand.Dim = SecondOperand.Dim;</para>
	/// <para>FirstOperandClosed : NOT('IFC4X1.IFCTESSELLATEDFACESET' IN TYPEOF(FirstOperand)) OR (EXISTS(FirstOperand.Closed) AND FirstOperand.Closed);</para>
	/// <para>SecondOperandClosed : NOT('IFC4X1.IFCTESSELLATEDFACESET' IN TYPEOF(SecondOperand)) OR (EXISTS(SecondOperand.Closed) AND SecondOperand.Closed);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBooleanResult : IfcGeometricRepresentationItem, IfcBooleanOperand, IfcCsgSelect
	{
		public virtual IfcBooleanOperator? Operator { get; set; }
		public virtual IfcBooleanOperand? FirstOperand { get; set; }
		public virtual IfcBooleanOperand? SecondOperand { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcBooleanResult() : base()
		{
		}
		public IfcBooleanResult(IfcBooleanOperator Operator, IfcBooleanOperand FirstOperand, IfcBooleanOperand SecondOperand) : base ()
		{
			this.Operator = Operator;
			this.FirstOperand = FirstOperand;
			this.SecondOperand = SecondOperand;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryCondition
	/// <para>ENTITY IfcBoundaryCondition</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBoundaryEdgeCondition</para>
	/// <para>,IfcBoundaryFaceCondition</para>
	/// <para>,IfcBoundaryNodeCondition));</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBoundaryCondition : Entity
	{
		public virtual IfcLabel? Name { get; set; }
		public IfcBoundaryCondition() : base()
		{
		}
		public IfcBoundaryCondition(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryCurve
	/// <para>ENTITY IfcBoundaryCurve</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcOuterBoundaryCurve))</para>
	/// <para>SUBTYPE OF (IfcCompositeCurveOnSurface);</para>
	/// <para>WHERE</para>
	/// <para>IsClosed : SELF\IfcCompositeCurve.ClosedCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryCurve : IfcCompositeCurveOnSurface
	{
		public IfcBoundaryCurve() : base()
		{
		}
		public IfcBoundaryCurve(List<IfcCompositeCurveSegment> Segments, IfcLogical SelfIntersect) : base (Segments, SelfIntersect)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryEdgeCondition
	/// <para>ENTITY IfcBoundaryEdgeCondition</para>
	/// <para>SUBTYPE OF (IfcBoundaryCondition);</para>
	/// <para>TranslationalStiffnessByLengthX : OPTIONAL IfcModulusOfTranslationalSubgradeReactionSelect;</para>
	/// <para>TranslationalStiffnessByLengthY : OPTIONAL IfcModulusOfTranslationalSubgradeReactionSelect;</para>
	/// <para>TranslationalStiffnessByLengthZ : OPTIONAL IfcModulusOfTranslationalSubgradeReactionSelect;</para>
	/// <para>RotationalStiffnessByLengthX : OPTIONAL IfcModulusOfRotationalSubgradeReactionSelect;</para>
	/// <para>RotationalStiffnessByLengthY : OPTIONAL IfcModulusOfRotationalSubgradeReactionSelect;</para>
	/// <para>RotationalStiffnessByLengthZ : OPTIONAL IfcModulusOfRotationalSubgradeReactionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryEdgeCondition : IfcBoundaryCondition
	{
		public virtual IfcModulusOfTranslationalSubgradeReactionSelect? TranslationalStiffnessByLengthX { get; set; }
		public virtual IfcModulusOfTranslationalSubgradeReactionSelect? TranslationalStiffnessByLengthY { get; set; }
		public virtual IfcModulusOfTranslationalSubgradeReactionSelect? TranslationalStiffnessByLengthZ { get; set; }
		public virtual IfcModulusOfRotationalSubgradeReactionSelect? RotationalStiffnessByLengthX { get; set; }
		public virtual IfcModulusOfRotationalSubgradeReactionSelect? RotationalStiffnessByLengthY { get; set; }
		public virtual IfcModulusOfRotationalSubgradeReactionSelect? RotationalStiffnessByLengthZ { get; set; }
		public IfcBoundaryEdgeCondition() : base()
		{
		}
		public IfcBoundaryEdgeCondition(IfcLabel Name, IfcModulusOfTranslationalSubgradeReactionSelect TranslationalStiffnessByLengthX, IfcModulusOfTranslationalSubgradeReactionSelect TranslationalStiffnessByLengthY, IfcModulusOfTranslationalSubgradeReactionSelect TranslationalStiffnessByLengthZ, IfcModulusOfRotationalSubgradeReactionSelect RotationalStiffnessByLengthX, IfcModulusOfRotationalSubgradeReactionSelect RotationalStiffnessByLengthY, IfcModulusOfRotationalSubgradeReactionSelect RotationalStiffnessByLengthZ) : base (Name)
		{
			this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX;
			this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY;
			this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ;
			this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX;
			this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY;
			this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryFaceCondition
	/// <para>ENTITY IfcBoundaryFaceCondition</para>
	/// <para>SUBTYPE OF (IfcBoundaryCondition);</para>
	/// <para>TranslationalStiffnessByAreaX : OPTIONAL IfcModulusOfSubgradeReactionSelect;</para>
	/// <para>TranslationalStiffnessByAreaY : OPTIONAL IfcModulusOfSubgradeReactionSelect;</para>
	/// <para>TranslationalStiffnessByAreaZ : OPTIONAL IfcModulusOfSubgradeReactionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryFaceCondition : IfcBoundaryCondition
	{
		public virtual IfcModulusOfSubgradeReactionSelect? TranslationalStiffnessByAreaX { get; set; }
		public virtual IfcModulusOfSubgradeReactionSelect? TranslationalStiffnessByAreaY { get; set; }
		public virtual IfcModulusOfSubgradeReactionSelect? TranslationalStiffnessByAreaZ { get; set; }
		public IfcBoundaryFaceCondition() : base()
		{
		}
		public IfcBoundaryFaceCondition(IfcLabel Name, IfcModulusOfSubgradeReactionSelect TranslationalStiffnessByAreaX, IfcModulusOfSubgradeReactionSelect TranslationalStiffnessByAreaY, IfcModulusOfSubgradeReactionSelect TranslationalStiffnessByAreaZ) : base (Name)
		{
			this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX;
			this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY;
			this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryNodeCondition
	/// <para>ENTITY IfcBoundaryNodeCondition</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBoundaryNodeConditionWarping))</para>
	/// <para>SUBTYPE OF (IfcBoundaryCondition);</para>
	/// <para>TranslationalStiffnessX : OPTIONAL IfcTranslationalStiffnessSelect;</para>
	/// <para>TranslationalStiffnessY : OPTIONAL IfcTranslationalStiffnessSelect;</para>
	/// <para>TranslationalStiffnessZ : OPTIONAL IfcTranslationalStiffnessSelect;</para>
	/// <para>RotationalStiffnessX : OPTIONAL IfcRotationalStiffnessSelect;</para>
	/// <para>RotationalStiffnessY : OPTIONAL IfcRotationalStiffnessSelect;</para>
	/// <para>RotationalStiffnessZ : OPTIONAL IfcRotationalStiffnessSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryNodeCondition : IfcBoundaryCondition
	{
		public virtual IfcTranslationalStiffnessSelect? TranslationalStiffnessX { get; set; }
		public virtual IfcTranslationalStiffnessSelect? TranslationalStiffnessY { get; set; }
		public virtual IfcTranslationalStiffnessSelect? TranslationalStiffnessZ { get; set; }
		public virtual IfcRotationalStiffnessSelect? RotationalStiffnessX { get; set; }
		public virtual IfcRotationalStiffnessSelect? RotationalStiffnessY { get; set; }
		public virtual IfcRotationalStiffnessSelect? RotationalStiffnessZ { get; set; }
		public IfcBoundaryNodeCondition() : base()
		{
		}
		public IfcBoundaryNodeCondition(IfcLabel Name, IfcTranslationalStiffnessSelect TranslationalStiffnessX, IfcTranslationalStiffnessSelect TranslationalStiffnessY, IfcTranslationalStiffnessSelect TranslationalStiffnessZ, IfcRotationalStiffnessSelect RotationalStiffnessX, IfcRotationalStiffnessSelect RotationalStiffnessY, IfcRotationalStiffnessSelect RotationalStiffnessZ) : base (Name)
		{
			this.TranslationalStiffnessX = TranslationalStiffnessX;
			this.TranslationalStiffnessY = TranslationalStiffnessY;
			this.TranslationalStiffnessZ = TranslationalStiffnessZ;
			this.RotationalStiffnessX = RotationalStiffnessX;
			this.RotationalStiffnessY = RotationalStiffnessY;
			this.RotationalStiffnessZ = RotationalStiffnessZ;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundaryNodeConditionWarping
	/// <para>ENTITY IfcBoundaryNodeConditionWarping</para>
	/// <para>SUBTYPE OF (IfcBoundaryNodeCondition);</para>
	/// <para>WarpingStiffness : OPTIONAL IfcWarpingStiffnessSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundaryNodeConditionWarping : IfcBoundaryNodeCondition
	{
		public virtual IfcWarpingStiffnessSelect? WarpingStiffness { get; set; }
		public IfcBoundaryNodeConditionWarping() : base()
		{
		}
		public IfcBoundaryNodeConditionWarping(IfcLabel Name, IfcTranslationalStiffnessSelect TranslationalStiffnessX, IfcTranslationalStiffnessSelect TranslationalStiffnessY, IfcTranslationalStiffnessSelect TranslationalStiffnessZ, IfcRotationalStiffnessSelect RotationalStiffnessX, IfcRotationalStiffnessSelect RotationalStiffnessY, IfcRotationalStiffnessSelect RotationalStiffnessZ, IfcWarpingStiffnessSelect WarpingStiffness) : base (Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ)
		{
			this.WarpingStiffness = WarpingStiffness;
		}
	}
	/// <summary>
	/// ENTITY IfcBoundedCurve
	/// <para>ENTITY IfcBoundedCurve</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAlignmentCurve</para>
	/// <para>,IfcBSplineCurve</para>
	/// <para>,IfcCompositeCurve</para>
	/// <para>,IfcCurveSegment2D</para>
	/// <para>,IfcIndexedPolyCurve</para>
	/// <para>,IfcPolyline</para>
	/// <para>,IfcTrimmedCurve))</para>
	/// <para>SUBTYPE OF (IfcCurve);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBoundedCurve : IfcCurve, IfcCurveOrEdgeCurve
	{
		public IfcBoundedCurve() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBoundedSurface
	/// <para>ENTITY IfcBoundedSurface</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBSplineSurface</para>
	/// <para>,IfcCurveBoundedPlane</para>
	/// <para>,IfcCurveBoundedSurface</para>
	/// <para>,IfcRectangularTrimmedSurface))</para>
	/// <para>SUBTYPE OF (IfcSurface);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBoundedSurface : IfcSurface
	{
		public IfcBoundedSurface() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBoundingBox
	/// <para>ENTITY IfcBoundingBox</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Corner : IfcCartesianPoint;</para>
	/// <para>XDim : IfcPositiveLengthMeasure;</para>
	/// <para>YDim : IfcPositiveLengthMeasure;</para>
	/// <para>ZDim : IfcPositiveLengthMeasure;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoundingBox : IfcGeometricRepresentationItem
	{
		public virtual IfcCartesianPoint? Corner { get; set; }
		public virtual IfcPositiveLengthMeasure? XDim { get; set; }
		public virtual IfcPositiveLengthMeasure? YDim { get; set; }
		public virtual IfcPositiveLengthMeasure? ZDim { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcBoundingBox() : base()
		{
		}
		public IfcBoundingBox(IfcCartesianPoint Corner, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim, IfcPositiveLengthMeasure ZDim) : base ()
		{
			this.Corner = Corner;
			this.XDim = XDim;
			this.YDim = YDim;
			this.ZDim = ZDim;
		}
	}
	/// <summary>
	/// ENTITY IfcBoxedHalfSpace
	/// <para>ENTITY IfcBoxedHalfSpace</para>
	/// <para>SUBTYPE OF (IfcHalfSpaceSolid);</para>
	/// <para>Enclosure : IfcBoundingBox;</para>
	/// <para>WHERE</para>
	/// <para>UnboundedSurface : NOT ('IFC4X1.IFCCURVEBOUNDEDPLANE' IN TYPEOF(SELF\IfcHalfSpaceSolid.BaseSurface));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBoxedHalfSpace : IfcHalfSpaceSolid
	{
		public virtual IfcBoundingBox? Enclosure { get; set; }
		public IfcBoxedHalfSpace() : base()
		{
		}
		public IfcBoxedHalfSpace(IfcSurface BaseSurface, IfcBoolean AgreementFlag, IfcBoundingBox Enclosure) : base (BaseSurface, AgreementFlag)
		{
			this.Enclosure = Enclosure;
		}
	}
	/// <summary>
	/// ENTITY IfcBuilding
	/// <para>ENTITY IfcBuilding</para>
	/// <para>SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>ElevationOfRefHeight : OPTIONAL IfcLengthMeasure;</para>
	/// <para>ElevationOfTerrain : OPTIONAL IfcLengthMeasure;</para>
	/// <para>BuildingAddress : OPTIONAL IfcPostalAddress;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuilding : IfcSpatialStructureElement
	{
		public virtual IfcLengthMeasure? ElevationOfRefHeight { get; set; }
		public virtual IfcLengthMeasure? ElevationOfTerrain { get; set; }
		public virtual IfcPostalAddress? BuildingAddress { get; set; }
		public IfcBuilding() : base()
		{
		}
		public IfcBuilding(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcLengthMeasure ElevationOfRefHeight, IfcLengthMeasure ElevationOfTerrain, IfcPostalAddress BuildingAddress) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.ElevationOfRefHeight = ElevationOfRefHeight;
			this.ElevationOfTerrain = ElevationOfTerrain;
			this.BuildingAddress = BuildingAddress;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElement
	/// <para>ENTITY IfcBuildingElement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBeam</para>
	/// <para>,IfcBuildingElementProxy</para>
	/// <para>,IfcChimney</para>
	/// <para>,IfcColumn</para>
	/// <para>,IfcCovering</para>
	/// <para>,IfcCurtainWall</para>
	/// <para>,IfcDoor</para>
	/// <para>,IfcFooting</para>
	/// <para>,IfcMember</para>
	/// <para>,IfcPile</para>
	/// <para>,IfcPlate</para>
	/// <para>,IfcRailing</para>
	/// <para>,IfcRamp</para>
	/// <para>,IfcRampFlight</para>
	/// <para>,IfcRoof</para>
	/// <para>,IfcShadingDevice</para>
	/// <para>,IfcSlab</para>
	/// <para>,IfcStair</para>
	/// <para>,IfcStairFlight</para>
	/// <para>,IfcWall</para>
	/// <para>,IfcWindow))</para>
	/// <para>SUBTYPE OF (IfcElement);</para>
	/// <para>WHERE</para>
	/// <para>MaxOneMaterialAssociation : SIZEOF (QUERY(temp <* SELF\IfcObjectDefinition.HasAssociations |</para>
	/// <para>'IFC4X1.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)</para>
	/// <para>)) <= 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBuildingElement : IfcElement
	{
		public IfcBuildingElement() : base()
		{
		}
		public IfcBuildingElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementPart
	/// <para>ENTITY IfcBuildingElementPart</para>
	/// <para>SUBTYPE OF (IfcElementComponent);</para>
	/// <para>PredefinedType : OPTIONAL IfcBuildingElementPartTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcBuildingElementPartTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBuildingElementPartTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCBUILDINGELEMENTPARTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementPart : IfcElementComponent
	{
		public virtual IfcBuildingElementPartTypeEnum? PredefinedType { get; set; }
		public IfcBuildingElementPart() : base()
		{
		}
		public IfcBuildingElementPart(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBuildingElementPartTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementPartType
	/// <para>ENTITY IfcBuildingElementPartType</para>
	/// <para>SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>PredefinedType : IfcBuildingElementPartTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcBuildingElementPartTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBuildingElementPartTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementPartType : IfcElementComponentType
	{
		public virtual IfcBuildingElementPartTypeEnum? PredefinedType { get; set; }
		public IfcBuildingElementPartType() : base()
		{
		}
		public IfcBuildingElementPartType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBuildingElementPartTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementProxy
	/// <para>ENTITY IfcBuildingElementProxy</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcBuildingElementProxyTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>HasObjectName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcBuildingElementProxyTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBuildingElementProxyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCBUILDINGELEMENTPROXYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementProxy : IfcBuildingElement
	{
		public virtual IfcBuildingElementProxyTypeEnum? PredefinedType { get; set; }
		public IfcBuildingElementProxy() : base()
		{
		}
		public IfcBuildingElementProxy(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBuildingElementProxyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementProxyType
	/// <para>ENTITY IfcBuildingElementProxyType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcBuildingElementProxyTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcBuildingElementProxyTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBuildingElementProxyTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingElementProxyType : IfcBuildingElementType
	{
		public virtual IfcBuildingElementProxyTypeEnum? PredefinedType { get; set; }
		public IfcBuildingElementProxyType() : base()
		{
		}
		public IfcBuildingElementProxyType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBuildingElementProxyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingElementType
	/// <para>ENTITY IfcBuildingElementType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBeamType</para>
	/// <para>,IfcBuildingElementProxyType</para>
	/// <para>,IfcChimneyType</para>
	/// <para>,IfcColumnType</para>
	/// <para>,IfcCoveringType</para>
	/// <para>,IfcCurtainWallType</para>
	/// <para>,IfcDoorType</para>
	/// <para>,IfcFootingType</para>
	/// <para>,IfcMemberType</para>
	/// <para>,IfcPileType</para>
	/// <para>,IfcPlateType</para>
	/// <para>,IfcRailingType</para>
	/// <para>,IfcRampFlightType</para>
	/// <para>,IfcRampType</para>
	/// <para>,IfcRoofType</para>
	/// <para>,IfcShadingDeviceType</para>
	/// <para>,IfcSlabType</para>
	/// <para>,IfcStairFlightType</para>
	/// <para>,IfcStairType</para>
	/// <para>,IfcWallType</para>
	/// <para>,IfcWindowType))</para>
	/// <para>SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcBuildingElementType : IfcElementType
	{
		public IfcBuildingElementType() : base()
		{
		}
		public IfcBuildingElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingStorey
	/// <para>ENTITY IfcBuildingStorey</para>
	/// <para>SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>Elevation : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingStorey : IfcSpatialStructureElement
	{
		public virtual IfcLengthMeasure? Elevation { get; set; }
		public IfcBuildingStorey() : base()
		{
		}
		public IfcBuildingStorey(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcLengthMeasure Elevation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.Elevation = Elevation;
		}
	}
	/// <summary>
	/// ENTITY IfcBuildingSystem
	/// <para>ENTITY IfcBuildingSystem</para>
	/// <para>SUBTYPE OF (IfcSystem);</para>
	/// <para>PredefinedType : OPTIONAL IfcBuildingSystemTypeEnum;</para>
	/// <para>LongName : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBuildingSystem : IfcSystem
	{
		public virtual IfcBuildingSystemTypeEnum? PredefinedType { get; set; }
		public virtual IfcLabel? LongName { get; set; }
		public IfcBuildingSystem() : base()
		{
		}
		public IfcBuildingSystem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcBuildingSystemTypeEnum PredefinedType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcBurner
	/// <para>ENTITY IfcBurner</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcBurnerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcBurnerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBurnerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCBURNERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBurner : IfcEnergyConversionDevice
	{
		public virtual IfcBurnerTypeEnum? PredefinedType { get; set; }
		public IfcBurner() : base()
		{
		}
		public IfcBurner(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcBurnerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcBurnerType
	/// <para>ENTITY IfcBurnerType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcBurnerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcBurnerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcBurnerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcBurnerType : IfcEnergyConversionDeviceType
	{
		public virtual IfcBurnerTypeEnum? PredefinedType { get; set; }
		public IfcBurnerType() : base()
		{
		}
		public IfcBurnerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcBurnerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCShapeProfileDef
	/// <para>ENTITY IfcCShapeProfileDef</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>Depth : IfcPositiveLengthMeasure;</para>
	/// <para>Width : IfcPositiveLengthMeasure;</para>
	/// <para>WallThickness : IfcPositiveLengthMeasure;</para>
	/// <para>Girth : IfcPositiveLengthMeasure;</para>
	/// <para>InternalFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidGirth : Girth < (Depth / 2.);</para>
	/// <para>ValidInternalFilletRadius : NOT(EXISTS(InternalFilletRadius)) OR</para>
	/// <para>((InternalFilletRadius <= Width/2. - WallThickness) AND (InternalFilletRadius <= Depth/2. - WallThickness));</para>
	/// <para>ValidWallThickness : (WallThickness < Width/2.) AND (WallThickness < Depth/2.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCShapeProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? Depth { get; set; }
		public virtual IfcPositiveLengthMeasure? Width { get; set; }
		public virtual IfcPositiveLengthMeasure? WallThickness { get; set; }
		public virtual IfcPositiveLengthMeasure? Girth { get; set; }
		public virtual IfcNonNegativeLengthMeasure? InternalFilletRadius { get; set; }
		public IfcCShapeProfileDef() : base()
		{
		}
		public IfcCShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure Width, IfcPositiveLengthMeasure WallThickness, IfcPositiveLengthMeasure Girth, IfcNonNegativeLengthMeasure InternalFilletRadius) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.Width = Width;
			this.WallThickness = WallThickness;
			this.Girth = Girth;
			this.InternalFilletRadius = InternalFilletRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierFitting
	/// <para>ENTITY IfcCableCarrierFitting</para>
	/// <para>SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>PredefinedType : OPTIONAL IfcCableCarrierFittingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCableCarrierFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableCarrierFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCABLECARRIERFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierFitting : IfcFlowFitting
	{
		public virtual IfcCableCarrierFittingTypeEnum? PredefinedType { get; set; }
		public IfcCableCarrierFitting() : base()
		{
		}
		public IfcCableCarrierFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableCarrierFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierFittingType
	/// <para>ENTITY IfcCableCarrierFittingType</para>
	/// <para>SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>PredefinedType : IfcCableCarrierFittingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCableCarrierFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableCarrierFittingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierFittingType : IfcFlowFittingType
	{
		public virtual IfcCableCarrierFittingTypeEnum? PredefinedType { get; set; }
		public IfcCableCarrierFittingType() : base()
		{
		}
		public IfcCableCarrierFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableCarrierFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierSegment
	/// <para>ENTITY IfcCableCarrierSegment</para>
	/// <para>SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>PredefinedType : OPTIONAL IfcCableCarrierSegmentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCableCarrierSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableCarrierSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCABLECARRIERSEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierSegment : IfcFlowSegment
	{
		public virtual IfcCableCarrierSegmentTypeEnum? PredefinedType { get; set; }
		public IfcCableCarrierSegment() : base()
		{
		}
		public IfcCableCarrierSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableCarrierSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableCarrierSegmentType
	/// <para>ENTITY IfcCableCarrierSegmentType</para>
	/// <para>SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>PredefinedType : IfcCableCarrierSegmentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCableCarrierSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableCarrierSegmentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableCarrierSegmentType : IfcFlowSegmentType
	{
		public virtual IfcCableCarrierSegmentTypeEnum? PredefinedType { get; set; }
		public IfcCableCarrierSegmentType() : base()
		{
		}
		public IfcCableCarrierSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableCarrierSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableFitting
	/// <para>ENTITY IfcCableFitting</para>
	/// <para>SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>PredefinedType : OPTIONAL IfcCableFittingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCableFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCABLEFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableFitting : IfcFlowFitting
	{
		public virtual IfcCableFittingTypeEnum? PredefinedType { get; set; }
		public IfcCableFitting() : base()
		{
		}
		public IfcCableFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableFittingType
	/// <para>ENTITY IfcCableFittingType</para>
	/// <para>SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>PredefinedType : IfcCableFittingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCableFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableFittingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableFittingType : IfcFlowFittingType
	{
		public virtual IfcCableFittingTypeEnum? PredefinedType { get; set; }
		public IfcCableFittingType() : base()
		{
		}
		public IfcCableFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableSegment
	/// <para>ENTITY IfcCableSegment</para>
	/// <para>SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>PredefinedType : OPTIONAL IfcCableSegmentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCableSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCABLESEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableSegment : IfcFlowSegment
	{
		public virtual IfcCableSegmentTypeEnum? PredefinedType { get; set; }
		public IfcCableSegment() : base()
		{
		}
		public IfcCableSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCableSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCableSegmentType
	/// <para>ENTITY IfcCableSegmentType</para>
	/// <para>SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>PredefinedType : IfcCableSegmentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCableSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCableSegmentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCableSegmentType : IfcFlowSegmentType
	{
		public virtual IfcCableSegmentTypeEnum? PredefinedType { get; set; }
		public IfcCableSegmentType() : base()
		{
		}
		public IfcCableSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCableSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPoint
	/// <para>ENTITY IfcCartesianPoint</para>
	/// <para>SUBTYPE OF (IfcPoint);</para>
	/// <para>Coordinates : LIST [1:3] OF IfcLengthMeasure;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := HIINDEX(Coordinates);</para>
	/// <para>WHERE</para>
	/// <para>CP2Dor3D : HIINDEX(Coordinates) >= 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianPoint : IfcPoint, IfcTrimmingSelect
	{
		public virtual List<IfcLengthMeasure>? Coordinates { get; set; }
		//TODO DERIVE
		public override IfcDimensionCount? Dim {get {return null;}}
		public IfcCartesianPoint() : base()
		{
		}
		public IfcCartesianPoint(List<IfcLengthMeasure> Coordinates) : base ()
		{
			this.Coordinates = Coordinates;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPointList
	/// <para>ENTITY IfcCartesianPointList</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCartesianPointList2D</para>
	/// <para>,IfcCartesianPointList3D))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := IfcPointListDim(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCartesianPointList : IfcGeometricRepresentationItem
	{
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcCartesianPointList() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPointList2D
	/// <para>ENTITY IfcCartesianPointList2D</para>
	/// <para>SUBTYPE OF (IfcCartesianPointList);</para>
	/// <para>CoordList : LIST [1:?] OF LIST [2:2] OF IfcLengthMeasure;</para>
	/// <para>TagList : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianPointList2D : IfcCartesianPointList
	{
		public virtual List<List<IfcLengthMeasure >>? CoordList { get; set; }
		public virtual List<IfcLabel>? TagList { get; set; }
		public IfcCartesianPointList2D() : base()
		{
		}
		public IfcCartesianPointList2D(List<List<IfcLengthMeasure >> CoordList, List<IfcLabel> TagList) : base ()
		{
			this.CoordList = CoordList;
			this.TagList = TagList;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianPointList3D
	/// <para>ENTITY IfcCartesianPointList3D</para>
	/// <para>SUBTYPE OF (IfcCartesianPointList);</para>
	/// <para>CoordList : LIST [1:?] OF LIST [3:3] OF IfcLengthMeasure;</para>
	/// <para>TagList : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianPointList3D : IfcCartesianPointList
	{
		public virtual List<List<IfcLengthMeasure >>? CoordList { get; set; }
		public virtual List<IfcLabel>? TagList { get; set; }
		public IfcCartesianPointList3D() : base()
		{
		}
		public IfcCartesianPointList3D(List<List<IfcLengthMeasure >> CoordList, List<IfcLabel> TagList) : base ()
		{
			this.CoordList = CoordList;
			this.TagList = TagList;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator
	/// <para>ENTITY IfcCartesianTransformationOperator</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCartesianTransformationOperator2D</para>
	/// <para>,IfcCartesianTransformationOperator3D))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Axis1 : OPTIONAL IfcDirection;</para>
	/// <para>Axis2 : OPTIONAL IfcDirection;</para>
	/// <para>LocalOrigin : IfcCartesianPoint;</para>
	/// <para>Scale : OPTIONAL IfcReal;</para>
	/// <para>DERIVE</para>
	/// <para>Scl : IfcReal := NVL(Scale, 1.0);</para>
	/// <para>Dim : IfcDimensionCount := LocalOrigin.Dim;</para>
	/// <para>WHERE</para>
	/// <para>ScaleGreaterZero : Scl > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCartesianTransformationOperator : IfcGeometricRepresentationItem
	{
		public virtual IfcDirection? Axis1 { get; set; }
		public virtual IfcDirection? Axis2 { get; set; }
		public virtual IfcCartesianPoint? LocalOrigin { get; set; }
		public virtual IfcReal? Scale { get; set; }
		//TODO DERIVE
		public virtual IfcReal? Scl {get {return null;}}
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcCartesianTransformationOperator() : base()
		{
		}
		public IfcCartesianTransformationOperator(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale) : base ()
		{
			this.Axis1 = Axis1;
			this.Axis2 = Axis2;
			this.LocalOrigin = LocalOrigin;
			this.Scale = Scale;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator2D
	/// <para>ENTITY IfcCartesianTransformationOperator2D</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCartesianTransformationOperator2DnonUniform))</para>
	/// <para>SUBTYPE OF (IfcCartesianTransformationOperator);</para>
	/// <para>DERIVE</para>
	/// <para>U : LIST [2:2] OF IfcDirection := IfcBaseAxis(2,SELF\IfcCartesianTransformationOperator.Axis1,</para>
	/// <para>SELF\IfcCartesianTransformationOperator.Axis2,?);</para>
	/// <para>WHERE</para>
	/// <para>DimEqual2 : SELF\IfcCartesianTransformationOperator.Dim = 2;</para>
	/// <para>Axis1Is2D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis1)) OR</para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis1.Dim = 2);</para>
	/// <para>Axis2Is2D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis2)) OR</para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis2.Dim = 2);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator2D : IfcCartesianTransformationOperator
	{
		//TODO DERIVE
		public virtual List<IfcDirection>? U {get {return null;}}
		public IfcCartesianTransformationOperator2D() : base()
		{
		}
		public IfcCartesianTransformationOperator2D(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale) : base (Axis1, Axis2, LocalOrigin, Scale)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator2DnonUniform
	/// <para>ENTITY IfcCartesianTransformationOperator2DnonUniform</para>
	/// <para>SUBTYPE OF (IfcCartesianTransformationOperator2D);</para>
	/// <para>Scale2 : OPTIONAL IfcReal;</para>
	/// <para>DERIVE</para>
	/// <para>Scl2 : IfcReal := NVL(Scale2, SELF\IfcCartesianTransformationOperator.Scl);</para>
	/// <para>WHERE</para>
	/// <para>Scale2GreaterZero : Scl2 > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator2DnonUniform : IfcCartesianTransformationOperator2D
	{
		public virtual IfcReal? Scale2 { get; set; }
		//TODO DERIVE
		public virtual IfcReal? Scl2 {get {return null;}}
		public IfcCartesianTransformationOperator2DnonUniform() : base()
		{
		}
		public IfcCartesianTransformationOperator2DnonUniform(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale, IfcReal Scale2) : base (Axis1, Axis2, LocalOrigin, Scale)
		{
			this.Scale2 = Scale2;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator3D
	/// <para>ENTITY IfcCartesianTransformationOperator3D</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCartesianTransformationOperator3DnonUniform))</para>
	/// <para>SUBTYPE OF (IfcCartesianTransformationOperator);</para>
	/// <para>Axis3 : OPTIONAL IfcDirection;</para>
	/// <para>DERIVE</para>
	/// <para>U : LIST [3:3] OF IfcDirection := IfcBaseAxis(3,SELF\IfcCartesianTransformationOperator.Axis1,</para>
	/// <para>SELF\IfcCartesianTransformationOperator.Axis2,Axis3);</para>
	/// <para>WHERE</para>
	/// <para>DimIs3D : SELF\IfcCartesianTransformationOperator.Dim = 3;</para>
	/// <para>Axis1Is3D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis1)) OR</para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis1.Dim = 3);</para>
	/// <para>Axis2Is3D : NOT(EXISTS(SELF\IfcCartesianTransformationOperator.Axis2)) OR</para>
	/// <para>(SELF\IfcCartesianTransformationOperator.Axis2.Dim = 3);</para>
	/// <para>Axis3Is3D : NOT(EXISTS(Axis3)) OR (Axis3.Dim = 3);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator3D : IfcCartesianTransformationOperator
	{
		public virtual IfcDirection? Axis3 { get; set; }
		//TODO DERIVE
		public virtual List<IfcDirection>? U {get {return null;}}
		public IfcCartesianTransformationOperator3D() : base()
		{
		}
		public IfcCartesianTransformationOperator3D(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale, IfcDirection Axis3) : base (Axis1, Axis2, LocalOrigin, Scale)
		{
			this.Axis3 = Axis3;
		}
	}
	/// <summary>
	/// ENTITY IfcCartesianTransformationOperator3DnonUniform
	/// <para>ENTITY IfcCartesianTransformationOperator3DnonUniform</para>
	/// <para>SUBTYPE OF (IfcCartesianTransformationOperator3D);</para>
	/// <para>Scale2 : OPTIONAL IfcReal;</para>
	/// <para>Scale3 : OPTIONAL IfcReal;</para>
	/// <para>DERIVE</para>
	/// <para>Scl2 : IfcReal := NVL(Scale2, SELF\IfcCartesianTransformationOperator.Scl);</para>
	/// <para>Scl3 : IfcReal := NVL(Scale3, SELF\IfcCartesianTransformationOperator.Scl);</para>
	/// <para>WHERE</para>
	/// <para>Scale2GreaterZero : Scl2 > 0.0;</para>
	/// <para>Scale3GreaterZero : Scl3 > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCartesianTransformationOperator3DnonUniform : IfcCartesianTransformationOperator3D
	{
		public virtual IfcReal? Scale2 { get; set; }
		public virtual IfcReal? Scale3 { get; set; }
		//TODO DERIVE
		public virtual IfcReal? Scl2 {get {return null;}}
		//TODO DERIVE
		public virtual IfcReal? Scl3 {get {return null;}}
		public IfcCartesianTransformationOperator3DnonUniform() : base()
		{
		}
		public IfcCartesianTransformationOperator3DnonUniform(IfcDirection Axis1, IfcDirection Axis2, IfcCartesianPoint LocalOrigin, IfcReal Scale, IfcDirection Axis3, IfcReal Scale2, IfcReal Scale3) : base (Axis1, Axis2, LocalOrigin, Scale, Axis3)
		{
			this.Scale2 = Scale2;
			this.Scale3 = Scale3;
		}
	}
	/// <summary>
	/// ENTITY IfcCenterLineProfileDef
	/// <para>ENTITY IfcCenterLineProfileDef</para>
	/// <para>SUBTYPE OF (IfcArbitraryOpenProfileDef);</para>
	/// <para>Thickness : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCenterLineProfileDef : IfcArbitraryOpenProfileDef
	{
		public virtual IfcPositiveLengthMeasure? Thickness { get; set; }
		public IfcCenterLineProfileDef() : base()
		{
		}
		public IfcCenterLineProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcBoundedCurve Curve, IfcPositiveLengthMeasure Thickness) : base (ProfileType, ProfileName, Curve)
		{
			this.Thickness = Thickness;
		}
	}
	/// <summary>
	/// ENTITY IfcChiller
	/// <para>ENTITY IfcChiller</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcChillerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcChillerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcChillerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCHILLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChiller : IfcEnergyConversionDevice
	{
		public virtual IfcChillerTypeEnum? PredefinedType { get; set; }
		public IfcChiller() : base()
		{
		}
		public IfcChiller(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcChillerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcChillerType
	/// <para>ENTITY IfcChillerType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcChillerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcChillerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcChillerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChillerType : IfcEnergyConversionDeviceType
	{
		public virtual IfcChillerTypeEnum? PredefinedType { get; set; }
		public IfcChillerType() : base()
		{
		}
		public IfcChillerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcChillerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcChimney
	/// <para>ENTITY IfcChimney</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcChimneyTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcChimneyTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcChimneyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCHIMNEYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChimney : IfcBuildingElement
	{
		public virtual IfcChimneyTypeEnum? PredefinedType { get; set; }
		public IfcChimney() : base()
		{
		}
		public IfcChimney(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcChimneyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcChimneyType
	/// <para>ENTITY IfcChimneyType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcChimneyTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcChimneyTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcChimneyTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcChimneyType : IfcBuildingElementType
	{
		public virtual IfcChimneyTypeEnum? PredefinedType { get; set; }
		public IfcChimneyType() : base()
		{
		}
		public IfcChimneyType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcChimneyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCircle
	/// <para>ENTITY IfcCircle</para>
	/// <para>SUBTYPE OF (IfcConic);</para>
	/// <para>Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCircle : IfcConic
	{
		public virtual IfcPositiveLengthMeasure? Radius { get; set; }
		public IfcCircle() : base()
		{
		}
		public IfcCircle(IfcAxis2Placement Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcCircleHollowProfileDef
	/// <para>ENTITY IfcCircleHollowProfileDef</para>
	/// <para>SUBTYPE OF (IfcCircleProfileDef);</para>
	/// <para>WallThickness : IfcPositiveLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : WallThickness < SELF\IfcCircleProfileDef.Radius;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCircleHollowProfileDef : IfcCircleProfileDef
	{
		public virtual IfcPositiveLengthMeasure? WallThickness { get; set; }
		public IfcCircleHollowProfileDef() : base()
		{
		}
		public IfcCircleHollowProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Radius, IfcPositiveLengthMeasure WallThickness) : base (ProfileType, ProfileName, Position, Radius)
		{
			this.WallThickness = WallThickness;
		}
	}
	/// <summary>
	/// ENTITY IfcCircleProfileDef
	/// <para>ENTITY IfcCircleProfileDef</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCircleHollowProfileDef))</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCircleProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? Radius { get; set; }
		public IfcCircleProfileDef() : base()
		{
		}
		public IfcCircleProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Radius) : base (ProfileType, ProfileName, Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcCircularArcSegment2D
	/// <para>ENTITY IfcCircularArcSegment2D</para>
	/// <para>SUBTYPE OF (IfcCurveSegment2D);</para>
	/// <para>Radius : IfcPositiveLengthMeasure;</para>
	/// <para>IsCCW : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCircularArcSegment2D : IfcCurveSegment2D
	{
		public virtual IfcPositiveLengthMeasure? Radius { get; set; }
		public virtual IfcBoolean? IsCCW { get; set; }
		public IfcCircularArcSegment2D() : base()
		{
		}
		public IfcCircularArcSegment2D(IfcCartesianPoint StartPoint, IfcPlaneAngleMeasure StartDirection, IfcPositiveLengthMeasure SegmentLength, IfcPositiveLengthMeasure Radius, IfcBoolean IsCCW) : base (StartPoint, StartDirection, SegmentLength)
		{
			this.Radius = Radius;
			this.IsCCW = IsCCW;
		}
	}
	/// <summary>
	/// ENTITY IfcCivilElement
	/// <para>ENTITY IfcCivilElement</para>
	/// <para>SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCivilElement : IfcElement
	{
		public IfcCivilElement() : base()
		{
		}
		public IfcCivilElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCivilElementType
	/// <para>ENTITY IfcCivilElementType</para>
	/// <para>SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCivilElementType : IfcElementType
	{
		public IfcCivilElementType() : base()
		{
		}
		public IfcCivilElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcClassification
	/// <para>ENTITY IfcClassification</para>
	/// <para>SUBTYPE OF (IfcExternalInformation);</para>
	/// <para>Source : OPTIONAL IfcLabel;</para>
	/// <para>Edition : OPTIONAL IfcLabel;</para>
	/// <para>EditionDate : OPTIONAL IfcDate;</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Location : OPTIONAL IfcURIReference;</para>
	/// <para>ReferenceTokens : OPTIONAL LIST [1:?] OF IfcIdentifier;</para>
	/// <para>INVERSE</para>
	/// <para>ClassificationForObjects : SET [0:?] OF IfcRelAssociatesClassification FOR RelatingClassification;</para>
	/// <para>HasReferences : SET [0:?] OF IfcClassificationReference FOR ReferencedSource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcClassification : IfcExternalInformation, IfcClassificationReferenceSelect, IfcClassificationSelect
	{
		public virtual IfcLabel? Source { get; set; }
		public virtual IfcLabel? Edition { get; set; }
		public virtual IfcDate? EditionDate { get; set; }
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcURIReference? Location { get; set; }
		public virtual List<IfcIdentifier>? ReferenceTokens { get; set; }
		//TODO INVERSE
		public List<IfcRelAssociatesClassification>? ClassificationForObjects => Model?.GetItems<IfcRelAssociatesClassification>().Where(x => x.RelatingClassification != null && x.RelatingClassification == this).ToList();
		//TODO INVERSE
		public List<IfcClassificationReference>? HasReferences => Model?.GetItems<IfcClassificationReference>().Where(x => x.ReferencedSource != null && x.ReferencedSource == this).ToList();
		public IfcClassification() : base()
		{
		}
		public IfcClassification(IfcLabel Source, IfcLabel Edition, IfcDate EditionDate, IfcLabel Name, IfcText Description, IfcURIReference Location, List<IfcIdentifier> ReferenceTokens) : base ()
		{
			this.Source = Source;
			this.Edition = Edition;
			this.EditionDate = EditionDate;
			this.Name = Name;
			this.Description = Description;
			this.Location = Location;
			this.ReferenceTokens = ReferenceTokens;
		}
	}
	/// <summary>
	/// ENTITY IfcClassificationReference
	/// <para>ENTITY IfcClassificationReference</para>
	/// <para>SUBTYPE OF (IfcExternalReference);</para>
	/// <para>ReferencedSource : OPTIONAL IfcClassificationReferenceSelect;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Sort : OPTIONAL IfcIdentifier;</para>
	/// <para>INVERSE</para>
	/// <para>ClassificationRefForObjects : SET [0:?] OF IfcRelAssociatesClassification FOR RelatingClassification;</para>
	/// <para>HasReferences : SET [0:?] OF IfcClassificationReference FOR ReferencedSource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcClassificationReference : IfcExternalReference, IfcClassificationReferenceSelect, IfcClassificationSelect
	{
		public virtual IfcClassificationReferenceSelect? ReferencedSource { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcIdentifier? Sort { get; set; }
		//TODO INVERSE
		public List<IfcRelAssociatesClassification>? ClassificationRefForObjects => Model?.GetItems<IfcRelAssociatesClassification>().Where(x => x.RelatingClassification != null && x.RelatingClassification == this).ToList();
		//TODO INVERSE
		public List<IfcClassificationReference>? HasReferences => Model?.GetItems<IfcClassificationReference>().Where(x => x.ReferencedSource != null && x.ReferencedSource == this).ToList();
		public IfcClassificationReference() : base()
		{
		}
		public IfcClassificationReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name, IfcClassificationReferenceSelect ReferencedSource, IfcText Description, IfcIdentifier Sort) : base (Location, Identification, Name)
		{
			this.ReferencedSource = ReferencedSource;
			this.Description = Description;
			this.Sort = Sort;
		}
	}
	/// <summary>
	/// ENTITY IfcClosedShell
	/// <para>ENTITY IfcClosedShell</para>
	/// <para>SUBTYPE OF (IfcConnectedFaceSet);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcClosedShell : IfcConnectedFaceSet, IfcShell, IfcSolidOrShell
	{
		public IfcClosedShell() : base()
		{
		}
		public IfcClosedShell(List<IfcFace> CfsFaces) : base (CfsFaces)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCoil
	/// <para>ENTITY IfcCoil</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcCoilTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCoilTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCoilTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCOILTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoil : IfcEnergyConversionDevice
	{
		public virtual IfcCoilTypeEnum? PredefinedType { get; set; }
		public IfcCoil() : base()
		{
		}
		public IfcCoil(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCoilTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoilType
	/// <para>ENTITY IfcCoilType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcCoilTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCoilTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCoilTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoilType : IfcEnergyConversionDeviceType
	{
		public virtual IfcCoilTypeEnum? PredefinedType { get; set; }
		public IfcCoilType() : base()
		{
		}
		public IfcCoilType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCoilTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcColourRgb
	/// <para>ENTITY IfcColourRgb</para>
	/// <para>SUBTYPE OF (IfcColourSpecification);</para>
	/// <para>Red : IfcNormalisedRatioMeasure;</para>
	/// <para>Green : IfcNormalisedRatioMeasure;</para>
	/// <para>Blue : IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColourRgb : IfcColourSpecification, IfcColourOrFactor
	{
		public virtual IfcNormalisedRatioMeasure? Red { get; set; }
		public virtual IfcNormalisedRatioMeasure? Green { get; set; }
		public virtual IfcNormalisedRatioMeasure? Blue { get; set; }
		public IfcColourRgb() : base()
		{
		}
		public IfcColourRgb(IfcLabel Name, IfcNormalisedRatioMeasure Red, IfcNormalisedRatioMeasure Green, IfcNormalisedRatioMeasure Blue) : base (Name)
		{
			this.Red = Red;
			this.Green = Green;
			this.Blue = Blue;
		}
	}
	/// <summary>
	/// ENTITY IfcColourRgbList
	/// <para>ENTITY IfcColourRgbList</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>ColourList : LIST [1:?] OF LIST [3:3] OF IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColourRgbList : IfcPresentationItem
	{
		public virtual List<List<IfcNormalisedRatioMeasure >>? ColourList { get; set; }
		public IfcColourRgbList() : base()
		{
		}
		public IfcColourRgbList(List<List<IfcNormalisedRatioMeasure >> ColourList) : base ()
		{
			this.ColourList = ColourList;
		}
	}
	/// <summary>
	/// ENTITY IfcColourSpecification
	/// <para>ENTITY IfcColourSpecification</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcColourRgb))</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcColourSpecification : IfcPresentationItem, IfcColour
	{
		public virtual IfcLabel? Name { get; set; }
		public IfcColourSpecification() : base()
		{
		}
		public IfcColourSpecification(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcColumn
	/// <para>ENTITY IfcColumn</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcColumnStandardCase))</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcColumnTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcColumnTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcColumnTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCOLUMNTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColumn : IfcBuildingElement
	{
		public virtual IfcColumnTypeEnum? PredefinedType { get; set; }
		public IfcColumn() : base()
		{
		}
		public IfcColumn(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcColumnTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcColumnStandardCase
	/// <para>ENTITY IfcColumnStandardCase</para>
	/// <para>SUBTYPE OF (IfcColumn);</para>
	/// <para>WHERE</para>
	/// <para>HasMaterialProfileSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4X1.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>('IFC4X1.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>('IFC4X1.IFCMATERIALPROFILESETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColumnStandardCase : IfcColumn
	{
		public IfcColumnStandardCase() : base()
		{
		}
		public IfcColumnStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcColumnTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcColumnType
	/// <para>ENTITY IfcColumnType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcColumnTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcColumnTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcColumnTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcColumnType : IfcBuildingElementType
	{
		public virtual IfcColumnTypeEnum? PredefinedType { get; set; }
		public IfcColumnType() : base()
		{
		}
		public IfcColumnType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcColumnTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCommunicationsAppliance
	/// <para>ENTITY IfcCommunicationsAppliance</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcCommunicationsApplianceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCommunicationsApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCommunicationsApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCOMMUNICATIONSAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCommunicationsAppliance : IfcFlowTerminal
	{
		public virtual IfcCommunicationsApplianceTypeEnum? PredefinedType { get; set; }
		public IfcCommunicationsAppliance() : base()
		{
		}
		public IfcCommunicationsAppliance(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCommunicationsApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCommunicationsApplianceType
	/// <para>ENTITY IfcCommunicationsApplianceType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcCommunicationsApplianceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCommunicationsApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCommunicationsApplianceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCommunicationsApplianceType : IfcFlowTerminalType
	{
		public virtual IfcCommunicationsApplianceTypeEnum? PredefinedType { get; set; }
		public IfcCommunicationsApplianceType() : base()
		{
		}
		public IfcCommunicationsApplianceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCommunicationsApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcComplexProperty
	/// <para>ENTITY IfcComplexProperty</para>
	/// <para>SUBTYPE OF (IfcProperty);</para>
	/// <para>UsageName : IfcIdentifier;</para>
	/// <para>HasProperties : SET [1:?] OF IfcProperty;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : SIZEOF(QUERY(temp <* HasProperties | SELF :=: temp)) = 0;</para>
	/// <para>WR22 : IfcUniquePropertyName(HasProperties);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcComplexProperty : IfcProperty
	{
		public virtual IfcIdentifier? UsageName { get; set; }
		public virtual List<IfcProperty>? HasProperties { get; set; }
		public IfcComplexProperty() : base()
		{
		}
		public IfcComplexProperty(IfcIdentifier Name, IfcText Description, IfcIdentifier UsageName, List<IfcProperty> HasProperties) : base (Name, Description)
		{
			this.UsageName = UsageName;
			this.HasProperties = HasProperties;
		}
	}
	/// <summary>
	/// ENTITY IfcComplexPropertyTemplate
	/// <para>ENTITY IfcComplexPropertyTemplate</para>
	/// <para>SUBTYPE OF (IfcPropertyTemplate);</para>
	/// <para>UsageName : OPTIONAL IfcLabel;</para>
	/// <para>TemplateType : OPTIONAL IfcComplexPropertyTemplateTypeEnum;</para>
	/// <para>HasPropertyTemplates : OPTIONAL SET [1:?] OF IfcPropertyTemplate;</para>
	/// <para>WHERE</para>
	/// <para>UniquePropertyNames : IfcUniquePropertyTemplateNames(HasPropertyTemplates);</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(temp <* HasPropertyTemplates | SELF :=: temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcComplexPropertyTemplate : IfcPropertyTemplate
	{
		public virtual IfcLabel? UsageName { get; set; }
		public virtual IfcComplexPropertyTemplateTypeEnum? TemplateType { get; set; }
		public virtual List<IfcPropertyTemplate>? HasPropertyTemplates { get; set; }
		public IfcComplexPropertyTemplate() : base()
		{
		}
		public IfcComplexPropertyTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel UsageName, IfcComplexPropertyTemplateTypeEnum TemplateType, List<IfcPropertyTemplate> HasPropertyTemplates) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.UsageName = UsageName;
			this.TemplateType = TemplateType;
			this.HasPropertyTemplates = HasPropertyTemplates;
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeCurve
	/// <para>ENTITY IfcCompositeCurve</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCompositeCurveOnSurface))</para>
	/// <para>SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>Segments : LIST [1:?] OF IfcCompositeCurveSegment;</para>
	/// <para>SelfIntersect : IfcLogical;</para>
	/// <para>DERIVE</para>
	/// <para>NSegments : IfcInteger := SIZEOF(Segments);</para>
	/// <para>ClosedCurve : IfcLogical := Segments[NSegments].Transition <> Discontinuous;</para>
	/// <para>WHERE</para>
	/// <para>CurveContinuous : ((NOT ClosedCurve) AND (SIZEOF(QUERY(Temp <* Segments | Temp.Transition = Discontinuous)) = 1)) OR ((ClosedCurve) AND (SIZEOF(QUERY(Temp <* Segments | Temp.Transition = Discontinuous)) = 0));</para>
	/// <para>SameDim : SIZEOF( QUERY( Temp <* Segments | Temp.Dim <> Segments[1].Dim)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeCurve : IfcBoundedCurve
	{
		public virtual List<IfcCompositeCurveSegment>? Segments { get; set; }
		public virtual IfcLogical? SelfIntersect { get; set; }
		//TODO DERIVE
		public virtual IfcInteger? NSegments {get {return null;}}
		//TODO DERIVE
		public virtual IfcLogical? ClosedCurve {get {return null;}}
		public IfcCompositeCurve() : base()
		{
		}
		public IfcCompositeCurve(List<IfcCompositeCurveSegment> Segments, IfcLogical SelfIntersect) : base ()
		{
			this.Segments = Segments;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeCurveOnSurface
	/// <para>ENTITY IfcCompositeCurveOnSurface</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBoundaryCurve))</para>
	/// <para>SUBTYPE OF (IfcCompositeCurve);</para>
	/// <para>DERIVE</para>
	/// <para>BasisSurface : SET [0:1] OF IfcSurface := IfcGetBasisSurface(SELF);</para>
	/// <para>WHERE</para>
	/// <para>SameSurface : SIZEOF(BasisSurface) > 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeCurveOnSurface : IfcCompositeCurve, IfcCurveOnSurface
	{
		//TODO DERIVE
		public virtual List<IfcSurface>? BasisSurface {get {return null;}}
		public IfcCompositeCurveOnSurface() : base()
		{
		}
		public IfcCompositeCurveOnSurface(List<IfcCompositeCurveSegment> Segments, IfcLogical SelfIntersect) : base (Segments, SelfIntersect)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeCurveSegment
	/// <para>ENTITY IfcCompositeCurveSegment</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcReparametrisedCompositeCurveSegment))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Transition : IfcTransitionCode;</para>
	/// <para>SameSense : IfcBoolean;</para>
	/// <para>ParentCurve : IfcCurve;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := ParentCurve.Dim;</para>
	/// <para>INVERSE</para>
	/// <para>UsingCurves : SET [1:?] OF IfcCompositeCurve FOR Segments;</para>
	/// <para>WHERE</para>
	/// <para>ParentIsBoundedCurve : ('IFC4X1.IFCBOUNDEDCURVE' IN TYPEOF(ParentCurve));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeCurveSegment : IfcGeometricRepresentationItem
	{
		public virtual IfcTransitionCode? Transition { get; set; }
		public virtual IfcBoolean? SameSense { get; set; }
		public virtual IfcCurve? ParentCurve { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		//TODO INVERSE
		public List<IfcCompositeCurve>? UsingCurves => Model?.GetItems<IfcCompositeCurve>().Where(x => x.Segments != null && x.Segments.Contains(this)).ToList();
		public IfcCompositeCurveSegment() : base()
		{
		}
		public IfcCompositeCurveSegment(IfcTransitionCode Transition, IfcBoolean SameSense, IfcCurve ParentCurve) : base ()
		{
			this.Transition = Transition;
			this.SameSense = SameSense;
			this.ParentCurve = ParentCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcCompositeProfileDef
	/// <para>ENTITY IfcCompositeProfileDef</para>
	/// <para>SUBTYPE OF (IfcProfileDef);</para>
	/// <para>Profiles : SET [2:?] OF IfcProfileDef;</para>
	/// <para>Label : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>InvariantProfileType : SIZEOF(QUERY(temp <* Profiles | temp.ProfileType <> Profiles[1].ProfileType)) = 0;</para>
	/// <para>NoRecursion : SIZEOF(QUERY(temp <* Profiles | 'IFC4X1.IFCCOMPOSITEPROFILEDEF' IN TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompositeProfileDef : IfcProfileDef
	{
		public virtual List<IfcProfileDef>? Profiles { get; set; }
		public virtual IfcLabel? Label { get; set; }
		public IfcCompositeProfileDef() : base()
		{
		}
		public IfcCompositeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, List<IfcProfileDef> Profiles, IfcLabel Label) : base (ProfileType, ProfileName)
		{
			this.Profiles = Profiles;
			this.Label = Label;
		}
	}
	/// <summary>
	/// ENTITY IfcCompressor
	/// <para>ENTITY IfcCompressor</para>
	/// <para>SUBTYPE OF (IfcFlowMovingDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcCompressorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCompressorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCompressorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCOMPRESSORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompressor : IfcFlowMovingDevice
	{
		public virtual IfcCompressorTypeEnum? PredefinedType { get; set; }
		public IfcCompressor() : base()
		{
		}
		public IfcCompressor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCompressorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCompressorType
	/// <para>ENTITY IfcCompressorType</para>
	/// <para>SUBTYPE OF (IfcFlowMovingDeviceType);</para>
	/// <para>PredefinedType : IfcCompressorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCompressorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCompressorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCompressorType : IfcFlowMovingDeviceType
	{
		public virtual IfcCompressorTypeEnum? PredefinedType { get; set; }
		public IfcCompressorType() : base()
		{
		}
		public IfcCompressorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCompressorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCondenser
	/// <para>ENTITY IfcCondenser</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcCondenserTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCondenserTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCondenserTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCONDENSERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCondenser : IfcEnergyConversionDevice
	{
		public virtual IfcCondenserTypeEnum? PredefinedType { get; set; }
		public IfcCondenser() : base()
		{
		}
		public IfcCondenser(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCondenserTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCondenserType
	/// <para>ENTITY IfcCondenserType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcCondenserTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCondenserTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCondenserTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCondenserType : IfcEnergyConversionDeviceType
	{
		public virtual IfcCondenserTypeEnum? PredefinedType { get; set; }
		public IfcCondenserType() : base()
		{
		}
		public IfcCondenserType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCondenserTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConic
	/// <para>ENTITY IfcConic</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCircle</para>
	/// <para>,IfcEllipse))</para>
	/// <para>SUBTYPE OF (IfcCurve);</para>
	/// <para>Position : IfcAxis2Placement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConic : IfcCurve
	{
		public virtual IfcAxis2Placement? Position { get; set; }
		public IfcConic() : base()
		{
		}
		public IfcConic(IfcAxis2Placement Position) : base ()
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectedFaceSet
	/// <para>ENTITY IfcConnectedFaceSet</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcClosedShell</para>
	/// <para>,IfcOpenShell))</para>
	/// <para>SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>CfsFaces : SET [1:?] OF IfcFace;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectedFaceSet : IfcTopologicalRepresentationItem
	{
		public virtual List<IfcFace>? CfsFaces { get; set; }
		public IfcConnectedFaceSet() : base()
		{
		}
		public IfcConnectedFaceSet(List<IfcFace> CfsFaces) : base ()
		{
			this.CfsFaces = CfsFaces;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionCurveGeometry
	/// <para>ENTITY IfcConnectionCurveGeometry</para>
	/// <para>SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>CurveOnRelatingElement : IfcCurveOrEdgeCurve;</para>
	/// <para>CurveOnRelatedElement : OPTIONAL IfcCurveOrEdgeCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionCurveGeometry : IfcConnectionGeometry
	{
		public virtual IfcCurveOrEdgeCurve? CurveOnRelatingElement { get; set; }
		public virtual IfcCurveOrEdgeCurve? CurveOnRelatedElement { get; set; }
		public IfcConnectionCurveGeometry() : base()
		{
		}
		public IfcConnectionCurveGeometry(IfcCurveOrEdgeCurve CurveOnRelatingElement, IfcCurveOrEdgeCurve CurveOnRelatedElement) : base ()
		{
			this.CurveOnRelatingElement = CurveOnRelatingElement;
			this.CurveOnRelatedElement = CurveOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionGeometry
	/// <para>ENTITY IfcConnectionGeometry</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcConnectionCurveGeometry</para>
	/// <para>,IfcConnectionPointGeometry</para>
	/// <para>,IfcConnectionSurfaceGeometry</para>
	/// <para>,IfcConnectionVolumeGeometry));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConnectionGeometry : Entity
	{
		public IfcConnectionGeometry() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionPointEccentricity
	/// <para>ENTITY IfcConnectionPointEccentricity</para>
	/// <para>SUBTYPE OF (IfcConnectionPointGeometry);</para>
	/// <para>EccentricityInX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>EccentricityInY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>EccentricityInZ : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionPointEccentricity : IfcConnectionPointGeometry
	{
		public virtual IfcLengthMeasure? EccentricityInX { get; set; }
		public virtual IfcLengthMeasure? EccentricityInY { get; set; }
		public virtual IfcLengthMeasure? EccentricityInZ { get; set; }
		public IfcConnectionPointEccentricity() : base()
		{
		}
		public IfcConnectionPointEccentricity(IfcPointOrVertexPoint PointOnRelatingElement, IfcPointOrVertexPoint PointOnRelatedElement, IfcLengthMeasure EccentricityInX, IfcLengthMeasure EccentricityInY, IfcLengthMeasure EccentricityInZ) : base (PointOnRelatingElement, PointOnRelatedElement)
		{
			this.EccentricityInX = EccentricityInX;
			this.EccentricityInY = EccentricityInY;
			this.EccentricityInZ = EccentricityInZ;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionPointGeometry
	/// <para>ENTITY IfcConnectionPointGeometry</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcConnectionPointEccentricity))</para>
	/// <para>SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>PointOnRelatingElement : IfcPointOrVertexPoint;</para>
	/// <para>PointOnRelatedElement : OPTIONAL IfcPointOrVertexPoint;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionPointGeometry : IfcConnectionGeometry
	{
		public virtual IfcPointOrVertexPoint? PointOnRelatingElement { get; set; }
		public virtual IfcPointOrVertexPoint? PointOnRelatedElement { get; set; }
		public IfcConnectionPointGeometry() : base()
		{
		}
		public IfcConnectionPointGeometry(IfcPointOrVertexPoint PointOnRelatingElement, IfcPointOrVertexPoint PointOnRelatedElement) : base ()
		{
			this.PointOnRelatingElement = PointOnRelatingElement;
			this.PointOnRelatedElement = PointOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionSurfaceGeometry
	/// <para>ENTITY IfcConnectionSurfaceGeometry</para>
	/// <para>SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>SurfaceOnRelatingElement : IfcSurfaceOrFaceSurface;</para>
	/// <para>SurfaceOnRelatedElement : OPTIONAL IfcSurfaceOrFaceSurface;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionSurfaceGeometry : IfcConnectionGeometry
	{
		public virtual IfcSurfaceOrFaceSurface? SurfaceOnRelatingElement { get; set; }
		public virtual IfcSurfaceOrFaceSurface? SurfaceOnRelatedElement { get; set; }
		public IfcConnectionSurfaceGeometry() : base()
		{
		}
		public IfcConnectionSurfaceGeometry(IfcSurfaceOrFaceSurface SurfaceOnRelatingElement, IfcSurfaceOrFaceSurface SurfaceOnRelatedElement) : base ()
		{
			this.SurfaceOnRelatingElement = SurfaceOnRelatingElement;
			this.SurfaceOnRelatedElement = SurfaceOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConnectionVolumeGeometry
	/// <para>ENTITY IfcConnectionVolumeGeometry</para>
	/// <para>SUBTYPE OF (IfcConnectionGeometry);</para>
	/// <para>VolumeOnRelatingElement : IfcSolidOrShell;</para>
	/// <para>VolumeOnRelatedElement : OPTIONAL IfcSolidOrShell;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConnectionVolumeGeometry : IfcConnectionGeometry
	{
		public virtual IfcSolidOrShell? VolumeOnRelatingElement { get; set; }
		public virtual IfcSolidOrShell? VolumeOnRelatedElement { get; set; }
		public IfcConnectionVolumeGeometry() : base()
		{
		}
		public IfcConnectionVolumeGeometry(IfcSolidOrShell VolumeOnRelatingElement, IfcSolidOrShell VolumeOnRelatedElement) : base ()
		{
			this.VolumeOnRelatingElement = VolumeOnRelatingElement;
			this.VolumeOnRelatedElement = VolumeOnRelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcConstraint
	/// <para>ENTITY IfcConstraint</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMetric</para>
	/// <para>,IfcObjective));</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>ConstraintGrade : IfcConstraintEnum;</para>
	/// <para>ConstraintSource : OPTIONAL IfcLabel;</para>
	/// <para>CreatingActor : OPTIONAL IfcActorSelect;</para>
	/// <para>CreationTime : OPTIONAL IfcDateTime;</para>
	/// <para>UserDefinedGrade : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>PropertiesForConstraint : SET [0:?] OF IfcResourceConstraintRelationship FOR RelatingConstraint;</para>
	/// <para>WHERE</para>
	/// <para>WR11 : (ConstraintGrade <> IfcConstraintEnum.USERDEFINED) OR</para>
	/// <para>((ConstraintGrade = IfcConstraintEnum.USERDEFINED) AND EXISTS(SELF\IfcConstraint.UserDefinedGrade));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConstraint : Entity, IfcResourceObjectSelect
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcConstraintEnum? ConstraintGrade { get; set; }
		public virtual IfcLabel? ConstraintSource { get; set; }
		public virtual IfcActorSelect? CreatingActor { get; set; }
		public virtual IfcDateTime? CreationTime { get; set; }
		public virtual IfcLabel? UserDefinedGrade { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReferences => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcResourceConstraintRelationship>? PropertiesForConstraint => Model?.GetItems<IfcResourceConstraintRelationship>().Where(x => x.RelatingConstraint != null && x.RelatingConstraint == this).ToList();
		public IfcConstraint() : base()
		{
		}
		public IfcConstraint(IfcLabel Name, IfcText Description, IfcConstraintEnum ConstraintGrade, IfcLabel ConstraintSource, IfcActorSelect CreatingActor, IfcDateTime CreationTime, IfcLabel UserDefinedGrade) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.ConstraintGrade = ConstraintGrade;
			this.ConstraintSource = ConstraintSource;
			this.CreatingActor = CreatingActor;
			this.CreationTime = CreationTime;
			this.UserDefinedGrade = UserDefinedGrade;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionEquipmentResource
	/// <para>ENTITY IfcConstructionEquipmentResource</para>
	/// <para>SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>PredefinedType : OPTIONAL IfcConstructionEquipmentResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionEquipmentResource : IfcConstructionResource
	{
		public virtual IfcConstructionEquipmentResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionEquipmentResource() : base()
		{
		}
		public IfcConstructionEquipmentResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionEquipmentResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionEquipmentResourceType
	/// <para>ENTITY IfcConstructionEquipmentResourceType</para>
	/// <para>SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>PredefinedType : IfcConstructionEquipmentResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionEquipmentResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionEquipmentResourceType : IfcConstructionResourceType
	{
		public virtual IfcConstructionEquipmentResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionEquipmentResourceType() : base()
		{
		}
		public IfcConstructionEquipmentResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionEquipmentResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionMaterialResource
	/// <para>ENTITY IfcConstructionMaterialResource</para>
	/// <para>SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>PredefinedType : OPTIONAL IfcConstructionMaterialResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcConstructionMaterialResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionMaterialResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionMaterialResource : IfcConstructionResource
	{
		public virtual IfcConstructionMaterialResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionMaterialResource() : base()
		{
		}
		public IfcConstructionMaterialResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionMaterialResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionMaterialResourceType
	/// <para>ENTITY IfcConstructionMaterialResourceType</para>
	/// <para>SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>PredefinedType : IfcConstructionMaterialResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcConstructionMaterialResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionMaterialResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionMaterialResourceType : IfcConstructionResourceType
	{
		public virtual IfcConstructionMaterialResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionMaterialResourceType() : base()
		{
		}
		public IfcConstructionMaterialResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionMaterialResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionProductResource
	/// <para>ENTITY IfcConstructionProductResource</para>
	/// <para>SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>PredefinedType : OPTIONAL IfcConstructionProductResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcConstructionProductResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionProductResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionProductResource : IfcConstructionResource
	{
		public virtual IfcConstructionProductResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionProductResource() : base()
		{
		}
		public IfcConstructionProductResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionProductResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionProductResourceType
	/// <para>ENTITY IfcConstructionProductResourceType</para>
	/// <para>SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>PredefinedType : IfcConstructionProductResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcConstructionProductResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcConstructionProductResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConstructionProductResourceType : IfcConstructionResourceType
	{
		public virtual IfcConstructionProductResourceTypeEnum? PredefinedType { get; set; }
		public IfcConstructionProductResourceType() : base()
		{
		}
		public IfcConstructionProductResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcConstructionProductResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionResource
	/// <para>ENTITY IfcConstructionResource</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcConstructionEquipmentResource</para>
	/// <para>,IfcConstructionMaterialResource</para>
	/// <para>,IfcConstructionProductResource</para>
	/// <para>,IfcCrewResource</para>
	/// <para>,IfcLaborResource</para>
	/// <para>,IfcSubContractResource))</para>
	/// <para>SUBTYPE OF (IfcResource);</para>
	/// <para>Usage : OPTIONAL IfcResourceTime;</para>
	/// <para>BaseCosts : OPTIONAL LIST [1:?] OF IfcAppliedValue;</para>
	/// <para>BaseQuantity : OPTIONAL IfcPhysicalQuantity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConstructionResource : IfcResource
	{
		public virtual IfcResourceTime? Usage { get; set; }
		public override List<IfcAppliedValue>? BaseCosts { get; set; }
		public override IfcPhysicalQuantity? BaseQuantity { get; set; }
		public IfcConstructionResource() : base()
		{
		}
		public IfcConstructionResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.Usage = Usage;
			this.BaseCosts = BaseCosts;
			this.BaseQuantity = BaseQuantity;
		}
	}
	/// <summary>
	/// ENTITY IfcConstructionResourceType
	/// <para>ENTITY IfcConstructionResourceType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcConstructionEquipmentResourceType</para>
	/// <para>,IfcConstructionMaterialResourceType</para>
	/// <para>,IfcConstructionProductResourceType</para>
	/// <para>,IfcCrewResourceType</para>
	/// <para>,IfcLaborResourceType</para>
	/// <para>,IfcSubContractResourceType))</para>
	/// <para>SUBTYPE OF (IfcTypeResource);</para>
	/// <para>BaseCosts : OPTIONAL LIST [1:?] OF IfcAppliedValue;</para>
	/// <para>BaseQuantity : OPTIONAL IfcPhysicalQuantity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcConstructionResourceType : IfcTypeResource
	{
		public override List<IfcAppliedValue>? BaseCosts { get; set; }
		public override IfcPhysicalQuantity? BaseQuantity { get; set; }
		public IfcConstructionResourceType() : base()
		{
		}
		public IfcConstructionResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType)
		{
			this.BaseCosts = BaseCosts;
			this.BaseQuantity = BaseQuantity;
		}
	}
	/// <summary>
	/// ENTITY IfcContext
	/// <para>ENTITY IfcContext</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcProject</para>
	/// <para>,IfcProjectLibrary))</para>
	/// <para>SUBTYPE OF (IfcObjectDefinition);</para>
	/// <para>ObjectType : OPTIONAL IfcLabel;</para>
	/// <para>LongName : OPTIONAL IfcLabel;</para>
	/// <para>Phase : OPTIONAL IfcLabel;</para>
	/// <para>RepresentationContexts : OPTIONAL SET [1:?] OF IfcRepresentationContext;</para>
	/// <para>UnitsInContext : OPTIONAL IfcUnitAssignment;</para>
	/// <para>INVERSE</para>
	/// <para>IsDefinedBy : SET [0:?] OF IfcRelDefinesByProperties FOR RelatedObjects;</para>
	/// <para>Declares : SET [0:?] OF IfcRelDeclares FOR RelatingContext;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcContext : IfcObjectDefinition
	{
		public virtual IfcLabel? ObjectType { get; set; }
		public virtual IfcLabel? LongName { get; set; }
		public virtual IfcLabel? Phase { get; set; }
		public virtual List<IfcRepresentationContext>? RepresentationContexts { get; set; }
		public virtual IfcUnitAssignment? UnitsInContext { get; set; }
		//TODO INVERSE
		public List<IfcRelDefinesByProperties>? IsDefinedBy => Model?.GetItems<IfcRelDefinesByProperties>().Where(x => x.RelatedObjects != null && x.RelatedObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelDeclares>? Declares => Model?.GetItems<IfcRelDeclares>().Where(x => x.RelatingContext != null && x.RelatingContext == this).ToList();
		public IfcContext() : base()
		{
		}
		public IfcContext(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcLabel Phase, List<IfcRepresentationContext> RepresentationContexts, IfcUnitAssignment UnitsInContext) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ObjectType = ObjectType;
			this.LongName = LongName;
			this.Phase = Phase;
			this.RepresentationContexts = RepresentationContexts;
			this.UnitsInContext = UnitsInContext;
		}
	}
	/// <summary>
	/// ENTITY IfcContextDependentUnit
	/// <para>ENTITY IfcContextDependentUnit</para>
	/// <para>SUBTYPE OF (IfcNamedUnit);</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcContextDependentUnit : IfcNamedUnit, IfcResourceObjectSelect
	{
		public virtual IfcLabel? Name { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReference => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		public IfcContextDependentUnit() : base()
		{
		}
		public IfcContextDependentUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcLabel Name) : base (Dimensions, UnitType)
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcControl
	/// <para>ENTITY IfcControl</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcActionRequest</para>
	/// <para>,IfcCostItem</para>
	/// <para>,IfcCostSchedule</para>
	/// <para>,IfcPerformanceHistory</para>
	/// <para>,IfcPermit</para>
	/// <para>,IfcProjectOrder</para>
	/// <para>,IfcWorkCalendar</para>
	/// <para>,IfcWorkControl))</para>
	/// <para>SUBTYPE OF (IfcObject);</para>
	/// <para>Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>INVERSE</para>
	/// <para>Controls : SET [0:?] OF IfcRelAssignsToControl FOR RelatingControl;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcControl : IfcObject
	{
		public virtual IfcIdentifier? Identification { get; set; }
		//TODO INVERSE
		public List<IfcRelAssignsToControl>? Controls => Model?.GetItems<IfcRelAssignsToControl>().Where(x => x.RelatingControl != null && x.RelatingControl == this).ToList();
		public IfcControl() : base()
		{
		}
		public IfcControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
		}
	}
	/// <summary>
	/// ENTITY IfcController
	/// <para>ENTITY IfcController</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcControllerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcControllerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcControllerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCONTROLLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcController : IfcDistributionControlElement
	{
		public virtual IfcControllerTypeEnum? PredefinedType { get; set; }
		public IfcController() : base()
		{
		}
		public IfcController(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcControllerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcControllerType
	/// <para>ENTITY IfcControllerType</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>PredefinedType : IfcControllerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcControllerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcControllerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcControllerType : IfcDistributionControlElementType
	{
		public virtual IfcControllerTypeEnum? PredefinedType { get; set; }
		public IfcControllerType() : base()
		{
		}
		public IfcControllerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcControllerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcConversionBasedUnit
	/// <para>ENTITY IfcConversionBasedUnit</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcConversionBasedUnitWithOffset))</para>
	/// <para>SUBTYPE OF (IfcNamedUnit);</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>ConversionFactor : IfcMeasureWithUnit;</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConversionBasedUnit : IfcNamedUnit, IfcResourceObjectSelect
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcMeasureWithUnit? ConversionFactor { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReference => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		public IfcConversionBasedUnit() : base()
		{
		}
		public IfcConversionBasedUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcLabel Name, IfcMeasureWithUnit ConversionFactor) : base (Dimensions, UnitType)
		{
			this.Name = Name;
			this.ConversionFactor = ConversionFactor;
		}
	}
	/// <summary>
	/// ENTITY IfcConversionBasedUnitWithOffset
	/// <para>ENTITY IfcConversionBasedUnitWithOffset</para>
	/// <para>SUBTYPE OF (IfcConversionBasedUnit);</para>
	/// <para>ConversionOffset : IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcConversionBasedUnitWithOffset : IfcConversionBasedUnit
	{
		public virtual IfcReal? ConversionOffset { get; set; }
		public IfcConversionBasedUnitWithOffset() : base()
		{
		}
		public IfcConversionBasedUnitWithOffset(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcLabel Name, IfcMeasureWithUnit ConversionFactor, IfcReal ConversionOffset) : base (Dimensions, UnitType, Name, ConversionFactor)
		{
			this.ConversionOffset = ConversionOffset;
		}
	}
	/// <summary>
	/// ENTITY IfcCooledBeam
	/// <para>ENTITY IfcCooledBeam</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcCooledBeamTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCooledBeamTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCooledBeamTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCOOLEDBEAMTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCooledBeam : IfcEnergyConversionDevice
	{
		public virtual IfcCooledBeamTypeEnum? PredefinedType { get; set; }
		public IfcCooledBeam() : base()
		{
		}
		public IfcCooledBeam(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCooledBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCooledBeamType
	/// <para>ENTITY IfcCooledBeamType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcCooledBeamTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCooledBeamTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCooledBeamTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCooledBeamType : IfcEnergyConversionDeviceType
	{
		public virtual IfcCooledBeamTypeEnum? PredefinedType { get; set; }
		public IfcCooledBeamType() : base()
		{
		}
		public IfcCooledBeamType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCooledBeamTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoolingTower
	/// <para>ENTITY IfcCoolingTower</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcCoolingTowerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCoolingTowerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCoolingTowerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCOOLINGTOWERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoolingTower : IfcEnergyConversionDevice
	{
		public virtual IfcCoolingTowerTypeEnum? PredefinedType { get; set; }
		public IfcCoolingTower() : base()
		{
		}
		public IfcCoolingTower(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCoolingTowerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoolingTowerType
	/// <para>ENTITY IfcCoolingTowerType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcCoolingTowerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCoolingTowerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCoolingTowerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoolingTowerType : IfcEnergyConversionDeviceType
	{
		public virtual IfcCoolingTowerTypeEnum? PredefinedType { get; set; }
		public IfcCoolingTowerType() : base()
		{
		}
		public IfcCoolingTowerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCoolingTowerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoordinateOperation
	/// <para>ENTITY IfcCoordinateOperation</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMapConversion));</para>
	/// <para>SourceCRS : IfcCoordinateReferenceSystemSelect;</para>
	/// <para>TargetCRS : IfcCoordinateReferenceSystem;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCoordinateOperation : Entity
	{
		public virtual IfcCoordinateReferenceSystemSelect? SourceCRS { get; set; }
		public virtual IfcCoordinateReferenceSystem? TargetCRS { get; set; }
		public IfcCoordinateOperation() : base()
		{
		}
		public IfcCoordinateOperation(IfcCoordinateReferenceSystemSelect SourceCRS, IfcCoordinateReferenceSystem TargetCRS) : base ()
		{
			this.SourceCRS = SourceCRS;
			this.TargetCRS = TargetCRS;
		}
	}
	/// <summary>
	/// ENTITY IfcCoordinateReferenceSystem
	/// <para>ENTITY IfcCoordinateReferenceSystem</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcProjectedCRS));</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>GeodeticDatum : OPTIONAL IfcIdentifier;</para>
	/// <para>VerticalDatum : OPTIONAL IfcIdentifier;</para>
	/// <para>INVERSE</para>
	/// <para>HasCoordinateOperation : SET [0:1] OF IfcCoordinateOperation FOR SourceCRS;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCoordinateReferenceSystem : Entity, IfcCoordinateReferenceSystemSelect
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcIdentifier? GeodeticDatum { get; set; }
		public virtual IfcIdentifier? VerticalDatum { get; set; }
		//TODO INVERSE
		public List<IfcCoordinateOperation>? HasCoordinateOperation => Model?.GetItems<IfcCoordinateOperation>().Where(x => x.SourceCRS != null && x.SourceCRS == this).ToList();
		public IfcCoordinateReferenceSystem() : base()
		{
		}
		public IfcCoordinateReferenceSystem(IfcLabel Name, IfcText Description, IfcIdentifier GeodeticDatum, IfcIdentifier VerticalDatum) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.GeodeticDatum = GeodeticDatum;
			this.VerticalDatum = VerticalDatum;
		}
	}
	/// <summary>
	/// ENTITY IfcCostItem
	/// <para>ENTITY IfcCostItem</para>
	/// <para>SUBTYPE OF (IfcControl);</para>
	/// <para>PredefinedType : OPTIONAL IfcCostItemTypeEnum;</para>
	/// <para>CostValues : OPTIONAL LIST [1:?] OF IfcCostValue;</para>
	/// <para>CostQuantities : OPTIONAL LIST [1:?] OF IfcPhysicalQuantity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCostItem : IfcControl
	{
		public virtual IfcCostItemTypeEnum? PredefinedType { get; set; }
		public virtual List<IfcCostValue>? CostValues { get; set; }
		public virtual List<IfcPhysicalQuantity>? CostQuantities { get; set; }
		public IfcCostItem() : base()
		{
		}
		public IfcCostItem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcCostItemTypeEnum PredefinedType, List<IfcCostValue> CostValues, List<IfcPhysicalQuantity> CostQuantities) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.CostValues = CostValues;
			this.CostQuantities = CostQuantities;
		}
	}
	/// <summary>
	/// ENTITY IfcCostSchedule
	/// <para>ENTITY IfcCostSchedule</para>
	/// <para>SUBTYPE OF (IfcControl);</para>
	/// <para>PredefinedType : OPTIONAL IfcCostScheduleTypeEnum;</para>
	/// <para>Status : OPTIONAL IfcLabel;</para>
	/// <para>SubmittedOn : OPTIONAL IfcDateTime;</para>
	/// <para>UpdateDate : OPTIONAL IfcDateTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCostSchedule : IfcControl
	{
		public virtual IfcCostScheduleTypeEnum? PredefinedType { get; set; }
		public virtual IfcLabel? Status { get; set; }
		public virtual IfcDateTime? SubmittedOn { get; set; }
		public virtual IfcDateTime? UpdateDate { get; set; }
		public IfcCostSchedule() : base()
		{
		}
		public IfcCostSchedule(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcCostScheduleTypeEnum PredefinedType, IfcLabel Status, IfcDateTime SubmittedOn, IfcDateTime UpdateDate) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.SubmittedOn = SubmittedOn;
			this.UpdateDate = UpdateDate;
		}
	}
	/// <summary>
	/// ENTITY IfcCostValue
	/// <para>ENTITY IfcCostValue</para>
	/// <para>SUBTYPE OF (IfcAppliedValue);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCostValue : IfcAppliedValue
	{
		public IfcCostValue() : base()
		{
		}
		public IfcCostValue(IfcLabel Name, IfcText Description, IfcAppliedValueSelect AppliedValue, IfcMeasureWithUnit UnitBasis, IfcDate ApplicableDate, IfcDate FixedUntilDate, IfcLabel Category, IfcLabel Condition, IfcArithmeticOperatorEnum ArithmeticOperator, List<IfcAppliedValue> Components) : base (Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCovering
	/// <para>ENTITY IfcCovering</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcCoveringTypeEnum;</para>
	/// <para>INVERSE</para>
	/// <para>CoversSpaces : SET [0:1] OF IfcRelCoversSpaces FOR RelatedCoverings;</para>
	/// <para>CoversElements : SET [0:1] OF IfcRelCoversBldgElements FOR RelatedCoverings;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCoveringTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCoveringTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCOVERINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCovering : IfcBuildingElement
	{
		public virtual IfcCoveringTypeEnum? PredefinedType { get; set; }
		//TODO INVERSE
		public List<IfcRelCoversSpaces>? CoversSpaces => Model?.GetItems<IfcRelCoversSpaces>().Where(x => x.RelatedCoverings != null && x.RelatedCoverings.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelCoversBldgElements>? CoversElements => Model?.GetItems<IfcRelCoversBldgElements>().Where(x => x.RelatedCoverings != null && x.RelatedCoverings.Contains(this)).ToList();
		public IfcCovering() : base()
		{
		}
		public IfcCovering(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCoveringTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCoveringType
	/// <para>ENTITY IfcCoveringType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcCoveringTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCoveringTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCoveringTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCoveringType : IfcBuildingElementType
	{
		public virtual IfcCoveringTypeEnum? PredefinedType { get; set; }
		public IfcCoveringType() : base()
		{
		}
		public IfcCoveringType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCoveringTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCrewResource
	/// <para>ENTITY IfcCrewResource</para>
	/// <para>SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>PredefinedType : OPTIONAL IfcCrewResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCrewResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCrewResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCrewResource : IfcConstructionResource
	{
		public virtual IfcCrewResourceTypeEnum? PredefinedType { get; set; }
		public IfcCrewResource() : base()
		{
		}
		public IfcCrewResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcCrewResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCrewResourceType
	/// <para>ENTITY IfcCrewResourceType</para>
	/// <para>SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>PredefinedType : IfcCrewResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCrewResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCrewResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCrewResourceType : IfcConstructionResourceType
	{
		public virtual IfcCrewResourceTypeEnum? PredefinedType { get; set; }
		public IfcCrewResourceType() : base()
		{
		}
		public IfcCrewResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcCrewResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCsgPrimitive3D
	/// <para>ENTITY IfcCsgPrimitive3D</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBlock</para>
	/// <para>,IfcRectangularPyramid</para>
	/// <para>,IfcRightCircularCone</para>
	/// <para>,IfcRightCircularCylinder</para>
	/// <para>,IfcSphere))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Position : IfcAxis2Placement3D;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCsgPrimitive3D : IfcGeometricRepresentationItem, IfcBooleanOperand, IfcCsgSelect
	{
		public virtual IfcAxis2Placement3D? Position { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcCsgPrimitive3D() : base()
		{
		}
		public IfcCsgPrimitive3D(IfcAxis2Placement3D Position) : base ()
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcCsgSolid
	/// <para>ENTITY IfcCsgSolid</para>
	/// <para>SUBTYPE OF (IfcSolidModel);</para>
	/// <para>TreeRootExpression : IfcCsgSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCsgSolid : IfcSolidModel
	{
		public virtual IfcCsgSelect? TreeRootExpression { get; set; }
		public IfcCsgSolid() : base()
		{
		}
		public IfcCsgSolid(IfcCsgSelect TreeRootExpression) : base ()
		{
			this.TreeRootExpression = TreeRootExpression;
		}
	}
	/// <summary>
	/// ENTITY IfcCurrencyRelationship
	/// <para>ENTITY IfcCurrencyRelationship</para>
	/// <para>SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>RelatingMonetaryUnit : IfcMonetaryUnit;</para>
	/// <para>RelatedMonetaryUnit : IfcMonetaryUnit;</para>
	/// <para>ExchangeRate : IfcPositiveRatioMeasure;</para>
	/// <para>RateDateTime : OPTIONAL IfcDateTime;</para>
	/// <para>RateSource : OPTIONAL IfcLibraryInformation;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurrencyRelationship : IfcResourceLevelRelationship
	{
		public virtual IfcMonetaryUnit? RelatingMonetaryUnit { get; set; }
		public virtual IfcMonetaryUnit? RelatedMonetaryUnit { get; set; }
		public virtual IfcPositiveRatioMeasure? ExchangeRate { get; set; }
		public virtual IfcDateTime? RateDateTime { get; set; }
		public virtual IfcLibraryInformation? RateSource { get; set; }
		public IfcCurrencyRelationship() : base()
		{
		}
		public IfcCurrencyRelationship(IfcLabel Name, IfcText Description, IfcMonetaryUnit RelatingMonetaryUnit, IfcMonetaryUnit RelatedMonetaryUnit, IfcPositiveRatioMeasure ExchangeRate, IfcDateTime RateDateTime, IfcLibraryInformation RateSource) : base (Name, Description)
		{
			this.RelatingMonetaryUnit = RelatingMonetaryUnit;
			this.RelatedMonetaryUnit = RelatedMonetaryUnit;
			this.ExchangeRate = ExchangeRate;
			this.RateDateTime = RateDateTime;
			this.RateSource = RateSource;
		}
	}
	/// <summary>
	/// ENTITY IfcCurtainWall
	/// <para>ENTITY IfcCurtainWall</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcCurtainWallTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcCurtainWallTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCurtainWallTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCCURTAINWALLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurtainWall : IfcBuildingElement
	{
		public virtual IfcCurtainWallTypeEnum? PredefinedType { get; set; }
		public IfcCurtainWall() : base()
		{
		}
		public IfcCurtainWall(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcCurtainWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCurtainWallType
	/// <para>ENTITY IfcCurtainWallType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcCurtainWallTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcCurtainWallTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcCurtainWallTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurtainWallType : IfcBuildingElementType
	{
		public virtual IfcCurtainWallTypeEnum? PredefinedType { get; set; }
		public IfcCurtainWallType() : base()
		{
		}
		public IfcCurtainWallType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcCurtainWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcCurve
	/// <para>ENTITY IfcCurve</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBoundedCurve</para>
	/// <para>,IfcConic</para>
	/// <para>,IfcLine</para>
	/// <para>,IfcOffsetCurve</para>
	/// <para>,IfcPcurve</para>
	/// <para>,IfcSurfaceCurve))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := IfcCurveDim(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCurve : IfcGeometricRepresentationItem, IfcGeometricSetSelect
	{
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcCurve() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcCurveBoundedPlane
	/// <para>ENTITY IfcCurveBoundedPlane</para>
	/// <para>SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>BasisSurface : IfcPlane;</para>
	/// <para>OuterBoundary : IfcCurve;</para>
	/// <para>InnerBoundaries : SET [0:?] OF IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveBoundedPlane : IfcBoundedSurface
	{
		public virtual IfcPlane? BasisSurface { get; set; }
		public virtual IfcCurve? OuterBoundary { get; set; }
		public virtual List<IfcCurve>? InnerBoundaries { get; set; }
		public IfcCurveBoundedPlane() : base()
		{
		}
		public IfcCurveBoundedPlane(IfcPlane BasisSurface, IfcCurve OuterBoundary, List<IfcCurve> InnerBoundaries) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.OuterBoundary = OuterBoundary;
			this.InnerBoundaries = InnerBoundaries;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveBoundedSurface
	/// <para>ENTITY IfcCurveBoundedSurface</para>
	/// <para>SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>BasisSurface : IfcSurface;</para>
	/// <para>Boundaries : SET [1:?] OF IfcBoundaryCurve;</para>
	/// <para>ImplicitOuter : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveBoundedSurface : IfcBoundedSurface
	{
		public virtual IfcSurface? BasisSurface { get; set; }
		public virtual List<IfcBoundaryCurve>? Boundaries { get; set; }
		public virtual IfcBoolean? ImplicitOuter { get; set; }
		public IfcCurveBoundedSurface() : base()
		{
		}
		public IfcCurveBoundedSurface(IfcSurface BasisSurface, List<IfcBoundaryCurve> Boundaries, IfcBoolean ImplicitOuter) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.Boundaries = Boundaries;
			this.ImplicitOuter = ImplicitOuter;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveSegment2D
	/// <para>ENTITY IfcCurveSegment2D</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCircularArcSegment2D</para>
	/// <para>,IfcLineSegment2D</para>
	/// <para>,IfcTransitionCurveSegment2D))</para>
	/// <para>SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>StartPoint : IfcCartesianPoint;</para>
	/// <para>StartDirection : IfcPlaneAngleMeasure;</para>
	/// <para>SegmentLength : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcCurveSegment2D : IfcBoundedCurve
	{
		public virtual IfcCartesianPoint? StartPoint { get; set; }
		public virtual IfcPlaneAngleMeasure? StartDirection { get; set; }
		public virtual IfcPositiveLengthMeasure? SegmentLength { get; set; }
		public IfcCurveSegment2D() : base()
		{
		}
		public IfcCurveSegment2D(IfcCartesianPoint StartPoint, IfcPlaneAngleMeasure StartDirection, IfcPositiveLengthMeasure SegmentLength) : base ()
		{
			this.StartPoint = StartPoint;
			this.StartDirection = StartDirection;
			this.SegmentLength = SegmentLength;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyle
	/// <para>ENTITY IfcCurveStyle</para>
	/// <para>SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>CurveFont : OPTIONAL IfcCurveFontOrScaledCurveFontSelect;</para>
	/// <para>CurveWidth : OPTIONAL IfcSizeSelect;</para>
	/// <para>CurveColour : OPTIONAL IfcColour;</para>
	/// <para>ModelOrDraughting : OPTIONAL IfcBoolean;</para>
	/// <para>WHERE</para>
	/// <para>MeasureOfWidth : (NOT(EXISTS(CurveWidth))) OR</para>
	/// <para>('IFC4X1.IFCPOSITIVELENGTHMEASURE' IN TYPEOF(CurveWidth)) OR</para>
	/// <para>(('IFC4X1.IFCDESCRIPTIVEMEASURE' IN TYPEOF(CurveWidth)) AND</para>
	/// <para>(CurveWidth = 'by layer'));</para>
	/// <para>IdentifiableCurveStyle : EXISTS(CurveFont) OR EXISTS(CurveWidth) OR EXISTS(CurveColour);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyle : IfcPresentationStyle, IfcPresentationStyleSelect
	{
		public virtual IfcCurveFontOrScaledCurveFontSelect? CurveFont { get; set; }
		public virtual IfcSizeSelect? CurveWidth { get; set; }
		public virtual IfcColour? CurveColour { get; set; }
		public virtual IfcBoolean? ModelOrDraughting { get; set; }
		public IfcCurveStyle() : base()
		{
		}
		public IfcCurveStyle(IfcLabel Name, IfcCurveFontOrScaledCurveFontSelect CurveFont, IfcSizeSelect CurveWidth, IfcColour CurveColour, IfcBoolean ModelOrDraughting) : base (Name)
		{
			this.CurveFont = CurveFont;
			this.CurveWidth = CurveWidth;
			this.CurveColour = CurveColour;
			this.ModelOrDraughting = ModelOrDraughting;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyleFont
	/// <para>ENTITY IfcCurveStyleFont</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>PatternList : LIST [1:?] OF IfcCurveStyleFontPattern;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyleFont : IfcPresentationItem, IfcCurveStyleFontSelect
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual List<IfcCurveStyleFontPattern>? PatternList { get; set; }
		public IfcCurveStyleFont() : base()
		{
		}
		public IfcCurveStyleFont(IfcLabel Name, List<IfcCurveStyleFontPattern> PatternList) : base ()
		{
			this.Name = Name;
			this.PatternList = PatternList;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyleFontAndScaling
	/// <para>ENTITY IfcCurveStyleFontAndScaling</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>CurveFont : IfcCurveStyleFontSelect;</para>
	/// <para>CurveFontScaling : IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyleFontAndScaling : IfcPresentationItem, IfcCurveFontOrScaledCurveFontSelect
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcCurveStyleFontSelect? CurveFont { get; set; }
		public virtual IfcPositiveRatioMeasure? CurveFontScaling { get; set; }
		public IfcCurveStyleFontAndScaling() : base()
		{
		}
		public IfcCurveStyleFontAndScaling(IfcLabel Name, IfcCurveStyleFontSelect CurveFont, IfcPositiveRatioMeasure CurveFontScaling) : base ()
		{
			this.Name = Name;
			this.CurveFont = CurveFont;
			this.CurveFontScaling = CurveFontScaling;
		}
	}
	/// <summary>
	/// ENTITY IfcCurveStyleFontPattern
	/// <para>ENTITY IfcCurveStyleFontPattern</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>VisibleSegmentLength : IfcLengthMeasure;</para>
	/// <para>InvisibleSegmentLength : IfcPositiveLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>VisibleLengthGreaterEqualZero : VisibleSegmentLength >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCurveStyleFontPattern : IfcPresentationItem
	{
		public virtual IfcLengthMeasure? VisibleSegmentLength { get; set; }
		public virtual IfcPositiveLengthMeasure? InvisibleSegmentLength { get; set; }
		public IfcCurveStyleFontPattern() : base()
		{
		}
		public IfcCurveStyleFontPattern(IfcLengthMeasure VisibleSegmentLength, IfcPositiveLengthMeasure InvisibleSegmentLength) : base ()
		{
			this.VisibleSegmentLength = VisibleSegmentLength;
			this.InvisibleSegmentLength = InvisibleSegmentLength;
		}
	}
	/// <summary>
	/// ENTITY IfcCylindricalSurface
	/// <para>ENTITY IfcCylindricalSurface</para>
	/// <para>SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcCylindricalSurface : IfcElementarySurface
	{
		public virtual IfcPositiveLengthMeasure? Radius { get; set; }
		public IfcCylindricalSurface() : base()
		{
		}
		public IfcCylindricalSurface(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcDamper
	/// <para>ENTITY IfcDamper</para>
	/// <para>SUBTYPE OF (IfcFlowController);</para>
	/// <para>PredefinedType : OPTIONAL IfcDamperTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcDamperTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDamperTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCDAMPERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDamper : IfcFlowController
	{
		public virtual IfcDamperTypeEnum? PredefinedType { get; set; }
		public IfcDamper() : base()
		{
		}
		public IfcDamper(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDamperTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDamperType
	/// <para>ENTITY IfcDamperType</para>
	/// <para>SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>PredefinedType : IfcDamperTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcDamperTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDamperTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDamperType : IfcFlowControllerType
	{
		public virtual IfcDamperTypeEnum? PredefinedType { get; set; }
		public IfcDamperType() : base()
		{
		}
		public IfcDamperType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDamperTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDerivedProfileDef
	/// <para>ENTITY IfcDerivedProfileDef</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMirroredProfileDef))</para>
	/// <para>SUBTYPE OF (IfcProfileDef);</para>
	/// <para>ParentProfile : IfcProfileDef;</para>
	/// <para>Operator : IfcCartesianTransformationOperator2D;</para>
	/// <para>Label : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>InvariantProfileType : SELF\IfcProfileDef.ProfileType = ParentProfile.ProfileType;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDerivedProfileDef : IfcProfileDef
	{
		public virtual IfcProfileDef? ParentProfile { get; set; }
		public virtual IfcCartesianTransformationOperator2D? Operator { get; set; }
		public virtual IfcLabel? Label { get; set; }
		public IfcDerivedProfileDef() : base()
		{
		}
		public IfcDerivedProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcProfileDef ParentProfile, IfcCartesianTransformationOperator2D Operator, IfcLabel Label) : base (ProfileType, ProfileName)
		{
			this.ParentProfile = ParentProfile;
			this.Operator = Operator;
			this.Label = Label;
		}
	}
	/// <summary>
	/// ENTITY IfcDerivedUnit;
	/// <para>ENTITY IfcDerivedUnit;</para>
	/// <para>Elements : SET [1:?] OF IfcDerivedUnitElement;</para>
	/// <para>UnitType : IfcDerivedUnitEnum;</para>
	/// <para>UserDefinedType : OPTIONAL IfcLabel;</para>
	/// <para>DERIVE</para>
	/// <para>Dimensions : IfcDimensionalExponents := IfcDeriveDimensionalExponents(Elements);</para>
	/// <para>WHERE</para>
	/// <para>WR1 : (SIZEOF (Elements) > 1) OR ((SIZEOF (Elements) = 1) AND (Elements[1].Exponent <> 1 ));</para>
	/// <para>WR2 : (UnitType <> IfcDerivedUnitEnum.USERDEFINED) OR</para>
	/// <para>((UnitType = IfcDerivedUnitEnum.USERDEFINED) AND</para>
	/// <para>(EXISTS(SELF.UserDefinedType)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDerivedUnit : Entity, IfcUnit
	{
		public virtual List<IfcDerivedUnitElement>? Elements { get; set; }
		public virtual IfcDerivedUnitEnum? UnitType { get; set; }
		public virtual IfcLabel? UserDefinedType { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionalExponents? Dimensions {get {return null;}}
		public IfcDerivedUnit() : base()
		{
		}
		public IfcDerivedUnit(List<IfcDerivedUnitElement> Elements, IfcDerivedUnitEnum UnitType, IfcLabel UserDefinedType) : base ()
		{
			this.Elements = Elements;
			this.UnitType = UnitType;
			this.UserDefinedType = UserDefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDerivedUnitElement;
	/// <para>ENTITY IfcDerivedUnitElement;</para>
	/// <para>Unit : IfcNamedUnit;</para>
	/// <para>Exponent : INTEGER;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDerivedUnitElement : Entity
	{
		public virtual IfcNamedUnit? Unit { get; set; }
		public virtual INTEGER? Exponent { get; set; }
		public IfcDerivedUnitElement() : base()
		{
		}
		public IfcDerivedUnitElement(IfcNamedUnit Unit, INTEGER Exponent) : base ()
		{
			this.Unit = Unit;
			this.Exponent = Exponent;
		}
	}
	/// <summary>
	/// ENTITY IfcDimensionalExponents;
	/// <para>ENTITY IfcDimensionalExponents;</para>
	/// <para>LengthExponent : INTEGER;</para>
	/// <para>MassExponent : INTEGER;</para>
	/// <para>TimeExponent : INTEGER;</para>
	/// <para>ElectricCurrentExponent : INTEGER;</para>
	/// <para>ThermodynamicTemperatureExponent : INTEGER;</para>
	/// <para>AmountOfSubstanceExponent : INTEGER;</para>
	/// <para>LuminousIntensityExponent : INTEGER;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDimensionalExponents : Entity
	{
		public virtual INTEGER? LengthExponent { get; set; }
		public virtual INTEGER? MassExponent { get; set; }
		public virtual INTEGER? TimeExponent { get; set; }
		public virtual INTEGER? ElectricCurrentExponent { get; set; }
		public virtual INTEGER? ThermodynamicTemperatureExponent { get; set; }
		public virtual INTEGER? AmountOfSubstanceExponent { get; set; }
		public virtual INTEGER? LuminousIntensityExponent { get; set; }
		public IfcDimensionalExponents() : base()
		{
		}
		public IfcDimensionalExponents(INTEGER LengthExponent, INTEGER MassExponent, INTEGER TimeExponent, INTEGER ElectricCurrentExponent, INTEGER ThermodynamicTemperatureExponent, INTEGER AmountOfSubstanceExponent, INTEGER LuminousIntensityExponent) : base ()
		{
			this.LengthExponent = LengthExponent;
			this.MassExponent = MassExponent;
			this.TimeExponent = TimeExponent;
			this.ElectricCurrentExponent = ElectricCurrentExponent;
			this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent;
			this.AmountOfSubstanceExponent = AmountOfSubstanceExponent;
			this.LuminousIntensityExponent = LuminousIntensityExponent;
		}
	}
	/// <summary>
	/// ENTITY IfcDirection
	/// <para>ENTITY IfcDirection</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>DirectionRatios : LIST [2:3] OF IfcReal;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := HIINDEX(DirectionRatios);</para>
	/// <para>WHERE</para>
	/// <para>MagnitudeGreaterZero : SIZEOF(QUERY(Tmp <* DirectionRatios | Tmp <> 0.0)) > 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDirection : IfcGeometricRepresentationItem, IfcGridPlacementDirectionSelect, IfcVectorOrDirection
	{
		public virtual List<IfcReal>? DirectionRatios { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcDirection() : base()
		{
		}
		public IfcDirection(List<IfcReal> DirectionRatios) : base ()
		{
			this.DirectionRatios = DirectionRatios;
		}
	}
	/// <summary>
	/// ENTITY IfcDiscreteAccessory
	/// <para>ENTITY IfcDiscreteAccessory</para>
	/// <para>SUBTYPE OF (IfcElementComponent);</para>
	/// <para>PredefinedType : OPTIONAL IfcDiscreteAccessoryTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcDiscreteAccessoryTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDiscreteAccessoryTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCDISCRETEACCESSORYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDiscreteAccessory : IfcElementComponent
	{
		public virtual IfcDiscreteAccessoryTypeEnum? PredefinedType { get; set; }
		public IfcDiscreteAccessory() : base()
		{
		}
		public IfcDiscreteAccessory(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDiscreteAccessoryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDiscreteAccessoryType
	/// <para>ENTITY IfcDiscreteAccessoryType</para>
	/// <para>SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>PredefinedType : IfcDiscreteAccessoryTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcDiscreteAccessoryTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDiscreteAccessoryTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDiscreteAccessoryType : IfcElementComponentType
	{
		public virtual IfcDiscreteAccessoryTypeEnum? PredefinedType { get; set; }
		public IfcDiscreteAccessoryType() : base()
		{
		}
		public IfcDiscreteAccessoryType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDiscreteAccessoryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistanceExpression
	/// <para>ENTITY IfcDistanceExpression</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>DistanceAlong : IfcLengthMeasure;</para>
	/// <para>OffsetLateral : OPTIONAL IfcLengthMeasure;</para>
	/// <para>OffsetVertical : OPTIONAL IfcLengthMeasure;</para>
	/// <para>OffsetLongitudinal : OPTIONAL IfcLengthMeasure;</para>
	/// <para>AlongHorizontal : OPTIONAL IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistanceExpression : IfcGeometricRepresentationItem
	{
		public virtual IfcLengthMeasure? DistanceAlong { get; set; }
		public virtual IfcLengthMeasure? OffsetLateral { get; set; }
		public virtual IfcLengthMeasure? OffsetVertical { get; set; }
		public virtual IfcLengthMeasure? OffsetLongitudinal { get; set; }
		public virtual IfcBoolean? AlongHorizontal { get; set; }
		public IfcDistanceExpression() : base()
		{
		}
		public IfcDistanceExpression(IfcLengthMeasure DistanceAlong, IfcLengthMeasure OffsetLateral, IfcLengthMeasure OffsetVertical, IfcLengthMeasure OffsetLongitudinal, IfcBoolean AlongHorizontal) : base ()
		{
			this.DistanceAlong = DistanceAlong;
			this.OffsetLateral = OffsetLateral;
			this.OffsetVertical = OffsetVertical;
			this.OffsetLongitudinal = OffsetLongitudinal;
			this.AlongHorizontal = AlongHorizontal;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionChamberElement
	/// <para>ENTITY IfcDistributionChamberElement</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcDistributionChamberElementTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcDistributionChamberElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDistributionChamberElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCDISTRIBUTIONCHAMBERELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionChamberElement : IfcDistributionFlowElement
	{
		public virtual IfcDistributionChamberElementTypeEnum? PredefinedType { get; set; }
		public IfcDistributionChamberElement() : base()
		{
		}
		public IfcDistributionChamberElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDistributionChamberElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionChamberElementType
	/// <para>ENTITY IfcDistributionChamberElementType</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>PredefinedType : IfcDistributionChamberElementTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcDistributionChamberElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDistributionChamberElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionChamberElementType : IfcDistributionFlowElementType
	{
		public virtual IfcDistributionChamberElementTypeEnum? PredefinedType { get; set; }
		public IfcDistributionChamberElementType() : base()
		{
		}
		public IfcDistributionChamberElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDistributionChamberElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionCircuit
	/// <para>ENTITY IfcDistributionCircuit</para>
	/// <para>SUBTYPE OF (IfcDistributionSystem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionCircuit : IfcDistributionSystem
	{
		public IfcDistributionCircuit() : base()
		{
		}
		public IfcDistributionCircuit(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcDistributionSystemEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionControlElement
	/// <para>ENTITY IfcDistributionControlElement</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcActuator</para>
	/// <para>,IfcAlarm</para>
	/// <para>,IfcController</para>
	/// <para>,IfcFlowInstrument</para>
	/// <para>,IfcProtectiveDeviceTrippingUnit</para>
	/// <para>,IfcSensor</para>
	/// <para>,IfcUnitaryControlElement))</para>
	/// <para>SUBTYPE OF (IfcDistributionElement);</para>
	/// <para>INVERSE</para>
	/// <para>AssignedToFlowElement : SET [0:1] OF IfcRelFlowControlElements FOR RelatedControlElements;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionControlElement : IfcDistributionElement
	{
		//TODO INVERSE
		public List<IfcRelFlowControlElements>? AssignedToFlowElement => Model?.GetItems<IfcRelFlowControlElements>().Where(x => x.RelatedControlElements != null && x.RelatedControlElements.Contains(this)).ToList();
		public IfcDistributionControlElement() : base()
		{
		}
		public IfcDistributionControlElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionControlElementType
	/// <para>ENTITY IfcDistributionControlElementType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcActuatorType</para>
	/// <para>,IfcAlarmType</para>
	/// <para>,IfcControllerType</para>
	/// <para>,IfcFlowInstrumentType</para>
	/// <para>,IfcProtectiveDeviceTrippingUnitType</para>
	/// <para>,IfcSensorType</para>
	/// <para>,IfcUnitaryControlElementType))</para>
	/// <para>SUBTYPE OF (IfcDistributionElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcDistributionControlElementType : IfcDistributionElementType
	{
		public IfcDistributionControlElementType() : base()
		{
		}
		public IfcDistributionControlElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionElement
	/// <para>ENTITY IfcDistributionElement</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDistributionControlElement</para>
	/// <para>,IfcDistributionFlowElement))</para>
	/// <para>SUBTYPE OF (IfcElement);</para>
	/// <para>INVERSE</para>
	/// <para>HasPorts : SET [0:?] OF IfcRelConnectsPortToElement FOR RelatedElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionElement : IfcElement
	{
		//TODO INVERSE
		public List<IfcRelConnectsPortToElement>? HasPorts => Model?.GetItems<IfcRelConnectsPortToElement>().Where(x => x.RelatedElement != null && x.RelatedElement == this).ToList();
		public IfcDistributionElement() : base()
		{
		}
		public IfcDistributionElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionElementType
	/// <para>ENTITY IfcDistributionElementType</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDistributionControlElementType</para>
	/// <para>,IfcDistributionFlowElementType))</para>
	/// <para>SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionElementType : IfcElementType
	{
		public IfcDistributionElementType() : base()
		{
		}
		public IfcDistributionElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionFlowElement
	/// <para>ENTITY IfcDistributionFlowElement</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDistributionChamberElement</para>
	/// <para>,IfcEnergyConversionDevice</para>
	/// <para>,IfcFlowController</para>
	/// <para>,IfcFlowFitting</para>
	/// <para>,IfcFlowMovingDevice</para>
	/// <para>,IfcFlowSegment</para>
	/// <para>,IfcFlowStorageDevice</para>
	/// <para>,IfcFlowTerminal</para>
	/// <para>,IfcFlowTreatmentDevice))</para>
	/// <para>SUBTYPE OF (IfcDistributionElement);</para>
	/// <para>INVERSE</para>
	/// <para>HasControlElements : SET [0:1] OF IfcRelFlowControlElements FOR RelatingFlowElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionFlowElement : IfcDistributionElement
	{
		//TODO INVERSE
		public List<IfcRelFlowControlElements>? HasControlElements => Model?.GetItems<IfcRelFlowControlElements>().Where(x => x.RelatingFlowElement != null && x.RelatingFlowElement == this).ToList();
		public IfcDistributionFlowElement() : base()
		{
		}
		public IfcDistributionFlowElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionFlowElementType
	/// <para>ENTITY IfcDistributionFlowElementType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDistributionChamberElementType</para>
	/// <para>,IfcEnergyConversionDeviceType</para>
	/// <para>,IfcFlowControllerType</para>
	/// <para>,IfcFlowFittingType</para>
	/// <para>,IfcFlowMovingDeviceType</para>
	/// <para>,IfcFlowSegmentType</para>
	/// <para>,IfcFlowStorageDeviceType</para>
	/// <para>,IfcFlowTerminalType</para>
	/// <para>,IfcFlowTreatmentDeviceType))</para>
	/// <para>SUBTYPE OF (IfcDistributionElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcDistributionFlowElementType : IfcDistributionElementType
	{
		public IfcDistributionFlowElementType() : base()
		{
		}
		public IfcDistributionFlowElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionPort
	/// <para>ENTITY IfcDistributionPort</para>
	/// <para>SUBTYPE OF (IfcPort);</para>
	/// <para>FlowDirection : OPTIONAL IfcFlowDirectionEnum;</para>
	/// <para>PredefinedType : OPTIONAL IfcDistributionPortTypeEnum;</para>
	/// <para>SystemType : OPTIONAL IfcDistributionSystemEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionPort : IfcPort
	{
		public virtual IfcFlowDirectionEnum? FlowDirection { get; set; }
		public virtual IfcDistributionPortTypeEnum? PredefinedType { get; set; }
		public virtual IfcDistributionSystemEnum? SystemType { get; set; }
		public IfcDistributionPort() : base()
		{
		}
		public IfcDistributionPort(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcFlowDirectionEnum FlowDirection, IfcDistributionPortTypeEnum PredefinedType, IfcDistributionSystemEnum SystemType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.FlowDirection = FlowDirection;
			this.PredefinedType = PredefinedType;
			this.SystemType = SystemType;
		}
	}
	/// <summary>
	/// ENTITY IfcDistributionSystem
	/// <para>ENTITY IfcDistributionSystem</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDistributionCircuit))</para>
	/// <para>SUBTYPE OF (IfcSystem);</para>
	/// <para>LongName : OPTIONAL IfcLabel;</para>
	/// <para>PredefinedType : OPTIONAL IfcDistributionSystemEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDistributionSystem : IfcSystem
	{
		public virtual IfcLabel? LongName { get; set; }
		public virtual IfcDistributionSystemEnum? PredefinedType { get; set; }
		public IfcDistributionSystem() : base()
		{
		}
		public IfcDistributionSystem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcDistributionSystemEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.LongName = LongName;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDocumentInformation
	/// <para>ENTITY IfcDocumentInformation</para>
	/// <para>SUBTYPE OF (IfcExternalInformation);</para>
	/// <para>Identification : IfcIdentifier;</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Location : OPTIONAL IfcURIReference;</para>
	/// <para>Purpose : OPTIONAL IfcText;</para>
	/// <para>IntendedUse : OPTIONAL IfcText;</para>
	/// <para>Scope : OPTIONAL IfcText;</para>
	/// <para>Revision : OPTIONAL IfcLabel;</para>
	/// <para>DocumentOwner : OPTIONAL IfcActorSelect;</para>
	/// <para>Editors : OPTIONAL SET [1:?] OF IfcActorSelect;</para>
	/// <para>CreationTime : OPTIONAL IfcDateTime;</para>
	/// <para>LastRevisionTime : OPTIONAL IfcDateTime;</para>
	/// <para>ElectronicFormat : OPTIONAL IfcIdentifier;</para>
	/// <para>ValidFrom : OPTIONAL IfcDate;</para>
	/// <para>ValidUntil : OPTIONAL IfcDate;</para>
	/// <para>Confidentiality : OPTIONAL IfcDocumentConfidentialityEnum;</para>
	/// <para>Status : OPTIONAL IfcDocumentStatusEnum;</para>
	/// <para>INVERSE</para>
	/// <para>DocumentInfoForObjects : SET [0:?] OF IfcRelAssociatesDocument FOR RelatingDocument;</para>
	/// <para>HasDocumentReferences : SET [0:?] OF IfcDocumentReference FOR ReferencedDocument;</para>
	/// <para>IsPointedTo : SET [0:?] OF IfcDocumentInformationRelationship FOR RelatedDocuments;</para>
	/// <para>IsPointer : SET [0:1] OF IfcDocumentInformationRelationship FOR RelatingDocument;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDocumentInformation : IfcExternalInformation, IfcDocumentSelect
	{
		public virtual IfcIdentifier? Identification { get; set; }
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcURIReference? Location { get; set; }
		public virtual IfcText? Purpose { get; set; }
		public virtual IfcText? IntendedUse { get; set; }
		public virtual IfcText? Scope { get; set; }
		public virtual IfcLabel? Revision { get; set; }
		public virtual IfcActorSelect? DocumentOwner { get; set; }
		public virtual List<IfcActorSelect>? Editors { get; set; }
		public virtual IfcDateTime? CreationTime { get; set; }
		public virtual IfcDateTime? LastRevisionTime { get; set; }
		public virtual IfcIdentifier? ElectronicFormat { get; set; }
		public virtual IfcDate? ValidFrom { get; set; }
		public virtual IfcDate? ValidUntil { get; set; }
		public virtual IfcDocumentConfidentialityEnum? Confidentiality { get; set; }
		public virtual IfcDocumentStatusEnum? Status { get; set; }
		//TODO INVERSE
		public List<IfcRelAssociatesDocument>? DocumentInfoForObjects => Model?.GetItems<IfcRelAssociatesDocument>().Where(x => x.RelatingDocument != null && x.RelatingDocument == this).ToList();
		//TODO INVERSE
		public List<IfcDocumentReference>? HasDocumentReferences => Model?.GetItems<IfcDocumentReference>().Where(x => x.ReferencedDocument != null && x.ReferencedDocument == this).ToList();
		//TODO INVERSE
		public List<IfcDocumentInformationRelationship>? IsPointedTo => Model?.GetItems<IfcDocumentInformationRelationship>().Where(x => x.RelatedDocuments != null && x.RelatedDocuments.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcDocumentInformationRelationship>? IsPointer => Model?.GetItems<IfcDocumentInformationRelationship>().Where(x => x.RelatingDocument != null && x.RelatingDocument == this).ToList();
		public IfcDocumentInformation() : base()
		{
		}
		public IfcDocumentInformation(IfcIdentifier Identification, IfcLabel Name, IfcText Description, IfcURIReference Location, IfcText Purpose, IfcText IntendedUse, IfcText Scope, IfcLabel Revision, IfcActorSelect DocumentOwner, List<IfcActorSelect> Editors, IfcDateTime CreationTime, IfcDateTime LastRevisionTime, IfcIdentifier ElectronicFormat, IfcDate ValidFrom, IfcDate ValidUntil, IfcDocumentConfidentialityEnum Confidentiality, IfcDocumentStatusEnum Status) : base ()
		{
			this.Identification = Identification;
			this.Name = Name;
			this.Description = Description;
			this.Location = Location;
			this.Purpose = Purpose;
			this.IntendedUse = IntendedUse;
			this.Scope = Scope;
			this.Revision = Revision;
			this.DocumentOwner = DocumentOwner;
			this.Editors = Editors;
			this.CreationTime = CreationTime;
			this.LastRevisionTime = LastRevisionTime;
			this.ElectronicFormat = ElectronicFormat;
			this.ValidFrom = ValidFrom;
			this.ValidUntil = ValidUntil;
			this.Confidentiality = Confidentiality;
			this.Status = Status;
		}
	}
	/// <summary>
	/// ENTITY IfcDocumentInformationRelationship
	/// <para>ENTITY IfcDocumentInformationRelationship</para>
	/// <para>SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>RelatingDocument : IfcDocumentInformation;</para>
	/// <para>RelatedDocuments : SET [1:?] OF IfcDocumentInformation;</para>
	/// <para>RelationshipType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDocumentInformationRelationship : IfcResourceLevelRelationship
	{
		public virtual IfcDocumentInformation? RelatingDocument { get; set; }
		public virtual List<IfcDocumentInformation>? RelatedDocuments { get; set; }
		public virtual IfcLabel? RelationshipType { get; set; }
		public IfcDocumentInformationRelationship() : base()
		{
		}
		public IfcDocumentInformationRelationship(IfcLabel Name, IfcText Description, IfcDocumentInformation RelatingDocument, List<IfcDocumentInformation> RelatedDocuments, IfcLabel RelationshipType) : base (Name, Description)
		{
			this.RelatingDocument = RelatingDocument;
			this.RelatedDocuments = RelatedDocuments;
			this.RelationshipType = RelationshipType;
		}
	}
	/// <summary>
	/// ENTITY IfcDocumentReference
	/// <para>ENTITY IfcDocumentReference</para>
	/// <para>SUBTYPE OF (IfcExternalReference);</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>ReferencedDocument : OPTIONAL IfcDocumentInformation;</para>
	/// <para>INVERSE</para>
	/// <para>DocumentRefForObjects : SET [0:?] OF IfcRelAssociatesDocument FOR RelatingDocument;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : EXISTS(Name) XOR EXISTS(ReferencedDocument);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDocumentReference : IfcExternalReference, IfcDocumentSelect
	{
		public virtual IfcText? Description { get; set; }
		public virtual IfcDocumentInformation? ReferencedDocument { get; set; }
		//TODO INVERSE
		public List<IfcRelAssociatesDocument>? DocumentRefForObjects => Model?.GetItems<IfcRelAssociatesDocument>().Where(x => x.RelatingDocument != null && x.RelatingDocument == this).ToList();
		public IfcDocumentReference() : base()
		{
		}
		public IfcDocumentReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name, IfcText Description, IfcDocumentInformation ReferencedDocument) : base (Location, Identification, Name)
		{
			this.Description = Description;
			this.ReferencedDocument = ReferencedDocument;
		}
	}
	/// <summary>
	/// ENTITY IfcDoor
	/// <para>ENTITY IfcDoor</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDoorStandardCase))</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>OverallHeight : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>OverallWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>PredefinedType : OPTIONAL IfcDoorTypeEnum;</para>
	/// <para>OperationType : OPTIONAL IfcDoorTypeOperationEnum;</para>
	/// <para>UserDefinedOperationType : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>CorrectStyleAssigned : (SIZEOF(IsTypedBy) = 0)</para>
	/// <para>OR ('IFC4X1.IFCDOORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoor : IfcBuildingElement
	{
		public virtual IfcPositiveLengthMeasure? OverallHeight { get; set; }
		public virtual IfcPositiveLengthMeasure? OverallWidth { get; set; }
		public virtual IfcDoorTypeEnum? PredefinedType { get; set; }
		public virtual IfcDoorTypeOperationEnum? OperationType { get; set; }
		public virtual IfcLabel? UserDefinedOperationType { get; set; }
		public IfcDoor() : base()
		{
		}
		public IfcDoor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure OverallHeight, IfcPositiveLengthMeasure OverallWidth, IfcDoorTypeEnum PredefinedType, IfcDoorTypeOperationEnum OperationType, IfcLabel UserDefinedOperationType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.OverallHeight = OverallHeight;
			this.OverallWidth = OverallWidth;
			this.PredefinedType = PredefinedType;
			this.OperationType = OperationType;
			this.UserDefinedOperationType = UserDefinedOperationType;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorLiningProperties
	/// <para>ENTITY IfcDoorLiningProperties</para>
	/// <para>SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>LiningDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>LiningThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>ThresholdDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>ThresholdThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>TransomThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>TransomOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>LiningOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>ThresholdOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>CasingThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>CasingDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>LiningToPanelOffsetX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>LiningToPanelOffsetY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>WR31 : NOT(EXISTS(LiningDepth) AND NOT(EXISTS(LiningThickness)));</para>
	/// <para>WR32 : NOT(EXISTS(ThresholdDepth) AND NOT(EXISTS(ThresholdThickness)));</para>
	/// <para>WR33 : (EXISTS(TransomOffset) AND EXISTS(TransomThickness)) XOR</para>
	/// <para>(NOT(EXISTS(TransomOffset)) AND NOT(EXISTS(TransomThickness)));</para>
	/// <para>WR34 : (EXISTS(CasingDepth) AND EXISTS(CasingThickness)) XOR</para>
	/// <para>(NOT(EXISTS(CasingDepth)) AND NOT(EXISTS(CasingThickness)));</para>
	/// <para>WR35 : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>AND</para>
	/// <para>(</para>
	/// <para>('IFC4X1.IFCDOORTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>OR</para>
	/// <para>('IFC4X1.IFCDOORSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorLiningProperties : IfcPreDefinedPropertySet
	{
		public virtual IfcPositiveLengthMeasure? LiningDepth { get; set; }
		public virtual IfcNonNegativeLengthMeasure? LiningThickness { get; set; }
		public virtual IfcPositiveLengthMeasure? ThresholdDepth { get; set; }
		public virtual IfcNonNegativeLengthMeasure? ThresholdThickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? TransomThickness { get; set; }
		public virtual IfcLengthMeasure? TransomOffset { get; set; }
		public virtual IfcLengthMeasure? LiningOffset { get; set; }
		public virtual IfcLengthMeasure? ThresholdOffset { get; set; }
		public virtual IfcPositiveLengthMeasure? CasingThickness { get; set; }
		public virtual IfcPositiveLengthMeasure? CasingDepth { get; set; }
		public virtual IfcShapeAspect? ShapeAspectStyle { get; set; }
		public virtual IfcLengthMeasure? LiningToPanelOffsetX { get; set; }
		public virtual IfcLengthMeasure? LiningToPanelOffsetY { get; set; }
		public IfcDoorLiningProperties() : base()
		{
		}
		public IfcDoorLiningProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPositiveLengthMeasure LiningDepth, IfcNonNegativeLengthMeasure LiningThickness, IfcPositiveLengthMeasure ThresholdDepth, IfcNonNegativeLengthMeasure ThresholdThickness, IfcNonNegativeLengthMeasure TransomThickness, IfcLengthMeasure TransomOffset, IfcLengthMeasure LiningOffset, IfcLengthMeasure ThresholdOffset, IfcPositiveLengthMeasure CasingThickness, IfcPositiveLengthMeasure CasingDepth, IfcShapeAspect ShapeAspectStyle, IfcLengthMeasure LiningToPanelOffsetX, IfcLengthMeasure LiningToPanelOffsetY) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.LiningDepth = LiningDepth;
			this.LiningThickness = LiningThickness;
			this.ThresholdDepth = ThresholdDepth;
			this.ThresholdThickness = ThresholdThickness;
			this.TransomThickness = TransomThickness;
			this.TransomOffset = TransomOffset;
			this.LiningOffset = LiningOffset;
			this.ThresholdOffset = ThresholdOffset;
			this.CasingThickness = CasingThickness;
			this.CasingDepth = CasingDepth;
			this.ShapeAspectStyle = ShapeAspectStyle;
			this.LiningToPanelOffsetX = LiningToPanelOffsetX;
			this.LiningToPanelOffsetY = LiningToPanelOffsetY;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorPanelProperties
	/// <para>ENTITY IfcDoorPanelProperties</para>
	/// <para>SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>PanelDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>PanelOperation : IfcDoorPanelOperationEnum;</para>
	/// <para>PanelWidth : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>PanelPosition : IfcDoorPanelPositionEnum;</para>
	/// <para>ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>WHERE</para>
	/// <para>ApplicableToType : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>AND</para>
	/// <para>(</para>
	/// <para>('IFC4X1.IFCDOORTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>OR</para>
	/// <para>('IFC4X1.IFCDOORSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorPanelProperties : IfcPreDefinedPropertySet
	{
		public virtual IfcPositiveLengthMeasure? PanelDepth { get; set; }
		public virtual IfcDoorPanelOperationEnum? PanelOperation { get; set; }
		public virtual IfcNormalisedRatioMeasure? PanelWidth { get; set; }
		public virtual IfcDoorPanelPositionEnum? PanelPosition { get; set; }
		public virtual IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcDoorPanelProperties() : base()
		{
		}
		public IfcDoorPanelProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPositiveLengthMeasure PanelDepth, IfcDoorPanelOperationEnum PanelOperation, IfcNormalisedRatioMeasure PanelWidth, IfcDoorPanelPositionEnum PanelPosition, IfcShapeAspect ShapeAspectStyle) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.PanelDepth = PanelDepth;
			this.PanelOperation = PanelOperation;
			this.PanelWidth = PanelWidth;
			this.PanelPosition = PanelPosition;
			this.ShapeAspectStyle = ShapeAspectStyle;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorStandardCase
	/// <para>ENTITY IfcDoorStandardCase</para>
	/// <para>SUBTYPE OF (IfcDoor);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorStandardCase : IfcDoor
	{
		public IfcDoorStandardCase() : base()
		{
		}
		public IfcDoorStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure OverallHeight, IfcPositiveLengthMeasure OverallWidth, IfcDoorTypeEnum PredefinedType, IfcDoorTypeOperationEnum OperationType, IfcLabel UserDefinedOperationType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDoorStyle
	/// <para>ENTITY IfcDoorStyle</para>
	/// <para>SUBTYPE OF (IfcTypeProduct);</para>
	/// <para>OperationType : IfcDoorStyleOperationEnum;</para>
	/// <para>ConstructionType : IfcDoorStyleConstructionEnum;</para>
	/// <para>ParameterTakesPrecedence : IfcBoolean;</para>
	/// <para>Sizeable : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorStyle : IfcTypeProduct
	{
		public virtual IfcDoorStyleOperationEnum? OperationType { get; set; }
		public virtual IfcDoorStyleConstructionEnum? ConstructionType { get; set; }
		public virtual IfcBoolean? ParameterTakesPrecedence { get; set; }
		public virtual IfcBoolean? Sizeable { get; set; }
		public IfcDoorStyle() : base()
		{
		}
		public IfcDoorStyle(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcDoorStyleOperationEnum OperationType, IfcDoorStyleConstructionEnum ConstructionType, IfcBoolean ParameterTakesPrecedence, IfcBoolean Sizeable) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.OperationType = OperationType;
			this.ConstructionType = ConstructionType;
			this.ParameterTakesPrecedence = ParameterTakesPrecedence;
			this.Sizeable = Sizeable;
		}
	}
	/// <summary>
	/// ENTITY IfcDoorType
	/// <para>ENTITY IfcDoorType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcDoorTypeEnum;</para>
	/// <para>OperationType : IfcDoorTypeOperationEnum;</para>
	/// <para>ParameterTakesPrecedence : OPTIONAL IfcBoolean;</para>
	/// <para>UserDefinedOperationType : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcDoorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDoorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDoorType : IfcBuildingElementType
	{
		public virtual IfcDoorTypeEnum? PredefinedType { get; set; }
		public virtual IfcDoorTypeOperationEnum? OperationType { get; set; }
		public virtual IfcBoolean? ParameterTakesPrecedence { get; set; }
		public virtual IfcLabel? UserDefinedOperationType { get; set; }
		public IfcDoorType() : base()
		{
		}
		public IfcDoorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDoorTypeEnum PredefinedType, IfcDoorTypeOperationEnum OperationType, IfcBoolean ParameterTakesPrecedence, IfcLabel UserDefinedOperationType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.OperationType = OperationType;
			this.ParameterTakesPrecedence = ParameterTakesPrecedence;
			this.UserDefinedOperationType = UserDefinedOperationType;
		}
	}
	/// <summary>
	/// ENTITY IfcDraughtingPreDefinedColour
	/// <para>ENTITY IfcDraughtingPreDefinedColour</para>
	/// <para>SUBTYPE OF (IfcPreDefinedColour);</para>
	/// <para>WHERE</para>
	/// <para>PreDefinedColourNames : SELF\IfcPreDefinedItem.Name IN ['black','red','green','blue','yellow',</para>
	/// <para>'magenta','cyan','white','by layer'];</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDraughtingPreDefinedColour : IfcPreDefinedColour
	{
		public IfcDraughtingPreDefinedColour() : base()
		{
		}
		public IfcDraughtingPreDefinedColour(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDraughtingPreDefinedCurveFont
	/// <para>ENTITY IfcDraughtingPreDefinedCurveFont</para>
	/// <para>SUBTYPE OF (IfcPreDefinedCurveFont);</para>
	/// <para>WHERE</para>
	/// <para>PreDefinedCurveFontNames : SELF\IfcPredefinedItem.Name IN</para>
	/// <para>['continuous',</para>
	/// <para>'chain',</para>
	/// <para>'chain double dash',</para>
	/// <para>'dashed',</para>
	/// <para>'dotted',</para>
	/// <para>'by layer'];</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDraughtingPreDefinedCurveFont : IfcPreDefinedCurveFont
	{
		public IfcDraughtingPreDefinedCurveFont() : base()
		{
		}
		public IfcDraughtingPreDefinedCurveFont(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcDuctFitting
	/// <para>ENTITY IfcDuctFitting</para>
	/// <para>SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>PredefinedType : OPTIONAL IfcDuctFittingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcDuctFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDuctFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCDUCTFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctFitting : IfcFlowFitting
	{
		public virtual IfcDuctFittingTypeEnum? PredefinedType { get; set; }
		public IfcDuctFitting() : base()
		{
		}
		public IfcDuctFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDuctFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctFittingType
	/// <para>ENTITY IfcDuctFittingType</para>
	/// <para>SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>PredefinedType : IfcDuctFittingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcDuctFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDuctFittingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctFittingType : IfcFlowFittingType
	{
		public virtual IfcDuctFittingTypeEnum? PredefinedType { get; set; }
		public IfcDuctFittingType() : base()
		{
		}
		public IfcDuctFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDuctFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSegment
	/// <para>ENTITY IfcDuctSegment</para>
	/// <para>SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>PredefinedType : OPTIONAL IfcDuctSegmentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcDuctSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDuctSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCDUCTSEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSegment : IfcFlowSegment
	{
		public virtual IfcDuctSegmentTypeEnum? PredefinedType { get; set; }
		public IfcDuctSegment() : base()
		{
		}
		public IfcDuctSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDuctSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSegmentType
	/// <para>ENTITY IfcDuctSegmentType</para>
	/// <para>SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>PredefinedType : IfcDuctSegmentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcDuctSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDuctSegmentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSegmentType : IfcFlowSegmentType
	{
		public virtual IfcDuctSegmentTypeEnum? PredefinedType { get; set; }
		public IfcDuctSegmentType() : base()
		{
		}
		public IfcDuctSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDuctSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSilencer
	/// <para>ENTITY IfcDuctSilencer</para>
	/// <para>SUBTYPE OF (IfcFlowTreatmentDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcDuctSilencerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcDuctSilencerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDuctSilencerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCDUCTSILENCERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSilencer : IfcFlowTreatmentDevice
	{
		public virtual IfcDuctSilencerTypeEnum? PredefinedType { get; set; }
		public IfcDuctSilencer() : base()
		{
		}
		public IfcDuctSilencer(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcDuctSilencerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcDuctSilencerType
	/// <para>ENTITY IfcDuctSilencerType</para>
	/// <para>SUBTYPE OF (IfcFlowTreatmentDeviceType);</para>
	/// <para>PredefinedType : IfcDuctSilencerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcDuctSilencerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcDuctSilencerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcDuctSilencerType : IfcFlowTreatmentDeviceType
	{
		public virtual IfcDuctSilencerTypeEnum? PredefinedType { get; set; }
		public IfcDuctSilencerType() : base()
		{
		}
		public IfcDuctSilencerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcDuctSilencerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEdge
	/// <para>ENTITY IfcEdge</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcEdgeCurve</para>
	/// <para>,IfcOrientedEdge</para>
	/// <para>,IfcSubedge))</para>
	/// <para>SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>EdgeStart : IfcVertex;</para>
	/// <para>EdgeEnd : IfcVertex;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEdge : IfcTopologicalRepresentationItem
	{
		public virtual IfcVertex? EdgeStart { get; set; }
		public virtual IfcVertex? EdgeEnd { get; set; }
		public IfcEdge() : base()
		{
		}
		public IfcEdge(IfcVertex EdgeStart, IfcVertex EdgeEnd) : base ()
		{
			this.EdgeStart = EdgeStart;
			this.EdgeEnd = EdgeEnd;
		}
	}
	/// <summary>
	/// ENTITY IfcEdgeCurve
	/// <para>ENTITY IfcEdgeCurve</para>
	/// <para>SUBTYPE OF (IfcEdge);</para>
	/// <para>EdgeGeometry : IfcCurve;</para>
	/// <para>SameSense : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEdgeCurve : IfcEdge, IfcCurveOrEdgeCurve
	{
		public virtual IfcCurve? EdgeGeometry { get; set; }
		public virtual IfcBoolean? SameSense { get; set; }
		public IfcEdgeCurve() : base()
		{
		}
		public IfcEdgeCurve(IfcVertex EdgeStart, IfcVertex EdgeEnd, IfcCurve EdgeGeometry, IfcBoolean SameSense) : base (EdgeStart, EdgeEnd)
		{
			this.EdgeGeometry = EdgeGeometry;
			this.SameSense = SameSense;
		}
	}
	/// <summary>
	/// ENTITY IfcEdgeLoop
	/// <para>ENTITY IfcEdgeLoop</para>
	/// <para>SUBTYPE OF (IfcLoop);</para>
	/// <para>EdgeList : LIST [1:?] OF IfcOrientedEdge;</para>
	/// <para>DERIVE</para>
	/// <para>Ne : IfcInteger := SIZEOF(EdgeList);</para>
	/// <para>WHERE</para>
	/// <para>IsClosed : (EdgeList[1].EdgeStart) :=: (EdgeList[Ne].EdgeEnd);</para>
	/// <para>IsContinuous : IfcLoopHeadToTail(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEdgeLoop : IfcLoop
	{
		public virtual List<IfcOrientedEdge>? EdgeList { get; set; }
		//TODO DERIVE
		public virtual IfcInteger? Ne {get {return null;}}
		public IfcEdgeLoop() : base()
		{
		}
		public IfcEdgeLoop(List<IfcOrientedEdge> EdgeList) : base ()
		{
			this.EdgeList = EdgeList;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricAppliance
	/// <para>ENTITY IfcElectricAppliance</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcElectricApplianceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcElectricApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricApplianceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCELECTRICAPPLIANCETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricAppliance : IfcFlowTerminal
	{
		public virtual IfcElectricApplianceTypeEnum? PredefinedType { get; set; }
		public IfcElectricAppliance() : base()
		{
		}
		public IfcElectricAppliance(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricApplianceType
	/// <para>ENTITY IfcElectricApplianceType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcElectricApplianceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcElectricApplianceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricApplianceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricApplianceType : IfcFlowTerminalType
	{
		public virtual IfcElectricApplianceTypeEnum? PredefinedType { get; set; }
		public IfcElectricApplianceType() : base()
		{
		}
		public IfcElectricApplianceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricApplianceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricDistributionBoard
	/// <para>ENTITY IfcElectricDistributionBoard</para>
	/// <para>SUBTYPE OF (IfcFlowController);</para>
	/// <para>PredefinedType : OPTIONAL IfcElectricDistributionBoardTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcElectricDistributionBoardTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricDistributionBoardTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCELECTRICDISTRIBUTIONBOARDTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricDistributionBoard : IfcFlowController
	{
		public virtual IfcElectricDistributionBoardTypeEnum? PredefinedType { get; set; }
		public IfcElectricDistributionBoard() : base()
		{
		}
		public IfcElectricDistributionBoard(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricDistributionBoardTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricDistributionBoardType
	/// <para>ENTITY IfcElectricDistributionBoardType</para>
	/// <para>SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>PredefinedType : IfcElectricDistributionBoardTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcElectricDistributionBoardTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricDistributionBoardTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricDistributionBoardType : IfcFlowControllerType
	{
		public virtual IfcElectricDistributionBoardTypeEnum? PredefinedType { get; set; }
		public IfcElectricDistributionBoardType() : base()
		{
		}
		public IfcElectricDistributionBoardType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricDistributionBoardTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricFlowStorageDevice
	/// <para>ENTITY IfcElectricFlowStorageDevice</para>
	/// <para>SUBTYPE OF (IfcFlowStorageDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcElectricFlowStorageDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCELECTRICFLOWSTORAGEDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricFlowStorageDevice : IfcFlowStorageDevice
	{
		public virtual IfcElectricFlowStorageDeviceTypeEnum? PredefinedType { get; set; }
		public IfcElectricFlowStorageDevice() : base()
		{
		}
		public IfcElectricFlowStorageDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricFlowStorageDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricFlowStorageDeviceType
	/// <para>ENTITY IfcElectricFlowStorageDeviceType</para>
	/// <para>SUBTYPE OF (IfcFlowStorageDeviceType);</para>
	/// <para>PredefinedType : IfcElectricFlowStorageDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricFlowStorageDeviceType : IfcFlowStorageDeviceType
	{
		public virtual IfcElectricFlowStorageDeviceTypeEnum? PredefinedType { get; set; }
		public IfcElectricFlowStorageDeviceType() : base()
		{
		}
		public IfcElectricFlowStorageDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricFlowStorageDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricGenerator
	/// <para>ENTITY IfcElectricGenerator</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcElectricGeneratorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcElectricGeneratorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricGeneratorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCELECTRICGENERATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricGenerator : IfcEnergyConversionDevice
	{
		public virtual IfcElectricGeneratorTypeEnum? PredefinedType { get; set; }
		public IfcElectricGenerator() : base()
		{
		}
		public IfcElectricGenerator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricGeneratorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricGeneratorType
	/// <para>ENTITY IfcElectricGeneratorType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcElectricGeneratorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcElectricGeneratorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricGeneratorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricGeneratorType : IfcEnergyConversionDeviceType
	{
		public virtual IfcElectricGeneratorTypeEnum? PredefinedType { get; set; }
		public IfcElectricGeneratorType() : base()
		{
		}
		public IfcElectricGeneratorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricGeneratorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricMotor
	/// <para>ENTITY IfcElectricMotor</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcElectricMotorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcElectricMotorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricMotorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCELECTRICMOTORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricMotor : IfcEnergyConversionDevice
	{
		public virtual IfcElectricMotorTypeEnum? PredefinedType { get; set; }
		public IfcElectricMotor() : base()
		{
		}
		public IfcElectricMotor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricMotorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricMotorType
	/// <para>ENTITY IfcElectricMotorType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcElectricMotorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcElectricMotorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricMotorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricMotorType : IfcEnergyConversionDeviceType
	{
		public virtual IfcElectricMotorTypeEnum? PredefinedType { get; set; }
		public IfcElectricMotorType() : base()
		{
		}
		public IfcElectricMotorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricMotorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricTimeControl
	/// <para>ENTITY IfcElectricTimeControl</para>
	/// <para>SUBTYPE OF (IfcFlowController);</para>
	/// <para>PredefinedType : OPTIONAL IfcElectricTimeControlTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcElectricTimeControlTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricTimeControlTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCELECTRICTIMECONTROLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricTimeControl : IfcFlowController
	{
		public virtual IfcElectricTimeControlTypeEnum? PredefinedType { get; set; }
		public IfcElectricTimeControl() : base()
		{
		}
		public IfcElectricTimeControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcElectricTimeControlTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElectricTimeControlType
	/// <para>ENTITY IfcElectricTimeControlType</para>
	/// <para>SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>PredefinedType : IfcElectricTimeControlTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcElectricTimeControlTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElectricTimeControlTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElectricTimeControlType : IfcFlowControllerType
	{
		public virtual IfcElectricTimeControlTypeEnum? PredefinedType { get; set; }
		public IfcElectricTimeControlType() : base()
		{
		}
		public IfcElectricTimeControlType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElectricTimeControlTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElement
	/// <para>ENTITY IfcElement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBuildingElement</para>
	/// <para>,IfcCivilElement</para>
	/// <para>,IfcDistributionElement</para>
	/// <para>,IfcElementAssembly</para>
	/// <para>,IfcElementComponent</para>
	/// <para>,IfcFeatureElement</para>
	/// <para>,IfcFurnishingElement</para>
	/// <para>,IfcGeographicElement</para>
	/// <para>,IfcTransportElement</para>
	/// <para>,IfcVirtualElement))</para>
	/// <para>SUBTYPE OF (IfcProduct);</para>
	/// <para>Tag : OPTIONAL IfcIdentifier;</para>
	/// <para>INVERSE</para>
	/// <para>FillsVoids : SET [0:1] OF IfcRelFillsElement FOR RelatedBuildingElement;</para>
	/// <para>ConnectedTo : SET [0:?] OF IfcRelConnectsElements FOR RelatingElement;</para>
	/// <para>IsInterferedByElements : SET [0:?] OF IfcRelInterferesElements FOR RelatedElement;</para>
	/// <para>InterferesElements : SET [0:?] OF IfcRelInterferesElements FOR RelatingElement;</para>
	/// <para>HasProjections : SET [0:?] OF IfcRelProjectsElement FOR RelatingElement;</para>
	/// <para>ReferencedInStructures : SET [0:?] OF IfcRelReferencedInSpatialStructure FOR RelatedElements;</para>
	/// <para>HasOpenings : SET [0:?] OF IfcRelVoidsElement FOR RelatingBuildingElement;</para>
	/// <para>IsConnectionRealization : SET [0:?] OF IfcRelConnectsWithRealizingElements FOR RealizingElements;</para>
	/// <para>ProvidesBoundaries : SET [0:?] OF IfcRelSpaceBoundary FOR RelatedBuildingElement;</para>
	/// <para>ConnectedFrom : SET [0:?] OF IfcRelConnectsElements FOR RelatedElement;</para>
	/// <para>ContainedInStructure : SET [0:1] OF IfcRelContainedInSpatialStructure FOR RelatedElements;</para>
	/// <para>HasCoverings : SET [0:?] OF IfcRelCoversBldgElements FOR RelatingBuildingElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElement : IfcProduct, IfcStructuralActivityAssignmentSelect
	{
		public virtual IfcIdentifier? Tag { get; set; }
		//TODO INVERSE
		public List<IfcRelFillsElement>? FillsVoids => Model?.GetItems<IfcRelFillsElement>().Where(x => x.RelatedBuildingElement != null && x.RelatedBuildingElement == this).ToList();
		//TODO INVERSE
		public List<IfcRelConnectsElements>? ConnectedTo => Model?.GetItems<IfcRelConnectsElements>().Where(x => x.RelatingElement != null && x.RelatingElement == this).ToList();
		//TODO INVERSE
		public List<IfcRelInterferesElements>? IsInterferedByElements => Model?.GetItems<IfcRelInterferesElements>().Where(x => x.RelatedElement != null && x.RelatedElement == this).ToList();
		//TODO INVERSE
		public List<IfcRelInterferesElements>? InterferesElements => Model?.GetItems<IfcRelInterferesElements>().Where(x => x.RelatingElement != null && x.RelatingElement == this).ToList();
		//TODO INVERSE
		public List<IfcRelProjectsElement>? HasProjections => Model?.GetItems<IfcRelProjectsElement>().Where(x => x.RelatingElement != null && x.RelatingElement == this).ToList();
		//TODO INVERSE
		public List<IfcRelReferencedInSpatialStructure>? ReferencedInStructures => Model?.GetItems<IfcRelReferencedInSpatialStructure>().Where(x => x.RelatedElements != null && x.RelatedElements.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelVoidsElement>? HasOpenings => Model?.GetItems<IfcRelVoidsElement>().Where(x => x.RelatingBuildingElement != null && x.RelatingBuildingElement == this).ToList();
		//TODO INVERSE
		public List<IfcRelConnectsWithRealizingElements>? IsConnectionRealization => Model?.GetItems<IfcRelConnectsWithRealizingElements>().Where(x => x.RealizingElements != null && x.RealizingElements.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelSpaceBoundary>? ProvidesBoundaries => Model?.GetItems<IfcRelSpaceBoundary>().Where(x => x.RelatedBuildingElement != null && x.RelatedBuildingElement == this).ToList();
		//TODO INVERSE
		public List<IfcRelConnectsElements>? ConnectedFrom => Model?.GetItems<IfcRelConnectsElements>().Where(x => x.RelatedElement != null && x.RelatedElement == this).ToList();
		//TODO INVERSE
		public List<IfcRelContainedInSpatialStructure>? ContainedInStructure => Model?.GetItems<IfcRelContainedInSpatialStructure>().Where(x => x.RelatedElements != null && x.RelatedElements.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelCoversBldgElements>? HasCoverings => Model?.GetItems<IfcRelCoversBldgElements>().Where(x => x.RelatingBuildingElement != null && x.RelatingBuildingElement == this).ToList();
		public IfcElement() : base()
		{
		}
		public IfcElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.Tag = Tag;
		}
	}
	/// <summary>
	/// ENTITY IfcElementAssembly
	/// <para>ENTITY IfcElementAssembly</para>
	/// <para>SUBTYPE OF (IfcElement);</para>
	/// <para>AssemblyPlace : OPTIONAL IfcAssemblyPlaceEnum;</para>
	/// <para>PredefinedType : OPTIONAL IfcElementAssemblyTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcElementAssemblyTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElementAssemblyTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCELEMENTASSEMBLYTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElementAssembly : IfcElement
	{
		public virtual IfcAssemblyPlaceEnum? AssemblyPlace { get; set; }
		public virtual IfcElementAssemblyTypeEnum? PredefinedType { get; set; }
		public IfcElementAssembly() : base()
		{
		}
		public IfcElementAssembly(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcAssemblyPlaceEnum AssemblyPlace, IfcElementAssemblyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.AssemblyPlace = AssemblyPlace;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElementAssemblyType
	/// <para>ENTITY IfcElementAssemblyType</para>
	/// <para>SUBTYPE OF (IfcElementType);</para>
	/// <para>PredefinedType : IfcElementAssemblyTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcElementAssemblyTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcElementAssemblyTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElementAssemblyType : IfcElementType
	{
		public virtual IfcElementAssemblyTypeEnum? PredefinedType { get; set; }
		public IfcElementAssemblyType() : base()
		{
		}
		public IfcElementAssemblyType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcElementAssemblyTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcElementComponent
	/// <para>ENTITY IfcElementComponent</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBuildingElementPart</para>
	/// <para>,IfcDiscreteAccessory</para>
	/// <para>,IfcFastener</para>
	/// <para>,IfcMechanicalFastener</para>
	/// <para>,IfcReinforcingElement</para>
	/// <para>,IfcVibrationIsolator))</para>
	/// <para>SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementComponent : IfcElement
	{
		public IfcElementComponent() : base()
		{
		}
		public IfcElementComponent(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcElementComponentType
	/// <para>ENTITY IfcElementComponentType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBuildingElementPartType</para>
	/// <para>,IfcDiscreteAccessoryType</para>
	/// <para>,IfcFastenerType</para>
	/// <para>,IfcMechanicalFastenerType</para>
	/// <para>,IfcReinforcingElementType</para>
	/// <para>,IfcVibrationIsolatorType))</para>
	/// <para>SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementComponentType : IfcElementType
	{
		public IfcElementComponentType() : base()
		{
		}
		public IfcElementComponentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcElementQuantity
	/// <para>ENTITY IfcElementQuantity</para>
	/// <para>SUBTYPE OF (IfcQuantitySet);</para>
	/// <para>MethodOfMeasurement : OPTIONAL IfcLabel;</para>
	/// <para>Quantities : SET [1:?] OF IfcPhysicalQuantity;</para>
	/// <para>WHERE</para>
	/// <para>UniqueQuantityNames : IfcUniqueQuantityNames(Quantities);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcElementQuantity : IfcQuantitySet
	{
		public virtual IfcLabel? MethodOfMeasurement { get; set; }
		public virtual List<IfcPhysicalQuantity>? Quantities { get; set; }
		public IfcElementQuantity() : base()
		{
		}
		public IfcElementQuantity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel MethodOfMeasurement, List<IfcPhysicalQuantity> Quantities) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.MethodOfMeasurement = MethodOfMeasurement;
			this.Quantities = Quantities;
		}
	}
	/// <summary>
	/// ENTITY IfcElementType
	/// <para>ENTITY IfcElementType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBuildingElementType</para>
	/// <para>,IfcCivilElementType</para>
	/// <para>,IfcDistributionElementType</para>
	/// <para>,IfcElementAssemblyType</para>
	/// <para>,IfcElementComponentType</para>
	/// <para>,IfcFurnishingElementType</para>
	/// <para>,IfcGeographicElementType</para>
	/// <para>,IfcTransportElementType))</para>
	/// <para>SUBTYPE OF (IfcTypeProduct);</para>
	/// <para>ElementType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementType : IfcTypeProduct
	{
		public virtual IfcLabel? ElementType { get; set; }
		public IfcElementType() : base()
		{
		}
		public IfcElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.ElementType = ElementType;
		}
	}
	/// <summary>
	/// ENTITY IfcElementarySurface
	/// <para>ENTITY IfcElementarySurface</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCylindricalSurface</para>
	/// <para>,IfcPlane</para>
	/// <para>,IfcSphericalSurface</para>
	/// <para>,IfcToroidalSurface))</para>
	/// <para>SUBTYPE OF (IfcSurface);</para>
	/// <para>Position : IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcElementarySurface : IfcSurface
	{
		public virtual IfcAxis2Placement3D? Position { get; set; }
		public IfcElementarySurface() : base()
		{
		}
		public IfcElementarySurface(IfcAxis2Placement3D Position) : base ()
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcEllipse
	/// <para>ENTITY IfcEllipse</para>
	/// <para>SUBTYPE OF (IfcConic);</para>
	/// <para>SemiAxis1 : IfcPositiveLengthMeasure;</para>
	/// <para>SemiAxis2 : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEllipse : IfcConic
	{
		public virtual IfcPositiveLengthMeasure? SemiAxis1 { get; set; }
		public virtual IfcPositiveLengthMeasure? SemiAxis2 { get; set; }
		public IfcEllipse() : base()
		{
		}
		public IfcEllipse(IfcAxis2Placement Position, IfcPositiveLengthMeasure SemiAxis1, IfcPositiveLengthMeasure SemiAxis2) : base (Position)
		{
			this.SemiAxis1 = SemiAxis1;
			this.SemiAxis2 = SemiAxis2;
		}
	}
	/// <summary>
	/// ENTITY IfcEllipseProfileDef
	/// <para>ENTITY IfcEllipseProfileDef</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>SemiAxis1 : IfcPositiveLengthMeasure;</para>
	/// <para>SemiAxis2 : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEllipseProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? SemiAxis1 { get; set; }
		public virtual IfcPositiveLengthMeasure? SemiAxis2 { get; set; }
		public IfcEllipseProfileDef() : base()
		{
		}
		public IfcEllipseProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure SemiAxis1, IfcPositiveLengthMeasure SemiAxis2) : base (ProfileType, ProfileName, Position)
		{
			this.SemiAxis1 = SemiAxis1;
			this.SemiAxis2 = SemiAxis2;
		}
	}
	/// <summary>
	/// ENTITY IfcEnergyConversionDevice
	/// <para>ENTITY IfcEnergyConversionDevice</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAirToAirHeatRecovery</para>
	/// <para>,IfcBoiler</para>
	/// <para>,IfcBurner</para>
	/// <para>,IfcChiller</para>
	/// <para>,IfcCoil</para>
	/// <para>,IfcCondenser</para>
	/// <para>,IfcCooledBeam</para>
	/// <para>,IfcCoolingTower</para>
	/// <para>,IfcElectricGenerator</para>
	/// <para>,IfcElectricMotor</para>
	/// <para>,IfcEngine</para>
	/// <para>,IfcEvaporativeCooler</para>
	/// <para>,IfcEvaporator</para>
	/// <para>,IfcHeatExchanger</para>
	/// <para>,IfcHumidifier</para>
	/// <para>,IfcMotorConnection</para>
	/// <para>,IfcSolarDevice</para>
	/// <para>,IfcTransformer</para>
	/// <para>,IfcTubeBundle</para>
	/// <para>,IfcUnitaryEquipment))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEnergyConversionDevice : IfcDistributionFlowElement
	{
		public IfcEnergyConversionDevice() : base()
		{
		}
		public IfcEnergyConversionDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcEnergyConversionDeviceType
	/// <para>ENTITY IfcEnergyConversionDeviceType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAirToAirHeatRecoveryType</para>
	/// <para>,IfcBoilerType</para>
	/// <para>,IfcBurnerType</para>
	/// <para>,IfcChillerType</para>
	/// <para>,IfcCoilType</para>
	/// <para>,IfcCondenserType</para>
	/// <para>,IfcCooledBeamType</para>
	/// <para>,IfcCoolingTowerType</para>
	/// <para>,IfcElectricGeneratorType</para>
	/// <para>,IfcElectricMotorType</para>
	/// <para>,IfcEngineType</para>
	/// <para>,IfcEvaporativeCoolerType</para>
	/// <para>,IfcEvaporatorType</para>
	/// <para>,IfcHeatExchangerType</para>
	/// <para>,IfcHumidifierType</para>
	/// <para>,IfcMotorConnectionType</para>
	/// <para>,IfcSolarDeviceType</para>
	/// <para>,IfcTransformerType</para>
	/// <para>,IfcTubeBundleType</para>
	/// <para>,IfcUnitaryEquipmentType))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcEnergyConversionDeviceType : IfcDistributionFlowElementType
	{
		public IfcEnergyConversionDeviceType() : base()
		{
		}
		public IfcEnergyConversionDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcEngine
	/// <para>ENTITY IfcEngine</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcEngineTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcEngineTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcEngineTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCENGINETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEngine : IfcEnergyConversionDevice
	{
		public virtual IfcEngineTypeEnum? PredefinedType { get; set; }
		public IfcEngine() : base()
		{
		}
		public IfcEngine(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEngineTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEngineType
	/// <para>ENTITY IfcEngineType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcEngineTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcEngineTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcEngineTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEngineType : IfcEnergyConversionDeviceType
	{
		public virtual IfcEngineTypeEnum? PredefinedType { get; set; }
		public IfcEngineType() : base()
		{
		}
		public IfcEngineType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcEngineTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporativeCooler
	/// <para>ENTITY IfcEvaporativeCooler</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcEvaporativeCoolerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcEvaporativeCoolerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcEvaporativeCoolerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCEVAPORATIVECOOLERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporativeCooler : IfcEnergyConversionDevice
	{
		public virtual IfcEvaporativeCoolerTypeEnum? PredefinedType { get; set; }
		public IfcEvaporativeCooler() : base()
		{
		}
		public IfcEvaporativeCooler(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEvaporativeCoolerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporativeCoolerType
	/// <para>ENTITY IfcEvaporativeCoolerType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcEvaporativeCoolerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcEvaporativeCoolerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcEvaporativeCoolerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporativeCoolerType : IfcEnergyConversionDeviceType
	{
		public virtual IfcEvaporativeCoolerTypeEnum? PredefinedType { get; set; }
		public IfcEvaporativeCoolerType() : base()
		{
		}
		public IfcEvaporativeCoolerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcEvaporativeCoolerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporator
	/// <para>ENTITY IfcEvaporator</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcEvaporatorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcEvaporatorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcEvaporatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCEVAPORATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporator : IfcEnergyConversionDevice
	{
		public virtual IfcEvaporatorTypeEnum? PredefinedType { get; set; }
		public IfcEvaporator() : base()
		{
		}
		public IfcEvaporator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcEvaporatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvaporatorType
	/// <para>ENTITY IfcEvaporatorType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcEvaporatorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcEvaporatorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcEvaporatorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvaporatorType : IfcEnergyConversionDeviceType
	{
		public virtual IfcEvaporatorTypeEnum? PredefinedType { get; set; }
		public IfcEvaporatorType() : base()
		{
		}
		public IfcEvaporatorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcEvaporatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcEvent
	/// <para>ENTITY IfcEvent</para>
	/// <para>SUBTYPE OF (IfcProcess);</para>
	/// <para>PredefinedType : OPTIONAL IfcEventTypeEnum;</para>
	/// <para>EventTriggerType : OPTIONAL IfcEventTriggerTypeEnum;</para>
	/// <para>UserDefinedEventTriggerType : OPTIONAL IfcLabel;</para>
	/// <para>EventOccurenceTime : OPTIONAL IfcEventTime;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcEventTypeEnum.USERDEFINED) OR ((PredefinedType = IfcEventTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : NOT(EXISTS(EventTriggerType)) OR (EventTriggerType <> IfcEventTriggerTypeEnum.USERDEFINED) OR ((EventTriggerType = IfcEventTriggerTypeEnum.USERDEFINED) AND EXISTS(UserDefinedEventTriggerType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEvent : IfcProcess
	{
		public virtual IfcEventTypeEnum? PredefinedType { get; set; }
		public virtual IfcEventTriggerTypeEnum? EventTriggerType { get; set; }
		public virtual IfcLabel? UserDefinedEventTriggerType { get; set; }
		public virtual IfcEventTime? EventOccurenceTime { get; set; }
		public IfcEvent() : base()
		{
		}
		public IfcEvent(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcEventTypeEnum PredefinedType, IfcEventTriggerTypeEnum EventTriggerType, IfcLabel UserDefinedEventTriggerType, IfcEventTime EventOccurenceTime) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.PredefinedType = PredefinedType;
			this.EventTriggerType = EventTriggerType;
			this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
			this.EventOccurenceTime = EventOccurenceTime;
		}
	}
	/// <summary>
	/// ENTITY IfcEventTime
	/// <para>ENTITY IfcEventTime</para>
	/// <para>SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>ActualDate : OPTIONAL IfcDateTime;</para>
	/// <para>EarlyDate : OPTIONAL IfcDateTime;</para>
	/// <para>LateDate : OPTIONAL IfcDateTime;</para>
	/// <para>ScheduleDate : OPTIONAL IfcDateTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEventTime : IfcSchedulingTime
	{
		public virtual IfcDateTime? ActualDate { get; set; }
		public virtual IfcDateTime? EarlyDate { get; set; }
		public virtual IfcDateTime? LateDate { get; set; }
		public virtual IfcDateTime? ScheduleDate { get; set; }
		public IfcEventTime() : base()
		{
		}
		public IfcEventTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcDateTime ActualDate, IfcDateTime EarlyDate, IfcDateTime LateDate, IfcDateTime ScheduleDate) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.ActualDate = ActualDate;
			this.EarlyDate = EarlyDate;
			this.LateDate = LateDate;
			this.ScheduleDate = ScheduleDate;
		}
	}
	/// <summary>
	/// ENTITY IfcEventType
	/// <para>ENTITY IfcEventType</para>
	/// <para>SUBTYPE OF (IfcTypeProcess);</para>
	/// <para>PredefinedType : IfcEventTypeEnum;</para>
	/// <para>EventTriggerType : IfcEventTriggerTypeEnum;</para>
	/// <para>UserDefinedEventTriggerType : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcEventTypeEnum.USERDEFINED) OR ((PredefinedType = IfcEventTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType));</para>
	/// <para>CorrectEventTriggerType : (EventTriggerType <> IfcEventTriggerTypeEnum.USERDEFINED) OR ((EventTriggerType = IfcEventTriggerTypeEnum.USERDEFINED) AND EXISTS(UserDefinedEventTriggerType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcEventType : IfcTypeProcess
	{
		public virtual IfcEventTypeEnum? PredefinedType { get; set; }
		public virtual IfcEventTriggerTypeEnum? EventTriggerType { get; set; }
		public virtual IfcLabel? UserDefinedEventTriggerType { get; set; }
		public IfcEventType() : base()
		{
		}
		public IfcEventType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType, IfcEventTypeEnum PredefinedType, IfcEventTriggerTypeEnum EventTriggerType, IfcLabel UserDefinedEventTriggerType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType)
		{
			this.PredefinedType = PredefinedType;
			this.EventTriggerType = EventTriggerType;
			this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
		}
	}
	/// <summary>
	/// ENTITY IfcExtendedProperties
	/// <para>ENTITY IfcExtendedProperties</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMaterialProperties</para>
	/// <para>,IfcProfileProperties))</para>
	/// <para>SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>Name : OPTIONAL IfcIdentifier;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Properties : SET [1:?] OF IfcProperty;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExtendedProperties : IfcPropertyAbstraction
	{
		public virtual IfcIdentifier? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual List<IfcProperty>? Properties { get; set; }
		public IfcExtendedProperties() : base()
		{
		}
		public IfcExtendedProperties(IfcIdentifier Name, IfcText Description, List<IfcProperty> Properties) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Properties = Properties;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalInformation
	/// <para>ENTITY IfcExternalInformation</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcClassification</para>
	/// <para>,IfcDocumentInformation</para>
	/// <para>,IfcLibraryInformation));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExternalInformation : Entity, IfcResourceObjectSelect
	{
		public IfcExternalInformation() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternalReference
	/// <para>ENTITY IfcExternalReference</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcClassificationReference</para>
	/// <para>,IfcDocumentReference</para>
	/// <para>,IfcExternallyDefinedHatchStyle</para>
	/// <para>,IfcExternallyDefinedSurfaceStyle</para>
	/// <para>,IfcExternallyDefinedTextFont</para>
	/// <para>,IfcLibraryReference));</para>
	/// <para>Location : OPTIONAL IfcURIReference;</para>
	/// <para>Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>ExternalReferenceForResources : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatingReference;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : EXISTS(Identification) OR EXISTS(Location) OR EXISTS(Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExternalReference : Entity, IfcLightDistributionDataSourceSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public virtual IfcURIReference? Location { get; set; }
		public virtual IfcIdentifier? Identification { get; set; }
		public virtual IfcLabel? Name { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? ExternalReferenceForResources => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatingReference != null && x.RelatingReference == this).ToList();
		public IfcExternalReference() : base()
		{
		}
		public IfcExternalReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base ()
		{
			this.Location = Location;
			this.Identification = Identification;
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalReferenceRelationship
	/// <para>ENTITY IfcExternalReferenceRelationship</para>
	/// <para>SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>RelatingReference : IfcExternalReference;</para>
	/// <para>RelatedResourceObjects : SET [1:?] OF IfcResourceObjectSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternalReferenceRelationship : IfcResourceLevelRelationship
	{
		public virtual IfcExternalReference? RelatingReference { get; set; }
		public virtual List<IfcResourceObjectSelect>? RelatedResourceObjects { get; set; }
		public IfcExternalReferenceRelationship() : base()
		{
		}
		public IfcExternalReferenceRelationship(IfcLabel Name, IfcText Description, IfcExternalReference RelatingReference, List<IfcResourceObjectSelect> RelatedResourceObjects) : base (Name, Description)
		{
			this.RelatingReference = RelatingReference;
			this.RelatedResourceObjects = RelatedResourceObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalSpatialElement
	/// <para>ENTITY IfcExternalSpatialElement</para>
	/// <para>SUBTYPE OF (IfcExternalSpatialStructureElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcExternalSpatialElementTypeEnum;</para>
	/// <para>INVERSE</para>
	/// <para>BoundedBy : SET [0:?] OF IfcRelSpaceBoundary FOR RelatingSpace;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternalSpatialElement : IfcExternalSpatialStructureElement, IfcSpaceBoundarySelect
	{
		public virtual IfcExternalSpatialElementTypeEnum? PredefinedType { get; set; }
		//TODO INVERSE
		public List<IfcRelSpaceBoundary>? BoundedBy => Model?.GetItems<IfcRelSpaceBoundary>().Where(x => x.RelatingSpace != null && x.RelatingSpace == this).ToList();
		public IfcExternalSpatialElement() : base()
		{
		}
		public IfcExternalSpatialElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcExternalSpatialElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcExternalSpatialStructureElement
	/// <para>ENTITY IfcExternalSpatialStructureElement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcExternalSpatialElement))</para>
	/// <para>SUBTYPE OF (IfcSpatialElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcExternalSpatialStructureElement : IfcSpatialElement
	{
		public IfcExternalSpatialStructureElement() : base()
		{
		}
		public IfcExternalSpatialStructureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternallyDefinedHatchStyle
	/// <para>ENTITY IfcExternallyDefinedHatchStyle</para>
	/// <para>SUBTYPE OF (IfcExternalReference);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternallyDefinedHatchStyle : IfcExternalReference, IfcFillStyleSelect
	{
		public IfcExternallyDefinedHatchStyle() : base()
		{
		}
		public IfcExternallyDefinedHatchStyle(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base (Location, Identification, Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternallyDefinedSurfaceStyle
	/// <para>ENTITY IfcExternallyDefinedSurfaceStyle</para>
	/// <para>SUBTYPE OF (IfcExternalReference);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternallyDefinedSurfaceStyle : IfcExternalReference, IfcSurfaceStyleElementSelect
	{
		public IfcExternallyDefinedSurfaceStyle() : base()
		{
		}
		public IfcExternallyDefinedSurfaceStyle(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base (Location, Identification, Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExternallyDefinedTextFont
	/// <para>ENTITY IfcExternallyDefinedTextFont</para>
	/// <para>SUBTYPE OF (IfcExternalReference);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExternallyDefinedTextFont : IfcExternalReference, IfcTextFontSelect
	{
		public IfcExternallyDefinedTextFont() : base()
		{
		}
		public IfcExternallyDefinedTextFont(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name) : base (Location, Identification, Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcExtrudedAreaSolid
	/// <para>ENTITY IfcExtrudedAreaSolid</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcExtrudedAreaSolidTapered))</para>
	/// <para>SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>ExtrudedDirection : IfcDirection;</para>
	/// <para>Depth : IfcPositiveLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidExtrusionDirection : IfcDotProduct(IfcRepresentationItem() || IfcGeometricRepresentationItem() || IfcDirection([0.0,0.0,1.0]), SELF.ExtrudedDirection) <> 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExtrudedAreaSolid : IfcSweptAreaSolid
	{
		public virtual IfcDirection? ExtrudedDirection { get; set; }
		public virtual IfcPositiveLengthMeasure? Depth { get; set; }
		public IfcExtrudedAreaSolid() : base()
		{
		}
		public IfcExtrudedAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcDirection ExtrudedDirection, IfcPositiveLengthMeasure Depth) : base (SweptArea, Position)
		{
			this.ExtrudedDirection = ExtrudedDirection;
			this.Depth = Depth;
		}
	}
	/// <summary>
	/// ENTITY IfcExtrudedAreaSolidTapered
	/// <para>ENTITY IfcExtrudedAreaSolidTapered</para>
	/// <para>SUBTYPE OF (IfcExtrudedAreaSolid);</para>
	/// <para>EndSweptArea : IfcProfileDef;</para>
	/// <para>WHERE</para>
	/// <para>CorrectProfileAssignment : IfcTaperedSweptAreaProfiles(SELF\IfcSweptAreaSolid.SweptArea, SELF.EndSweptArea);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcExtrudedAreaSolidTapered : IfcExtrudedAreaSolid
	{
		public virtual IfcProfileDef? EndSweptArea { get; set; }
		public IfcExtrudedAreaSolidTapered() : base()
		{
		}
		public IfcExtrudedAreaSolidTapered(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcDirection ExtrudedDirection, IfcPositiveLengthMeasure Depth, IfcProfileDef EndSweptArea) : base (SweptArea, Position, ExtrudedDirection, Depth)
		{
			this.EndSweptArea = EndSweptArea;
		}
	}
	/// <summary>
	/// ENTITY IfcFace
	/// <para>ENTITY IfcFace</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcFaceSurface))</para>
	/// <para>SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>Bounds : SET [1:?] OF IfcFaceBound;</para>
	/// <para>INVERSE</para>
	/// <para>HasTextureMaps : SET [0:?] OF IfcTextureMap FOR MappedTo;</para>
	/// <para>WHERE</para>
	/// <para>HasOuterBound : SIZEOF(QUERY(temp <* Bounds | 'IFC4X1.IFCFACEOUTERBOUND' IN TYPEOF(temp))) <= 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFace : IfcTopologicalRepresentationItem
	{
		public virtual List<IfcFaceBound>? Bounds { get; set; }
		//TODO INVERSE
		public List<IfcTextureMap>? HasTextureMaps => Model?.GetItems<IfcTextureMap>().Where(x => x.MappedTo != null && x.MappedTo == this).ToList();
		public IfcFace() : base()
		{
		}
		public IfcFace(List<IfcFaceBound> Bounds) : base ()
		{
			this.Bounds = Bounds;
		}
	}
	/// <summary>
	/// ENTITY IfcFaceBasedSurfaceModel
	/// <para>ENTITY IfcFaceBasedSurfaceModel</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>FbsmFaces : SET [1:?] OF IfcConnectedFaceSet;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceBasedSurfaceModel : IfcGeometricRepresentationItem, IfcSurfaceOrFaceSurface
	{
		public virtual List<IfcConnectedFaceSet>? FbsmFaces { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcFaceBasedSurfaceModel() : base()
		{
		}
		public IfcFaceBasedSurfaceModel(List<IfcConnectedFaceSet> FbsmFaces) : base ()
		{
			this.FbsmFaces = FbsmFaces;
		}
	}
	/// <summary>
	/// ENTITY IfcFaceBound
	/// <para>ENTITY IfcFaceBound</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcFaceOuterBound))</para>
	/// <para>SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>Bound : IfcLoop;</para>
	/// <para>Orientation : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceBound : IfcTopologicalRepresentationItem
	{
		public virtual IfcLoop? Bound { get; set; }
		public virtual IfcBoolean? Orientation { get; set; }
		public IfcFaceBound() : base()
		{
		}
		public IfcFaceBound(IfcLoop Bound, IfcBoolean Orientation) : base ()
		{
			this.Bound = Bound;
			this.Orientation = Orientation;
		}
	}
	/// <summary>
	/// ENTITY IfcFaceOuterBound
	/// <para>ENTITY IfcFaceOuterBound</para>
	/// <para>SUBTYPE OF (IfcFaceBound);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceOuterBound : IfcFaceBound
	{
		public IfcFaceOuterBound() : base()
		{
		}
		public IfcFaceOuterBound(IfcLoop Bound, IfcBoolean Orientation) : base (Bound, Orientation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFaceSurface
	/// <para>ENTITY IfcFaceSurface</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAdvancedFace))</para>
	/// <para>SUBTYPE OF (IfcFace);</para>
	/// <para>FaceSurface : IfcSurface;</para>
	/// <para>SameSense : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFaceSurface : IfcFace, IfcSurfaceOrFaceSurface
	{
		public virtual IfcSurface? FaceSurface { get; set; }
		public virtual IfcBoolean? SameSense { get; set; }
		public IfcFaceSurface() : base()
		{
		}
		public IfcFaceSurface(List<IfcFaceBound> Bounds, IfcSurface FaceSurface, IfcBoolean SameSense) : base (Bounds)
		{
			this.FaceSurface = FaceSurface;
			this.SameSense = SameSense;
		}
	}
	/// <summary>
	/// ENTITY IfcFacetedBrep
	/// <para>ENTITY IfcFacetedBrep</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcFacetedBrepWithVoids))</para>
	/// <para>SUBTYPE OF (IfcManifoldSolidBrep);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFacetedBrep : IfcManifoldSolidBrep
	{
		public IfcFacetedBrep() : base()
		{
		}
		public IfcFacetedBrep(IfcClosedShell Outer) : base (Outer)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFacetedBrepWithVoids
	/// <para>ENTITY IfcFacetedBrepWithVoids</para>
	/// <para>SUBTYPE OF (IfcFacetedBrep);</para>
	/// <para>Voids : SET [1:?] OF IfcClosedShell;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFacetedBrepWithVoids : IfcFacetedBrep
	{
		public virtual List<IfcClosedShell>? Voids { get; set; }
		public IfcFacetedBrepWithVoids() : base()
		{
		}
		public IfcFacetedBrepWithVoids(IfcClosedShell Outer, List<IfcClosedShell> Voids) : base (Outer)
		{
			this.Voids = Voids;
		}
	}
	/// <summary>
	/// ENTITY IfcFailureConnectionCondition
	/// <para>ENTITY IfcFailureConnectionCondition</para>
	/// <para>SUBTYPE OF (IfcStructuralConnectionCondition);</para>
	/// <para>TensionFailureX : OPTIONAL IfcForceMeasure;</para>
	/// <para>TensionFailureY : OPTIONAL IfcForceMeasure;</para>
	/// <para>TensionFailureZ : OPTIONAL IfcForceMeasure;</para>
	/// <para>CompressionFailureX : OPTIONAL IfcForceMeasure;</para>
	/// <para>CompressionFailureY : OPTIONAL IfcForceMeasure;</para>
	/// <para>CompressionFailureZ : OPTIONAL IfcForceMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFailureConnectionCondition : IfcStructuralConnectionCondition
	{
		public virtual IfcForceMeasure? TensionFailureX { get; set; }
		public virtual IfcForceMeasure? TensionFailureY { get; set; }
		public virtual IfcForceMeasure? TensionFailureZ { get; set; }
		public virtual IfcForceMeasure? CompressionFailureX { get; set; }
		public virtual IfcForceMeasure? CompressionFailureY { get; set; }
		public virtual IfcForceMeasure? CompressionFailureZ { get; set; }
		public IfcFailureConnectionCondition() : base()
		{
		}
		public IfcFailureConnectionCondition(IfcLabel Name, IfcForceMeasure TensionFailureX, IfcForceMeasure TensionFailureY, IfcForceMeasure TensionFailureZ, IfcForceMeasure CompressionFailureX, IfcForceMeasure CompressionFailureY, IfcForceMeasure CompressionFailureZ) : base (Name)
		{
			this.TensionFailureX = TensionFailureX;
			this.TensionFailureY = TensionFailureY;
			this.TensionFailureZ = TensionFailureZ;
			this.CompressionFailureX = CompressionFailureX;
			this.CompressionFailureY = CompressionFailureY;
			this.CompressionFailureZ = CompressionFailureZ;
		}
	}
	/// <summary>
	/// ENTITY IfcFan
	/// <para>ENTITY IfcFan</para>
	/// <para>SUBTYPE OF (IfcFlowMovingDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcFanTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcFanTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFanTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCFANTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFan : IfcFlowMovingDevice
	{
		public virtual IfcFanTypeEnum? PredefinedType { get; set; }
		public IfcFan() : base()
		{
		}
		public IfcFan(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFanTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFanType
	/// <para>ENTITY IfcFanType</para>
	/// <para>SUBTYPE OF (IfcFlowMovingDeviceType);</para>
	/// <para>PredefinedType : IfcFanTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcFanTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFanTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFanType : IfcFlowMovingDeviceType
	{
		public virtual IfcFanTypeEnum? PredefinedType { get; set; }
		public IfcFanType() : base()
		{
		}
		public IfcFanType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFanTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFastener
	/// <para>ENTITY IfcFastener</para>
	/// <para>SUBTYPE OF (IfcElementComponent);</para>
	/// <para>PredefinedType : OPTIONAL IfcFastenerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFastenerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCFASTENERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFastener : IfcElementComponent
	{
		public virtual IfcFastenerTypeEnum? PredefinedType { get; set; }
		public IfcFastener() : base()
		{
		}
		public IfcFastener(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFastenerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFastenerType
	/// <para>ENTITY IfcFastenerType</para>
	/// <para>SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>PredefinedType : IfcFastenerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFastenerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFastenerType : IfcElementComponentType
	{
		public virtual IfcFastenerTypeEnum? PredefinedType { get; set; }
		public IfcFastenerType() : base()
		{
		}
		public IfcFastenerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFastenerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFeatureElement
	/// <para>ENTITY IfcFeatureElement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcFeatureElementAddition</para>
	/// <para>,IfcFeatureElementSubtraction</para>
	/// <para>,IfcSurfaceFeature))</para>
	/// <para>SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFeatureElement : IfcElement
	{
		public IfcFeatureElement() : base()
		{
		}
		public IfcFeatureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFeatureElementAddition
	/// <para>ENTITY IfcFeatureElementAddition</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcProjectionElement))</para>
	/// <para>SUBTYPE OF (IfcFeatureElement);</para>
	/// <para>INVERSE</para>
	/// <para>ProjectsElements : IfcRelProjectsElement FOR RelatedFeatureElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFeatureElementAddition : IfcFeatureElement
	{
		//TODO INVERSE
		public IfcRelProjectsElement? ProjectsElements => Model?.GetItems<IfcRelProjectsElement>().FirstOrDefault(x => x.RelatedFeatureElement != null && x.RelatedFeatureElement == this);
		public IfcFeatureElementAddition() : base()
		{
		}
		public IfcFeatureElementAddition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFeatureElementSubtraction
	/// <para>ENTITY IfcFeatureElementSubtraction</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcOpeningElement</para>
	/// <para>,IfcVoidingFeature))</para>
	/// <para>SUBTYPE OF (IfcFeatureElement);</para>
	/// <para>INVERSE</para>
	/// <para>VoidsElements : IfcRelVoidsElement FOR RelatedOpeningElement;</para>
	/// <para>WHERE</para>
	/// <para>HasNoSubtraction : SIZEOF(SELF\IfcElement.HasOpenings) = 0;</para>
	/// <para>IsNotFilling : SIZEOF(SELF\IfcElement.FillsVoids) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFeatureElementSubtraction : IfcFeatureElement
	{
		//TODO INVERSE
		public IfcRelVoidsElement? VoidsElements => Model?.GetItems<IfcRelVoidsElement>().FirstOrDefault(x => x.RelatedOpeningElement != null && x.RelatedOpeningElement == this);
		public IfcFeatureElementSubtraction() : base()
		{
		}
		public IfcFeatureElementSubtraction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFillAreaStyle
	/// <para>ENTITY IfcFillAreaStyle</para>
	/// <para>SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>FillStyles : SET [1:?] OF IfcFillStyleSelect;</para>
	/// <para>ModelorDraughting : OPTIONAL IfcBoolean;</para>
	/// <para>WHERE</para>
	/// <para>MaxOneColour : SIZEOF(QUERY(Style <* SELF.FillStyles |</para>
	/// <para>'IFC4X1.IFCCOLOUR' IN</para>
	/// <para>TYPEOF(Style)</para>
	/// <para>)) <= 1;</para>
	/// <para>MaxOneExtHatchStyle : SIZEOF(QUERY(Style <* SELF.FillStyles |</para>
	/// <para>'IFC4X1.IFCEXTERNALLYDEFINEDHATCHSTYLE' IN</para>
	/// <para>TYPEOF(Style)</para>
	/// <para>)) <= 1;</para>
	/// <para>ConsistentHatchStyleDef : IfcCorrectFillAreaStyle(SELF.FillStyles);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFillAreaStyle : IfcPresentationStyle, IfcPresentationStyleSelect
	{
		public virtual List<IfcFillStyleSelect>? FillStyles { get; set; }
		public virtual IfcBoolean? ModelorDraughting { get; set; }
		public IfcFillAreaStyle() : base()
		{
		}
		public IfcFillAreaStyle(IfcLabel Name, List<IfcFillStyleSelect> FillStyles, IfcBoolean ModelorDraughting) : base (Name)
		{
			this.FillStyles = FillStyles;
			this.ModelorDraughting = ModelorDraughting;
		}
	}
	/// <summary>
	/// ENTITY IfcFillAreaStyleHatching
	/// <para>ENTITY IfcFillAreaStyleHatching</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>HatchLineAppearance : IfcCurveStyle;</para>
	/// <para>StartOfNextHatchLine : IfcHatchLineDistanceSelect;</para>
	/// <para>PointOfReferenceHatchLine : OPTIONAL IfcCartesianPoint;</para>
	/// <para>PatternStart : OPTIONAL IfcCartesianPoint;</para>
	/// <para>HatchLineAngle : IfcPlaneAngleMeasure;</para>
	/// <para>WHERE</para>
	/// <para>PatternStart2D : NOT(EXISTS(PatternStart)) OR (PatternStart.Dim = 2);</para>
	/// <para>RefHatchLine2D : NOT(EXISTS(PointOfReferenceHatchLine)) OR (PointOfReferenceHatchLine.Dim = 2);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFillAreaStyleHatching : IfcGeometricRepresentationItem, IfcFillStyleSelect
	{
		public virtual IfcCurveStyle? HatchLineAppearance { get; set; }
		public virtual IfcHatchLineDistanceSelect? StartOfNextHatchLine { get; set; }
		public virtual IfcCartesianPoint? PointOfReferenceHatchLine { get; set; }
		public virtual IfcCartesianPoint? PatternStart { get; set; }
		public virtual IfcPlaneAngleMeasure? HatchLineAngle { get; set; }
		public IfcFillAreaStyleHatching() : base()
		{
		}
		public IfcFillAreaStyleHatching(IfcCurveStyle HatchLineAppearance, IfcHatchLineDistanceSelect StartOfNextHatchLine, IfcCartesianPoint PointOfReferenceHatchLine, IfcCartesianPoint PatternStart, IfcPlaneAngleMeasure HatchLineAngle) : base ()
		{
			this.HatchLineAppearance = HatchLineAppearance;
			this.StartOfNextHatchLine = StartOfNextHatchLine;
			this.PointOfReferenceHatchLine = PointOfReferenceHatchLine;
			this.PatternStart = PatternStart;
			this.HatchLineAngle = HatchLineAngle;
		}
	}
	/// <summary>
	/// ENTITY IfcFillAreaStyleTiles
	/// <para>ENTITY IfcFillAreaStyleTiles</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>TilingPattern : LIST [2:2] OF IfcVector;</para>
	/// <para>Tiles : SET [1:?] OF IfcStyledItem;</para>
	/// <para>TilingScale : IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFillAreaStyleTiles : IfcGeometricRepresentationItem, IfcFillStyleSelect
	{
		public virtual List<IfcVector>? TilingPattern { get; set; }
		public virtual List<IfcStyledItem>? Tiles { get; set; }
		public virtual IfcPositiveRatioMeasure? TilingScale { get; set; }
		public IfcFillAreaStyleTiles() : base()
		{
		}
		public IfcFillAreaStyleTiles(List<IfcVector> TilingPattern, List<IfcStyledItem> Tiles, IfcPositiveRatioMeasure TilingScale) : base ()
		{
			this.TilingPattern = TilingPattern;
			this.Tiles = Tiles;
			this.TilingScale = TilingScale;
		}
	}
	/// <summary>
	/// ENTITY IfcFilter
	/// <para>ENTITY IfcFilter</para>
	/// <para>SUBTYPE OF (IfcFlowTreatmentDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcFilterTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcFilterTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFilterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCFILTERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFilter : IfcFlowTreatmentDevice
	{
		public virtual IfcFilterTypeEnum? PredefinedType { get; set; }
		public IfcFilter() : base()
		{
		}
		public IfcFilter(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFilterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFilterType
	/// <para>ENTITY IfcFilterType</para>
	/// <para>SUBTYPE OF (IfcFlowTreatmentDeviceType);</para>
	/// <para>PredefinedType : IfcFilterTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcFilterTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFilterTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFilterType : IfcFlowTreatmentDeviceType
	{
		public virtual IfcFilterTypeEnum? PredefinedType { get; set; }
		public IfcFilterType() : base()
		{
		}
		public IfcFilterType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFilterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFireSuppressionTerminal
	/// <para>ENTITY IfcFireSuppressionTerminal</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcFireSuppressionTerminalTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcFireSuppressionTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFireSuppressionTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCFIRESUPPRESSIONTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFireSuppressionTerminal : IfcFlowTerminal
	{
		public virtual IfcFireSuppressionTerminalTypeEnum? PredefinedType { get; set; }
		public IfcFireSuppressionTerminal() : base()
		{
		}
		public IfcFireSuppressionTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFireSuppressionTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFireSuppressionTerminalType
	/// <para>ENTITY IfcFireSuppressionTerminalType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcFireSuppressionTerminalTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcFireSuppressionTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFireSuppressionTerminalTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFireSuppressionTerminalType : IfcFlowTerminalType
	{
		public virtual IfcFireSuppressionTerminalTypeEnum? PredefinedType { get; set; }
		public IfcFireSuppressionTerminalType() : base()
		{
		}
		public IfcFireSuppressionTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFireSuppressionTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFixedReferenceSweptAreaSolid
	/// <para>ENTITY IfcFixedReferenceSweptAreaSolid</para>
	/// <para>SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>Directrix : IfcCurve;</para>
	/// <para>StartParam : OPTIONAL IfcParameterValue;</para>
	/// <para>EndParam : OPTIONAL IfcParameterValue;</para>
	/// <para>FixedReference : IfcDirection;</para>
	/// <para>WHERE</para>
	/// <para>DirectrixBounded : (EXISTS(StartParam) AND EXISTS(EndParam)) OR</para>
	/// <para>(SIZEOF(['IFC4X1.IFCCONIC', 'IFC4X1.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFixedReferenceSweptAreaSolid : IfcSweptAreaSolid
	{
		public virtual IfcCurve? Directrix { get; set; }
		public virtual IfcParameterValue? StartParam { get; set; }
		public virtual IfcParameterValue? EndParam { get; set; }
		public virtual IfcDirection? FixedReference { get; set; }
		public IfcFixedReferenceSweptAreaSolid() : base()
		{
		}
		public IfcFixedReferenceSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcCurve Directrix, IfcParameterValue StartParam, IfcParameterValue EndParam, IfcDirection FixedReference) : base (SweptArea, Position)
		{
			this.Directrix = Directrix;
			this.StartParam = StartParam;
			this.EndParam = EndParam;
			this.FixedReference = FixedReference;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowController
	/// <para>ENTITY IfcFlowController</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAirTerminalBox</para>
	/// <para>,IfcDamper</para>
	/// <para>,IfcElectricDistributionBoard</para>
	/// <para>,IfcElectricTimeControl</para>
	/// <para>,IfcFlowMeter</para>
	/// <para>,IfcProtectiveDevice</para>
	/// <para>,IfcSwitchingDevice</para>
	/// <para>,IfcValve))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowController : IfcDistributionFlowElement
	{
		public IfcFlowController() : base()
		{
		}
		public IfcFlowController(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowControllerType
	/// <para>ENTITY IfcFlowControllerType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAirTerminalBoxType</para>
	/// <para>,IfcDamperType</para>
	/// <para>,IfcElectricDistributionBoardType</para>
	/// <para>,IfcElectricTimeControlType</para>
	/// <para>,IfcFlowMeterType</para>
	/// <para>,IfcProtectiveDeviceType</para>
	/// <para>,IfcSwitchingDeviceType</para>
	/// <para>,IfcValveType))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowControllerType : IfcDistributionFlowElementType
	{
		public IfcFlowControllerType() : base()
		{
		}
		public IfcFlowControllerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowFitting
	/// <para>ENTITY IfcFlowFitting</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCableCarrierFitting</para>
	/// <para>,IfcCableFitting</para>
	/// <para>,IfcDuctFitting</para>
	/// <para>,IfcJunctionBox</para>
	/// <para>,IfcPipeFitting))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowFitting : IfcDistributionFlowElement
	{
		public IfcFlowFitting() : base()
		{
		}
		public IfcFlowFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowFittingType
	/// <para>ENTITY IfcFlowFittingType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCableCarrierFittingType</para>
	/// <para>,IfcCableFittingType</para>
	/// <para>,IfcDuctFittingType</para>
	/// <para>,IfcJunctionBoxType</para>
	/// <para>,IfcPipeFittingType))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowFittingType : IfcDistributionFlowElementType
	{
		public IfcFlowFittingType() : base()
		{
		}
		public IfcFlowFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowInstrument
	/// <para>ENTITY IfcFlowInstrument</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcFlowInstrumentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcFlowInstrumentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFlowInstrumentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCFLOWINSTRUMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowInstrument : IfcDistributionControlElement
	{
		public virtual IfcFlowInstrumentTypeEnum? PredefinedType { get; set; }
		public IfcFlowInstrument() : base()
		{
		}
		public IfcFlowInstrument(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFlowInstrumentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowInstrumentType
	/// <para>ENTITY IfcFlowInstrumentType</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>PredefinedType : IfcFlowInstrumentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcFlowInstrumentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFlowInstrumentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowInstrumentType : IfcDistributionControlElementType
	{
		public virtual IfcFlowInstrumentTypeEnum? PredefinedType { get; set; }
		public IfcFlowInstrumentType() : base()
		{
		}
		public IfcFlowInstrumentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFlowInstrumentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMeter
	/// <para>ENTITY IfcFlowMeter</para>
	/// <para>SUBTYPE OF (IfcFlowController);</para>
	/// <para>PredefinedType : OPTIONAL IfcFlowMeterTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcFlowMeterTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFlowMeterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCFLOWMETERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowMeter : IfcFlowController
	{
		public virtual IfcFlowMeterTypeEnum? PredefinedType { get; set; }
		public IfcFlowMeter() : base()
		{
		}
		public IfcFlowMeter(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFlowMeterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMeterType
	/// <para>ENTITY IfcFlowMeterType</para>
	/// <para>SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>PredefinedType : IfcFlowMeterTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcFlowMeterTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFlowMeterTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowMeterType : IfcFlowControllerType
	{
		public virtual IfcFlowMeterTypeEnum? PredefinedType { get; set; }
		public IfcFlowMeterType() : base()
		{
		}
		public IfcFlowMeterType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFlowMeterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMovingDevice
	/// <para>ENTITY IfcFlowMovingDevice</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCompressor</para>
	/// <para>,IfcFan</para>
	/// <para>,IfcPump))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowMovingDevice : IfcDistributionFlowElement
	{
		public IfcFlowMovingDevice() : base()
		{
		}
		public IfcFlowMovingDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowMovingDeviceType
	/// <para>ENTITY IfcFlowMovingDeviceType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCompressorType</para>
	/// <para>,IfcFanType</para>
	/// <para>,IfcPumpType))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowMovingDeviceType : IfcDistributionFlowElementType
	{
		public IfcFlowMovingDeviceType() : base()
		{
		}
		public IfcFlowMovingDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowSegment
	/// <para>ENTITY IfcFlowSegment</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCableCarrierSegment</para>
	/// <para>,IfcCableSegment</para>
	/// <para>,IfcDuctSegment</para>
	/// <para>,IfcPipeSegment))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowSegment : IfcDistributionFlowElement
	{
		public IfcFlowSegment() : base()
		{
		}
		public IfcFlowSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowSegmentType
	/// <para>ENTITY IfcFlowSegmentType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCableCarrierSegmentType</para>
	/// <para>,IfcCableSegmentType</para>
	/// <para>,IfcDuctSegmentType</para>
	/// <para>,IfcPipeSegmentType))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowSegmentType : IfcDistributionFlowElementType
	{
		public IfcFlowSegmentType() : base()
		{
		}
		public IfcFlowSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowStorageDevice
	/// <para>ENTITY IfcFlowStorageDevice</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcElectricFlowStorageDevice</para>
	/// <para>,IfcTank))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowStorageDevice : IfcDistributionFlowElement
	{
		public IfcFlowStorageDevice() : base()
		{
		}
		public IfcFlowStorageDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowStorageDeviceType
	/// <para>ENTITY IfcFlowStorageDeviceType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcElectricFlowStorageDeviceType</para>
	/// <para>,IfcTankType))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowStorageDeviceType : IfcDistributionFlowElementType
	{
		public IfcFlowStorageDeviceType() : base()
		{
		}
		public IfcFlowStorageDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTerminal
	/// <para>ENTITY IfcFlowTerminal</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAirTerminal</para>
	/// <para>,IfcAudioVisualAppliance</para>
	/// <para>,IfcCommunicationsAppliance</para>
	/// <para>,IfcElectricAppliance</para>
	/// <para>,IfcFireSuppressionTerminal</para>
	/// <para>,IfcLamp</para>
	/// <para>,IfcLightFixture</para>
	/// <para>,IfcMedicalDevice</para>
	/// <para>,IfcOutlet</para>
	/// <para>,IfcSanitaryTerminal</para>
	/// <para>,IfcSpaceHeater</para>
	/// <para>,IfcStackTerminal</para>
	/// <para>,IfcWasteTerminal))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowTerminal : IfcDistributionFlowElement
	{
		public IfcFlowTerminal() : base()
		{
		}
		public IfcFlowTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTerminalType
	/// <para>ENTITY IfcFlowTerminalType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAirTerminalType</para>
	/// <para>,IfcAudioVisualApplianceType</para>
	/// <para>,IfcCommunicationsApplianceType</para>
	/// <para>,IfcElectricApplianceType</para>
	/// <para>,IfcFireSuppressionTerminalType</para>
	/// <para>,IfcLampType</para>
	/// <para>,IfcLightFixtureType</para>
	/// <para>,IfcMedicalDeviceType</para>
	/// <para>,IfcOutletType</para>
	/// <para>,IfcSanitaryTerminalType</para>
	/// <para>,IfcSpaceHeaterType</para>
	/// <para>,IfcStackTerminalType</para>
	/// <para>,IfcWasteTerminalType))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowTerminalType : IfcDistributionFlowElementType
	{
		public IfcFlowTerminalType() : base()
		{
		}
		public IfcFlowTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTreatmentDevice
	/// <para>ENTITY IfcFlowTreatmentDevice</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDuctSilencer</para>
	/// <para>,IfcFilter</para>
	/// <para>,IfcInterceptor))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFlowTreatmentDevice : IfcDistributionFlowElement
	{
		public IfcFlowTreatmentDevice() : base()
		{
		}
		public IfcFlowTreatmentDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFlowTreatmentDeviceType
	/// <para>ENTITY IfcFlowTreatmentDeviceType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDuctSilencerType</para>
	/// <para>,IfcFilterType</para>
	/// <para>,IfcInterceptorType))</para>
	/// <para>SUBTYPE OF (IfcDistributionFlowElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcFlowTreatmentDeviceType : IfcDistributionFlowElementType
	{
		public IfcFlowTreatmentDeviceType() : base()
		{
		}
		public IfcFlowTreatmentDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFooting
	/// <para>ENTITY IfcFooting</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcFootingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT EXISTS(PredefinedType) OR</para>
	/// <para>(PredefinedType <> IfcFootingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFootingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCFOOTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFooting : IfcBuildingElement
	{
		public virtual IfcFootingTypeEnum? PredefinedType { get; set; }
		public IfcFooting() : base()
		{
		}
		public IfcFooting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFootingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFootingType
	/// <para>ENTITY IfcFootingType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcFootingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcFootingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFootingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFootingType : IfcBuildingElementType
	{
		public virtual IfcFootingTypeEnum? PredefinedType { get; set; }
		public IfcFootingType() : base()
		{
		}
		public IfcFootingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcFootingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFurnishingElement
	/// <para>ENTITY IfcFurnishingElement</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcFurniture</para>
	/// <para>,IfcSystemFurnitureElement))</para>
	/// <para>SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurnishingElement : IfcElement
	{
		public IfcFurnishingElement() : base()
		{
		}
		public IfcFurnishingElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFurnishingElementType
	/// <para>ENTITY IfcFurnishingElementType</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcFurnitureType</para>
	/// <para>,IfcSystemFurnitureElementType))</para>
	/// <para>SUBTYPE OF (IfcElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurnishingElementType : IfcElementType
	{
		public IfcFurnishingElementType() : base()
		{
		}
		public IfcFurnishingElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcFurniture
	/// <para>ENTITY IfcFurniture</para>
	/// <para>SUBTYPE OF (IfcFurnishingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcFurnitureTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcFurnitureTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFurnitureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCFURNITURETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurniture : IfcFurnishingElement
	{
		public virtual IfcFurnitureTypeEnum? PredefinedType { get; set; }
		public IfcFurniture() : base()
		{
		}
		public IfcFurniture(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcFurnitureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcFurnitureType
	/// <para>ENTITY IfcFurnitureType</para>
	/// <para>SUBTYPE OF (IfcFurnishingElementType);</para>
	/// <para>AssemblyPlace : IfcAssemblyPlaceEnum;</para>
	/// <para>PredefinedType : OPTIONAL IfcFurnitureTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcFurnitureTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcFurnitureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcFurnitureType : IfcFurnishingElementType
	{
		public virtual IfcAssemblyPlaceEnum? AssemblyPlace { get; set; }
		public virtual IfcFurnitureTypeEnum? PredefinedType { get; set; }
		public IfcFurnitureType() : base()
		{
		}
		public IfcFurnitureType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcAssemblyPlaceEnum AssemblyPlace, IfcFurnitureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.AssemblyPlace = AssemblyPlace;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcGeographicElement
	/// <para>ENTITY IfcGeographicElement</para>
	/// <para>SUBTYPE OF (IfcElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcGeographicElementTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcGeographicElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcGeographicElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCGEOGRAPHICELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeographicElement : IfcElement
	{
		public virtual IfcGeographicElementTypeEnum? PredefinedType { get; set; }
		public IfcGeographicElement() : base()
		{
		}
		public IfcGeographicElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcGeographicElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcGeographicElementType
	/// <para>ENTITY IfcGeographicElementType</para>
	/// <para>SUBTYPE OF (IfcElementType);</para>
	/// <para>PredefinedType : IfcGeographicElementTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcGeographicElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcGeographicElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeographicElementType : IfcElementType
	{
		public virtual IfcGeographicElementTypeEnum? PredefinedType { get; set; }
		public IfcGeographicElementType() : base()
		{
		}
		public IfcGeographicElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcGeographicElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricCurveSet
	/// <para>ENTITY IfcGeometricCurveSet</para>
	/// <para>SUBTYPE OF (IfcGeometricSet);</para>
	/// <para>WHERE</para>
	/// <para>NoSurfaces : SIZEOF(QUERY(Temp <* SELF\IfcGeometricSet.Elements |</para>
	/// <para>'IFC4X1.IFCSURFACE' IN TYPEOF(Temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricCurveSet : IfcGeometricSet
	{
		public IfcGeometricCurveSet() : base()
		{
		}
		public IfcGeometricCurveSet(List<IfcGeometricSetSelect> Elements) : base (Elements)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricRepresentationContext
	/// <para>ENTITY IfcGeometricRepresentationContext</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcGeometricRepresentationSubContext))</para>
	/// <para>SUBTYPE OF (IfcRepresentationContext);</para>
	/// <para>CoordinateSpaceDimension : IfcDimensionCount;</para>
	/// <para>Precision : OPTIONAL IfcReal;</para>
	/// <para>WorldCoordinateSystem : IfcAxis2Placement;</para>
	/// <para>TrueNorth : OPTIONAL IfcDirection;</para>
	/// <para>INVERSE</para>
	/// <para>HasSubContexts : SET [0:?] OF IfcGeometricRepresentationSubContext FOR ParentContext;</para>
	/// <para>HasCoordinateOperation : SET [0:1] OF IfcCoordinateOperation FOR SourceCRS;</para>
	/// <para>WHERE</para>
	/// <para>North2D : NOT(EXISTS(TrueNorth)) OR (HIINDEX(TrueNorth.DirectionRatios) = 2);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricRepresentationContext : IfcRepresentationContext, IfcCoordinateReferenceSystemSelect
	{
		public virtual IfcDimensionCount? CoordinateSpaceDimension { get; set; }
		public virtual IfcReal? Precision { get; set; }
		public virtual IfcAxis2Placement? WorldCoordinateSystem { get; set; }
		public virtual IfcDirection? TrueNorth { get; set; }
		//TODO INVERSE
		public List<IfcGeometricRepresentationSubContext>? HasSubContexts => Model?.GetItems<IfcGeometricRepresentationSubContext>().Where(x => x.ParentContext != null && x.ParentContext == this).ToList();
		//TODO INVERSE
		public List<IfcCoordinateOperation>? HasCoordinateOperation => Model?.GetItems<IfcCoordinateOperation>().Where(x => x.SourceCRS != null && x.SourceCRS == this).ToList();
		public IfcGeometricRepresentationContext() : base()
		{
		}
		public IfcGeometricRepresentationContext(IfcLabel ContextIdentifier, IfcLabel ContextType, IfcDimensionCount CoordinateSpaceDimension, IfcReal Precision, IfcAxis2Placement WorldCoordinateSystem, IfcDirection TrueNorth) : base (ContextIdentifier, ContextType)
		{
			this.CoordinateSpaceDimension = CoordinateSpaceDimension;
			this.Precision = Precision;
			this.WorldCoordinateSystem = WorldCoordinateSystem;
			this.TrueNorth = TrueNorth;
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricRepresentationItem
	/// <para>ENTITY IfcGeometricRepresentationItem</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAlignment2DHorizontal</para>
	/// <para>,IfcAlignment2DSegment</para>
	/// <para>,IfcAlignment2DVertical</para>
	/// <para>,IfcAnnotationFillArea</para>
	/// <para>,IfcBooleanResult</para>
	/// <para>,IfcBoundingBox</para>
	/// <para>,IfcCartesianPointList</para>
	/// <para>,IfcCartesianTransformationOperator</para>
	/// <para>,IfcCompositeCurveSegment</para>
	/// <para>,IfcCsgPrimitive3D</para>
	/// <para>,IfcCurve</para>
	/// <para>,IfcDirection</para>
	/// <para>,IfcDistanceExpression</para>
	/// <para>,IfcFaceBasedSurfaceModel</para>
	/// <para>,IfcFillAreaStyleHatching</para>
	/// <para>,IfcFillAreaStyleTiles</para>
	/// <para>,IfcGeometricSet</para>
	/// <para>,IfcHalfSpaceSolid</para>
	/// <para>,IfcLightSource</para>
	/// <para>,IfcOrientationExpression</para>
	/// <para>,IfcPlacement</para>
	/// <para>,IfcPlanarExtent</para>
	/// <para>,IfcPoint</para>
	/// <para>,IfcSectionedSpine</para>
	/// <para>,IfcShellBasedSurfaceModel</para>
	/// <para>,IfcSolidModel</para>
	/// <para>,IfcSurface</para>
	/// <para>,IfcTessellatedItem</para>
	/// <para>,IfcTextLiteral</para>
	/// <para>,IfcVector))</para>
	/// <para>SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcGeometricRepresentationItem : IfcRepresentationItem
	{
		public IfcGeometricRepresentationItem() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricRepresentationSubContext
	/// <para>ENTITY IfcGeometricRepresentationSubContext</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationContext);</para>
	/// <para>ParentContext : IfcGeometricRepresentationContext;</para>
	/// <para>TargetScale : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>TargetView : IfcGeometricProjectionEnum;</para>
	/// <para>UserDefinedTargetView : OPTIONAL IfcLabel;</para>
	/// <para>DERIVE</para>
	/// <para>SELF\IfcGeometricRepresentationContext.WorldCoordinateSystem : IfcAxis2Placement := ParentContext.WorldCoordinateSystem;</para>
	/// <para>SELF\IfcGeometricRepresentationContext.CoordinateSpaceDimension : IfcDimensionCount := ParentContext.CoordinateSpaceDimension;</para>
	/// <para>SELF\IfcGeometricRepresentationContext.TrueNorth : IfcDirection := NVL(ParentContext.TrueNorth, IfcConvertDirectionInto2D(SELF\IfcGeometricRepresentationContext.WorldCoordinateSystem.P[2]));</para>
	/// <para>SELF\IfcGeometricRepresentationContext.Precision : IfcReal := NVL(ParentContext.Precision,1.E-5);</para>
	/// <para>WHERE</para>
	/// <para>ParentNoSub : NOT('IFC4X1.IFCGEOMETRICREPRESENTATIONSUBCONTEXT' IN TYPEOF(ParentContext));</para>
	/// <para>UserTargetProvided : (TargetView <> IfcGeometricProjectionEnum.USERDEFINED) OR</para>
	/// <para>((TargetView =  IfcGeometricProjectionEnum.USERDEFINED) AND EXISTS(UserDefinedTargetView));</para>
	/// <para>NoCoordOperation : SIZEOF(SELF\IfcGeometricRepresentationContext.HasCoordinateOperation) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricRepresentationSubContext : IfcGeometricRepresentationContext
	{
		public virtual IfcGeometricRepresentationContext? ParentContext { get; set; }
		public virtual IfcPositiveRatioMeasure? TargetScale { get; set; }
		public virtual IfcGeometricProjectionEnum? TargetView { get; set; }
		public virtual IfcLabel? UserDefinedTargetView { get; set; }
		//TODO DERIVE
		public override IfcAxis2Placement? WorldCoordinateSystem {get {return null;}}
		//TODO DERIVE
		public override IfcDimensionCount? CoordinateSpaceDimension {get {return null;}}
		//TODO DERIVE
		public override IfcDirection? TrueNorth {get {return null;}}
		//TODO DERIVE
		public override IfcReal? Precision {get {return null;}}
		public IfcGeometricRepresentationSubContext() : base()
		{
		}
		public IfcGeometricRepresentationSubContext(IfcLabel ContextIdentifier, IfcLabel ContextType, IfcDimensionCount CoordinateSpaceDimension, IfcReal Precision, IfcAxis2Placement WorldCoordinateSystem, IfcDirection TrueNorth, IfcGeometricRepresentationContext ParentContext, IfcPositiveRatioMeasure TargetScale, IfcGeometricProjectionEnum TargetView, IfcLabel UserDefinedTargetView) : base (ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth)
		{
			this.ParentContext = ParentContext;
			this.TargetScale = TargetScale;
			this.TargetView = TargetView;
			this.UserDefinedTargetView = UserDefinedTargetView;
		}
	}
	/// <summary>
	/// ENTITY IfcGeometricSet
	/// <para>ENTITY IfcGeometricSet</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcGeometricCurveSet))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Elements : SET [1:?] OF IfcGeometricSetSelect;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := Elements[1].Dim;</para>
	/// <para>WHERE</para>
	/// <para>ConsistentDim : SIZEOF(QUERY(Temp <* Elements |</para>
	/// <para>Temp.Dim <> Elements[1].Dim))</para>
	/// <para>= 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGeometricSet : IfcGeometricRepresentationItem
	{
		public virtual List<IfcGeometricSetSelect>? Elements { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcGeometricSet() : base()
		{
		}
		public IfcGeometricSet(List<IfcGeometricSetSelect> Elements) : base ()
		{
			this.Elements = Elements;
		}
	}
	/// <summary>
	/// ENTITY IfcGrid
	/// <para>ENTITY IfcGrid</para>
	/// <para>SUBTYPE OF (IfcPositioningElement);</para>
	/// <para>UAxes : LIST [1:?] OF UNIQUE IfcGridAxis;</para>
	/// <para>VAxes : LIST [1:?] OF UNIQUE IfcGridAxis;</para>
	/// <para>WAxes : OPTIONAL LIST [1:?] OF UNIQUE IfcGridAxis;</para>
	/// <para>PredefinedType : OPTIONAL IfcGridTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGrid : IfcPositioningElement
	{
		public IfcGrid() : base()
		{
		}
		public IfcGrid(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcGridAxis;
	/// <para>ENTITY IfcGridAxis;</para>
	/// <para>AxisTag : OPTIONAL IfcLabel;</para>
	/// <para>AxisCurve : IfcCurve;</para>
	/// <para>SameSense : IfcBoolean;</para>
	/// <para>INVERSE</para>
	/// <para>PartOfW : SET [0:1] OF IfcGrid FOR WAxes;</para>
	/// <para>PartOfV : SET [0:1] OF IfcGrid FOR VAxes;</para>
	/// <para>PartOfU : SET [0:1] OF IfcGrid FOR UAxes;</para>
	/// <para>HasIntersections : SET [0:?] OF IfcVirtualGridIntersection FOR IntersectingAxes;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : AxisCurve.Dim = 2;</para>
	/// <para>WR2 : (SIZEOF(PartOfU) = 1) XOR (SIZEOF(PartOfV) = 1) XOR (SIZEOF(PartOfW) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGridAxis : Entity
	{
		public virtual IfcLabel? AxisTag { get; set; }
		public virtual IfcCurve? AxisCurve { get; set; }
		public virtual IfcBoolean? SameSense { get; set; }
		//TODO INVERSE
		//TODO INVERSE
		//TODO INVERSE
		//TODO INVERSE
		public IfcGridAxis() : base()
		{
		}
		public IfcGridAxis(IfcLabel AxisTag, IfcCurve AxisCurve, IfcBoolean SameSense) : base ()
		{
			this.AxisTag = AxisTag;
			this.AxisCurve = AxisCurve;
			this.SameSense = SameSense;
		}
	}
	/// <summary>
	/// ENTITY IfcGridPlacement
	/// <para>ENTITY IfcGridPlacement</para>
	/// <para>SUBTYPE OF (IfcObjectPlacement);</para>
	/// <para>PlacementLocation : IfcVirtualGridIntersection;</para>
	/// <para>PlacementRefDirection : OPTIONAL IfcGridPlacementDirectionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGridPlacement : IfcObjectPlacement
	{
		public virtual IfcVirtualGridIntersection? PlacementLocation { get; set; }
		public virtual IfcGridPlacementDirectionSelect? PlacementRefDirection { get; set; }
		public IfcGridPlacement() : base()
		{
		}
		public IfcGridPlacement(IfcVirtualGridIntersection PlacementLocation, IfcGridPlacementDirectionSelect PlacementRefDirection) : base ()
		{
			this.PlacementLocation = PlacementLocation;
			this.PlacementRefDirection = PlacementRefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcGroup
	/// <para>ENTITY IfcGroup</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAsset</para>
	/// <para>,IfcInventory</para>
	/// <para>,IfcStructuralLoadGroup</para>
	/// <para>,IfcStructuralResultGroup</para>
	/// <para>,IfcSystem))</para>
	/// <para>SUBTYPE OF (IfcObject);</para>
	/// <para>INVERSE</para>
	/// <para>IsGroupedBy : SET [0:?] OF IfcRelAssignsToGroup FOR RelatingGroup;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcGroup : IfcObject
	{
		//TODO INVERSE
		public List<IfcRelAssignsToGroup>? IsGroupedBy => Model?.GetItems<IfcRelAssignsToGroup>().Where(x => x.RelatingGroup != null && x.RelatingGroup == this).ToList();
		public IfcGroup() : base()
		{
		}
		public IfcGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcHalfSpaceSolid
	/// <para>ENTITY IfcHalfSpaceSolid</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBoxedHalfSpace</para>
	/// <para>,IfcPolygonalBoundedHalfSpace))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>BaseSurface : IfcSurface;</para>
	/// <para>AgreementFlag : IfcBoolean;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHalfSpaceSolid : IfcGeometricRepresentationItem, IfcBooleanOperand
	{
		public virtual IfcSurface? BaseSurface { get; set; }
		public virtual IfcBoolean? AgreementFlag { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcHalfSpaceSolid() : base()
		{
		}
		public IfcHalfSpaceSolid(IfcSurface BaseSurface, IfcBoolean AgreementFlag) : base ()
		{
			this.BaseSurface = BaseSurface;
			this.AgreementFlag = AgreementFlag;
		}
	}
	/// <summary>
	/// ENTITY IfcHeatExchanger
	/// <para>ENTITY IfcHeatExchanger</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcHeatExchangerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcHeatExchangerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcHeatExchangerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCHEATEXCHANGERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHeatExchanger : IfcEnergyConversionDevice
	{
		public virtual IfcHeatExchangerTypeEnum? PredefinedType { get; set; }
		public IfcHeatExchanger() : base()
		{
		}
		public IfcHeatExchanger(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcHeatExchangerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcHeatExchangerType
	/// <para>ENTITY IfcHeatExchangerType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcHeatExchangerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcHeatExchangerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcHeatExchangerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHeatExchangerType : IfcEnergyConversionDeviceType
	{
		public virtual IfcHeatExchangerTypeEnum? PredefinedType { get; set; }
		public IfcHeatExchangerType() : base()
		{
		}
		public IfcHeatExchangerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcHeatExchangerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcHumidifier
	/// <para>ENTITY IfcHumidifier</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcHumidifierTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcHumidifierTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcHumidifierTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCHUMIDIFIERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHumidifier : IfcEnergyConversionDevice
	{
		public virtual IfcHumidifierTypeEnum? PredefinedType { get; set; }
		public IfcHumidifier() : base()
		{
		}
		public IfcHumidifier(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcHumidifierTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcHumidifierType
	/// <para>ENTITY IfcHumidifierType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcHumidifierTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcHumidifierTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcHumidifierTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcHumidifierType : IfcEnergyConversionDeviceType
	{
		public virtual IfcHumidifierTypeEnum? PredefinedType { get; set; }
		public IfcHumidifierType() : base()
		{
		}
		public IfcHumidifierType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcHumidifierTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcIShapeProfileDef
	/// <para>ENTITY IfcIShapeProfileDef</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>OverallWidth : IfcPositiveLengthMeasure;</para>
	/// <para>OverallDepth : IfcPositiveLengthMeasure;</para>
	/// <para>WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>FlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>FlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidFlangeThickness : (2. * FlangeThickness) < OverallDepth;</para>
	/// <para>ValidWebThickness : WebThickness < OverallWidth;</para>
	/// <para>ValidFilletRadius : NOT(EXISTS(FilletRadius)) OR</para>
	/// <para>((FilletRadius <= (OverallWidth - WebThickness)/2.) AND</para>
	/// <para>(FilletRadius <= (OverallDepth - (2. * FlangeThickness))/2.));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIShapeProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? OverallWidth { get; set; }
		public virtual IfcPositiveLengthMeasure? OverallDepth { get; set; }
		public virtual IfcPositiveLengthMeasure? WebThickness { get; set; }
		public virtual IfcPositiveLengthMeasure? FlangeThickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public virtual IfcNonNegativeLengthMeasure? FlangeEdgeRadius { get; set; }
		public virtual IfcPlaneAngleMeasure? FlangeSlope { get; set; }
		public IfcIShapeProfileDef() : base()
		{
		}
		public IfcIShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure OverallWidth, IfcPositiveLengthMeasure OverallDepth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure FlangeEdgeRadius, IfcPlaneAngleMeasure FlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.OverallWidth = OverallWidth;
			this.OverallDepth = OverallDepth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.FlangeEdgeRadius = FlangeEdgeRadius;
			this.FlangeSlope = FlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcImageTexture
	/// <para>ENTITY IfcImageTexture</para>
	/// <para>SUBTYPE OF (IfcSurfaceTexture);</para>
	/// <para>URLReference : IfcURIReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcImageTexture : IfcSurfaceTexture
	{
		public virtual IfcURIReference? URLReference { get; set; }
		public IfcImageTexture() : base()
		{
		}
		public IfcImageTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter, IfcURIReference URLReference) : base (RepeatS, RepeatT, Mode, TextureTransform, Parameter)
		{
			this.URLReference = URLReference;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedColourMap
	/// <para>ENTITY IfcIndexedColourMap</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>MappedTo : IfcTessellatedFaceSet;</para>
	/// <para>Opacity : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>Colours : IfcColourRgbList;</para>
	/// <para>ColourIndex : LIST [1:?] OF IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedColourMap : IfcPresentationItem
	{
		public virtual IfcTessellatedFaceSet? MappedTo { get; set; }
		public virtual IfcNormalisedRatioMeasure? Opacity { get; set; }
		public virtual IfcColourRgbList? Colours { get; set; }
		public virtual List<IfcPositiveInteger>? ColourIndex { get; set; }
		public IfcIndexedColourMap() : base()
		{
		}
		public IfcIndexedColourMap(IfcTessellatedFaceSet MappedTo, IfcNormalisedRatioMeasure Opacity, IfcColourRgbList Colours, List<IfcPositiveInteger> ColourIndex) : base ()
		{
			this.MappedTo = MappedTo;
			this.Opacity = Opacity;
			this.Colours = Colours;
			this.ColourIndex = ColourIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedPolyCurve
	/// <para>ENTITY IfcIndexedPolyCurve</para>
	/// <para>SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>Points : IfcCartesianPointList;</para>
	/// <para>Segments : OPTIONAL LIST [1:?] OF IfcSegmentIndexSelect;</para>
	/// <para>SelfIntersect : OPTIONAL IfcBoolean;</para>
	/// <para>WHERE</para>
	/// <para>Consecutive : (SIZEOF(Segments) = 0) OR IfcConsecutiveSegments(Segments);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedPolyCurve : IfcBoundedCurve
	{
		public virtual IfcCartesianPointList? Points { get; set; }
		public virtual List<IfcSegmentIndexSelect>? Segments { get; set; }
		public virtual IfcBoolean? SelfIntersect { get; set; }
		public IfcIndexedPolyCurve() : base()
		{
		}
		public IfcIndexedPolyCurve(IfcCartesianPointList Points, List<IfcSegmentIndexSelect> Segments, IfcBoolean SelfIntersect) : base ()
		{
			this.Points = Points;
			this.Segments = Segments;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedPolygonalFace
	/// <para>ENTITY IfcIndexedPolygonalFace</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcIndexedPolygonalFaceWithVoids))</para>
	/// <para>SUBTYPE OF (IfcTessellatedItem);</para>
	/// <para>CoordIndex : LIST [3:?] OF IfcPositiveInteger;</para>
	/// <para>INVERSE</para>
	/// <para>ToFaceSet : SET [1:?] OF IfcPolygonalFaceSet FOR Faces;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedPolygonalFace : IfcTessellatedItem
	{
		public virtual List<IfcPositiveInteger>? CoordIndex { get; set; }
		//TODO INVERSE
		public List<IfcPolygonalFaceSet>? ToFaceSet => Model?.GetItems<IfcPolygonalFaceSet>().Where(x => x.Faces != null && x.Faces.Contains(this)).ToList();
		public IfcIndexedPolygonalFace() : base()
		{
		}
		public IfcIndexedPolygonalFace(List<IfcPositiveInteger> CoordIndex) : base ()
		{
			this.CoordIndex = CoordIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedPolygonalFaceWithVoids
	/// <para>ENTITY IfcIndexedPolygonalFaceWithVoids</para>
	/// <para>SUBTYPE OF (IfcIndexedPolygonalFace);</para>
	/// <para>InnerCoordIndices : LIST [1:?] OF LIST [3:?] OF UNIQUE IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedPolygonalFaceWithVoids : IfcIndexedPolygonalFace
	{
		public IfcIndexedPolygonalFaceWithVoids() : base()
		{
		}
		public IfcIndexedPolygonalFaceWithVoids(List<IfcPositiveInteger> CoordIndex) : base (CoordIndex)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedTextureMap
	/// <para>ENTITY IfcIndexedTextureMap</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcIndexedTriangleTextureMap))</para>
	/// <para>SUBTYPE OF (IfcTextureCoordinate);</para>
	/// <para>MappedTo : IfcTessellatedFaceSet;</para>
	/// <para>TexCoords : IfcTextureVertexList;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcIndexedTextureMap : IfcTextureCoordinate
	{
		public virtual IfcTessellatedFaceSet? MappedTo { get; set; }
		public virtual IfcTextureVertexList? TexCoords { get; set; }
		public IfcIndexedTextureMap() : base()
		{
		}
		public IfcIndexedTextureMap(List<IfcSurfaceTexture> Maps, IfcTessellatedFaceSet MappedTo, IfcTextureVertexList TexCoords) : base (Maps)
		{
			this.MappedTo = MappedTo;
			this.TexCoords = TexCoords;
		}
	}
	/// <summary>
	/// ENTITY IfcIndexedTriangleTextureMap
	/// <para>ENTITY IfcIndexedTriangleTextureMap</para>
	/// <para>SUBTYPE OF (IfcIndexedTextureMap);</para>
	/// <para>TexCoordIndex : OPTIONAL LIST [1:?] OF LIST [3:3] OF IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIndexedTriangleTextureMap : IfcIndexedTextureMap
	{
		public virtual List<List<IfcPositiveInteger >>? TexCoordIndex { get; set; }
		public IfcIndexedTriangleTextureMap() : base()
		{
		}
		public IfcIndexedTriangleTextureMap(List<IfcSurfaceTexture> Maps, IfcTessellatedFaceSet MappedTo, IfcTextureVertexList TexCoords, List<List<IfcPositiveInteger >> TexCoordIndex) : base (Maps, MappedTo, TexCoords)
		{
			this.TexCoordIndex = TexCoordIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcInterceptor
	/// <para>ENTITY IfcInterceptor</para>
	/// <para>SUBTYPE OF (IfcFlowTreatmentDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcInterceptorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcInterceptorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcInterceptorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCINTERCEPTORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcInterceptor : IfcFlowTreatmentDevice
	{
		public virtual IfcInterceptorTypeEnum? PredefinedType { get; set; }
		public IfcInterceptor() : base()
		{
		}
		public IfcInterceptor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcInterceptorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcInterceptorType
	/// <para>ENTITY IfcInterceptorType</para>
	/// <para>SUBTYPE OF (IfcFlowTreatmentDeviceType);</para>
	/// <para>PredefinedType : IfcInterceptorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcInterceptorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcInterceptorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcInterceptorType : IfcFlowTreatmentDeviceType
	{
		public virtual IfcInterceptorTypeEnum? PredefinedType { get; set; }
		public IfcInterceptorType() : base()
		{
		}
		public IfcInterceptorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcInterceptorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcIntersectionCurve
	/// <para>ENTITY IfcIntersectionCurve</para>
	/// <para>SUBTYPE OF (IfcSurfaceCurve);</para>
	/// <para>WHERE</para>
	/// <para>TwoPCurves : SIZEOF(SELF\IfcSurfaceCurve.AssociatedGeometry) = 2;</para>
	/// <para>DistinctSurfaces : IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[1]) <> IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[2]);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIntersectionCurve : IfcSurfaceCurve
	{
		public IfcIntersectionCurve() : base()
		{
		}
		public IfcIntersectionCurve(IfcCurve Curve3D, List<IfcPcurve> AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation MasterRepresentation) : base (Curve3D, AssociatedGeometry, MasterRepresentation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcInventory
	/// <para>ENTITY IfcInventory</para>
	/// <para>SUBTYPE OF (IfcGroup);</para>
	/// <para>PredefinedType : OPTIONAL IfcInventoryTypeEnum;</para>
	/// <para>Jurisdiction : OPTIONAL IfcActorSelect;</para>
	/// <para>ResponsiblePersons : OPTIONAL SET [1:?] OF IfcPerson;</para>
	/// <para>LastUpdateDate : OPTIONAL IfcDate;</para>
	/// <para>CurrentValue : OPTIONAL IfcCostValue;</para>
	/// <para>OriginalValue : OPTIONAL IfcCostValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcInventory : IfcGroup
	{
		public virtual IfcInventoryTypeEnum? PredefinedType { get; set; }
		public virtual IfcActorSelect? Jurisdiction { get; set; }
		public virtual List<IfcPerson>? ResponsiblePersons { get; set; }
		public virtual IfcDate? LastUpdateDate { get; set; }
		public virtual IfcCostValue? CurrentValue { get; set; }
		public virtual IfcCostValue? OriginalValue { get; set; }
		public IfcInventory() : base()
		{
		}
		public IfcInventory(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcInventoryTypeEnum PredefinedType, IfcActorSelect Jurisdiction, List<IfcPerson> ResponsiblePersons, IfcDate LastUpdateDate, IfcCostValue CurrentValue, IfcCostValue OriginalValue) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.Jurisdiction = Jurisdiction;
			this.ResponsiblePersons = ResponsiblePersons;
			this.LastUpdateDate = LastUpdateDate;
			this.CurrentValue = CurrentValue;
			this.OriginalValue = OriginalValue;
		}
	}
	/// <summary>
	/// ENTITY IfcIrregularTimeSeries
	/// <para>ENTITY IfcIrregularTimeSeries</para>
	/// <para>SUBTYPE OF (IfcTimeSeries);</para>
	/// <para>Values : LIST [1:?] OF IfcIrregularTimeSeriesValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIrregularTimeSeries : IfcTimeSeries
	{
		public virtual List<IfcIrregularTimeSeriesValue>? Values { get; set; }
		public IfcIrregularTimeSeries() : base()
		{
		}
		public IfcIrregularTimeSeries(IfcLabel Name, IfcText Description, IfcDateTime StartTime, IfcDateTime EndTime, IfcTimeSeriesDataTypeEnum TimeSeriesDataType, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcUnit Unit, List<IfcIrregularTimeSeriesValue> Values) : base (Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit)
		{
			this.Values = Values;
		}
	}
	/// <summary>
	/// ENTITY IfcIrregularTimeSeriesValue;
	/// <para>ENTITY IfcIrregularTimeSeriesValue;</para>
	/// <para>TimeStamp : IfcDateTime;</para>
	/// <para>ListValues : LIST [1:?] OF IfcValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcIrregularTimeSeriesValue : Entity
	{
		public virtual IfcDateTime? TimeStamp { get; set; }
		public virtual List<IfcValue>? ListValues { get; set; }
		public IfcIrregularTimeSeriesValue() : base()
		{
		}
		public IfcIrregularTimeSeriesValue(IfcDateTime TimeStamp, List<IfcValue> ListValues) : base ()
		{
			this.TimeStamp = TimeStamp;
			this.ListValues = ListValues;
		}
	}
	/// <summary>
	/// ENTITY IfcJunctionBox
	/// <para>ENTITY IfcJunctionBox</para>
	/// <para>SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>PredefinedType : OPTIONAL IfcJunctionBoxTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcJunctionBoxTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcJunctionBoxTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCJUNCTIONBOXTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcJunctionBox : IfcFlowFitting
	{
		public virtual IfcJunctionBoxTypeEnum? PredefinedType { get; set; }
		public IfcJunctionBox() : base()
		{
		}
		public IfcJunctionBox(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcJunctionBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcJunctionBoxType
	/// <para>ENTITY IfcJunctionBoxType</para>
	/// <para>SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>PredefinedType : IfcJunctionBoxTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcJunctionBoxTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcJunctionBoxTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcJunctionBoxType : IfcFlowFittingType
	{
		public virtual IfcJunctionBoxTypeEnum? PredefinedType { get; set; }
		public IfcJunctionBoxType() : base()
		{
		}
		public IfcJunctionBoxType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcJunctionBoxTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLShapeProfileDef
	/// <para>ENTITY IfcLShapeProfileDef</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>Depth : IfcPositiveLengthMeasure;</para>
	/// <para>Width : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>Thickness : IfcPositiveLengthMeasure;</para>
	/// <para>FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>EdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>LegSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidThickness : (Thickness < Depth) AND (NOT(EXISTS(Width)) OR (Thickness < Width));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLShapeProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? Depth { get; set; }
		public virtual IfcPositiveLengthMeasure? Width { get; set; }
		public virtual IfcPositiveLengthMeasure? Thickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public virtual IfcNonNegativeLengthMeasure? EdgeRadius { get; set; }
		public virtual IfcPlaneAngleMeasure? LegSlope { get; set; }
		public IfcLShapeProfileDef() : base()
		{
		}
		public IfcLShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure Width, IfcPositiveLengthMeasure Thickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure EdgeRadius, IfcPlaneAngleMeasure LegSlope) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.Width = Width;
			this.Thickness = Thickness;
			this.FilletRadius = FilletRadius;
			this.EdgeRadius = EdgeRadius;
			this.LegSlope = LegSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcLaborResource
	/// <para>ENTITY IfcLaborResource</para>
	/// <para>SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>PredefinedType : OPTIONAL IfcLaborResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcLaborResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcLaborResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLaborResource : IfcConstructionResource
	{
		public virtual IfcLaborResourceTypeEnum? PredefinedType { get; set; }
		public IfcLaborResource() : base()
		{
		}
		public IfcLaborResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcLaborResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLaborResourceType
	/// <para>ENTITY IfcLaborResourceType</para>
	/// <para>SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>PredefinedType : IfcLaborResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcLaborResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcLaborResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLaborResourceType : IfcConstructionResourceType
	{
		public virtual IfcLaborResourceTypeEnum? PredefinedType { get; set; }
		public IfcLaborResourceType() : base()
		{
		}
		public IfcLaborResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcLaborResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLagTime
	/// <para>ENTITY IfcLagTime</para>
	/// <para>SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>LagValue : IfcTimeOrRatioSelect;</para>
	/// <para>DurationType : IfcTaskDurationEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLagTime : IfcSchedulingTime
	{
		public virtual IfcTimeOrRatioSelect? LagValue { get; set; }
		public virtual IfcTaskDurationEnum? DurationType { get; set; }
		public IfcLagTime() : base()
		{
		}
		public IfcLagTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcTimeOrRatioSelect LagValue, IfcTaskDurationEnum DurationType) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.LagValue = LagValue;
			this.DurationType = DurationType;
		}
	}
	/// <summary>
	/// ENTITY IfcLamp
	/// <para>ENTITY IfcLamp</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcLampTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcLampTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcLampTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCLAMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLamp : IfcFlowTerminal
	{
		public virtual IfcLampTypeEnum? PredefinedType { get; set; }
		public IfcLamp() : base()
		{
		}
		public IfcLamp(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLampType
	/// <para>ENTITY IfcLampType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcLampTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcLampTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcLampTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLampType : IfcFlowTerminalType
	{
		public virtual IfcLampTypeEnum? PredefinedType { get; set; }
		public IfcLampType() : base()
		{
		}
		public IfcLampType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcLampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLibraryInformation
	/// <para>ENTITY IfcLibraryInformation</para>
	/// <para>SUBTYPE OF (IfcExternalInformation);</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>Version : OPTIONAL IfcLabel;</para>
	/// <para>Publisher : OPTIONAL IfcActorSelect;</para>
	/// <para>VersionDate : OPTIONAL IfcDateTime;</para>
	/// <para>Location : OPTIONAL IfcURIReference;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>INVERSE</para>
	/// <para>LibraryInfoForObjects : SET [0:?] OF IfcRelAssociatesLibrary FOR RelatingLibrary;</para>
	/// <para>HasLibraryReferences : SET [0:?] OF IfcLibraryReference FOR ReferencedLibrary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLibraryInformation : IfcExternalInformation, IfcLibrarySelect
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcLabel? Version { get; set; }
		public virtual IfcActorSelect? Publisher { get; set; }
		public virtual IfcDateTime? VersionDate { get; set; }
		public virtual IfcURIReference? Location { get; set; }
		public virtual IfcText? Description { get; set; }
		//TODO INVERSE
		public List<IfcRelAssociatesLibrary>? LibraryInfoForObjects => Model?.GetItems<IfcRelAssociatesLibrary>().Where(x => x.RelatingLibrary != null && x.RelatingLibrary == this).ToList();
		//TODO INVERSE
		public List<IfcLibraryReference>? HasLibraryReferences => Model?.GetItems<IfcLibraryReference>().Where(x => x.ReferencedLibrary != null && x.ReferencedLibrary == this).ToList();
		public IfcLibraryInformation() : base()
		{
		}
		public IfcLibraryInformation(IfcLabel Name, IfcLabel Version, IfcActorSelect Publisher, IfcDateTime VersionDate, IfcURIReference Location, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Version = Version;
			this.Publisher = Publisher;
			this.VersionDate = VersionDate;
			this.Location = Location;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcLibraryReference
	/// <para>ENTITY IfcLibraryReference</para>
	/// <para>SUBTYPE OF (IfcExternalReference);</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Language : OPTIONAL IfcLanguageId;</para>
	/// <para>ReferencedLibrary : OPTIONAL IfcLibraryInformation;</para>
	/// <para>INVERSE</para>
	/// <para>LibraryRefForObjects : SET [0:?] OF IfcRelAssociatesLibrary FOR RelatingLibrary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLibraryReference : IfcExternalReference, IfcLibrarySelect
	{
		public virtual IfcText? Description { get; set; }
		public virtual IfcLanguageId? Language { get; set; }
		public virtual IfcLibraryInformation? ReferencedLibrary { get; set; }
		//TODO INVERSE
		public List<IfcRelAssociatesLibrary>? LibraryRefForObjects => Model?.GetItems<IfcRelAssociatesLibrary>().Where(x => x.RelatingLibrary != null && x.RelatingLibrary == this).ToList();
		public IfcLibraryReference() : base()
		{
		}
		public IfcLibraryReference(IfcURIReference Location, IfcIdentifier Identification, IfcLabel Name, IfcText Description, IfcLanguageId Language, IfcLibraryInformation ReferencedLibrary) : base (Location, Identification, Name)
		{
			this.Description = Description;
			this.Language = Language;
			this.ReferencedLibrary = ReferencedLibrary;
		}
	}
	/// <summary>
	/// ENTITY IfcLightDistributionData;
	/// <para>ENTITY IfcLightDistributionData;</para>
	/// <para>MainPlaneAngle : IfcPlaneAngleMeasure;</para>
	/// <para>SecondaryPlaneAngle : LIST [1:?] OF IfcPlaneAngleMeasure;</para>
	/// <para>LuminousIntensity : LIST [1:?] OF IfcLuminousIntensityDistributionMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightDistributionData : Entity
	{
		public virtual IfcPlaneAngleMeasure? MainPlaneAngle { get; set; }
		public virtual List<IfcPlaneAngleMeasure>? SecondaryPlaneAngle { get; set; }
		public virtual List<IfcLuminousIntensityDistributionMeasure>? LuminousIntensity { get; set; }
		public IfcLightDistributionData() : base()
		{
		}
		public IfcLightDistributionData(IfcPlaneAngleMeasure MainPlaneAngle, List<IfcPlaneAngleMeasure> SecondaryPlaneAngle, List<IfcLuminousIntensityDistributionMeasure> LuminousIntensity) : base ()
		{
			this.MainPlaneAngle = MainPlaneAngle;
			this.SecondaryPlaneAngle = SecondaryPlaneAngle;
			this.LuminousIntensity = LuminousIntensity;
		}
	}
	/// <summary>
	/// ENTITY IfcLightFixture
	/// <para>ENTITY IfcLightFixture</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcLightFixtureTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcLightFixtureTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcLightFixtureTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCLIGHTFIXTURETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightFixture : IfcFlowTerminal
	{
		public virtual IfcLightFixtureTypeEnum? PredefinedType { get; set; }
		public IfcLightFixture() : base()
		{
		}
		public IfcLightFixture(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLightFixtureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLightFixtureType
	/// <para>ENTITY IfcLightFixtureType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcLightFixtureTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcLightFixtureTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcLightFixtureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightFixtureType : IfcFlowTerminalType
	{
		public virtual IfcLightFixtureTypeEnum? PredefinedType { get; set; }
		public IfcLightFixtureType() : base()
		{
		}
		public IfcLightFixtureType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcLightFixtureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcLightIntensityDistribution;
	/// <para>ENTITY IfcLightIntensityDistribution;</para>
	/// <para>LightDistributionCurve : IfcLightDistributionCurveEnum;</para>
	/// <para>DistributionData : LIST [1:?] OF IfcLightDistributionData;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightIntensityDistribution : Entity, IfcLightDistributionDataSourceSelect
	{
		public virtual IfcLightDistributionCurveEnum? LightDistributionCurve { get; set; }
		public virtual List<IfcLightDistributionData>? DistributionData { get; set; }
		public IfcLightIntensityDistribution() : base()
		{
		}
		public IfcLightIntensityDistribution(IfcLightDistributionCurveEnum LightDistributionCurve, List<IfcLightDistributionData> DistributionData) : base ()
		{
			this.LightDistributionCurve = LightDistributionCurve;
			this.DistributionData = DistributionData;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSource
	/// <para>ENTITY IfcLightSource</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcLightSourceAmbient</para>
	/// <para>,IfcLightSourceDirectional</para>
	/// <para>,IfcLightSourceGoniometric</para>
	/// <para>,IfcLightSourcePositional))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>LightColour : IfcColourRgb;</para>
	/// <para>AmbientIntensity : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>Intensity : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcLightSource : IfcGeometricRepresentationItem
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcColourRgb? LightColour { get; set; }
		public virtual IfcNormalisedRatioMeasure? AmbientIntensity { get; set; }
		public virtual IfcNormalisedRatioMeasure? Intensity { get; set; }
		public IfcLightSource() : base()
		{
		}
		public IfcLightSource(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity) : base ()
		{
			this.Name = Name;
			this.LightColour = LightColour;
			this.AmbientIntensity = AmbientIntensity;
			this.Intensity = Intensity;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceAmbient
	/// <para>ENTITY IfcLightSourceAmbient</para>
	/// <para>SUBTYPE OF (IfcLightSource);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceAmbient : IfcLightSource
	{
		public IfcLightSourceAmbient() : base()
		{
		}
		public IfcLightSourceAmbient(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceDirectional
	/// <para>ENTITY IfcLightSourceDirectional</para>
	/// <para>SUBTYPE OF (IfcLightSource);</para>
	/// <para>Orientation : IfcDirection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceDirectional : IfcLightSource
	{
		public virtual IfcDirection? Orientation { get; set; }
		public IfcLightSourceDirectional() : base()
		{
		}
		public IfcLightSourceDirectional(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcDirection Orientation) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
			this.Orientation = Orientation;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceGoniometric
	/// <para>ENTITY IfcLightSourceGoniometric</para>
	/// <para>SUBTYPE OF (IfcLightSource);</para>
	/// <para>Position : IfcAxis2Placement3D;</para>
	/// <para>ColourAppearance : OPTIONAL IfcColourRgb;</para>
	/// <para>ColourTemperature : IfcThermodynamicTemperatureMeasure;</para>
	/// <para>LuminousFlux : IfcLuminousFluxMeasure;</para>
	/// <para>LightEmissionSource : IfcLightEmissionSourceEnum;</para>
	/// <para>LightDistributionDataSource : IfcLightDistributionDataSourceSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceGoniometric : IfcLightSource
	{
		public virtual IfcAxis2Placement3D? Position { get; set; }
		public virtual IfcColourRgb? ColourAppearance { get; set; }
		public virtual IfcThermodynamicTemperatureMeasure? ColourTemperature { get; set; }
		public virtual IfcLuminousFluxMeasure? LuminousFlux { get; set; }
		public virtual IfcLightEmissionSourceEnum? LightEmissionSource { get; set; }
		public virtual IfcLightDistributionDataSourceSelect? LightDistributionDataSource { get; set; }
		public IfcLightSourceGoniometric() : base()
		{
		}
		public IfcLightSourceGoniometric(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcAxis2Placement3D Position, IfcColourRgb ColourAppearance, IfcThermodynamicTemperatureMeasure ColourTemperature, IfcLuminousFluxMeasure LuminousFlux, IfcLightEmissionSourceEnum LightEmissionSource, IfcLightDistributionDataSourceSelect LightDistributionDataSource) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
			this.Position = Position;
			this.ColourAppearance = ColourAppearance;
			this.ColourTemperature = ColourTemperature;
			this.LuminousFlux = LuminousFlux;
			this.LightEmissionSource = LightEmissionSource;
			this.LightDistributionDataSource = LightDistributionDataSource;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourcePositional
	/// <para>ENTITY IfcLightSourcePositional</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcLightSourceSpot))</para>
	/// <para>SUBTYPE OF (IfcLightSource);</para>
	/// <para>Position : IfcCartesianPoint;</para>
	/// <para>Radius : IfcPositiveLengthMeasure;</para>
	/// <para>ConstantAttenuation : IfcReal;</para>
	/// <para>DistanceAttenuation : IfcReal;</para>
	/// <para>QuadricAttenuation : IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourcePositional : IfcLightSource
	{
		public virtual IfcCartesianPoint? Position { get; set; }
		public virtual IfcPositiveLengthMeasure? Radius { get; set; }
		public virtual IfcReal? ConstantAttenuation { get; set; }
		public virtual IfcReal? DistanceAttenuation { get; set; }
		public virtual IfcReal? QuadricAttenuation { get; set; }
		public IfcLightSourcePositional() : base()
		{
		}
		public IfcLightSourcePositional(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcCartesianPoint Position, IfcPositiveLengthMeasure Radius, IfcReal ConstantAttenuation, IfcReal DistanceAttenuation, IfcReal QuadricAttenuation) : base (Name, LightColour, AmbientIntensity, Intensity)
		{
			this.Position = Position;
			this.Radius = Radius;
			this.ConstantAttenuation = ConstantAttenuation;
			this.DistanceAttenuation = DistanceAttenuation;
			this.QuadricAttenuation = QuadricAttenuation;
		}
	}
	/// <summary>
	/// ENTITY IfcLightSourceSpot
	/// <para>ENTITY IfcLightSourceSpot</para>
	/// <para>SUBTYPE OF (IfcLightSourcePositional);</para>
	/// <para>Orientation : IfcDirection;</para>
	/// <para>ConcentrationExponent : OPTIONAL IfcReal;</para>
	/// <para>SpreadAngle : IfcPositivePlaneAngleMeasure;</para>
	/// <para>BeamWidthAngle : IfcPositivePlaneAngleMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLightSourceSpot : IfcLightSourcePositional
	{
		public virtual IfcDirection? Orientation { get; set; }
		public virtual IfcReal? ConcentrationExponent { get; set; }
		public virtual IfcPositivePlaneAngleMeasure? SpreadAngle { get; set; }
		public virtual IfcPositivePlaneAngleMeasure? BeamWidthAngle { get; set; }
		public IfcLightSourceSpot() : base()
		{
		}
		public IfcLightSourceSpot(IfcLabel Name, IfcColourRgb LightColour, IfcNormalisedRatioMeasure AmbientIntensity, IfcNormalisedRatioMeasure Intensity, IfcCartesianPoint Position, IfcPositiveLengthMeasure Radius, IfcReal ConstantAttenuation, IfcReal DistanceAttenuation, IfcReal QuadricAttenuation, IfcDirection Orientation, IfcReal ConcentrationExponent, IfcPositivePlaneAngleMeasure SpreadAngle, IfcPositivePlaneAngleMeasure BeamWidthAngle) : base (Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation)
		{
			this.Orientation = Orientation;
			this.ConcentrationExponent = ConcentrationExponent;
			this.SpreadAngle = SpreadAngle;
			this.BeamWidthAngle = BeamWidthAngle;
		}
	}
	/// <summary>
	/// ENTITY IfcLine
	/// <para>ENTITY IfcLine</para>
	/// <para>SUBTYPE OF (IfcCurve);</para>
	/// <para>Pnt : IfcCartesianPoint;</para>
	/// <para>Dir : IfcVector;</para>
	/// <para>WHERE</para>
	/// <para>SameDim : Dir.Dim = Pnt.Dim;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLine : IfcCurve
	{
		public virtual IfcCartesianPoint? Pnt { get; set; }
		public virtual IfcVector? Dir { get; set; }
		public IfcLine() : base()
		{
		}
		public IfcLine(IfcCartesianPoint Pnt, IfcVector Dir) : base ()
		{
			this.Pnt = Pnt;
			this.Dir = Dir;
		}
	}
	/// <summary>
	/// ENTITY IfcLineSegment2D
	/// <para>ENTITY IfcLineSegment2D</para>
	/// <para>SUBTYPE OF (IfcCurveSegment2D);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLineSegment2D : IfcCurveSegment2D
	{
		public IfcLineSegment2D() : base()
		{
		}
		public IfcLineSegment2D(IfcCartesianPoint StartPoint, IfcPlaneAngleMeasure StartDirection, IfcPositiveLengthMeasure SegmentLength) : base (StartPoint, StartDirection, SegmentLength)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcLinearPlacement
	/// <para>ENTITY IfcLinearPlacement</para>
	/// <para>SUBTYPE OF (IfcObjectPlacement);</para>
	/// <para>PlacementRelTo : IfcCurve;</para>
	/// <para>Distance : IfcDistanceExpression;</para>
	/// <para>Orientation : OPTIONAL IfcOrientationExpression;</para>
	/// <para>CartesianPosition : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLinearPlacement : IfcObjectPlacement
	{
		public virtual IfcCurve? PlacementRelTo { get; set; }
		public virtual IfcDistanceExpression? Distance { get; set; }
		public virtual IfcOrientationExpression? Orientation { get; set; }
		public virtual IfcAxis2Placement3D? CartesianPosition { get; set; }
		public IfcLinearPlacement() : base()
		{
		}
		public IfcLinearPlacement(IfcCurve PlacementRelTo, IfcDistanceExpression Distance, IfcOrientationExpression Orientation, IfcAxis2Placement3D CartesianPosition) : base ()
		{
			this.PlacementRelTo = PlacementRelTo;
			this.Distance = Distance;
			this.Orientation = Orientation;
			this.CartesianPosition = CartesianPosition;
		}
	}
	/// <summary>
	/// ENTITY IfcLinearPositioningElement
	/// <para>ENTITY IfcLinearPositioningElement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAlignment))</para>
	/// <para>SUBTYPE OF (IfcPositioningElement);</para>
	/// <para>Axis : IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcLinearPositioningElement : IfcPositioningElement
	{
		public virtual IfcCurve? Axis { get; set; }
		public IfcLinearPositioningElement() : base()
		{
		}
		public IfcLinearPositioningElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcCurve Axis) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.Axis = Axis;
		}
	}
	/// <summary>
	/// ENTITY IfcLocalPlacement
	/// <para>ENTITY IfcLocalPlacement</para>
	/// <para>SUBTYPE OF (IfcObjectPlacement);</para>
	/// <para>PlacementRelTo : OPTIONAL IfcObjectPlacement;</para>
	/// <para>RelativePlacement : IfcAxis2Placement;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : IfcCorrectLocalPlacement(RelativePlacement, PlacementRelTo);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLocalPlacement : IfcObjectPlacement
	{
		public virtual IfcObjectPlacement? PlacementRelTo { get; set; }
		public virtual IfcAxis2Placement? RelativePlacement { get; set; }
		public IfcLocalPlacement() : base()
		{
		}
		public IfcLocalPlacement(IfcObjectPlacement PlacementRelTo, IfcAxis2Placement RelativePlacement) : base ()
		{
			this.PlacementRelTo = PlacementRelTo;
			this.RelativePlacement = RelativePlacement;
		}
	}
	/// <summary>
	/// ENTITY IfcLoop
	/// <para>ENTITY IfcLoop</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcEdgeLoop</para>
	/// <para>,IfcPolyLoop</para>
	/// <para>,IfcVertexLoop))</para>
	/// <para>SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcLoop : IfcTopologicalRepresentationItem
	{
		public IfcLoop() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcManifoldSolidBrep
	/// <para>ENTITY IfcManifoldSolidBrep</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAdvancedBrep</para>
	/// <para>,IfcFacetedBrep))</para>
	/// <para>SUBTYPE OF (IfcSolidModel);</para>
	/// <para>Outer : IfcClosedShell;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcManifoldSolidBrep : IfcSolidModel
	{
		public virtual IfcClosedShell? Outer { get; set; }
		public IfcManifoldSolidBrep() : base()
		{
		}
		public IfcManifoldSolidBrep(IfcClosedShell Outer) : base ()
		{
			this.Outer = Outer;
		}
	}
	/// <summary>
	/// ENTITY IfcMapConversion
	/// <para>ENTITY IfcMapConversion</para>
	/// <para>SUBTYPE OF (IfcCoordinateOperation);</para>
	/// <para>Eastings : IfcLengthMeasure;</para>
	/// <para>Northings : IfcLengthMeasure;</para>
	/// <para>OrthogonalHeight : IfcLengthMeasure;</para>
	/// <para>XAxisAbscissa : OPTIONAL IfcReal;</para>
	/// <para>XAxisOrdinate : OPTIONAL IfcReal;</para>
	/// <para>Scale : OPTIONAL IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMapConversion : IfcCoordinateOperation
	{
		public virtual IfcLengthMeasure? Eastings { get; set; }
		public virtual IfcLengthMeasure? Northings { get; set; }
		public virtual IfcLengthMeasure? OrthogonalHeight { get; set; }
		public virtual IfcReal? XAxisAbscissa { get; set; }
		public virtual IfcReal? XAxisOrdinate { get; set; }
		public virtual IfcReal? Scale { get; set; }
		public IfcMapConversion() : base()
		{
		}
		public IfcMapConversion(IfcCoordinateReferenceSystemSelect SourceCRS, IfcCoordinateReferenceSystem TargetCRS, IfcLengthMeasure Eastings, IfcLengthMeasure Northings, IfcLengthMeasure OrthogonalHeight, IfcReal XAxisAbscissa, IfcReal XAxisOrdinate, IfcReal Scale) : base (SourceCRS, TargetCRS)
		{
			this.Eastings = Eastings;
			this.Northings = Northings;
			this.OrthogonalHeight = OrthogonalHeight;
			this.XAxisAbscissa = XAxisAbscissa;
			this.XAxisOrdinate = XAxisOrdinate;
			this.Scale = Scale;
		}
	}
	/// <summary>
	/// ENTITY IfcMappedItem
	/// <para>ENTITY IfcMappedItem</para>
	/// <para>SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>MappingSource : IfcRepresentationMap;</para>
	/// <para>MappingTarget : IfcCartesianTransformationOperator;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMappedItem : IfcRepresentationItem
	{
		public virtual IfcRepresentationMap? MappingSource { get; set; }
		public virtual IfcCartesianTransformationOperator? MappingTarget { get; set; }
		public IfcMappedItem() : base()
		{
		}
		public IfcMappedItem(IfcRepresentationMap MappingSource, IfcCartesianTransformationOperator MappingTarget) : base ()
		{
			this.MappingSource = MappingSource;
			this.MappingTarget = MappingTarget;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterial
	/// <para>ENTITY IfcMaterial</para>
	/// <para>SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Category : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>HasRepresentation : SET [0:1] OF IfcMaterialDefinitionRepresentation FOR RepresentedMaterial;</para>
	/// <para>IsRelatedWith : SET [0:?] OF IfcMaterialRelationship FOR RelatedMaterials;</para>
	/// <para>RelatesTo : SET [0:1] OF IfcMaterialRelationship FOR RelatingMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterial : IfcMaterialDefinition
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcLabel? Category { get; set; }
		//TODO INVERSE
		public List<IfcMaterialDefinitionRepresentation>? HasRepresentation => Model?.GetItems<IfcMaterialDefinitionRepresentation>().Where(x => x.RepresentedMaterial != null && x.RepresentedMaterial == this).ToList();
		//TODO INVERSE
		public List<IfcMaterialRelationship>? IsRelatedWith => Model?.GetItems<IfcMaterialRelationship>().Where(x => x.RelatedMaterials != null && x.RelatedMaterials.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcMaterialRelationship>? RelatesTo => Model?.GetItems<IfcMaterialRelationship>().Where(x => x.RelatingMaterial != null && x.RelatingMaterial == this).ToList();
		public IfcMaterial() : base()
		{
		}
		public IfcMaterial(IfcLabel Name, IfcText Description, IfcLabel Category) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Category = Category;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialClassificationRelationship;
	/// <para>ENTITY IfcMaterialClassificationRelationship;</para>
	/// <para>MaterialClassifications : SET [1:?] OF IfcClassificationSelect;</para>
	/// <para>ClassifiedMaterial : IfcMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialClassificationRelationship : Entity
	{
		public virtual List<IfcClassificationSelect>? MaterialClassifications { get; set; }
		public virtual IfcMaterial? ClassifiedMaterial { get; set; }
		public IfcMaterialClassificationRelationship() : base()
		{
		}
		public IfcMaterialClassificationRelationship(List<IfcClassificationSelect> MaterialClassifications, IfcMaterial ClassifiedMaterial) : base ()
		{
			this.MaterialClassifications = MaterialClassifications;
			this.ClassifiedMaterial = ClassifiedMaterial;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialConstituent
	/// <para>ENTITY IfcMaterialConstituent</para>
	/// <para>SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Material : IfcMaterial;</para>
	/// <para>Fraction : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>Category : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>ToMaterialConstituentSet : IfcMaterialConstituentSet FOR MaterialConstituents;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialConstituent : IfcMaterialDefinition
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcMaterial? Material { get; set; }
		public virtual IfcNormalisedRatioMeasure? Fraction { get; set; }
		public virtual IfcLabel? Category { get; set; }
		//TODO INVERSE
		public IfcMaterialConstituentSet? ToMaterialConstituentSet => Model?.GetItems<IfcMaterialConstituentSet>().FirstOrDefault(x => x.MaterialConstituents != null && x.MaterialConstituents.Contains(this));
		public IfcMaterialConstituent() : base()
		{
		}
		public IfcMaterialConstituent(IfcLabel Name, IfcText Description, IfcMaterial Material, IfcNormalisedRatioMeasure Fraction, IfcLabel Category) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Material = Material;
			this.Fraction = Fraction;
			this.Category = Category;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialConstituentSet
	/// <para>ENTITY IfcMaterialConstituentSet</para>
	/// <para>SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>MaterialConstituents : OPTIONAL SET [1:?] OF IfcMaterialConstituent;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialConstituentSet : IfcMaterialDefinition
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual List<IfcMaterialConstituent>? MaterialConstituents { get; set; }
		public IfcMaterialConstituentSet() : base()
		{
		}
		public IfcMaterialConstituentSet(IfcLabel Name, IfcText Description, List<IfcMaterialConstituent> MaterialConstituents) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.MaterialConstituents = MaterialConstituents;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialDefinition
	/// <para>ENTITY IfcMaterialDefinition</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMaterial</para>
	/// <para>,IfcMaterialConstituent</para>
	/// <para>,IfcMaterialConstituentSet</para>
	/// <para>,IfcMaterialLayer</para>
	/// <para>,IfcMaterialLayerSet</para>
	/// <para>,IfcMaterialProfile</para>
	/// <para>,IfcMaterialProfileSet));</para>
	/// <para>INVERSE</para>
	/// <para>AssociatedTo : SET [0:?] OF IfcRelAssociatesMaterial FOR RelatingMaterial;</para>
	/// <para>HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>HasProperties : SET [0:?] OF IfcMaterialProperties FOR Material;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcMaterialDefinition : Entity, IfcMaterialSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		//TODO INVERSE
		public List<IfcRelAssociatesMaterial>? AssociatedTo => Model?.GetItems<IfcRelAssociatesMaterial>().Where(x => x.RelatingMaterial != null && x.RelatingMaterial == this).ToList();
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReferences => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcMaterialProperties>? HasProperties => Model?.GetItems<IfcMaterialProperties>().Where(x => x.Material != null && x.Material == this).ToList();
		public IfcMaterialDefinition() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialDefinitionRepresentation
	/// <para>ENTITY IfcMaterialDefinitionRepresentation</para>
	/// <para>SUBTYPE OF (IfcProductRepresentation);</para>
	/// <para>RepresentedMaterial : IfcMaterial;</para>
	/// <para>WHERE</para>
	/// <para>OnlyStyledRepresentations : SIZEOF(QUERY(temp <* Representations |</para>
	/// <para>(NOT('IFC4X1.IFCSTYLEDREPRESENTATION' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialDefinitionRepresentation : IfcProductRepresentation
	{
		public virtual IfcMaterial? RepresentedMaterial { get; set; }
		public IfcMaterialDefinitionRepresentation() : base()
		{
		}
		public IfcMaterialDefinitionRepresentation(IfcLabel Name, IfcText Description, List<IfcRepresentation> Representations, IfcMaterial RepresentedMaterial) : base (Name, Description, Representations)
		{
			this.RepresentedMaterial = RepresentedMaterial;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayer
	/// <para>ENTITY IfcMaterialLayer</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMaterialLayerWithOffsets))</para>
	/// <para>SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>Material : OPTIONAL IfcMaterial;</para>
	/// <para>LayerThickness : IfcNonNegativeLengthMeasure;</para>
	/// <para>IsVentilated : OPTIONAL IfcLogical;</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Category : OPTIONAL IfcLabel;</para>
	/// <para>Priority : OPTIONAL IfcInteger;</para>
	/// <para>INVERSE</para>
	/// <para>ToMaterialLayerSet : IfcMaterialLayerSet FOR MaterialLayers;</para>
	/// <para>WHERE</para>
	/// <para>NormalizedPriority : NOT(EXISTS(Priority)) OR {0 <= Priority <= 100};</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayer : IfcMaterialDefinition
	{
		public virtual IfcMaterial? Material { get; set; }
		public virtual IfcNonNegativeLengthMeasure? LayerThickness { get; set; }
		public virtual IfcLogical? IsVentilated { get; set; }
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcLabel? Category { get; set; }
		public virtual IfcInteger? Priority { get; set; }
		//TODO INVERSE
		public IfcMaterialLayerSet? ToMaterialLayerSet => Model?.GetItems<IfcMaterialLayerSet>().FirstOrDefault(x => x.MaterialLayers != null && x.MaterialLayers.Contains(this));
		public IfcMaterialLayer() : base()
		{
		}
		public IfcMaterialLayer(IfcMaterial Material, IfcNonNegativeLengthMeasure LayerThickness, IfcLogical IsVentilated, IfcLabel Name, IfcText Description, IfcLabel Category, IfcInteger Priority) : base ()
		{
			this.Material = Material;
			this.LayerThickness = LayerThickness;
			this.IsVentilated = IsVentilated;
			this.Name = Name;
			this.Description = Description;
			this.Category = Category;
			this.Priority = Priority;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayerSet
	/// <para>ENTITY IfcMaterialLayerSet</para>
	/// <para>SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>MaterialLayers : LIST [1:?] OF IfcMaterialLayer;</para>
	/// <para>LayerSetName : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>DERIVE</para>
	/// <para>TotalThickness : IfcLengthMeasure := IfcMlsTotalThickness(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayerSet : IfcMaterialDefinition
	{
		public virtual List<IfcMaterialLayer>? MaterialLayers { get; set; }
		public virtual IfcLabel? LayerSetName { get; set; }
		public virtual IfcText? Description { get; set; }
		//TODO DERIVE
		public virtual IfcLengthMeasure? TotalThickness {get {return null;}}
		public IfcMaterialLayerSet() : base()
		{
		}
		public IfcMaterialLayerSet(List<IfcMaterialLayer> MaterialLayers, IfcLabel LayerSetName, IfcText Description) : base ()
		{
			this.MaterialLayers = MaterialLayers;
			this.LayerSetName = LayerSetName;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayerSetUsage
	/// <para>ENTITY IfcMaterialLayerSetUsage</para>
	/// <para>SUBTYPE OF (IfcMaterialUsageDefinition);</para>
	/// <para>ForLayerSet : IfcMaterialLayerSet;</para>
	/// <para>LayerSetDirection : IfcLayerSetDirectionEnum;</para>
	/// <para>DirectionSense : IfcDirectionSenseEnum;</para>
	/// <para>OffsetFromReferenceLine : IfcLengthMeasure;</para>
	/// <para>ReferenceExtent : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayerSetUsage : IfcMaterialUsageDefinition
	{
		public virtual IfcMaterialLayerSet? ForLayerSet { get; set; }
		public virtual IfcLayerSetDirectionEnum? LayerSetDirection { get; set; }
		public virtual IfcDirectionSenseEnum? DirectionSense { get; set; }
		public virtual IfcLengthMeasure? OffsetFromReferenceLine { get; set; }
		public virtual IfcPositiveLengthMeasure? ReferenceExtent { get; set; }
		public IfcMaterialLayerSetUsage() : base()
		{
		}
		public IfcMaterialLayerSetUsage(IfcMaterialLayerSet ForLayerSet, IfcLayerSetDirectionEnum LayerSetDirection, IfcDirectionSenseEnum DirectionSense, IfcLengthMeasure OffsetFromReferenceLine, IfcPositiveLengthMeasure ReferenceExtent) : base ()
		{
			this.ForLayerSet = ForLayerSet;
			this.LayerSetDirection = LayerSetDirection;
			this.DirectionSense = DirectionSense;
			this.OffsetFromReferenceLine = OffsetFromReferenceLine;
			this.ReferenceExtent = ReferenceExtent;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialLayerWithOffsets
	/// <para>ENTITY IfcMaterialLayerWithOffsets</para>
	/// <para>SUBTYPE OF (IfcMaterialLayer);</para>
	/// <para>OffsetDirection : IfcLayerSetDirectionEnum;</para>
	/// <para>OffsetValues : ARRAY [1:2] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialLayerWithOffsets : IfcMaterialLayer
	{
		public virtual IfcLayerSetDirectionEnum? OffsetDirection { get; set; }
		public virtual List<IfcLengthMeasure>? OffsetValues { get; set; }
		public IfcMaterialLayerWithOffsets() : base()
		{
		}
		public IfcMaterialLayerWithOffsets(IfcMaterial Material, IfcNonNegativeLengthMeasure LayerThickness, IfcLogical IsVentilated, IfcLabel Name, IfcText Description, IfcLabel Category, IfcInteger Priority, IfcLayerSetDirectionEnum OffsetDirection, List<IfcLengthMeasure> OffsetValues) : base (Material, LayerThickness, IsVentilated, Name, Description, Category, Priority)
		{
			this.OffsetDirection = OffsetDirection;
			this.OffsetValues = OffsetValues;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialList;
	/// <para>ENTITY IfcMaterialList;</para>
	/// <para>Materials : LIST [1:?] OF IfcMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialList : Entity, IfcMaterialSelect
	{
		public virtual List<IfcMaterial>? Materials { get; set; }
		public IfcMaterialList() : base()
		{
		}
		public IfcMaterialList(List<IfcMaterial> Materials) : base ()
		{
			this.Materials = Materials;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfile
	/// <para>ENTITY IfcMaterialProfile</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMaterialProfileWithOffsets))</para>
	/// <para>SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Material : OPTIONAL IfcMaterial;</para>
	/// <para>Profile : IfcProfileDef;</para>
	/// <para>Priority : OPTIONAL IfcInteger;</para>
	/// <para>Category : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>ToMaterialProfileSet : IfcMaterialProfileSet FOR MaterialProfiles;</para>
	/// <para>WHERE</para>
	/// <para>NormalizedPriority : NOT(EXISTS(Priority)) OR {0 <= Priority <= 100};</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfile : IfcMaterialDefinition
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcMaterial? Material { get; set; }
		public virtual IfcProfileDef? Profile { get; set; }
		public virtual IfcInteger? Priority { get; set; }
		public virtual IfcLabel? Category { get; set; }
		//TODO INVERSE
		public IfcMaterialProfileSet? ToMaterialProfileSet => Model?.GetItems<IfcMaterialProfileSet>().FirstOrDefault(x => x.MaterialProfiles != null && x.MaterialProfiles.Contains(this));
		public IfcMaterialProfile() : base()
		{
		}
		public IfcMaterialProfile(IfcLabel Name, IfcText Description, IfcMaterial Material, IfcProfileDef Profile, IfcInteger Priority, IfcLabel Category) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Material = Material;
			this.Profile = Profile;
			this.Priority = Priority;
			this.Category = Category;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileSet
	/// <para>ENTITY IfcMaterialProfileSet</para>
	/// <para>SUBTYPE OF (IfcMaterialDefinition);</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>MaterialProfiles : LIST [1:?] OF IfcMaterialProfile;</para>
	/// <para>CompositeProfile : OPTIONAL IfcCompositeProfileDef;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileSet : IfcMaterialDefinition
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual List<IfcMaterialProfile>? MaterialProfiles { get; set; }
		public virtual IfcCompositeProfileDef? CompositeProfile { get; set; }
		public IfcMaterialProfileSet() : base()
		{
		}
		public IfcMaterialProfileSet(IfcLabel Name, IfcText Description, List<IfcMaterialProfile> MaterialProfiles, IfcCompositeProfileDef CompositeProfile) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.MaterialProfiles = MaterialProfiles;
			this.CompositeProfile = CompositeProfile;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileSetUsage
	/// <para>ENTITY IfcMaterialProfileSetUsage</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMaterialProfileSetUsageTapering))</para>
	/// <para>SUBTYPE OF (IfcMaterialUsageDefinition);</para>
	/// <para>ForProfileSet : IfcMaterialProfileSet;</para>
	/// <para>CardinalPoint : OPTIONAL IfcCardinalPointReference;</para>
	/// <para>ReferenceExtent : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileSetUsage : IfcMaterialUsageDefinition
	{
		public virtual IfcMaterialProfileSet? ForProfileSet { get; set; }
		public virtual IfcCardinalPointReference? CardinalPoint { get; set; }
		public virtual IfcPositiveLengthMeasure? ReferenceExtent { get; set; }
		public IfcMaterialProfileSetUsage() : base()
		{
		}
		public IfcMaterialProfileSetUsage(IfcMaterialProfileSet ForProfileSet, IfcCardinalPointReference CardinalPoint, IfcPositiveLengthMeasure ReferenceExtent) : base ()
		{
			this.ForProfileSet = ForProfileSet;
			this.CardinalPoint = CardinalPoint;
			this.ReferenceExtent = ReferenceExtent;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileSetUsageTapering
	/// <para>ENTITY IfcMaterialProfileSetUsageTapering</para>
	/// <para>SUBTYPE OF (IfcMaterialProfileSetUsage);</para>
	/// <para>ForProfileEndSet : IfcMaterialProfileSet;</para>
	/// <para>CardinalEndPoint : OPTIONAL IfcCardinalPointReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileSetUsageTapering : IfcMaterialProfileSetUsage
	{
		public virtual IfcMaterialProfileSet? ForProfileEndSet { get; set; }
		public virtual IfcCardinalPointReference? CardinalEndPoint { get; set; }
		public IfcMaterialProfileSetUsageTapering() : base()
		{
		}
		public IfcMaterialProfileSetUsageTapering(IfcMaterialProfileSet ForProfileSet, IfcCardinalPointReference CardinalPoint, IfcPositiveLengthMeasure ReferenceExtent, IfcMaterialProfileSet ForProfileEndSet, IfcCardinalPointReference CardinalEndPoint) : base (ForProfileSet, CardinalPoint, ReferenceExtent)
		{
			this.ForProfileEndSet = ForProfileEndSet;
			this.CardinalEndPoint = CardinalEndPoint;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProfileWithOffsets
	/// <para>ENTITY IfcMaterialProfileWithOffsets</para>
	/// <para>SUBTYPE OF (IfcMaterialProfile);</para>
	/// <para>OffsetValues : ARRAY [1:2] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProfileWithOffsets : IfcMaterialProfile
	{
		public virtual List<IfcLengthMeasure>? OffsetValues { get; set; }
		public IfcMaterialProfileWithOffsets() : base()
		{
		}
		public IfcMaterialProfileWithOffsets(IfcLabel Name, IfcText Description, IfcMaterial Material, IfcProfileDef Profile, IfcInteger Priority, IfcLabel Category, List<IfcLengthMeasure> OffsetValues) : base (Name, Description, Material, Profile, Priority, Category)
		{
			this.OffsetValues = OffsetValues;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialProperties
	/// <para>ENTITY IfcMaterialProperties</para>
	/// <para>SUBTYPE OF (IfcExtendedProperties);</para>
	/// <para>Material : IfcMaterialDefinition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialProperties : IfcExtendedProperties
	{
		public virtual IfcMaterialDefinition? Material { get; set; }
		public IfcMaterialProperties() : base()
		{
		}
		public IfcMaterialProperties(IfcIdentifier Name, IfcText Description, List<IfcProperty> Properties, IfcMaterialDefinition Material) : base (Name, Description, Properties)
		{
			this.Material = Material;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialRelationship
	/// <para>ENTITY IfcMaterialRelationship</para>
	/// <para>SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>RelatingMaterial : IfcMaterial;</para>
	/// <para>RelatedMaterials : SET [1:?] OF IfcMaterial;</para>
	/// <para>Expression : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMaterialRelationship : IfcResourceLevelRelationship
	{
		public virtual IfcMaterial? RelatingMaterial { get; set; }
		public virtual List<IfcMaterial>? RelatedMaterials { get; set; }
		public virtual IfcLabel? Expression { get; set; }
		public IfcMaterialRelationship() : base()
		{
		}
		public IfcMaterialRelationship(IfcLabel Name, IfcText Description, IfcMaterial RelatingMaterial, List<IfcMaterial> RelatedMaterials, IfcLabel Expression) : base (Name, Description)
		{
			this.RelatingMaterial = RelatingMaterial;
			this.RelatedMaterials = RelatedMaterials;
			this.Expression = Expression;
		}
	}
	/// <summary>
	/// ENTITY IfcMaterialUsageDefinition
	/// <para>ENTITY IfcMaterialUsageDefinition</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMaterialLayerSetUsage</para>
	/// <para>,IfcMaterialProfileSetUsage));</para>
	/// <para>INVERSE</para>
	/// <para>AssociatedTo : SET [1:?] OF IfcRelAssociatesMaterial FOR RelatingMaterial;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcMaterialUsageDefinition : Entity, IfcMaterialSelect
	{
		//TODO INVERSE
		public List<IfcRelAssociatesMaterial>? AssociatedTo => Model?.GetItems<IfcRelAssociatesMaterial>().Where(x => x.RelatingMaterial != null && x.RelatingMaterial == this).ToList();
		public IfcMaterialUsageDefinition() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMeasureWithUnit;
	/// <para>ENTITY IfcMeasureWithUnit;</para>
	/// <para>ValueComponent : IfcValue;</para>
	/// <para>UnitComponent : IfcUnit;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMeasureWithUnit : Entity, IfcAppliedValueSelect, IfcMetricValueSelect
	{
		public virtual IfcValue? ValueComponent { get; set; }
		public virtual IfcUnit? UnitComponent { get; set; }
		public IfcMeasureWithUnit() : base()
		{
		}
		public IfcMeasureWithUnit(IfcValue ValueComponent, IfcUnit UnitComponent) : base ()
		{
			this.ValueComponent = ValueComponent;
			this.UnitComponent = UnitComponent;
		}
	}
	/// <summary>
	/// ENTITY IfcMechanicalFastener
	/// <para>ENTITY IfcMechanicalFastener</para>
	/// <para>SUBTYPE OF (IfcElementComponent);</para>
	/// <para>NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>NominalLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>PredefinedType : OPTIONAL IfcMechanicalFastenerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcMechanicalFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMechanicalFastenerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCMECHANICALFASTENERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMechanicalFastener : IfcElementComponent
	{
		public virtual IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public virtual IfcPositiveLengthMeasure? NominalLength { get; set; }
		public virtual IfcMechanicalFastenerTypeEnum? PredefinedType { get; set; }
		public IfcMechanicalFastener() : base()
		{
		}
		public IfcMechanicalFastener(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure NominalDiameter, IfcPositiveLengthMeasure NominalLength, IfcMechanicalFastenerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.NominalDiameter = NominalDiameter;
			this.NominalLength = NominalLength;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMechanicalFastenerType
	/// <para>ENTITY IfcMechanicalFastenerType</para>
	/// <para>SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>PredefinedType : IfcMechanicalFastenerTypeEnum;</para>
	/// <para>NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>NominalLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcMechanicalFastenerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMechanicalFastenerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMechanicalFastenerType : IfcElementComponentType
	{
		public virtual IfcMechanicalFastenerTypeEnum? PredefinedType { get; set; }
		public virtual IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public virtual IfcPositiveLengthMeasure? NominalLength { get; set; }
		public IfcMechanicalFastenerType() : base()
		{
		}
		public IfcMechanicalFastenerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMechanicalFastenerTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcPositiveLengthMeasure NominalLength) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.NominalLength = NominalLength;
		}
	}
	/// <summary>
	/// ENTITY IfcMedicalDevice
	/// <para>ENTITY IfcMedicalDevice</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcMedicalDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcMedicalDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMedicalDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCMEDICALDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMedicalDevice : IfcFlowTerminal
	{
		public virtual IfcMedicalDeviceTypeEnum? PredefinedType { get; set; }
		public IfcMedicalDevice() : base()
		{
		}
		public IfcMedicalDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMedicalDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMedicalDeviceType
	/// <para>ENTITY IfcMedicalDeviceType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcMedicalDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcMedicalDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMedicalDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMedicalDeviceType : IfcFlowTerminalType
	{
		public virtual IfcMedicalDeviceTypeEnum? PredefinedType { get; set; }
		public IfcMedicalDeviceType() : base()
		{
		}
		public IfcMedicalDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMedicalDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMember
	/// <para>ENTITY IfcMember</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMemberStandardCase))</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcMemberTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcMemberTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMemberTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCMEMBERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMember : IfcBuildingElement
	{
		public virtual IfcMemberTypeEnum? PredefinedType { get; set; }
		public IfcMember() : base()
		{
		}
		public IfcMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMemberTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMemberStandardCase
	/// <para>ENTITY IfcMemberStandardCase</para>
	/// <para>SUBTYPE OF (IfcMember);</para>
	/// <para>WHERE</para>
	/// <para>HasMaterialProfileSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4X1.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>('IFC4X1.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>('IFC4X1.IFCMATERIALPROFILESETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMemberStandardCase : IfcMember
	{
		public IfcMemberStandardCase() : base()
		{
		}
		public IfcMemberStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMemberTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMemberType
	/// <para>ENTITY IfcMemberType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcMemberTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcMemberTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMemberTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMemberType : IfcBuildingElementType
	{
		public virtual IfcMemberTypeEnum? PredefinedType { get; set; }
		public IfcMemberType() : base()
		{
		}
		public IfcMemberType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMemberTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMetric
	/// <para>ENTITY IfcMetric</para>
	/// <para>SUBTYPE OF (IfcConstraint);</para>
	/// <para>Benchmark : IfcBenchmarkEnum;</para>
	/// <para>ValueSource : OPTIONAL IfcLabel;</para>
	/// <para>DataValue : OPTIONAL IfcMetricValueSelect;</para>
	/// <para>ReferencePath : OPTIONAL IfcReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMetric : IfcConstraint
	{
		public virtual IfcBenchmarkEnum? Benchmark { get; set; }
		public virtual IfcLabel? ValueSource { get; set; }
		public virtual IfcMetricValueSelect? DataValue { get; set; }
		public virtual IfcReference? ReferencePath { get; set; }
		public IfcMetric() : base()
		{
		}
		public IfcMetric(IfcLabel Name, IfcText Description, IfcConstraintEnum ConstraintGrade, IfcLabel ConstraintSource, IfcActorSelect CreatingActor, IfcDateTime CreationTime, IfcLabel UserDefinedGrade, IfcBenchmarkEnum Benchmark, IfcLabel ValueSource, IfcMetricValueSelect DataValue, IfcReference ReferencePath) : base (Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade)
		{
			this.Benchmark = Benchmark;
			this.ValueSource = ValueSource;
			this.DataValue = DataValue;
			this.ReferencePath = ReferencePath;
		}
	}
	/// <summary>
	/// ENTITY IfcMirroredProfileDef
	/// <para>ENTITY IfcMirroredProfileDef</para>
	/// <para>SUBTYPE OF (IfcDerivedProfileDef);</para>
	/// <para>DERIVE</para>
	/// <para>SELF\IfcDerivedProfileDef.Operator : IfcCartesianTransformationOperator2D :=</para>
	/// <para>IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>IfcCartesianTransformationOperator(</para>
	/// <para>-- Axis1</para>
	/// <para>IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>IfcDirection([-1., 0.]),</para>
	/// <para>-- Axis2</para>
	/// <para>IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>IfcDirection([ 0., 1.]),</para>
	/// <para>-- LocalOrigin</para>
	/// <para>IfcRepresentationItem() || IfcGeometricRepresentationItem() ||</para>
	/// <para>IfcPoint() || IfcCartesianPoint([0., 0.]),</para>
	/// <para>-- Scale</para>
	/// <para>1.) ||</para>
	/// <para>IfcCartesianTransformationOperator2D();</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMirroredProfileDef : IfcDerivedProfileDef
	{
		//TODO DERIVE
		public override IfcCartesianTransformationOperator2D? Operator {get {return null;}}
		public IfcMirroredProfileDef() : base()
		{
		}
		public IfcMirroredProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcProfileDef ParentProfile, IfcCartesianTransformationOperator2D Operator, IfcLabel Label) : base (ProfileType, ProfileName, ParentProfile, Operator, Label)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcMonetaryUnit;
	/// <para>ENTITY IfcMonetaryUnit;</para>
	/// <para>Currency : IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMonetaryUnit : Entity, IfcUnit
	{
		public virtual IfcLabel? Currency { get; set; }
		public IfcMonetaryUnit() : base()
		{
		}
		public IfcMonetaryUnit(IfcLabel Currency) : base ()
		{
			this.Currency = Currency;
		}
	}
	/// <summary>
	/// ENTITY IfcMotorConnection
	/// <para>ENTITY IfcMotorConnection</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcMotorConnectionTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcMotorConnectionTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMotorConnectionTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCMOTORCONNECTIONTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMotorConnection : IfcEnergyConversionDevice
	{
		public virtual IfcMotorConnectionTypeEnum? PredefinedType { get; set; }
		public IfcMotorConnection() : base()
		{
		}
		public IfcMotorConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcMotorConnectionTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcMotorConnectionType
	/// <para>ENTITY IfcMotorConnectionType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcMotorConnectionTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcMotorConnectionTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcMotorConnectionTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcMotorConnectionType : IfcEnergyConversionDeviceType
	{
		public virtual IfcMotorConnectionTypeEnum? PredefinedType { get; set; }
		public IfcMotorConnectionType() : base()
		{
		}
		public IfcMotorConnectionType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcMotorConnectionTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcNamedUnit
	/// <para>ENTITY IfcNamedUnit</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcContextDependentUnit</para>
	/// <para>,IfcConversionBasedUnit</para>
	/// <para>,IfcSIUnit));</para>
	/// <para>Dimensions : IfcDimensionalExponents;</para>
	/// <para>UnitType : IfcUnitEnum;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : IfcCorrectDimensions (SELF.UnitType, SELF.Dimensions);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcNamedUnit : Entity, IfcUnit
	{
		public virtual IfcDimensionalExponents? Dimensions { get; set; }
		public virtual IfcUnitEnum? UnitType { get; set; }
		public IfcNamedUnit() : base()
		{
		}
		public IfcNamedUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType) : base ()
		{
			this.Dimensions = Dimensions;
			this.UnitType = UnitType;
		}
	}
	/// <summary>
	/// ENTITY IfcObject
	/// <para>ENTITY IfcObject</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcActor</para>
	/// <para>,IfcControl</para>
	/// <para>,IfcGroup</para>
	/// <para>,IfcProcess</para>
	/// <para>,IfcProduct</para>
	/// <para>,IfcResource))</para>
	/// <para>SUBTYPE OF (IfcObjectDefinition);</para>
	/// <para>ObjectType : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>IsDeclaredBy : SET [0:1] OF IfcRelDefinesByObject FOR RelatedObjects;</para>
	/// <para>Declares : SET [0:?] OF IfcRelDefinesByObject FOR RelatingObject;</para>
	/// <para>IsTypedBy : SET [0:1] OF IfcRelDefinesByType FOR RelatedObjects;</para>
	/// <para>IsDefinedBy : SET [0:?] OF IfcRelDefinesByProperties FOR RelatedObjects;</para>
	/// <para>WHERE</para>
	/// <para>UniquePropertySetNames : ((SIZEOF(IsDefinedBy) = 0) OR IfcUniqueDefinitionNames(IsDefinedBy));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcObject : IfcObjectDefinition
	{
		public virtual IfcLabel? ObjectType { get; set; }
		//TODO INVERSE
		public List<IfcRelDefinesByObject>? IsDeclaredBy => Model?.GetItems<IfcRelDefinesByObject>().Where(x => x.RelatedObjects != null && x.RelatedObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelDefinesByObject>? Declares => Model?.GetItems<IfcRelDefinesByObject>().Where(x => x.RelatingObject != null && x.RelatingObject == this).ToList();
		//TODO INVERSE
		public List<IfcRelDefinesByType>? IsTypedBy => Model?.GetItems<IfcRelDefinesByType>().Where(x => x.RelatedObjects != null && x.RelatedObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelDefinesByProperties>? IsDefinedBy => Model?.GetItems<IfcRelDefinesByProperties>().Where(x => x.RelatedObjects != null && x.RelatedObjects.Contains(this)).ToList();
		public IfcObject() : base()
		{
		}
		public IfcObject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ObjectType = ObjectType;
		}
	}
	/// <summary>
	/// ENTITY IfcObjectDefinition
	/// <para>ENTITY IfcObjectDefinition</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcContext</para>
	/// <para>,IfcObject</para>
	/// <para>,IfcTypeObject))</para>
	/// <para>SUBTYPE OF (IfcRoot);</para>
	/// <para>INVERSE</para>
	/// <para>HasAssignments : SET [0:?] OF IfcRelAssigns FOR RelatedObjects;</para>
	/// <para>Nests : SET [0:1] OF IfcRelNests FOR RelatedObjects;</para>
	/// <para>IsNestedBy : SET [0:?] OF IfcRelNests FOR RelatingObject;</para>
	/// <para>HasContext : SET [0:1] OF IfcRelDeclares FOR RelatedDefinitions;</para>
	/// <para>IsDecomposedBy : SET [0:?] OF IfcRelAggregates FOR RelatingObject;</para>
	/// <para>Decomposes : SET [0:1] OF IfcRelAggregates FOR RelatedObjects;</para>
	/// <para>HasAssociations : SET [0:?] OF IfcRelAssociates FOR RelatedObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcObjectDefinition : IfcRoot, IfcDefinitionSelect
	{
		//TODO INVERSE
		public List<IfcRelAssigns>? HasAssignments => Model?.GetItems<IfcRelAssigns>().Where(x => x.RelatedObjects != null && x.RelatedObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelNests>? Nests => Model?.GetItems<IfcRelNests>().Where(x => x.RelatedObjects != null && x.RelatedObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelNests>? IsNestedBy => Model?.GetItems<IfcRelNests>().Where(x => x.RelatingObject != null && x.RelatingObject == this).ToList();
		//TODO INVERSE
		public List<IfcRelDeclares>? HasContext => Model?.GetItems<IfcRelDeclares>().Where(x => x.RelatedDefinitions != null && x.RelatedDefinitions.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelAggregates>? IsDecomposedBy => Model?.GetItems<IfcRelAggregates>().Where(x => x.RelatingObject != null && x.RelatingObject == this).ToList();
		//TODO INVERSE
		public List<IfcRelAggregates>? Decomposes => Model?.GetItems<IfcRelAggregates>().Where(x => x.RelatedObjects != null && x.RelatedObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelAssociates>? HasAssociations => Model?.GetItems<IfcRelAssociates>().Where(x => x.RelatedObjects != null && x.RelatedObjects.Contains(this)).ToList();
		public IfcObjectDefinition() : base()
		{
		}
		public IfcObjectDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcObjectPlacement
	/// <para>ENTITY IfcObjectPlacement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcGridPlacement</para>
	/// <para>,IfcLinearPlacement</para>
	/// <para>,IfcLocalPlacement));</para>
	/// <para>INVERSE</para>
	/// <para>PlacesObject : SET [0:?] OF IfcProduct FOR ObjectPlacement;</para>
	/// <para>ReferencedByPlacements : SET [0:?] OF IfcLocalPlacement FOR PlacementRelTo;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcObjectPlacement : Entity
	{
		//TODO INVERSE
		public List<IfcProduct>? PlacesObject => Model?.GetItems<IfcProduct>().Where(x => x.ObjectPlacement != null && x.ObjectPlacement == this).ToList();
		//TODO INVERSE
		public List<IfcLocalPlacement>? ReferencedByPlacements => Model?.GetItems<IfcLocalPlacement>().Where(x => x.PlacementRelTo != null && x.PlacementRelTo == this).ToList();
		public IfcObjectPlacement() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcObjective
	/// <para>ENTITY IfcObjective</para>
	/// <para>SUBTYPE OF (IfcConstraint);</para>
	/// <para>BenchmarkValues : OPTIONAL LIST [1:?] OF IfcConstraint;</para>
	/// <para>LogicalAggregator : OPTIONAL IfcLogicalOperatorEnum;</para>
	/// <para>ObjectiveQualifier : IfcObjectiveEnum;</para>
	/// <para>UserDefinedQualifier : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : (ObjectiveQualifier <> IfcObjectiveEnum.USERDEFINED) OR</para>
	/// <para>((ObjectiveQualifier = IfcObjectiveEnum.USERDEFINED) AND EXISTS(SELF\IfcObjective.UserDefinedQualifier));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcObjective : IfcConstraint
	{
		public virtual List<IfcConstraint>? BenchmarkValues { get; set; }
		public virtual IfcLogicalOperatorEnum? LogicalAggregator { get; set; }
		public virtual IfcObjectiveEnum? ObjectiveQualifier { get; set; }
		public virtual IfcLabel? UserDefinedQualifier { get; set; }
		public IfcObjective() : base()
		{
		}
		public IfcObjective(IfcLabel Name, IfcText Description, IfcConstraintEnum ConstraintGrade, IfcLabel ConstraintSource, IfcActorSelect CreatingActor, IfcDateTime CreationTime, IfcLabel UserDefinedGrade, List<IfcConstraint> BenchmarkValues, IfcLogicalOperatorEnum LogicalAggregator, IfcObjectiveEnum ObjectiveQualifier, IfcLabel UserDefinedQualifier) : base (Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade)
		{
			this.BenchmarkValues = BenchmarkValues;
			this.LogicalAggregator = LogicalAggregator;
			this.ObjectiveQualifier = ObjectiveQualifier;
			this.UserDefinedQualifier = UserDefinedQualifier;
		}
	}
	/// <summary>
	/// ENTITY IfcOccupant
	/// <para>ENTITY IfcOccupant</para>
	/// <para>SUBTYPE OF (IfcActor);</para>
	/// <para>PredefinedType : OPTIONAL IfcOccupantTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>WR31 : NOT(PredefinedType = IfcOccupantTypeEnum.USERDEFINED)</para>
	/// <para>OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOccupant : IfcActor
	{
		public virtual IfcOccupantTypeEnum? PredefinedType { get; set; }
		public IfcOccupant() : base()
		{
		}
		public IfcOccupant(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcActorSelect TheActor, IfcOccupantTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOffsetCurve
	/// <para>ENTITY IfcOffsetCurve</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcOffsetCurve2D</para>
	/// <para>,IfcOffsetCurve3D</para>
	/// <para>,IfcOffsetCurveByDistances))</para>
	/// <para>SUBTYPE OF (IfcCurve);</para>
	/// <para>BasisCurve : IfcCurve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcOffsetCurve : IfcCurve
	{
		public virtual IfcCurve? BasisCurve { get; set; }
		public IfcOffsetCurve() : base()
		{
		}
		public IfcOffsetCurve(IfcCurve BasisCurve) : base ()
		{
			this.BasisCurve = BasisCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcOffsetCurve2D
	/// <para>ENTITY IfcOffsetCurve2D</para>
	/// <para>SUBTYPE OF (IfcOffsetCurve);</para>
	/// <para>Distance : IfcLengthMeasure;</para>
	/// <para>SelfIntersect : IfcLogical;</para>
	/// <para>WHERE</para>
	/// <para>DimIs2D : BasisCurve.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOffsetCurve2D : IfcOffsetCurve
	{
		public virtual IfcLengthMeasure? Distance { get; set; }
		public virtual IfcLogical? SelfIntersect { get; set; }
		public IfcOffsetCurve2D() : base()
		{
		}
		public IfcOffsetCurve2D(IfcCurve BasisCurve, IfcLengthMeasure Distance, IfcLogical SelfIntersect) : base (BasisCurve)
		{
			this.Distance = Distance;
			this.SelfIntersect = SelfIntersect;
		}
	}
	/// <summary>
	/// ENTITY IfcOffsetCurve3D
	/// <para>ENTITY IfcOffsetCurve3D</para>
	/// <para>SUBTYPE OF (IfcOffsetCurve);</para>
	/// <para>Distance : IfcLengthMeasure;</para>
	/// <para>SelfIntersect : IfcLogical;</para>
	/// <para>RefDirection : IfcDirection;</para>
	/// <para>WHERE</para>
	/// <para>DimIs2D : BasisCurve.Dim = 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOffsetCurve3D : IfcOffsetCurve
	{
		public virtual IfcLengthMeasure? Distance { get; set; }
		public virtual IfcLogical? SelfIntersect { get; set; }
		public virtual IfcDirection? RefDirection { get; set; }
		public IfcOffsetCurve3D() : base()
		{
		}
		public IfcOffsetCurve3D(IfcCurve BasisCurve, IfcLengthMeasure Distance, IfcLogical SelfIntersect, IfcDirection RefDirection) : base (BasisCurve)
		{
			this.Distance = Distance;
			this.SelfIntersect = SelfIntersect;
			this.RefDirection = RefDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcOffsetCurveByDistances
	/// <para>ENTITY IfcOffsetCurveByDistances</para>
	/// <para>SUBTYPE OF (IfcOffsetCurve);</para>
	/// <para>OffsetValues : LIST [1:?] OF IfcDistanceExpression;</para>
	/// <para>Tag : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOffsetCurveByDistances : IfcOffsetCurve
	{
		public virtual List<IfcDistanceExpression>? OffsetValues { get; set; }
		public virtual IfcLabel? Tag { get; set; }
		public IfcOffsetCurveByDistances() : base()
		{
		}
		public IfcOffsetCurveByDistances(IfcCurve BasisCurve, List<IfcDistanceExpression> OffsetValues, IfcLabel Tag) : base (BasisCurve)
		{
			this.OffsetValues = OffsetValues;
			this.Tag = Tag;
		}
	}
	/// <summary>
	/// ENTITY IfcOpenShell
	/// <para>ENTITY IfcOpenShell</para>
	/// <para>SUBTYPE OF (IfcConnectedFaceSet);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOpenShell : IfcConnectedFaceSet, IfcShell
	{
		public IfcOpenShell() : base()
		{
		}
		public IfcOpenShell(List<IfcFace> CfsFaces) : base (CfsFaces)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcOpeningElement
	/// <para>ENTITY IfcOpeningElement</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcOpeningStandardCase))</para>
	/// <para>SUBTYPE OF (IfcFeatureElementSubtraction);</para>
	/// <para>PredefinedType : OPTIONAL IfcOpeningElementTypeEnum;</para>
	/// <para>INVERSE</para>
	/// <para>HasFillings : SET [0:?] OF IfcRelFillsElement FOR RelatingOpeningElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOpeningElement : IfcFeatureElementSubtraction
	{
		public virtual IfcOpeningElementTypeEnum? PredefinedType { get; set; }
		//TODO INVERSE
		public List<IfcRelFillsElement>? HasFillings => Model?.GetItems<IfcRelFillsElement>().Where(x => x.RelatingOpeningElement != null && x.RelatingOpeningElement == this).ToList();
		public IfcOpeningElement() : base()
		{
		}
		public IfcOpeningElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcOpeningElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOpeningStandardCase
	/// <para>ENTITY IfcOpeningStandardCase</para>
	/// <para>SUBTYPE OF (IfcOpeningElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOpeningStandardCase : IfcOpeningElement
	{
		public IfcOpeningStandardCase() : base()
		{
		}
		public IfcOpeningStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcOpeningElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcOrganization;
	/// <para>ENTITY IfcOrganization;</para>
	/// <para>Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Roles : OPTIONAL LIST [1:?] OF IfcActorRole;</para>
	/// <para>Addresses : OPTIONAL LIST [1:?] OF IfcAddress;</para>
	/// <para>INVERSE</para>
	/// <para>IsRelatedBy : SET [0:?] OF IfcOrganizationRelationship FOR RelatedOrganizations;</para>
	/// <para>Relates : SET [0:?] OF IfcOrganizationRelationship FOR RelatingOrganization;</para>
	/// <para>Engages : SET [0:?] OF IfcPersonAndOrganization FOR TheOrganization;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOrganization : Entity, IfcActorSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public virtual IfcIdentifier? Identification { get; set; }
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual List<IfcActorRole>? Roles { get; set; }
		public virtual List<IfcAddress>? Addresses { get; set; }
		//TODO INVERSE
		public List<IfcOrganizationRelationship>? IsRelatedBy => Model?.GetItems<IfcOrganizationRelationship>().Where(x => x.RelatedOrganizations != null && x.RelatedOrganizations.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcOrganizationRelationship>? Relates => Model?.GetItems<IfcOrganizationRelationship>().Where(x => x.RelatingOrganization != null && x.RelatingOrganization == this).ToList();
		//TODO INVERSE
		public List<IfcPersonAndOrganization>? Engages => Model?.GetItems<IfcPersonAndOrganization>().Where(x => x.TheOrganization != null && x.TheOrganization == this).ToList();
		public IfcOrganization() : base()
		{
		}
		public IfcOrganization(IfcIdentifier Identification, IfcLabel Name, IfcText Description, List<IfcActorRole> Roles, List<IfcAddress> Addresses) : base ()
		{
			this.Identification = Identification;
			this.Name = Name;
			this.Description = Description;
			this.Roles = Roles;
			this.Addresses = Addresses;
		}
	}
	/// <summary>
	/// ENTITY IfcOrganizationRelationship
	/// <para>ENTITY IfcOrganizationRelationship</para>
	/// <para>SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>RelatingOrganization : IfcOrganization;</para>
	/// <para>RelatedOrganizations : SET [1:?] OF IfcOrganization;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOrganizationRelationship : IfcResourceLevelRelationship
	{
		public virtual IfcOrganization? RelatingOrganization { get; set; }
		public virtual List<IfcOrganization>? RelatedOrganizations { get; set; }
		public IfcOrganizationRelationship() : base()
		{
		}
		public IfcOrganizationRelationship(IfcLabel Name, IfcText Description, IfcOrganization RelatingOrganization, List<IfcOrganization> RelatedOrganizations) : base (Name, Description)
		{
			this.RelatingOrganization = RelatingOrganization;
			this.RelatedOrganizations = RelatedOrganizations;
		}
	}
	/// <summary>
	/// ENTITY IfcOrientationExpression
	/// <para>ENTITY IfcOrientationExpression</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>LateralAxisDirection : IfcDirection;</para>
	/// <para>VerticalAxisDirection : IfcDirection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOrientationExpression : IfcGeometricRepresentationItem
	{
		public virtual IfcDirection? LateralAxisDirection { get; set; }
		public virtual IfcDirection? VerticalAxisDirection { get; set; }
		public IfcOrientationExpression() : base()
		{
		}
		public IfcOrientationExpression(IfcDirection LateralAxisDirection, IfcDirection VerticalAxisDirection) : base ()
		{
			this.LateralAxisDirection = LateralAxisDirection;
			this.VerticalAxisDirection = VerticalAxisDirection;
		}
	}
	/// <summary>
	/// ENTITY IfcOrientedEdge
	/// <para>ENTITY IfcOrientedEdge</para>
	/// <para>SUBTYPE OF (IfcEdge);</para>
	/// <para>EdgeElement : IfcEdge;</para>
	/// <para>Orientation : IfcBoolean;</para>
	/// <para>DERIVE</para>
	/// <para>SELF\IfcEdge.EdgeStart : IfcVertex := IfcBooleanChoose</para>
	/// <para>(Orientation, EdgeElement.EdgeStart, EdgeElement.EdgeEnd);</para>
	/// <para>SELF\IfcEdge.EdgeEnd : IfcVertex := IfcBooleanChoose</para>
	/// <para>(Orientation, EdgeElement.EdgeEnd, EdgeElement.EdgeStart);</para>
	/// <para>WHERE</para>
	/// <para>EdgeElementNotOriented : NOT('IFC4X1.IFCORIENTEDEDGE' IN TYPEOF(EdgeElement));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOrientedEdge : IfcEdge
	{
		public virtual IfcEdge? EdgeElement { get; set; }
		public virtual IfcBoolean? Orientation { get; set; }
		//TODO DERIVE
		public override IfcVertex? EdgeStart {get {return null;}}
		//TODO DERIVE
		public override IfcVertex? EdgeEnd {get {return null;}}
		public IfcOrientedEdge() : base()
		{
		}
		public IfcOrientedEdge(IfcVertex EdgeStart, IfcVertex EdgeEnd, IfcEdge EdgeElement, IfcBoolean Orientation) : base (EdgeStart, EdgeEnd)
		{
			this.EdgeElement = EdgeElement;
			this.Orientation = Orientation;
		}
	}
	/// <summary>
	/// ENTITY IfcOuterBoundaryCurve
	/// <para>ENTITY IfcOuterBoundaryCurve</para>
	/// <para>SUBTYPE OF (IfcBoundaryCurve);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOuterBoundaryCurve : IfcBoundaryCurve
	{
		public IfcOuterBoundaryCurve() : base()
		{
		}
		public IfcOuterBoundaryCurve(List<IfcCompositeCurveSegment> Segments, IfcLogical SelfIntersect) : base (Segments, SelfIntersect)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcOutlet
	/// <para>ENTITY IfcOutlet</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcOutletTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcOutletTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcOutletTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCOUTLETTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOutlet : IfcFlowTerminal
	{
		public virtual IfcOutletTypeEnum? PredefinedType { get; set; }
		public IfcOutlet() : base()
		{
		}
		public IfcOutlet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcOutletTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOutletType
	/// <para>ENTITY IfcOutletType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcOutletTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcOutletTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcOutletTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOutletType : IfcFlowTerminalType
	{
		public virtual IfcOutletTypeEnum? PredefinedType { get; set; }
		public IfcOutletType() : base()
		{
		}
		public IfcOutletType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcOutletTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcOwnerHistory;
	/// <para>ENTITY IfcOwnerHistory;</para>
	/// <para>OwningUser : IfcPersonAndOrganization;</para>
	/// <para>OwningApplication : IfcApplication;</para>
	/// <para>State : OPTIONAL IfcStateEnum;</para>
	/// <para>ChangeAction : OPTIONAL IfcChangeActionEnum;</para>
	/// <para>LastModifiedDate : OPTIONAL IfcTimeStamp;</para>
	/// <para>LastModifyingUser : OPTIONAL IfcPersonAndOrganization;</para>
	/// <para>LastModifyingApplication : OPTIONAL IfcApplication;</para>
	/// <para>CreationDate : IfcTimeStamp;</para>
	/// <para>WHERE</para>
	/// <para>CorrectChangeAction : (EXISTS(LastModifiedDate)) OR</para>
	/// <para>(NOT(EXISTS(LastModifiedDate)) AND NOT(EXISTS(ChangeAction))) OR</para>
	/// <para>(NOT(EXISTS(LastModifiedDate)) AND EXISTS(ChangeAction) AND ((ChangeAction = IfcChangeActionEnum.NOTDEFINED) OR (ChangeAction = IfcChangeActionEnum.NOCHANGE)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcOwnerHistory : Entity
	{
		public virtual IfcPersonAndOrganization? OwningUser { get; set; }
		public virtual IfcApplication? OwningApplication { get; set; }
		public virtual IfcStateEnum? State { get; set; }
		public virtual IfcChangeActionEnum? ChangeAction { get; set; }
		public virtual IfcTimeStamp? LastModifiedDate { get; set; }
		public virtual IfcPersonAndOrganization? LastModifyingUser { get; set; }
		public virtual IfcApplication? LastModifyingApplication { get; set; }
		public virtual IfcTimeStamp? CreationDate { get; set; }
		public IfcOwnerHistory() : base()
		{
		}
		public IfcOwnerHistory(IfcPersonAndOrganization OwningUser, IfcApplication OwningApplication, IfcStateEnum State, IfcChangeActionEnum ChangeAction, IfcTimeStamp LastModifiedDate, IfcPersonAndOrganization LastModifyingUser, IfcApplication LastModifyingApplication, IfcTimeStamp CreationDate) : base ()
		{
			this.OwningUser = OwningUser;
			this.OwningApplication = OwningApplication;
			this.State = State;
			this.ChangeAction = ChangeAction;
			this.LastModifiedDate = LastModifiedDate;
			this.LastModifyingUser = LastModifyingUser;
			this.LastModifyingApplication = LastModifyingApplication;
			this.CreationDate = CreationDate;
		}
	}
	/// <summary>
	/// ENTITY IfcParameterizedProfileDef
	/// <para>ENTITY IfcParameterizedProfileDef</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAsymmetricIShapeProfileDef</para>
	/// <para>,IfcCShapeProfileDef</para>
	/// <para>,IfcCircleProfileDef</para>
	/// <para>,IfcEllipseProfileDef</para>
	/// <para>,IfcIShapeProfileDef</para>
	/// <para>,IfcLShapeProfileDef</para>
	/// <para>,IfcRectangleProfileDef</para>
	/// <para>,IfcTShapeProfileDef</para>
	/// <para>,IfcTrapeziumProfileDef</para>
	/// <para>,IfcUShapeProfileDef</para>
	/// <para>,IfcZShapeProfileDef))</para>
	/// <para>SUBTYPE OF (IfcProfileDef);</para>
	/// <para>Position : OPTIONAL IfcAxis2Placement2D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcParameterizedProfileDef : IfcProfileDef
	{
		public virtual IfcAxis2Placement2D? Position { get; set; }
		public IfcParameterizedProfileDef() : base()
		{
		}
		public IfcParameterizedProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position) : base (ProfileType, ProfileName)
		{
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcPath
	/// <para>ENTITY IfcPath</para>
	/// <para>SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>EdgeList : LIST [1:?] OF UNIQUE IfcOrientedEdge;</para>
	/// <para>WHERE</para>
	/// <para>IsContinuous : IfcPathHeadToTail(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPath : IfcTopologicalRepresentationItem
	{
		public IfcPath() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPcurve
	/// <para>ENTITY IfcPcurve</para>
	/// <para>SUBTYPE OF (IfcCurve);</para>
	/// <para>BasisSurface : IfcSurface;</para>
	/// <para>ReferenceCurve : IfcCurve;</para>
	/// <para>WHERE</para>
	/// <para>DimIs2D : ReferenceCurve.Dim = 2;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPcurve : IfcCurve, IfcCurveOnSurface
	{
		public virtual IfcSurface? BasisSurface { get; set; }
		public virtual IfcCurve? ReferenceCurve { get; set; }
		public IfcPcurve() : base()
		{
		}
		public IfcPcurve(IfcSurface BasisSurface, IfcCurve ReferenceCurve) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.ReferenceCurve = ReferenceCurve;
		}
	}
	/// <summary>
	/// ENTITY IfcPerformanceHistory
	/// <para>ENTITY IfcPerformanceHistory</para>
	/// <para>SUBTYPE OF (IfcControl);</para>
	/// <para>LifeCyclePhase : IfcLabel;</para>
	/// <para>PredefinedType : OPTIONAL IfcPerformanceHistoryTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPerformanceHistory : IfcControl
	{
		public virtual IfcLabel? LifeCyclePhase { get; set; }
		public virtual IfcPerformanceHistoryTypeEnum? PredefinedType { get; set; }
		public IfcPerformanceHistory() : base()
		{
		}
		public IfcPerformanceHistory(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcLabel LifeCyclePhase, IfcPerformanceHistoryTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.LifeCyclePhase = LifeCyclePhase;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPermeableCoveringProperties
	/// <para>ENTITY IfcPermeableCoveringProperties</para>
	/// <para>SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>OperationType : IfcPermeableCoveringOperationEnum;</para>
	/// <para>PanelPosition : IfcWindowPanelPositionEnum;</para>
	/// <para>FrameDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>FrameThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPermeableCoveringProperties : IfcPreDefinedPropertySet
	{
		public virtual IfcPermeableCoveringOperationEnum? OperationType { get; set; }
		public virtual IfcWindowPanelPositionEnum? PanelPosition { get; set; }
		public virtual IfcPositiveLengthMeasure? FrameDepth { get; set; }
		public virtual IfcPositiveLengthMeasure? FrameThickness { get; set; }
		public virtual IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcPermeableCoveringProperties() : base()
		{
		}
		public IfcPermeableCoveringProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPermeableCoveringOperationEnum OperationType, IfcWindowPanelPositionEnum PanelPosition, IfcPositiveLengthMeasure FrameDepth, IfcPositiveLengthMeasure FrameThickness, IfcShapeAspect ShapeAspectStyle) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.OperationType = OperationType;
			this.PanelPosition = PanelPosition;
			this.FrameDepth = FrameDepth;
			this.FrameThickness = FrameThickness;
			this.ShapeAspectStyle = ShapeAspectStyle;
		}
	}
	/// <summary>
	/// ENTITY IfcPermit
	/// <para>ENTITY IfcPermit</para>
	/// <para>SUBTYPE OF (IfcControl);</para>
	/// <para>PredefinedType : OPTIONAL IfcPermitTypeEnum;</para>
	/// <para>Status : OPTIONAL IfcLabel;</para>
	/// <para>LongDescription : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPermit : IfcControl
	{
		public virtual IfcPermitTypeEnum? PredefinedType { get; set; }
		public virtual IfcLabel? Status { get; set; }
		public virtual IfcText? LongDescription { get; set; }
		public IfcPermit() : base()
		{
		}
		public IfcPermit(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcPermitTypeEnum PredefinedType, IfcLabel Status, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcPerson;
	/// <para>ENTITY IfcPerson;</para>
	/// <para>Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>FamilyName : OPTIONAL IfcLabel;</para>
	/// <para>GivenName : OPTIONAL IfcLabel;</para>
	/// <para>MiddleNames : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>PrefixTitles : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>SuffixTitles : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>Roles : OPTIONAL LIST [1:?] OF IfcActorRole;</para>
	/// <para>Addresses : OPTIONAL LIST [1:?] OF IfcAddress;</para>
	/// <para>INVERSE</para>
	/// <para>EngagedIn : SET [0:?] OF IfcPersonAndOrganization FOR ThePerson;</para>
	/// <para>WHERE</para>
	/// <para>IdentifiablePerson : EXISTS(Identification) OR EXISTS(FamilyName) OR EXISTS(GivenName);</para>
	/// <para>ValidSetOfNames : NOT EXISTS(MiddleNames) OR EXISTS(FamilyName) OR EXISTS(GivenName);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPerson : Entity, IfcActorSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public virtual IfcIdentifier? Identification { get; set; }
		public virtual IfcLabel? FamilyName { get; set; }
		public virtual IfcLabel? GivenName { get; set; }
		public virtual List<IfcLabel>? MiddleNames { get; set; }
		public virtual List<IfcLabel>? PrefixTitles { get; set; }
		public virtual List<IfcLabel>? SuffixTitles { get; set; }
		public virtual List<IfcActorRole>? Roles { get; set; }
		public virtual List<IfcAddress>? Addresses { get; set; }
		//TODO INVERSE
		public List<IfcPersonAndOrganization>? EngagedIn => Model?.GetItems<IfcPersonAndOrganization>().Where(x => x.ThePerson != null && x.ThePerson == this).ToList();
		public IfcPerson() : base()
		{
		}
		public IfcPerson(IfcIdentifier Identification, IfcLabel FamilyName, IfcLabel GivenName, List<IfcLabel> MiddleNames, List<IfcLabel> PrefixTitles, List<IfcLabel> SuffixTitles, List<IfcActorRole> Roles, List<IfcAddress> Addresses) : base ()
		{
			this.Identification = Identification;
			this.FamilyName = FamilyName;
			this.GivenName = GivenName;
			this.MiddleNames = MiddleNames;
			this.PrefixTitles = PrefixTitles;
			this.SuffixTitles = SuffixTitles;
			this.Roles = Roles;
			this.Addresses = Addresses;
		}
	}
	/// <summary>
	/// ENTITY IfcPersonAndOrganization;
	/// <para>ENTITY IfcPersonAndOrganization;</para>
	/// <para>ThePerson : IfcPerson;</para>
	/// <para>TheOrganization : IfcOrganization;</para>
	/// <para>Roles : OPTIONAL LIST [1:?] OF IfcActorRole;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPersonAndOrganization : Entity, IfcActorSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public virtual IfcPerson? ThePerson { get; set; }
		public virtual IfcOrganization? TheOrganization { get; set; }
		public virtual List<IfcActorRole>? Roles { get; set; }
		public IfcPersonAndOrganization() : base()
		{
		}
		public IfcPersonAndOrganization(IfcPerson ThePerson, IfcOrganization TheOrganization, List<IfcActorRole> Roles) : base ()
		{
			this.ThePerson = ThePerson;
			this.TheOrganization = TheOrganization;
			this.Roles = Roles;
		}
	}
	/// <summary>
	/// ENTITY IfcPhysicalComplexQuantity
	/// <para>ENTITY IfcPhysicalComplexQuantity</para>
	/// <para>SUBTYPE OF (IfcPhysicalQuantity);</para>
	/// <para>HasQuantities : SET [1:?] OF IfcPhysicalQuantity;</para>
	/// <para>Discrimination : IfcLabel;</para>
	/// <para>Quality : OPTIONAL IfcLabel;</para>
	/// <para>Usage : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(temp <* HasQuantities | SELF :=: temp)) = 0;</para>
	/// <para>UniqueQuantityNames : IfcUniqueQuantityNames(HasQuantities);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPhysicalComplexQuantity : IfcPhysicalQuantity
	{
		public virtual List<IfcPhysicalQuantity>? HasQuantities { get; set; }
		public virtual IfcLabel? Discrimination { get; set; }
		public virtual IfcLabel? Quality { get; set; }
		public virtual IfcLabel? Usage { get; set; }
		public IfcPhysicalComplexQuantity() : base()
		{
		}
		public IfcPhysicalComplexQuantity(IfcLabel Name, IfcText Description, List<IfcPhysicalQuantity> HasQuantities, IfcLabel Discrimination, IfcLabel Quality, IfcLabel Usage) : base (Name, Description)
		{
			this.HasQuantities = HasQuantities;
			this.Discrimination = Discrimination;
			this.Quality = Quality;
			this.Usage = Usage;
		}
	}
	/// <summary>
	/// ENTITY IfcPhysicalQuantity
	/// <para>ENTITY IfcPhysicalQuantity</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPhysicalComplexQuantity</para>
	/// <para>,IfcPhysicalSimpleQuantity));</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>PartOfComplex : SET [0:1] OF IfcPhysicalComplexQuantity FOR HasQuantities;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPhysicalQuantity : Entity, IfcResourceObjectSelect
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReferences => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcPhysicalComplexQuantity>? PartOfComplex => Model?.GetItems<IfcPhysicalComplexQuantity>().Where(x => x.HasQuantities != null && x.HasQuantities.Contains(this)).ToList();
		public IfcPhysicalQuantity() : base()
		{
		}
		public IfcPhysicalQuantity(IfcLabel Name, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcPhysicalSimpleQuantity
	/// <para>ENTITY IfcPhysicalSimpleQuantity</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcQuantityArea</para>
	/// <para>,IfcQuantityCount</para>
	/// <para>,IfcQuantityLength</para>
	/// <para>,IfcQuantityTime</para>
	/// <para>,IfcQuantityVolume</para>
	/// <para>,IfcQuantityWeight))</para>
	/// <para>SUBTYPE OF (IfcPhysicalQuantity);</para>
	/// <para>Unit : OPTIONAL IfcNamedUnit;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPhysicalSimpleQuantity : IfcPhysicalQuantity
	{
		public virtual IfcNamedUnit? Unit { get; set; }
		public IfcPhysicalSimpleQuantity() : base()
		{
		}
		public IfcPhysicalSimpleQuantity(IfcLabel Name, IfcText Description, IfcNamedUnit Unit) : base (Name, Description)
		{
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcPile
	/// <para>ENTITY IfcPile</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcPileTypeEnum;</para>
	/// <para>ConstructionType : OPTIONAL IfcPileConstructionEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT EXISTS(PredefinedType) OR</para>
	/// <para>(PredefinedType <> IfcPileTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPileTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCPILETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPile : IfcBuildingElement
	{
		public virtual IfcPileTypeEnum? PredefinedType { get; set; }
		public virtual IfcPileConstructionEnum? ConstructionType { get; set; }
		public IfcPile() : base()
		{
		}
		public IfcPile(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPileTypeEnum PredefinedType, IfcPileConstructionEnum ConstructionType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
			this.ConstructionType = ConstructionType;
		}
	}
	/// <summary>
	/// ENTITY IfcPileType
	/// <para>ENTITY IfcPileType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcPileTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcPileTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPileTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPileType : IfcBuildingElementType
	{
		public virtual IfcPileTypeEnum? PredefinedType { get; set; }
		public IfcPileType() : base()
		{
		}
		public IfcPileType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPileTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeFitting
	/// <para>ENTITY IfcPipeFitting</para>
	/// <para>SUBTYPE OF (IfcFlowFitting);</para>
	/// <para>PredefinedType : OPTIONAL IfcPipeFittingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcPipeFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPipeFittingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCPIPEFITTINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeFitting : IfcFlowFitting
	{
		public virtual IfcPipeFittingTypeEnum? PredefinedType { get; set; }
		public IfcPipeFitting() : base()
		{
		}
		public IfcPipeFitting(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPipeFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeFittingType
	/// <para>ENTITY IfcPipeFittingType</para>
	/// <para>SUBTYPE OF (IfcFlowFittingType);</para>
	/// <para>PredefinedType : IfcPipeFittingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcPipeFittingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPipeFittingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeFittingType : IfcFlowFittingType
	{
		public virtual IfcPipeFittingTypeEnum? PredefinedType { get; set; }
		public IfcPipeFittingType() : base()
		{
		}
		public IfcPipeFittingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPipeFittingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeSegment
	/// <para>ENTITY IfcPipeSegment</para>
	/// <para>SUBTYPE OF (IfcFlowSegment);</para>
	/// <para>PredefinedType : OPTIONAL IfcPipeSegmentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcPipeSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPipeSegmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCPIPESEGMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeSegment : IfcFlowSegment
	{
		public virtual IfcPipeSegmentTypeEnum? PredefinedType { get; set; }
		public IfcPipeSegment() : base()
		{
		}
		public IfcPipeSegment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPipeSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPipeSegmentType
	/// <para>ENTITY IfcPipeSegmentType</para>
	/// <para>SUBTYPE OF (IfcFlowSegmentType);</para>
	/// <para>PredefinedType : IfcPipeSegmentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcPipeSegmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPipeSegmentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPipeSegmentType : IfcFlowSegmentType
	{
		public virtual IfcPipeSegmentTypeEnum? PredefinedType { get; set; }
		public IfcPipeSegmentType() : base()
		{
		}
		public IfcPipeSegmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPipeSegmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPixelTexture
	/// <para>ENTITY IfcPixelTexture</para>
	/// <para>SUBTYPE OF (IfcSurfaceTexture);</para>
	/// <para>Width : IfcInteger;</para>
	/// <para>Height : IfcInteger;</para>
	/// <para>ColourComponents : IfcInteger;</para>
	/// <para>Pixel : LIST [1:?] OF IfcBinary;</para>
	/// <para>WHERE</para>
	/// <para>MinPixelInS : Width >= 1;</para>
	/// <para>MinPixelInT : Height >= 1;</para>
	/// <para>NumberOfColours : {1 <= ColourComponents <= 4};</para>
	/// <para>SizeOfPixelList : SIZEOF(Pixel) = (Width * Height);</para>
	/// <para>PixelAsByteAndSameLength : SIZEOF(QUERY(temp<* Pixel |</para>
	/// <para>(BLENGTH(temp) MOD 8 = 0) AND</para>
	/// <para>(BLENGTH(temp) = BLENGTH(Pixel[1]))</para>
	/// <para>)) = SIZEOF(Pixel);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPixelTexture : IfcSurfaceTexture
	{
		public virtual IfcInteger? Width { get; set; }
		public virtual IfcInteger? Height { get; set; }
		public virtual IfcInteger? ColourComponents { get; set; }
		public virtual List<IfcBinary>? Pixel { get; set; }
		public IfcPixelTexture() : base()
		{
		}
		public IfcPixelTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter, IfcInteger Width, IfcInteger Height, IfcInteger ColourComponents, List<IfcBinary> Pixel) : base (RepeatS, RepeatT, Mode, TextureTransform, Parameter)
		{
			this.Width = Width;
			this.Height = Height;
			this.ColourComponents = ColourComponents;
			this.Pixel = Pixel;
		}
	}
	/// <summary>
	/// ENTITY IfcPlacement
	/// <para>ENTITY IfcPlacement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAxis1Placement</para>
	/// <para>,IfcAxis2Placement2D</para>
	/// <para>,IfcAxis2Placement3D))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Location : IfcCartesianPoint;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := Location.Dim;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPlacement : IfcGeometricRepresentationItem
	{
		public virtual IfcCartesianPoint? Location { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcPlacement() : base()
		{
		}
		public IfcPlacement(IfcCartesianPoint Location) : base ()
		{
			this.Location = Location;
		}
	}
	/// <summary>
	/// ENTITY IfcPlanarBox
	/// <para>ENTITY IfcPlanarBox</para>
	/// <para>SUBTYPE OF (IfcPlanarExtent);</para>
	/// <para>Placement : IfcAxis2Placement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlanarBox : IfcPlanarExtent
	{
		public virtual IfcAxis2Placement? Placement { get; set; }
		public IfcPlanarBox() : base()
		{
		}
		public IfcPlanarBox(IfcLengthMeasure SizeInX, IfcLengthMeasure SizeInY, IfcAxis2Placement Placement) : base (SizeInX, SizeInY)
		{
			this.Placement = Placement;
		}
	}
	/// <summary>
	/// ENTITY IfcPlanarExtent
	/// <para>ENTITY IfcPlanarExtent</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPlanarBox))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>SizeInX : IfcLengthMeasure;</para>
	/// <para>SizeInY : IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlanarExtent : IfcGeometricRepresentationItem
	{
		public virtual IfcLengthMeasure? SizeInX { get; set; }
		public virtual IfcLengthMeasure? SizeInY { get; set; }
		public IfcPlanarExtent() : base()
		{
		}
		public IfcPlanarExtent(IfcLengthMeasure SizeInX, IfcLengthMeasure SizeInY) : base ()
		{
			this.SizeInX = SizeInX;
			this.SizeInY = SizeInY;
		}
	}
	/// <summary>
	/// ENTITY IfcPlane
	/// <para>ENTITY IfcPlane</para>
	/// <para>SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlane : IfcElementarySurface
	{
		public IfcPlane() : base()
		{
		}
		public IfcPlane(IfcAxis2Placement3D Position) : base (Position)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPlate
	/// <para>ENTITY IfcPlate</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPlateStandardCase))</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcPlateTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcPlateTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPlateTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCPLATETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlate : IfcBuildingElement
	{
		public virtual IfcPlateTypeEnum? PredefinedType { get; set; }
		public IfcPlate() : base()
		{
		}
		public IfcPlate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPlateTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPlateStandardCase
	/// <para>ENTITY IfcPlateStandardCase</para>
	/// <para>SUBTYPE OF (IfcPlate);</para>
	/// <para>WHERE</para>
	/// <para>HasMaterialLayerSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4X1.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>('IFC4X1.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>('IFC4X1.IFCMATERIALLAYERSETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlateStandardCase : IfcPlate
	{
		public IfcPlateStandardCase() : base()
		{
		}
		public IfcPlateStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPlateTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPlateType
	/// <para>ENTITY IfcPlateType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcPlateTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcPlateTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPlateTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPlateType : IfcBuildingElementType
	{
		public virtual IfcPlateTypeEnum? PredefinedType { get; set; }
		public IfcPlateType() : base()
		{
		}
		public IfcPlateType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPlateTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPoint
	/// <para>ENTITY IfcPoint</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCartesianPoint</para>
	/// <para>,IfcPointOnCurve</para>
	/// <para>,IfcPointOnSurface))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPoint : IfcGeometricRepresentationItem, IfcGeometricSetSelect, IfcPointOrVertexPoint
	{
		public virtual IfcDimensionCount? Dim { get; set;  }
		public IfcPoint() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPointOnCurve
	/// <para>ENTITY IfcPointOnCurve</para>
	/// <para>SUBTYPE OF (IfcPoint);</para>
	/// <para>BasisCurve : IfcCurve;</para>
	/// <para>PointParameter : IfcParameterValue;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := BasisCurve.Dim;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPointOnCurve : IfcPoint
	{
		public virtual IfcCurve? BasisCurve { get; set; }
		public virtual IfcParameterValue? PointParameter { get; set; }
		//TODO DERIVE
		public override IfcDimensionCount? Dim {get {return null;}}
		public IfcPointOnCurve() : base()
		{
		}
		public IfcPointOnCurve(IfcCurve BasisCurve, IfcParameterValue PointParameter) : base ()
		{
			this.BasisCurve = BasisCurve;
			this.PointParameter = PointParameter;
		}
	}
	/// <summary>
	/// ENTITY IfcPointOnSurface
	/// <para>ENTITY IfcPointOnSurface</para>
	/// <para>SUBTYPE OF (IfcPoint);</para>
	/// <para>BasisSurface : IfcSurface;</para>
	/// <para>PointParameterU : IfcParameterValue;</para>
	/// <para>PointParameterV : IfcParameterValue;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := BasisSurface.Dim;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPointOnSurface : IfcPoint
	{
		public virtual IfcSurface? BasisSurface { get; set; }
		public virtual IfcParameterValue? PointParameterU { get; set; }
		public virtual IfcParameterValue? PointParameterV { get; set; }
		//TODO DERIVE
		public override IfcDimensionCount? Dim {get {return null;}}
		public IfcPointOnSurface() : base()
		{
		}
		public IfcPointOnSurface(IfcSurface BasisSurface, IfcParameterValue PointParameterU, IfcParameterValue PointParameterV) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.PointParameterU = PointParameterU;
			this.PointParameterV = PointParameterV;
		}
	}
	/// <summary>
	/// ENTITY IfcPolyLoop
	/// <para>ENTITY IfcPolyLoop</para>
	/// <para>SUBTYPE OF (IfcLoop);</para>
	/// <para>Polygon : LIST [3:?] OF UNIQUE IfcCartesianPoint;</para>
	/// <para>WHERE</para>
	/// <para>AllPointsSameDim : SIZEOF(QUERY(Temp <* Polygon | Temp.Dim <> Polygon[1].Dim)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolyLoop : IfcLoop
	{
		public IfcPolyLoop() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPolygonalBoundedHalfSpace
	/// <para>ENTITY IfcPolygonalBoundedHalfSpace</para>
	/// <para>SUBTYPE OF (IfcHalfSpaceSolid);</para>
	/// <para>Position : IfcAxis2Placement3D;</para>
	/// <para>PolygonalBoundary : IfcBoundedCurve;</para>
	/// <para>WHERE</para>
	/// <para>BoundaryDim : PolygonalBoundary.Dim = 2;</para>
	/// <para>BoundaryType : SIZEOF(TYPEOF(PolygonalBoundary) * [</para>
	/// <para>'IFC4X1.IFCPOLYLINE',</para>
	/// <para>'IFC4X1.IFCCOMPOSITECURVE']</para>
	/// <para>) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolygonalBoundedHalfSpace : IfcHalfSpaceSolid
	{
		public virtual IfcAxis2Placement3D? Position { get; set; }
		public virtual IfcBoundedCurve? PolygonalBoundary { get; set; }
		public IfcPolygonalBoundedHalfSpace() : base()
		{
		}
		public IfcPolygonalBoundedHalfSpace(IfcSurface BaseSurface, IfcBoolean AgreementFlag, IfcAxis2Placement3D Position, IfcBoundedCurve PolygonalBoundary) : base (BaseSurface, AgreementFlag)
		{
			this.Position = Position;
			this.PolygonalBoundary = PolygonalBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcPolygonalFaceSet
	/// <para>ENTITY IfcPolygonalFaceSet</para>
	/// <para>SUBTYPE OF (IfcTessellatedFaceSet);</para>
	/// <para>Closed : OPTIONAL IfcBoolean;</para>
	/// <para>Faces : LIST [1:?] OF IfcIndexedPolygonalFace;</para>
	/// <para>PnIndex : OPTIONAL LIST [1:?] OF IfcPositiveInteger;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolygonalFaceSet : IfcTessellatedFaceSet
	{
		public virtual IfcBoolean? Closed { get; set; }
		public virtual List<IfcIndexedPolygonalFace>? Faces { get; set; }
		public virtual List<IfcPositiveInteger>? PnIndex { get; set; }
		public IfcPolygonalFaceSet() : base()
		{
		}
		public IfcPolygonalFaceSet(IfcCartesianPointList3D Coordinates, IfcBoolean Closed, List<IfcIndexedPolygonalFace> Faces, List<IfcPositiveInteger> PnIndex) : base (Coordinates)
		{
			this.Closed = Closed;
			this.Faces = Faces;
			this.PnIndex = PnIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcPolyline
	/// <para>ENTITY IfcPolyline</para>
	/// <para>SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>Points : LIST [2:?] OF IfcCartesianPoint;</para>
	/// <para>WHERE</para>
	/// <para>SameDim : SIZEOF(QUERY(Temp <* Points | Temp.Dim <> Points[1].Dim)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPolyline : IfcBoundedCurve
	{
		public virtual List<IfcCartesianPoint>? Points { get; set; }
		public IfcPolyline() : base()
		{
		}
		public IfcPolyline(List<IfcCartesianPoint> Points) : base ()
		{
			this.Points = Points;
		}
	}
	/// <summary>
	/// ENTITY IfcPort
	/// <para>ENTITY IfcPort</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDistributionPort))</para>
	/// <para>SUBTYPE OF (IfcProduct);</para>
	/// <para>INVERSE</para>
	/// <para>ContainedIn : SET [0:1] OF IfcRelConnectsPortToElement FOR RelatingPort;</para>
	/// <para>ConnectedFrom : SET [0:1] OF IfcRelConnectsPorts FOR RelatedPort;</para>
	/// <para>ConnectedTo : SET [0:1] OF IfcRelConnectsPorts FOR RelatingPort;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPort : IfcProduct
	{
		//TODO INVERSE
		public List<IfcRelConnectsPortToElement>? ContainedIn => Model?.GetItems<IfcRelConnectsPortToElement>().Where(x => x.RelatingPort != null && x.RelatingPort == this).ToList();
		//TODO INVERSE
		public List<IfcRelConnectsPorts>? ConnectedFrom => Model?.GetItems<IfcRelConnectsPorts>().Where(x => x.RelatedPort != null && x.RelatedPort == this).ToList();
		//TODO INVERSE
		public List<IfcRelConnectsPorts>? ConnectedTo => Model?.GetItems<IfcRelConnectsPorts>().Where(x => x.RelatingPort != null && x.RelatingPort == this).ToList();
		public IfcPort() : base()
		{
		}
		public IfcPort(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPositioningElement
	/// <para>ENTITY IfcPositioningElement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcGrid</para>
	/// <para>,IfcLinearPositioningElement</para>
	/// <para>,IfcReferent))</para>
	/// <para>SUBTYPE OF (IfcProduct);</para>
	/// <para>INVERSE</para>
	/// <para>ContainedInStructure : SET [0:1] OF IfcRelContainedInSpatialStructure FOR RelatedElements;</para>
	/// <para>WHERE</para>
	/// <para>HasPlacement : EXISTS(SELF\IfcProduct.ObjectPlacement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPositioningElement : IfcProduct
	{
		//TODO INVERSE
		public List<IfcRelContainedInSpatialStructure>? ContainedInStructure => Model?.GetItems<IfcRelContainedInSpatialStructure>().Where(x => x.RelatedElements != null && x.RelatedElements.Contains(this)).ToList();
		public IfcPositioningElement() : base()
		{
		}
		public IfcPositioningElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPostalAddress
	/// <para>ENTITY IfcPostalAddress</para>
	/// <para>SUBTYPE OF (IfcAddress);</para>
	/// <para>InternalLocation : OPTIONAL IfcLabel;</para>
	/// <para>AddressLines : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>PostalBox : OPTIONAL IfcLabel;</para>
	/// <para>Town : OPTIONAL IfcLabel;</para>
	/// <para>Region : OPTIONAL IfcLabel;</para>
	/// <para>PostalCode : OPTIONAL IfcLabel;</para>
	/// <para>Country : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : EXISTS (InternalLocation) OR</para>
	/// <para>EXISTS (AddressLines) OR</para>
	/// <para>EXISTS (PostalBox) OR</para>
	/// <para>EXISTS (PostalCode) OR</para>
	/// <para>EXISTS (Town) OR</para>
	/// <para>EXISTS (Region) OR</para>
	/// <para>EXISTS (Country);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPostalAddress : IfcAddress
	{
		public virtual IfcLabel? InternalLocation { get; set; }
		public virtual List<IfcLabel>? AddressLines { get; set; }
		public virtual IfcLabel? PostalBox { get; set; }
		public virtual IfcLabel? Town { get; set; }
		public virtual IfcLabel? Region { get; set; }
		public virtual IfcLabel? PostalCode { get; set; }
		public virtual IfcLabel? Country { get; set; }
		public IfcPostalAddress() : base()
		{
		}
		public IfcPostalAddress(IfcAddressTypeEnum Purpose, IfcText Description, IfcLabel UserDefinedPurpose, IfcLabel InternalLocation, List<IfcLabel> AddressLines, IfcLabel PostalBox, IfcLabel Town, IfcLabel Region, IfcLabel PostalCode, IfcLabel Country) : base (Purpose, Description, UserDefinedPurpose)
		{
			this.InternalLocation = InternalLocation;
			this.AddressLines = AddressLines;
			this.PostalBox = PostalBox;
			this.Town = Town;
			this.Region = Region;
			this.PostalCode = PostalCode;
			this.Country = Country;
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedColour
	/// <para>ENTITY IfcPreDefinedColour</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDraughtingPreDefinedColour))</para>
	/// <para>SUBTYPE OF (IfcPreDefinedItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedColour : IfcPreDefinedItem, IfcColour
	{
		public IfcPreDefinedColour() : base()
		{
		}
		public IfcPreDefinedColour(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedCurveFont
	/// <para>ENTITY IfcPreDefinedCurveFont</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDraughtingPreDefinedCurveFont))</para>
	/// <para>SUBTYPE OF (IfcPreDefinedItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedCurveFont : IfcPreDefinedItem, IfcCurveStyleFontSelect
	{
		public IfcPreDefinedCurveFont() : base()
		{
		}
		public IfcPreDefinedCurveFont(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedItem
	/// <para>ENTITY IfcPreDefinedItem</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPreDefinedColour</para>
	/// <para>,IfcPreDefinedCurveFont</para>
	/// <para>,IfcPreDefinedTextFont))</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedItem : IfcPresentationItem
	{
		public virtual IfcLabel? Name { get; set; }
		public IfcPreDefinedItem() : base()
		{
		}
		public IfcPreDefinedItem(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedProperties
	/// <para>ENTITY IfcPreDefinedProperties</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcReinforcementBarProperties</para>
	/// <para>,IfcSectionProperties</para>
	/// <para>,IfcSectionReinforcementProperties))</para>
	/// <para>SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedProperties : IfcPropertyAbstraction
	{
		public IfcPreDefinedProperties() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedPropertySet
	/// <para>ENTITY IfcPreDefinedPropertySet</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDoorLiningProperties</para>
	/// <para>,IfcDoorPanelProperties</para>
	/// <para>,IfcPermeableCoveringProperties</para>
	/// <para>,IfcReinforcementDefinitionProperties</para>
	/// <para>,IfcWindowLiningProperties</para>
	/// <para>,IfcWindowPanelProperties))</para>
	/// <para>SUBTYPE OF (IfcPropertySetDefinition);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedPropertySet : IfcPropertySetDefinition
	{
		public IfcPreDefinedPropertySet() : base()
		{
		}
		public IfcPreDefinedPropertySet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPreDefinedTextFont
	/// <para>ENTITY IfcPreDefinedTextFont</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcTextStyleFontModel))</para>
	/// <para>SUBTYPE OF (IfcPreDefinedItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPreDefinedTextFont : IfcPreDefinedItem, IfcTextFontSelect
	{
		public IfcPreDefinedTextFont() : base()
		{
		}
		public IfcPreDefinedTextFont(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationItem
	/// <para>ENTITY IfcPresentationItem</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcColourRgbList</para>
	/// <para>,IfcColourSpecification</para>
	/// <para>,IfcCurveStyleFont</para>
	/// <para>,IfcCurveStyleFontAndScaling</para>
	/// <para>,IfcCurveStyleFontPattern</para>
	/// <para>,IfcIndexedColourMap</para>
	/// <para>,IfcPreDefinedItem</para>
	/// <para>,IfcSurfaceStyleLighting</para>
	/// <para>,IfcSurfaceStyleRefraction</para>
	/// <para>,IfcSurfaceStyleShading</para>
	/// <para>,IfcSurfaceStyleWithTextures</para>
	/// <para>,IfcSurfaceTexture</para>
	/// <para>,IfcTextStyleForDefinedFont</para>
	/// <para>,IfcTextStyleTextModel</para>
	/// <para>,IfcTextureCoordinate</para>
	/// <para>,IfcTextureVertex</para>
	/// <para>,IfcTextureVertexList));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPresentationItem : Entity
	{
		public IfcPresentationItem() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationLayerAssignment
	/// <para>ENTITY IfcPresentationLayerAssignment</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPresentationLayerWithStyle));</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>AssignedItems : SET [1:?] OF IfcLayeredItem;</para>
	/// <para>Identifier : OPTIONAL IfcIdentifier;</para>
	/// <para>WHERE</para>
	/// <para>ApplicableItems : SIZEOF(QUERY(temp <* AssignedItems | (</para>
	/// <para>SIZEOF(TYPEOF(temp) * [</para>
	/// <para>'IFC4X1.IFCSHAPEREPRESENTATION',</para>
	/// <para>'IFC4X1.IFCGEOMETRICREPRESENTATIONITEM',</para>
	/// <para>'IFC4X1.IFCMAPPEDITEM']) = 1)</para>
	/// <para>)) = SIZEOF(AssignedItems);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPresentationLayerAssignment : Entity
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual List<IfcLayeredItem>? AssignedItems { get; set; }
		public virtual IfcIdentifier? Identifier { get; set; }
		public IfcPresentationLayerAssignment() : base()
		{
		}
		public IfcPresentationLayerAssignment(IfcLabel Name, IfcText Description, List<IfcLayeredItem> AssignedItems, IfcIdentifier Identifier) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.AssignedItems = AssignedItems;
			this.Identifier = Identifier;
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationLayerWithStyle
	/// <para>ENTITY IfcPresentationLayerWithStyle</para>
	/// <para>SUBTYPE OF (IfcPresentationLayerAssignment);</para>
	/// <para>LayerOn : IfcLogical;</para>
	/// <para>LayerFrozen : IfcLogical;</para>
	/// <para>LayerBlocked : IfcLogical;</para>
	/// <para>LayerStyles : SET [0:?] OF IfcPresentationStyle;</para>
	/// <para>WHERE</para>
	/// <para>ApplicableOnlyToItems : SIZEOF(QUERY(temp <* AssignedItems | (SIZEOF(TYPEOF(temp) * ['IFC4X1.IfcGeometricRepresentationItem','IFC4X1.IfcMappedItem']) >= 1))) = SIZEOF(AssignedItems);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPresentationLayerWithStyle : IfcPresentationLayerAssignment
	{
		public virtual IfcLogical? LayerOn { get; set; }
		public virtual IfcLogical? LayerFrozen { get; set; }
		public virtual IfcLogical? LayerBlocked { get; set; }
		public virtual List<IfcPresentationStyle>? LayerStyles { get; set; }
		public IfcPresentationLayerWithStyle() : base()
		{
		}
		public IfcPresentationLayerWithStyle(IfcLabel Name, IfcText Description, List<IfcLayeredItem> AssignedItems, IfcIdentifier Identifier, IfcLogical LayerOn, IfcLogical LayerFrozen, IfcLogical LayerBlocked, List<IfcPresentationStyle> LayerStyles) : base (Name, Description, AssignedItems, Identifier)
		{
			this.LayerOn = LayerOn;
			this.LayerFrozen = LayerFrozen;
			this.LayerBlocked = LayerBlocked;
			this.LayerStyles = LayerStyles;
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationStyle
	/// <para>ENTITY IfcPresentationStyle</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCurveStyle</para>
	/// <para>,IfcFillAreaStyle</para>
	/// <para>,IfcSurfaceStyle</para>
	/// <para>,IfcTextStyle));</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPresentationStyle : Entity, IfcStyleAssignmentSelect
	{
		public virtual IfcLabel? Name { get; set; }
		public IfcPresentationStyle() : base()
		{
		}
		public IfcPresentationStyle(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcPresentationStyleAssignment;
	/// <para>ENTITY IfcPresentationStyleAssignment;</para>
	/// <para>Styles : SET [1:?] OF IfcPresentationStyleSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPresentationStyleAssignment : Entity, IfcStyleAssignmentSelect
	{
		public virtual List<IfcPresentationStyleSelect>? Styles { get; set; }
		public IfcPresentationStyleAssignment() : base()
		{
		}
		public IfcPresentationStyleAssignment(List<IfcPresentationStyleSelect> Styles) : base ()
		{
			this.Styles = Styles;
		}
	}
	/// <summary>
	/// ENTITY IfcProcedure
	/// <para>ENTITY IfcProcedure</para>
	/// <para>SUBTYPE OF (IfcProcess);</para>
	/// <para>PredefinedType : OPTIONAL IfcProcedureTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>HasName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcProcedureTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcProcedureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProcedure : IfcProcess
	{
		public virtual IfcProcedureTypeEnum? PredefinedType { get; set; }
		public IfcProcedure() : base()
		{
		}
		public IfcProcedure(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcProcedureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProcedureType
	/// <para>ENTITY IfcProcedureType</para>
	/// <para>SUBTYPE OF (IfcTypeProcess);</para>
	/// <para>PredefinedType : IfcProcedureTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcProcedureTypeEnum.USERDEFINED) OR ((PredefinedType = IfcProcedureTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProcedureType : IfcTypeProcess
	{
		public virtual IfcProcedureTypeEnum? PredefinedType { get; set; }
		public IfcProcedureType() : base()
		{
		}
		public IfcProcedureType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType, IfcProcedureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProcess
	/// <para>ENTITY IfcProcess</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcEvent</para>
	/// <para>,IfcProcedure</para>
	/// <para>,IfcTask))</para>
	/// <para>SUBTYPE OF (IfcObject);</para>
	/// <para>Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>LongDescription : OPTIONAL IfcText;</para>
	/// <para>INVERSE</para>
	/// <para>IsPredecessorTo : SET [0:?] OF IfcRelSequence FOR RelatingProcess;</para>
	/// <para>IsSuccessorFrom : SET [0:?] OF IfcRelSequence FOR RelatedProcess;</para>
	/// <para>OperatesOn : SET [0:?] OF IfcRelAssignsToProcess FOR RelatingProcess;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProcess : IfcObject, IfcProcessSelect
	{
		public virtual IfcIdentifier? Identification { get; set; }
		public virtual IfcText? LongDescription { get; set; }
		//TODO INVERSE
		public List<IfcRelSequence>? IsPredecessorTo => Model?.GetItems<IfcRelSequence>().Where(x => x.RelatingProcess != null && x.RelatingProcess == this).ToList();
		//TODO INVERSE
		public List<IfcRelSequence>? IsSuccessorFrom => Model?.GetItems<IfcRelSequence>().Where(x => x.RelatedProcess != null && x.RelatedProcess == this).ToList();
		//TODO INVERSE
		public List<IfcRelAssignsToProcess>? OperatesOn => Model?.GetItems<IfcRelAssignsToProcess>().Where(x => x.RelatingProcess != null && x.RelatingProcess == this).ToList();
		public IfcProcess() : base()
		{
		}
		public IfcProcess(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcProduct
	/// <para>ENTITY IfcProduct</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcAnnotation</para>
	/// <para>,IfcElement</para>
	/// <para>,IfcPort</para>
	/// <para>,IfcPositioningElement</para>
	/// <para>,IfcProxy</para>
	/// <para>,IfcSpatialElement</para>
	/// <para>,IfcStructuralActivity</para>
	/// <para>,IfcStructuralItem))</para>
	/// <para>SUBTYPE OF (IfcObject);</para>
	/// <para>ObjectPlacement : OPTIONAL IfcObjectPlacement;</para>
	/// <para>Representation : OPTIONAL IfcProductRepresentation;</para>
	/// <para>INVERSE</para>
	/// <para>ReferencedBy : SET [0:?] OF IfcRelAssignsToProduct FOR RelatingProduct;</para>
	/// <para>WHERE</para>
	/// <para>PlacementForShapeRepresentation : (EXISTS(Representation) AND EXISTS(ObjectPlacement))</para>
	/// <para>OR (EXISTS(Representation) AND</para>
	/// <para>(SIZEOF(QUERY(temp <* Representation.Representations | 'IFC4X1.IFCSHAPEREPRESENTATION' IN TYPEOF(temp))) = 0))</para>
	/// <para>OR (NOT(EXISTS(Representation)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProduct : IfcObject, IfcProductSelect
	{
		public virtual IfcObjectPlacement? ObjectPlacement { get; set; }
		public virtual IfcProductRepresentation? Representation { get; set; }
		//TODO INVERSE
		public List<IfcRelAssignsToProduct>? ReferencedBy => Model?.GetItems<IfcRelAssignsToProduct>().Where(x => x.RelatingProduct != null && x.RelatingProduct == this).ToList();
		public IfcProduct() : base()
		{
		}
		public IfcProduct(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.ObjectPlacement = ObjectPlacement;
			this.Representation = Representation;
		}
	}
	/// <summary>
	/// ENTITY IfcProductDefinitionShape
	/// <para>ENTITY IfcProductDefinitionShape</para>
	/// <para>SUBTYPE OF (IfcProductRepresentation);</para>
	/// <para>INVERSE</para>
	/// <para>ShapeOfProduct : SET [1:?] OF IfcProduct FOR Representation;</para>
	/// <para>HasShapeAspects : SET [0:?] OF IfcShapeAspect FOR PartOfProductDefinitionShape;</para>
	/// <para>WHERE</para>
	/// <para>OnlyShapeModel : SIZEOF(QUERY(temp <* Representations |</para>
	/// <para>(NOT('IFC4X1.IFCSHAPEMODEL' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProductDefinitionShape : IfcProductRepresentation, IfcProductRepresentationSelect
	{
		//TODO INVERSE
		public List<IfcProduct>? ShapeOfProduct => Model?.GetItems<IfcProduct>().Where(x => x.Representation != null && x.Representation == this).ToList();
		//TODO INVERSE
		public List<IfcShapeAspect>? HasShapeAspects => Model?.GetItems<IfcShapeAspect>().Where(x => x.PartOfProductDefinitionShape != null && x.PartOfProductDefinitionShape == this).ToList();
		public IfcProductDefinitionShape() : base()
		{
		}
		public IfcProductDefinitionShape(IfcLabel Name, IfcText Description, List<IfcRepresentation> Representations) : base (Name, Description, Representations)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProductRepresentation
	/// <para>ENTITY IfcProductRepresentation</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcMaterialDefinitionRepresentation</para>
	/// <para>,IfcProductDefinitionShape));</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Representations : LIST [1:?] OF IfcRepresentation;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProductRepresentation : Entity
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual List<IfcRepresentation>? Representations { get; set; }
		public IfcProductRepresentation() : base()
		{
		}
		public IfcProductRepresentation(IfcLabel Name, IfcText Description, List<IfcRepresentation> Representations) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.Representations = Representations;
		}
	}
	/// <summary>
	/// ENTITY IfcProfileDef
	/// <para>ENTITY IfcProfileDef</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcArbitraryClosedProfileDef</para>
	/// <para>,IfcArbitraryOpenProfileDef</para>
	/// <para>,IfcCompositeProfileDef</para>
	/// <para>,IfcDerivedProfileDef</para>
	/// <para>,IfcParameterizedProfileDef));</para>
	/// <para>ProfileType : IfcProfileTypeEnum;</para>
	/// <para>ProfileName : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReference : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>HasProperties : SET [0:?] OF IfcProfileProperties FOR ProfileDefinition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProfileDef : Entity, IfcResourceObjectSelect
	{
		public virtual IfcProfileTypeEnum? ProfileType { get; set; }
		public virtual IfcLabel? ProfileName { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReference => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcProfileProperties>? HasProperties => Model?.GetItems<IfcProfileProperties>().Where(x => x.ProfileDefinition != null && x.ProfileDefinition == this).ToList();
		public IfcProfileDef() : base()
		{
		}
		public IfcProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName) : base ()
		{
			this.ProfileType = ProfileType;
			this.ProfileName = ProfileName;
		}
	}
	/// <summary>
	/// ENTITY IfcProfileProperties
	/// <para>ENTITY IfcProfileProperties</para>
	/// <para>SUBTYPE OF (IfcExtendedProperties);</para>
	/// <para>ProfileDefinition : IfcProfileDef;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProfileProperties : IfcExtendedProperties
	{
		public virtual IfcProfileDef? ProfileDefinition { get; set; }
		public IfcProfileProperties() : base()
		{
		}
		public IfcProfileProperties(IfcIdentifier Name, IfcText Description, List<IfcProperty> Properties, IfcProfileDef ProfileDefinition) : base (Name, Description, Properties)
		{
			this.ProfileDefinition = ProfileDefinition;
		}
	}
	/// <summary>
	/// ENTITY IfcProject
	/// <para>ENTITY IfcProject</para>
	/// <para>SUBTYPE OF (IfcContext);</para>
	/// <para>WHERE</para>
	/// <para>HasName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>CorrectContext : NOT(EXISTS(SELF\IfcContext.RepresentationContexts)) OR</para>
	/// <para>(SIZEOF(QUERY(Temp <* SELF\IfcContext.RepresentationContexts |</para>
	/// <para>'IFC4X1.IFCGEOMETRICREPRESENTATIONSUBCONTEXT' IN TYPEOF(Temp)</para>
	/// <para>)) = 0);</para>
	/// <para>NoDecomposition : SIZEOF(SELF\IfcObjectDefinition.Decomposes) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProject : IfcContext
	{
		public IfcProject() : base()
		{
		}
		public IfcProject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcLabel Phase, List<IfcRepresentationContext> RepresentationContexts, IfcUnitAssignment UnitsInContext) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProjectLibrary
	/// <para>ENTITY IfcProjectLibrary</para>
	/// <para>SUBTYPE OF (IfcContext);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectLibrary : IfcContext
	{
		public IfcProjectLibrary() : base()
		{
		}
		public IfcProjectLibrary(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName, IfcLabel Phase, List<IfcRepresentationContext> RepresentationContexts, IfcUnitAssignment UnitsInContext) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProjectOrder
	/// <para>ENTITY IfcProjectOrder</para>
	/// <para>SUBTYPE OF (IfcControl);</para>
	/// <para>PredefinedType : OPTIONAL IfcProjectOrderTypeEnum;</para>
	/// <para>Status : OPTIONAL IfcLabel;</para>
	/// <para>LongDescription : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectOrder : IfcControl
	{
		public virtual IfcProjectOrderTypeEnum? PredefinedType { get; set; }
		public virtual IfcLabel? Status { get; set; }
		public virtual IfcText? LongDescription { get; set; }
		public IfcProjectOrder() : base()
		{
		}
		public IfcProjectOrder(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcProjectOrderTypeEnum PredefinedType, IfcLabel Status, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.PredefinedType = PredefinedType;
			this.Status = Status;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcProjectedCRS
	/// <para>ENTITY IfcProjectedCRS</para>
	/// <para>SUBTYPE OF (IfcCoordinateReferenceSystem);</para>
	/// <para>MapProjection : OPTIONAL IfcIdentifier;</para>
	/// <para>MapZone : OPTIONAL IfcIdentifier;</para>
	/// <para>MapUnit : OPTIONAL IfcNamedUnit;</para>
	/// <para>WHERE</para>
	/// <para>IsLengthUnit : NOT(EXISTS(MapUnit)) OR (MapUnit.UnitType = IfcUnitEnum.LENGTHUNIT);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectedCRS : IfcCoordinateReferenceSystem
	{
		public virtual IfcIdentifier? MapProjection { get; set; }
		public virtual IfcIdentifier? MapZone { get; set; }
		public virtual IfcNamedUnit? MapUnit { get; set; }
		public IfcProjectedCRS() : base()
		{
		}
		public IfcProjectedCRS(IfcLabel Name, IfcText Description, IfcIdentifier GeodeticDatum, IfcIdentifier VerticalDatum, IfcIdentifier MapProjection, IfcIdentifier MapZone, IfcNamedUnit MapUnit) : base (Name, Description, GeodeticDatum, VerticalDatum)
		{
			this.MapProjection = MapProjection;
			this.MapZone = MapZone;
			this.MapUnit = MapUnit;
		}
	}
	/// <summary>
	/// ENTITY IfcProjectionElement
	/// <para>ENTITY IfcProjectionElement</para>
	/// <para>SUBTYPE OF (IfcFeatureElementAddition);</para>
	/// <para>PredefinedType : OPTIONAL IfcProjectionElementTypeEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProjectionElement : IfcFeatureElementAddition
	{
		public virtual IfcProjectionElementTypeEnum? PredefinedType { get; set; }
		public IfcProjectionElement() : base()
		{
		}
		public IfcProjectionElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcProjectionElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProperty
	/// <para>ENTITY IfcProperty</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcComplexProperty</para>
	/// <para>,IfcSimpleProperty))</para>
	/// <para>SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>Name : IfcIdentifier;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>INVERSE</para>
	/// <para>PartOfPset : SET [0:?] OF IfcPropertySet FOR HasProperties;</para>
	/// <para>PropertyForDependance : SET [0:?] OF IfcPropertyDependencyRelationship FOR DependingProperty;</para>
	/// <para>PropertyDependsOn : SET [0:?] OF IfcPropertyDependencyRelationship FOR DependantProperty;</para>
	/// <para>PartOfComplex : SET [0:?] OF IfcComplexProperty FOR HasProperties;</para>
	/// <para>HasConstraints : SET [0:?] OF IfcResourceConstraintRelationship FOR RelatedResourceObjects;</para>
	/// <para>HasApprovals : SET [0:?] OF IfcResourceApprovalRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcProperty : IfcPropertyAbstraction
	{
		public virtual IfcIdentifier? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		//TODO INVERSE
		public List<IfcPropertySet>? PartOfPset => Model?.GetItems<IfcPropertySet>().Where(x => x.HasProperties != null && x.HasProperties.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcPropertyDependencyRelationship>? PropertyForDependance => Model?.GetItems<IfcPropertyDependencyRelationship>().Where(x => x.DependingProperty != null && x.DependingProperty == this).ToList();
		//TODO INVERSE
		public List<IfcPropertyDependencyRelationship>? PropertyDependsOn => Model?.GetItems<IfcPropertyDependencyRelationship>().Where(x => x.DependantProperty != null && x.DependantProperty == this).ToList();
		//TODO INVERSE
		public List<IfcComplexProperty>? PartOfComplex => Model?.GetItems<IfcComplexProperty>().Where(x => x.HasProperties != null && x.HasProperties.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcResourceConstraintRelationship>? HasConstraints => Model?.GetItems<IfcResourceConstraintRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcResourceApprovalRelationship>? HasApprovals => Model?.GetItems<IfcResourceApprovalRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		public IfcProperty() : base()
		{
		}
		public IfcProperty(IfcIdentifier Name, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyAbstraction
	/// <para>ENTITY IfcPropertyAbstraction</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcExtendedProperties</para>
	/// <para>,IfcPreDefinedProperties</para>
	/// <para>,IfcProperty</para>
	/// <para>,IfcPropertyEnumeration));</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyAbstraction : Entity, IfcResourceObjectSelect
	{
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReferences => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		public IfcPropertyAbstraction() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyBoundedValue
	/// <para>ENTITY IfcPropertyBoundedValue</para>
	/// <para>SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>UpperBoundValue : OPTIONAL IfcValue;</para>
	/// <para>LowerBoundValue : OPTIONAL IfcValue;</para>
	/// <para>Unit : OPTIONAL IfcUnit;</para>
	/// <para>SetPointValue : OPTIONAL IfcValue;</para>
	/// <para>WHERE</para>
	/// <para>SameUnitUpperLower : NOT(EXISTS(UpperBoundValue)) OR NOT(EXISTS(LowerBoundValue)) OR</para>
	/// <para>(TYPEOF(UpperBoundValue) = TYPEOF(LowerBoundValue));</para>
	/// <para>SameUnitUpperSet : NOT(EXISTS(UpperBoundValue)) OR NOT(EXISTS(SetPointValue)) OR</para>
	/// <para>(TYPEOF(UpperBoundValue) = TYPEOF(SetPointValue));</para>
	/// <para>SameUnitLowerSet : NOT(EXISTS(LowerBoundValue)) OR NOT(EXISTS(SetPointValue)) OR</para>
	/// <para>(TYPEOF(LowerBoundValue) = TYPEOF(SetPointValue));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyBoundedValue : IfcSimpleProperty
	{
		public virtual IfcValue? UpperBoundValue { get; set; }
		public virtual IfcValue? LowerBoundValue { get; set; }
		public virtual IfcUnit? Unit { get; set; }
		public virtual IfcValue? SetPointValue { get; set; }
		public IfcPropertyBoundedValue() : base()
		{
		}
		public IfcPropertyBoundedValue(IfcIdentifier Name, IfcText Description, IfcValue UpperBoundValue, IfcValue LowerBoundValue, IfcUnit Unit, IfcValue SetPointValue) : base (Name, Description)
		{
			this.UpperBoundValue = UpperBoundValue;
			this.LowerBoundValue = LowerBoundValue;
			this.Unit = Unit;
			this.SetPointValue = SetPointValue;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyDefinition
	/// <para>ENTITY IfcPropertyDefinition</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPropertySetDefinition</para>
	/// <para>,IfcPropertyTemplateDefinition))</para>
	/// <para>SUBTYPE OF (IfcRoot);</para>
	/// <para>INVERSE</para>
	/// <para>HasContext : SET [0:1] OF IfcRelDeclares FOR RelatedDefinitions;</para>
	/// <para>HasAssociations : SET [0:?] OF IfcRelAssociates FOR RelatedObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyDefinition : IfcRoot, IfcDefinitionSelect
	{
		//TODO INVERSE
		public List<IfcRelDeclares>? HasContext => Model?.GetItems<IfcRelDeclares>().Where(x => x.RelatedDefinitions != null && x.RelatedDefinitions.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelAssociates>? HasAssociations => Model?.GetItems<IfcRelAssociates>().Where(x => x.RelatedObjects != null && x.RelatedObjects.Contains(this)).ToList();
		public IfcPropertyDefinition() : base()
		{
		}
		public IfcPropertyDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyDependencyRelationship
	/// <para>ENTITY IfcPropertyDependencyRelationship</para>
	/// <para>SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>DependingProperty : IfcProperty;</para>
	/// <para>DependantProperty : IfcProperty;</para>
	/// <para>Expression : OPTIONAL IfcText;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : DependingProperty :<>: DependantProperty;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyDependencyRelationship : IfcResourceLevelRelationship
	{
		public virtual IfcProperty? DependingProperty { get; set; }
		public virtual IfcProperty? DependantProperty { get; set; }
		public virtual IfcText? Expression { get; set; }
		public IfcPropertyDependencyRelationship() : base()
		{
		}
		public IfcPropertyDependencyRelationship(IfcLabel Name, IfcText Description, IfcProperty DependingProperty, IfcProperty DependantProperty, IfcText Expression) : base (Name, Description)
		{
			this.DependingProperty = DependingProperty;
			this.DependantProperty = DependantProperty;
			this.Expression = Expression;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyEnumeratedValue
	/// <para>ENTITY IfcPropertyEnumeratedValue</para>
	/// <para>SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>EnumerationValues : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>EnumerationReference : OPTIONAL IfcPropertyEnumeration;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : NOT(EXISTS(EnumerationReference))</para>
	/// <para>OR  NOT(EXISTS(EnumerationValues))</para>
	/// <para>OR  (SIZEOF(QUERY(temp <* EnumerationValues |</para>
	/// <para>temp IN EnumerationReference.EnumerationValues))</para>
	/// <para>= SIZEOF(EnumerationValues));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyEnumeratedValue : IfcSimpleProperty
	{
		public virtual List<IfcValue>? EnumerationValues { get; set; }
		public virtual IfcPropertyEnumeration? EnumerationReference { get; set; }
		public IfcPropertyEnumeratedValue() : base()
		{
		}
		public IfcPropertyEnumeratedValue(IfcIdentifier Name, IfcText Description, List<IfcValue> EnumerationValues, IfcPropertyEnumeration EnumerationReference) : base (Name, Description)
		{
			this.EnumerationValues = EnumerationValues;
			this.EnumerationReference = EnumerationReference;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyEnumeration
	/// <para>ENTITY IfcPropertyEnumeration</para>
	/// <para>SUBTYPE OF (IfcPropertyAbstraction);</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>EnumerationValues : LIST [1:?] OF UNIQUE IfcValue;</para>
	/// <para>Unit : OPTIONAL IfcUnit;</para>
	/// <para>UNIQUE</para>
	/// <para>UR1 : Name;</para>
	/// <para>WHERE</para>
	/// <para>WR01 : SIZEOF(QUERY(temp <* SELF.EnumerationValues |</para>
	/// <para>NOT(TYPEOF(SELF.EnumerationValues[1]) = TYPEOF(temp))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyEnumeration : IfcPropertyAbstraction
	{
		public virtual IfcLabel? Name { get; set; }
		public IfcPropertyEnumeration() : base()
		{
		}
		public IfcPropertyEnumeration(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyListValue
	/// <para>ENTITY IfcPropertyListValue</para>
	/// <para>SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>ListValues : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>Unit : OPTIONAL IfcUnit;</para>
	/// <para>WHERE</para>
	/// <para>WR31 : SIZEOF(QUERY(temp <* SELF.ListValues |</para>
	/// <para>NOT(TYPEOF(SELF.ListValues[1]) = TYPEOF(temp))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyListValue : IfcSimpleProperty
	{
		public virtual List<IfcValue>? ListValues { get; set; }
		public virtual IfcUnit? Unit { get; set; }
		public IfcPropertyListValue() : base()
		{
		}
		public IfcPropertyListValue(IfcIdentifier Name, IfcText Description, List<IfcValue> ListValues, IfcUnit Unit) : base (Name, Description)
		{
			this.ListValues = ListValues;
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyReferenceValue
	/// <para>ENTITY IfcPropertyReferenceValue</para>
	/// <para>SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>UsageName : OPTIONAL IfcText;</para>
	/// <para>PropertyReference : OPTIONAL IfcObjectReferenceSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyReferenceValue : IfcSimpleProperty
	{
		public virtual IfcText? UsageName { get; set; }
		public virtual IfcObjectReferenceSelect? PropertyReference { get; set; }
		public IfcPropertyReferenceValue() : base()
		{
		}
		public IfcPropertyReferenceValue(IfcIdentifier Name, IfcText Description, IfcText UsageName, IfcObjectReferenceSelect PropertyReference) : base (Name, Description)
		{
			this.UsageName = UsageName;
			this.PropertyReference = PropertyReference;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySet
	/// <para>ENTITY IfcPropertySet</para>
	/// <para>SUBTYPE OF (IfcPropertySetDefinition);</para>
	/// <para>HasProperties : SET [1:?] OF IfcProperty;</para>
	/// <para>WHERE</para>
	/// <para>ExistsName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>UniquePropertyNames : IfcUniquePropertyName(HasProperties);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertySet : IfcPropertySetDefinition
	{
		public virtual List<IfcProperty>? HasProperties { get; set; }
		public IfcPropertySet() : base()
		{
		}
		public IfcPropertySet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcProperty> HasProperties) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.HasProperties = HasProperties;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySetDefinition
	/// <para>ENTITY IfcPropertySetDefinition</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPreDefinedPropertySet</para>
	/// <para>,IfcPropertySet</para>
	/// <para>,IfcQuantitySet))</para>
	/// <para>SUBTYPE OF (IfcPropertyDefinition);</para>
	/// <para>INVERSE</para>
	/// <para>DefinesType : SET [0:?] OF IfcTypeObject FOR HasPropertySets;</para>
	/// <para>IsDefinedBy : SET [0:?] OF IfcRelDefinesByTemplate FOR RelatedPropertySets;</para>
	/// <para>DefinesOccurrence : SET [0:?] OF IfcRelDefinesByProperties FOR RelatingPropertyDefinition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertySetDefinition : IfcPropertyDefinition, IfcPropertySetDefinitionSelect
	{
		//TODO INVERSE
		public List<IfcTypeObject>? DefinesType => Model?.GetItems<IfcTypeObject>().Where(x => x.HasPropertySets != null && x.HasPropertySets.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelDefinesByTemplate>? IsDefinedBy => Model?.GetItems<IfcRelDefinesByTemplate>().Where(x => x.RelatedPropertySets != null && x.RelatedPropertySets.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelDefinesByProperties>? DefinesOccurrence => Model?.GetItems<IfcRelDefinesByProperties>().Where(x => x.RelatingPropertyDefinition != null && x.RelatingPropertyDefinition == this).ToList();
		public IfcPropertySetDefinition() : base()
		{
		}
		public IfcPropertySetDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySetTemplate
	/// <para>ENTITY IfcPropertySetTemplate</para>
	/// <para>SUBTYPE OF (IfcPropertyTemplateDefinition);</para>
	/// <para>TemplateType : OPTIONAL IfcPropertySetTemplateTypeEnum;</para>
	/// <para>ApplicableEntity : OPTIONAL IfcIdentifier;</para>
	/// <para>HasPropertyTemplates : SET [1:?] OF IfcPropertyTemplate;</para>
	/// <para>INVERSE</para>
	/// <para>Defines : SET [0:?] OF IfcRelDefinesByTemplate FOR RelatingTemplate;</para>
	/// <para>WHERE</para>
	/// <para>ExistsName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>UniquePropertyNames : IfcUniquePropertyTemplateNames(HasPropertyTemplates);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertySetTemplate : IfcPropertyTemplateDefinition
	{
		public virtual IfcPropertySetTemplateTypeEnum? TemplateType { get; set; }
		public virtual IfcIdentifier? ApplicableEntity { get; set; }
		public virtual List<IfcPropertyTemplate>? HasPropertyTemplates { get; set; }
		//TODO INVERSE
		public List<IfcRelDefinesByTemplate>? Defines => Model?.GetItems<IfcRelDefinesByTemplate>().Where(x => x.RelatingTemplate != null && x.RelatingTemplate == this).ToList();
		public IfcPropertySetTemplate() : base()
		{
		}
		public IfcPropertySetTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPropertySetTemplateTypeEnum TemplateType, IfcIdentifier ApplicableEntity, List<IfcPropertyTemplate> HasPropertyTemplates) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.TemplateType = TemplateType;
			this.ApplicableEntity = ApplicableEntity;
			this.HasPropertyTemplates = HasPropertyTemplates;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertySingleValue
	/// <para>ENTITY IfcPropertySingleValue</para>
	/// <para>SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>NominalValue : OPTIONAL IfcValue;</para>
	/// <para>Unit : OPTIONAL IfcUnit;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertySingleValue : IfcSimpleProperty
	{
		public virtual IfcValue? NominalValue { get; set; }
		public virtual IfcUnit? Unit { get; set; }
		public IfcPropertySingleValue() : base()
		{
		}
		public IfcPropertySingleValue(IfcIdentifier Name, IfcText Description, IfcValue NominalValue, IfcUnit Unit) : base (Name, Description)
		{
			this.NominalValue = NominalValue;
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyTableValue
	/// <para>ENTITY IfcPropertyTableValue</para>
	/// <para>SUBTYPE OF (IfcSimpleProperty);</para>
	/// <para>DefiningValues : OPTIONAL LIST [1:?] OF UNIQUE IfcValue;</para>
	/// <para>DefinedValues : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>Expression : OPTIONAL IfcText;</para>
	/// <para>DefiningUnit : OPTIONAL IfcUnit;</para>
	/// <para>DefinedUnit : OPTIONAL IfcUnit;</para>
	/// <para>CurveInterpolation : OPTIONAL IfcCurveInterpolationEnum;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : (NOT(EXISTS(DefiningValues)) AND NOT(EXISTS(DefinedValues)))</para>
	/// <para>OR (SIZEOF(DefiningValues) = SIZEOF(DefinedValues));</para>
	/// <para>WR22 : NOT(EXISTS(DefiningValues)) OR</para>
	/// <para>(SIZEOF(QUERY(temp <* SELF.DefiningValues | TYPEOF(temp) <> TYPEOF(SELF.DefiningValues[1])</para>
	/// <para>)) = 0);</para>
	/// <para>WR23 : NOT(EXISTS(DefinedValues)) OR</para>
	/// <para>(SIZEOF(QUERY(temp <* SELF.DefinedValues | TYPEOF(temp) <> TYPEOF(SELF.DefinedValues[1])</para>
	/// <para>)) = 0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPropertyTableValue : IfcSimpleProperty
	{
		public IfcPropertyTableValue() : base()
		{
		}
		public IfcPropertyTableValue(IfcIdentifier Name, IfcText Description) : base (Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyTemplate
	/// <para>ENTITY IfcPropertyTemplate</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcComplexPropertyTemplate</para>
	/// <para>,IfcSimplePropertyTemplate))</para>
	/// <para>SUBTYPE OF (IfcPropertyTemplateDefinition);</para>
	/// <para>INVERSE</para>
	/// <para>PartOfComplexTemplate : SET [0:?] OF IfcComplexPropertyTemplate FOR HasPropertyTemplates;</para>
	/// <para>PartOfPsetTemplate : SET [0:?] OF IfcPropertySetTemplate FOR HasPropertyTemplates;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyTemplate : IfcPropertyTemplateDefinition
	{
		//TODO INVERSE
		public List<IfcComplexPropertyTemplate>? PartOfComplexTemplate => Model?.GetItems<IfcComplexPropertyTemplate>().Where(x => x.HasPropertyTemplates != null && x.HasPropertyTemplates.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcPropertySetTemplate>? PartOfPsetTemplate => Model?.GetItems<IfcPropertySetTemplate>().Where(x => x.HasPropertyTemplates != null && x.HasPropertyTemplates.Contains(this)).ToList();
		public IfcPropertyTemplate() : base()
		{
		}
		public IfcPropertyTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcPropertyTemplateDefinition
	/// <para>ENTITY IfcPropertyTemplateDefinition</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPropertySetTemplate</para>
	/// <para>,IfcPropertyTemplate))</para>
	/// <para>SUBTYPE OF (IfcPropertyDefinition);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcPropertyTemplateDefinition : IfcPropertyDefinition
	{
		public IfcPropertyTemplateDefinition() : base()
		{
		}
		public IfcPropertyTemplateDefinition(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDevice
	/// <para>ENTITY IfcProtectiveDevice</para>
	/// <para>SUBTYPE OF (IfcFlowController);</para>
	/// <para>PredefinedType : OPTIONAL IfcProtectiveDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcProtectiveDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcProtectiveDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCPROTECTIVEDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDevice : IfcFlowController
	{
		public virtual IfcProtectiveDeviceTypeEnum? PredefinedType { get; set; }
		public IfcProtectiveDevice() : base()
		{
		}
		public IfcProtectiveDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcProtectiveDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDeviceTrippingUnit
	/// <para>ENTITY IfcProtectiveDeviceTrippingUnit</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcProtectiveDeviceTrippingUnitTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCPROTECTIVEDEVICETRIPPINGUNITTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDeviceTrippingUnit : IfcDistributionControlElement
	{
		public virtual IfcProtectiveDeviceTrippingUnitTypeEnum? PredefinedType { get; set; }
		public IfcProtectiveDeviceTrippingUnit() : base()
		{
		}
		public IfcProtectiveDeviceTrippingUnit(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcProtectiveDeviceTrippingUnitTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDeviceTrippingUnitType
	/// <para>ENTITY IfcProtectiveDeviceTrippingUnitType</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>PredefinedType : IfcProtectiveDeviceTrippingUnitTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDeviceTrippingUnitType : IfcDistributionControlElementType
	{
		public virtual IfcProtectiveDeviceTrippingUnitTypeEnum? PredefinedType { get; set; }
		public IfcProtectiveDeviceTrippingUnitType() : base()
		{
		}
		public IfcProtectiveDeviceTrippingUnitType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcProtectiveDeviceTrippingUnitTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProtectiveDeviceType
	/// <para>ENTITY IfcProtectiveDeviceType</para>
	/// <para>SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>PredefinedType : IfcProtectiveDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcProtectiveDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcProtectiveDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProtectiveDeviceType : IfcFlowControllerType
	{
		public virtual IfcProtectiveDeviceTypeEnum? PredefinedType { get; set; }
		public IfcProtectiveDeviceType() : base()
		{
		}
		public IfcProtectiveDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcProtectiveDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcProxy
	/// <para>ENTITY IfcProxy</para>
	/// <para>SUBTYPE OF (IfcProduct);</para>
	/// <para>ProxyType : IfcObjectTypeEnum;</para>
	/// <para>Tag : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcProxy : IfcProduct
	{
		public virtual IfcObjectTypeEnum? ProxyType { get; set; }
		public virtual IfcLabel? Tag { get; set; }
		public IfcProxy() : base()
		{
		}
		public IfcProxy(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcObjectTypeEnum ProxyType, IfcLabel Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.ProxyType = ProxyType;
			this.Tag = Tag;
		}
	}
	/// <summary>
	/// ENTITY IfcPump
	/// <para>ENTITY IfcPump</para>
	/// <para>SUBTYPE OF (IfcFlowMovingDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcPumpTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcPumpTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPumpTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCPUMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPump : IfcFlowMovingDevice
	{
		public virtual IfcPumpTypeEnum? PredefinedType { get; set; }
		public IfcPump() : base()
		{
		}
		public IfcPump(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPumpTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcPumpType
	/// <para>ENTITY IfcPumpType</para>
	/// <para>SUBTYPE OF (IfcFlowMovingDeviceType);</para>
	/// <para>PredefinedType : IfcPumpTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcPumpTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcPumpTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcPumpType : IfcFlowMovingDeviceType
	{
		public virtual IfcPumpTypeEnum? PredefinedType { get; set; }
		public IfcPumpType() : base()
		{
		}
		public IfcPumpType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcPumpTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityArea
	/// <para>ENTITY IfcQuantityArea</para>
	/// <para>SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>AreaValue : IfcAreaMeasure;</para>
	/// <para>Formula : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>(SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.AREAUNIT);</para>
	/// <para>WR22 : AreaValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityArea : IfcPhysicalSimpleQuantity
	{
		public virtual IfcAreaMeasure? AreaValue { get; set; }
		public virtual IfcLabel? Formula { get; set; }
		public IfcQuantityArea() : base()
		{
		}
		public IfcQuantityArea(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcAreaMeasure AreaValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.AreaValue = AreaValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityCount
	/// <para>ENTITY IfcQuantityCount</para>
	/// <para>SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>CountValue : IfcCountMeasure;</para>
	/// <para>Formula : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : CountValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityCount : IfcPhysicalSimpleQuantity
	{
		public virtual IfcCountMeasure? CountValue { get; set; }
		public virtual IfcLabel? Formula { get; set; }
		public IfcQuantityCount() : base()
		{
		}
		public IfcQuantityCount(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcCountMeasure CountValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.CountValue = CountValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityLength
	/// <para>ENTITY IfcQuantityLength</para>
	/// <para>SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>LengthValue : IfcLengthMeasure;</para>
	/// <para>Formula : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>(SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.LENGTHUNIT);</para>
	/// <para>WR22 : LengthValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityLength : IfcPhysicalSimpleQuantity
	{
		public virtual IfcLengthMeasure? LengthValue { get; set; }
		public virtual IfcLabel? Formula { get; set; }
		public IfcQuantityLength() : base()
		{
		}
		public IfcQuantityLength(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcLengthMeasure LengthValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.LengthValue = LengthValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantitySet
	/// <para>ENTITY IfcQuantitySet</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcElementQuantity))</para>
	/// <para>SUBTYPE OF (IfcPropertySetDefinition);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcQuantitySet : IfcPropertySetDefinition
	{
		public IfcQuantitySet() : base()
		{
		}
		public IfcQuantitySet(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityTime
	/// <para>ENTITY IfcQuantityTime</para>
	/// <para>SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>TimeValue : IfcTimeMeasure;</para>
	/// <para>Formula : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>(SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.TIMEUNIT);</para>
	/// <para>WR22 : TimeValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityTime : IfcPhysicalSimpleQuantity
	{
		public virtual IfcTimeMeasure? TimeValue { get; set; }
		public virtual IfcLabel? Formula { get; set; }
		public IfcQuantityTime() : base()
		{
		}
		public IfcQuantityTime(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcTimeMeasure TimeValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.TimeValue = TimeValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityVolume
	/// <para>ENTITY IfcQuantityVolume</para>
	/// <para>SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>VolumeValue : IfcVolumeMeasure;</para>
	/// <para>Formula : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>(SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.VOLUMEUNIT);</para>
	/// <para>WR22 : VolumeValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityVolume : IfcPhysicalSimpleQuantity
	{
		public virtual IfcVolumeMeasure? VolumeValue { get; set; }
		public virtual IfcLabel? Formula { get; set; }
		public IfcQuantityVolume() : base()
		{
		}
		public IfcQuantityVolume(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcVolumeMeasure VolumeValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.VolumeValue = VolumeValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcQuantityWeight
	/// <para>ENTITY IfcQuantityWeight</para>
	/// <para>SUBTYPE OF (IfcPhysicalSimpleQuantity);</para>
	/// <para>WeightValue : IfcMassMeasure;</para>
	/// <para>Formula : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR21 : NOT(EXISTS(SELF\IfcPhysicalSimpleQuantity.Unit)) OR</para>
	/// <para>(SELF\IfcPhysicalSimpleQuantity.Unit.UnitType = IfcUnitEnum.MASSUNIT);</para>
	/// <para>WR22 : WeightValue >= 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcQuantityWeight : IfcPhysicalSimpleQuantity
	{
		public virtual IfcMassMeasure? WeightValue { get; set; }
		public virtual IfcLabel? Formula { get; set; }
		public IfcQuantityWeight() : base()
		{
		}
		public IfcQuantityWeight(IfcLabel Name, IfcText Description, IfcNamedUnit Unit, IfcMassMeasure WeightValue, IfcLabel Formula) : base (Name, Description, Unit)
		{
			this.WeightValue = WeightValue;
			this.Formula = Formula;
		}
	}
	/// <summary>
	/// ENTITY IfcRailing
	/// <para>ENTITY IfcRailing</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcRailingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcRailingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRailingTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCRAILINGTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRailing : IfcBuildingElement
	{
		public virtual IfcRailingTypeEnum? PredefinedType { get; set; }
		public IfcRailing() : base()
		{
		}
		public IfcRailing(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRailingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRailingType
	/// <para>ENTITY IfcRailingType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcRailingTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcRailingTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRailingTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRailingType : IfcBuildingElementType
	{
		public virtual IfcRailingTypeEnum? PredefinedType { get; set; }
		public IfcRailingType() : base()
		{
		}
		public IfcRailingType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRailingTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRamp
	/// <para>ENTITY IfcRamp</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcRampTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcRampTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRampTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCRAMPTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRamp : IfcBuildingElement
	{
		public virtual IfcRampTypeEnum? PredefinedType { get; set; }
		public IfcRamp() : base()
		{
		}
		public IfcRamp(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRampFlight
	/// <para>ENTITY IfcRampFlight</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcRampFlightTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcRampFlightTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRampFlightTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCRAMPFLIGHTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRampFlight : IfcBuildingElement
	{
		public virtual IfcRampFlightTypeEnum? PredefinedType { get; set; }
		public IfcRampFlight() : base()
		{
		}
		public IfcRampFlight(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRampFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRampFlightType
	/// <para>ENTITY IfcRampFlightType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcRampFlightTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcRampFlightTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRampFlightTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRampFlightType : IfcBuildingElementType
	{
		public virtual IfcRampFlightTypeEnum? PredefinedType { get; set; }
		public IfcRampFlightType() : base()
		{
		}
		public IfcRampFlightType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRampFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRampType
	/// <para>ENTITY IfcRampType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcRampTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcRampTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRampTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRampType : IfcBuildingElementType
	{
		public virtual IfcRampTypeEnum? PredefinedType { get; set; }
		public IfcRampType() : base()
		{
		}
		public IfcRampType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRampTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRationalBSplineCurveWithKnots
	/// <para>ENTITY IfcRationalBSplineCurveWithKnots</para>
	/// <para>SUBTYPE OF (IfcBSplineCurveWithKnots);</para>
	/// <para>WeightsData : LIST [2:?] OF IfcReal;</para>
	/// <para>DERIVE</para>
	/// <para>Weights : ARRAY [0:UpperIndexOnControlPoints] OF IfcReal := IfcListToArray(WeightsData,0,SELF\IfcBSplineCurve.UpperIndexOnControlPoints);</para>
	/// <para>WHERE</para>
	/// <para>SameNumOfWeightsAndPoints : SIZEOF(WeightsData) = SIZEOF(SELF\IfcBSplineCurve.ControlPointsList);</para>
	/// <para>WeightsGreaterZero : IfcCurveWeightsPositive(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRationalBSplineCurveWithKnots : IfcBSplineCurveWithKnots
	{
		public virtual List<IfcReal>? WeightsData { get; set; }
		//TODO DERIVE
		public virtual List<IfcReal>? Weights {get {return null;}}
		public IfcRationalBSplineCurveWithKnots() : base()
		{
		}
		public IfcRationalBSplineCurveWithKnots(IfcInteger Degree, List<IfcCartesianPoint> ControlPointsList, IfcBSplineCurveForm CurveForm, IfcLogical ClosedCurve, IfcLogical SelfIntersect, List<IfcInteger> KnotMultiplicities, List<IfcParameterValue> Knots, IfcKnotType KnotSpec, List<IfcReal> WeightsData) : base (Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec)
		{
			this.WeightsData = WeightsData;
		}
	}
	/// <summary>
	/// ENTITY IfcRationalBSplineSurfaceWithKnots
	/// <para>ENTITY IfcRationalBSplineSurfaceWithKnots</para>
	/// <para>SUBTYPE OF (IfcBSplineSurfaceWithKnots);</para>
	/// <para>WeightsData : LIST [2:?] OF LIST [2:?] OF IfcReal;</para>
	/// <para>DERIVE</para>
	/// <para>Weights : ARRAY [0:UUpper] OF ARRAY [0:VUpper] OF IfcReal := IfcMakeArrayOfArray(WeightsData,0,UUpper,0,VUpper);</para>
	/// <para>WHERE</para>
	/// <para>CorrespondingWeightsDataLists : (SIZEOF(WeightsData) = SIZEOF(SELF\IfcBSplineSurface.ControlPointsList))</para>
	/// <para>AND</para>
	/// <para>(SIZEOF(WeightsData[1]) = SIZEOF(SELF\IfcBSplineSurface.ControlPointsList[1]));</para>
	/// <para>WeightValuesGreaterZero : IfcSurfaceWeightsPositive(SELF);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRationalBSplineSurfaceWithKnots : IfcBSplineSurfaceWithKnots
	{
		public virtual List<List<IfcReal >>? WeightsData { get; set; }
		//TODO DERIVE
		public virtual List<List<IfcReal >>? Weights {get {return null;}}
		public IfcRationalBSplineSurfaceWithKnots() : base()
		{
		}
		public IfcRationalBSplineSurfaceWithKnots(IfcInteger UDegree, IfcInteger VDegree, List<List<IfcCartesianPoint >> ControlPointsList, IfcBSplineSurfaceForm SurfaceForm, IfcLogical UClosed, IfcLogical VClosed, IfcLogical SelfIntersect, List<IfcInteger> UMultiplicities, List<IfcInteger> VMultiplicities, List<IfcParameterValue> UKnots, List<IfcParameterValue> VKnots, IfcKnotType KnotSpec, List<List<IfcReal >> WeightsData) : base (UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec)
		{
			this.WeightsData = WeightsData;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangleHollowProfileDef
	/// <para>ENTITY IfcRectangleHollowProfileDef</para>
	/// <para>SUBTYPE OF (IfcRectangleProfileDef);</para>
	/// <para>WallThickness : IfcPositiveLengthMeasure;</para>
	/// <para>InnerFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>OuterFilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidWallThickness : (WallThickness < (SELF\IfcRectangleProfileDef.XDim/2.)) AND</para>
	/// <para>(WallThickness < (SELF\IfcRectangleProfileDef.YDim/2.));</para>
	/// <para>ValidInnerRadius : NOT(EXISTS(InnerFilletRadius)) OR</para>
	/// <para>((InnerFilletRadius <= (SELF\IfcRectangleProfileDef.XDim/2. - WallThickness)) AND</para>
	/// <para>(InnerFilletRadius <= (SELF\IfcRectangleProfileDef.YDim/2. - WallThickness)));</para>
	/// <para>ValidOuterRadius : NOT(EXISTS(OuterFilletRadius)) OR</para>
	/// <para>((OuterFilletRadius <= (SELF\IfcRectangleProfileDef.XDim/2.)) AND</para>
	/// <para>(OuterFilletRadius <= (SELF\IfcRectangleProfileDef.YDim/2.)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangleHollowProfileDef : IfcRectangleProfileDef
	{
		public virtual IfcPositiveLengthMeasure? WallThickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? InnerFilletRadius { get; set; }
		public virtual IfcNonNegativeLengthMeasure? OuterFilletRadius { get; set; }
		public IfcRectangleHollowProfileDef() : base()
		{
		}
		public IfcRectangleHollowProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim, IfcPositiveLengthMeasure WallThickness, IfcNonNegativeLengthMeasure InnerFilletRadius, IfcNonNegativeLengthMeasure OuterFilletRadius) : base (ProfileType, ProfileName, Position, XDim, YDim)
		{
			this.WallThickness = WallThickness;
			this.InnerFilletRadius = InnerFilletRadius;
			this.OuterFilletRadius = OuterFilletRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangleProfileDef
	/// <para>ENTITY IfcRectangleProfileDef</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRectangleHollowProfileDef</para>
	/// <para>,IfcRoundedRectangleProfileDef))</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>XDim : IfcPositiveLengthMeasure;</para>
	/// <para>YDim : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangleProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? XDim { get; set; }
		public virtual IfcPositiveLengthMeasure? YDim { get; set; }
		public IfcRectangleProfileDef() : base()
		{
		}
		public IfcRectangleProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim) : base (ProfileType, ProfileName, Position)
		{
			this.XDim = XDim;
			this.YDim = YDim;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangularPyramid
	/// <para>ENTITY IfcRectangularPyramid</para>
	/// <para>SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>XLength : IfcPositiveLengthMeasure;</para>
	/// <para>YLength : IfcPositiveLengthMeasure;</para>
	/// <para>Height : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangularPyramid : IfcCsgPrimitive3D
	{
		public virtual IfcPositiveLengthMeasure? XLength { get; set; }
		public virtual IfcPositiveLengthMeasure? YLength { get; set; }
		public virtual IfcPositiveLengthMeasure? Height { get; set; }
		public IfcRectangularPyramid() : base()
		{
		}
		public IfcRectangularPyramid(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure XLength, IfcPositiveLengthMeasure YLength, IfcPositiveLengthMeasure Height) : base (Position)
		{
			this.XLength = XLength;
			this.YLength = YLength;
			this.Height = Height;
		}
	}
	/// <summary>
	/// ENTITY IfcRectangularTrimmedSurface
	/// <para>ENTITY IfcRectangularTrimmedSurface</para>
	/// <para>SUBTYPE OF (IfcBoundedSurface);</para>
	/// <para>BasisSurface : IfcSurface;</para>
	/// <para>U1 : IfcParameterValue;</para>
	/// <para>V1 : IfcParameterValue;</para>
	/// <para>U2 : IfcParameterValue;</para>
	/// <para>V2 : IfcParameterValue;</para>
	/// <para>Usense : IfcBoolean;</para>
	/// <para>Vsense : IfcBoolean;</para>
	/// <para>WHERE</para>
	/// <para>U1AndU2Different : U1 <> U2;</para>
	/// <para>V1AndV2Different : V1 <> V2;</para>
	/// <para>UsenseCompatible : (('IFC4X1.IFCELEMENTARYSURFACE' IN TYPEOF(BasisSurface)) AND</para>
	/// <para>(NOT ('IFC4X1.IFCPLANE' IN TYPEOF(BasisSurface)))) OR</para>
	/// <para>('IFC4X1.IFCSURFACEOFREVOLUTION' IN TYPEOF(BasisSurface)) OR</para>
	/// <para>(Usense = (U2 > U1));</para>
	/// <para>VsenseCompatible : Vsense = (V2 > V1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRectangularTrimmedSurface : IfcBoundedSurface
	{
		public virtual IfcSurface? BasisSurface { get; set; }
		public virtual IfcParameterValue? U1 { get; set; }
		public virtual IfcParameterValue? V1 { get; set; }
		public virtual IfcParameterValue? U2 { get; set; }
		public virtual IfcParameterValue? V2 { get; set; }
		public virtual IfcBoolean? Usense { get; set; }
		public virtual IfcBoolean? Vsense { get; set; }
		public IfcRectangularTrimmedSurface() : base()
		{
		}
		public IfcRectangularTrimmedSurface(IfcSurface BasisSurface, IfcParameterValue U1, IfcParameterValue V1, IfcParameterValue U2, IfcParameterValue V2, IfcBoolean Usense, IfcBoolean Vsense) : base ()
		{
			this.BasisSurface = BasisSurface;
			this.U1 = U1;
			this.V1 = V1;
			this.U2 = U2;
			this.V2 = V2;
			this.Usense = Usense;
			this.Vsense = Vsense;
		}
	}
	/// <summary>
	/// ENTITY IfcRecurrencePattern;
	/// <para>ENTITY IfcRecurrencePattern;</para>
	/// <para>RecurrenceType : IfcRecurrenceTypeEnum;</para>
	/// <para>DayComponent : OPTIONAL SET [1:?] OF IfcDayInMonthNumber;</para>
	/// <para>WeekdayComponent : OPTIONAL SET [1:?] OF IfcDayInWeekNumber;</para>
	/// <para>MonthComponent : OPTIONAL SET [1:?] OF IfcMonthInYearNumber;</para>
	/// <para>Position : OPTIONAL IfcInteger;</para>
	/// <para>Interval : OPTIONAL IfcInteger;</para>
	/// <para>Occurrences : OPTIONAL IfcInteger;</para>
	/// <para>TimePeriods : OPTIONAL LIST [1:?] OF IfcTimePeriod;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRecurrencePattern : Entity
	{
		public virtual IfcRecurrenceTypeEnum? RecurrenceType { get; set; }
		public virtual List<IfcDayInMonthNumber>? DayComponent { get; set; }
		public virtual List<IfcDayInWeekNumber>? WeekdayComponent { get; set; }
		public virtual List<IfcMonthInYearNumber>? MonthComponent { get; set; }
		public virtual IfcInteger? Position { get; set; }
		public virtual IfcInteger? Interval { get; set; }
		public virtual IfcInteger? Occurrences { get; set; }
		public virtual List<IfcTimePeriod>? TimePeriods { get; set; }
		public IfcRecurrencePattern() : base()
		{
		}
		public IfcRecurrencePattern(IfcRecurrenceTypeEnum RecurrenceType, List<IfcDayInMonthNumber> DayComponent, List<IfcDayInWeekNumber> WeekdayComponent, List<IfcMonthInYearNumber> MonthComponent, IfcInteger Position, IfcInteger Interval, IfcInteger Occurrences, List<IfcTimePeriod> TimePeriods) : base ()
		{
			this.RecurrenceType = RecurrenceType;
			this.DayComponent = DayComponent;
			this.WeekdayComponent = WeekdayComponent;
			this.MonthComponent = MonthComponent;
			this.Position = Position;
			this.Interval = Interval;
			this.Occurrences = Occurrences;
			this.TimePeriods = TimePeriods;
		}
	}
	/// <summary>
	/// ENTITY IfcReference;
	/// <para>ENTITY IfcReference;</para>
	/// <para>TypeIdentifier : OPTIONAL IfcIdentifier;</para>
	/// <para>AttributeIdentifier : OPTIONAL IfcIdentifier;</para>
	/// <para>InstanceName : OPTIONAL IfcLabel;</para>
	/// <para>ListPositions : OPTIONAL LIST [1:?] OF IfcInteger;</para>
	/// <para>InnerReference : OPTIONAL IfcReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReference : Entity, IfcAppliedValueSelect, IfcMetricValueSelect
	{
		public virtual IfcIdentifier? TypeIdentifier { get; set; }
		public virtual IfcIdentifier? AttributeIdentifier { get; set; }
		public virtual IfcLabel? InstanceName { get; set; }
		public virtual List<IfcInteger>? ListPositions { get; set; }
		public virtual IfcReference? InnerReference { get; set; }
		public IfcReference() : base()
		{
		}
		public IfcReference(IfcIdentifier TypeIdentifier, IfcIdentifier AttributeIdentifier, IfcLabel InstanceName, List<IfcInteger> ListPositions, IfcReference InnerReference) : base ()
		{
			this.TypeIdentifier = TypeIdentifier;
			this.AttributeIdentifier = AttributeIdentifier;
			this.InstanceName = InstanceName;
			this.ListPositions = ListPositions;
			this.InnerReference = InnerReference;
		}
	}
	/// <summary>
	/// ENTITY IfcReferent
	/// <para>ENTITY IfcReferent</para>
	/// <para>SUBTYPE OF (IfcPositioningElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcReferentTypeEnum;</para>
	/// <para>RestartDistance : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReferent : IfcPositioningElement
	{
		public virtual IfcReferentTypeEnum? PredefinedType { get; set; }
		public virtual IfcLengthMeasure? RestartDistance { get; set; }
		public IfcReferent() : base()
		{
		}
		public IfcReferent(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcReferentTypeEnum PredefinedType, IfcLengthMeasure RestartDistance) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.PredefinedType = PredefinedType;
			this.RestartDistance = RestartDistance;
		}
	}
	/// <summary>
	/// ENTITY IfcRegularTimeSeries
	/// <para>ENTITY IfcRegularTimeSeries</para>
	/// <para>SUBTYPE OF (IfcTimeSeries);</para>
	/// <para>TimeStep : IfcTimeMeasure;</para>
	/// <para>Values : LIST [1:?] OF IfcTimeSeriesValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRegularTimeSeries : IfcTimeSeries
	{
		public virtual IfcTimeMeasure? TimeStep { get; set; }
		public virtual List<IfcTimeSeriesValue>? Values { get; set; }
		public IfcRegularTimeSeries() : base()
		{
		}
		public IfcRegularTimeSeries(IfcLabel Name, IfcText Description, IfcDateTime StartTime, IfcDateTime EndTime, IfcTimeSeriesDataTypeEnum TimeSeriesDataType, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcUnit Unit, IfcTimeMeasure TimeStep, List<IfcTimeSeriesValue> Values) : base (Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit)
		{
			this.TimeStep = TimeStep;
			this.Values = Values;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcementBarProperties
	/// <para>ENTITY IfcReinforcementBarProperties</para>
	/// <para>SUBTYPE OF (IfcPreDefinedProperties);</para>
	/// <para>TotalCrossSectionArea : IfcAreaMeasure;</para>
	/// <para>SteelGrade : IfcLabel;</para>
	/// <para>BarSurface : OPTIONAL IfcReinforcingBarSurfaceEnum;</para>
	/// <para>EffectiveDepth : OPTIONAL IfcLengthMeasure;</para>
	/// <para>NominalBarDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>BarCount : OPTIONAL IfcCountMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcementBarProperties : IfcPreDefinedProperties
	{
		public virtual IfcAreaMeasure? TotalCrossSectionArea { get; set; }
		public virtual IfcLabel? SteelGrade { get; set; }
		public virtual IfcReinforcingBarSurfaceEnum? BarSurface { get; set; }
		public virtual IfcLengthMeasure? EffectiveDepth { get; set; }
		public virtual IfcPositiveLengthMeasure? NominalBarDiameter { get; set; }
		public virtual IfcCountMeasure? BarCount { get; set; }
		public IfcReinforcementBarProperties() : base()
		{
		}
		public IfcReinforcementBarProperties(IfcAreaMeasure TotalCrossSectionArea, IfcLabel SteelGrade, IfcReinforcingBarSurfaceEnum BarSurface, IfcLengthMeasure EffectiveDepth, IfcPositiveLengthMeasure NominalBarDiameter, IfcCountMeasure BarCount) : base ()
		{
			this.TotalCrossSectionArea = TotalCrossSectionArea;
			this.SteelGrade = SteelGrade;
			this.BarSurface = BarSurface;
			this.EffectiveDepth = EffectiveDepth;
			this.NominalBarDiameter = NominalBarDiameter;
			this.BarCount = BarCount;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcementDefinitionProperties
	/// <para>ENTITY IfcReinforcementDefinitionProperties</para>
	/// <para>SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>DefinitionType : OPTIONAL IfcLabel;</para>
	/// <para>ReinforcementSectionDefinitions : LIST [1:?] OF IfcSectionReinforcementProperties;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcementDefinitionProperties : IfcPreDefinedPropertySet
	{
		public virtual IfcLabel? DefinitionType { get; set; }
		public virtual List<IfcSectionReinforcementProperties>? ReinforcementSectionDefinitions { get; set; }
		public IfcReinforcementDefinitionProperties() : base()
		{
		}
		public IfcReinforcementDefinitionProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel DefinitionType, List<IfcSectionReinforcementProperties> ReinforcementSectionDefinitions) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.DefinitionType = DefinitionType;
			this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingBar
	/// <para>ENTITY IfcReinforcingBar</para>
	/// <para>SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>BarLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>PredefinedType : OPTIONAL IfcReinforcingBarTypeEnum;</para>
	/// <para>BarSurface : OPTIONAL IfcReinforcingBarSurfaceEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT EXISTS(PredefinedType) OR</para>
	/// <para>(PredefinedType <> IfcReinforcingBarTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcReinforcingBarTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCREINFORCINGBARTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingBar : IfcReinforcingElement
	{
		public virtual IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public virtual IfcAreaMeasure? CrossSectionArea { get; set; }
		public virtual IfcPositiveLengthMeasure? BarLength { get; set; }
		public virtual IfcReinforcingBarTypeEnum? PredefinedType { get; set; }
		public virtual IfcReinforcingBarSurfaceEnum? BarSurface { get; set; }
		public IfcReinforcingBar() : base()
		{
		}
		public IfcReinforcingBar(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcPositiveLengthMeasure BarLength, IfcReinforcingBarTypeEnum PredefinedType, IfcReinforcingBarSurfaceEnum BarSurface) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.BarLength = BarLength;
			this.PredefinedType = PredefinedType;
			this.BarSurface = BarSurface;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingBarType
	/// <para>ENTITY IfcReinforcingBarType</para>
	/// <para>SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>PredefinedType : IfcReinforcingBarTypeEnum;</para>
	/// <para>NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>BarLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>BarSurface : OPTIONAL IfcReinforcingBarSurfaceEnum;</para>
	/// <para>BendingShapeCode : OPTIONAL IfcLabel;</para>
	/// <para>BendingParameters : OPTIONAL LIST [1:?] OF IfcBendingParameterSelect;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcReinforcingBarTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcReinforcingBarTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>BendingShapeCodeProvided : NOT EXISTS(BendingParameters) OR EXISTS(BendingShapeCode);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingBarType : IfcReinforcingElementType
	{
		public virtual IfcReinforcingBarTypeEnum? PredefinedType { get; set; }
		public virtual IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public virtual IfcAreaMeasure? CrossSectionArea { get; set; }
		public virtual IfcPositiveLengthMeasure? BarLength { get; set; }
		public virtual IfcReinforcingBarSurfaceEnum? BarSurface { get; set; }
		public virtual IfcLabel? BendingShapeCode { get; set; }
		public virtual List<IfcBendingParameterSelect>? BendingParameters { get; set; }
		public IfcReinforcingBarType() : base()
		{
		}
		public IfcReinforcingBarType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcReinforcingBarTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcPositiveLengthMeasure BarLength, IfcReinforcingBarSurfaceEnum BarSurface, IfcLabel BendingShapeCode, List<IfcBendingParameterSelect> BendingParameters) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.BarLength = BarLength;
			this.BarSurface = BarSurface;
			this.BendingShapeCode = BendingShapeCode;
			this.BendingParameters = BendingParameters;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingElement
	/// <para>ENTITY IfcReinforcingElement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcReinforcingBar</para>
	/// <para>,IfcReinforcingMesh</para>
	/// <para>,IfcTendon</para>
	/// <para>,IfcTendonAnchor))</para>
	/// <para>SUBTYPE OF (IfcElementComponent);</para>
	/// <para>SteelGrade : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcReinforcingElement : IfcElementComponent
	{
		public virtual IfcLabel? SteelGrade { get; set; }
		public IfcReinforcingElement() : base()
		{
		}
		public IfcReinforcingElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.SteelGrade = SteelGrade;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingElementType
	/// <para>ENTITY IfcReinforcingElementType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcReinforcingBarType</para>
	/// <para>,IfcReinforcingMeshType</para>
	/// <para>,IfcTendonAnchorType</para>
	/// <para>,IfcTendonType))</para>
	/// <para>SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcReinforcingElementType : IfcElementComponentType
	{
		public IfcReinforcingElementType() : base()
		{
		}
		public IfcReinforcingElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingMesh
	/// <para>ENTITY IfcReinforcingMesh</para>
	/// <para>SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>MeshLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>MeshWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>LongitudinalBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>TransverseBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>LongitudinalBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>TransverseBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>LongitudinalBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>TransverseBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>PredefinedType : OPTIONAL IfcReinforcingMeshTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT EXISTS(PredefinedType) OR</para>
	/// <para>(PredefinedType <> IfcReinforcingMeshTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcReinforcingMeshTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCREINFORCINGMESHTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingMesh : IfcReinforcingElement
	{
		public virtual IfcPositiveLengthMeasure? MeshLength { get; set; }
		public virtual IfcPositiveLengthMeasure? MeshWidth { get; set; }
		public virtual IfcPositiveLengthMeasure? LongitudinalBarNominalDiameter { get; set; }
		public virtual IfcPositiveLengthMeasure? TransverseBarNominalDiameter { get; set; }
		public virtual IfcAreaMeasure? LongitudinalBarCrossSectionArea { get; set; }
		public virtual IfcAreaMeasure? TransverseBarCrossSectionArea { get; set; }
		public virtual IfcPositiveLengthMeasure? LongitudinalBarSpacing { get; set; }
		public virtual IfcPositiveLengthMeasure? TransverseBarSpacing { get; set; }
		public virtual IfcReinforcingMeshTypeEnum? PredefinedType { get; set; }
		public IfcReinforcingMesh() : base()
		{
		}
		public IfcReinforcingMesh(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcPositiveLengthMeasure MeshLength, IfcPositiveLengthMeasure MeshWidth, IfcPositiveLengthMeasure LongitudinalBarNominalDiameter, IfcPositiveLengthMeasure TransverseBarNominalDiameter, IfcAreaMeasure LongitudinalBarCrossSectionArea, IfcAreaMeasure TransverseBarCrossSectionArea, IfcPositiveLengthMeasure LongitudinalBarSpacing, IfcPositiveLengthMeasure TransverseBarSpacing, IfcReinforcingMeshTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.MeshLength = MeshLength;
			this.MeshWidth = MeshWidth;
			this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
			this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
			this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
			this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
			this.LongitudinalBarSpacing = LongitudinalBarSpacing;
			this.TransverseBarSpacing = TransverseBarSpacing;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcReinforcingMeshType
	/// <para>ENTITY IfcReinforcingMeshType</para>
	/// <para>SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>PredefinedType : IfcReinforcingMeshTypeEnum;</para>
	/// <para>MeshLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>MeshWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>LongitudinalBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>TransverseBarNominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>LongitudinalBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>TransverseBarCrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>LongitudinalBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>TransverseBarSpacing : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>BendingShapeCode : OPTIONAL IfcLabel;</para>
	/// <para>BendingParameters : OPTIONAL LIST [1:?] OF IfcBendingParameterSelect;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcReinforcingMeshTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcReinforcingMeshTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>BendingShapeCodeProvided : NOT EXISTS(BendingParameters) OR EXISTS(BendingShapeCode);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReinforcingMeshType : IfcReinforcingElementType
	{
		public virtual IfcReinforcingMeshTypeEnum? PredefinedType { get; set; }
		public virtual IfcPositiveLengthMeasure? MeshLength { get; set; }
		public virtual IfcPositiveLengthMeasure? MeshWidth { get; set; }
		public virtual IfcPositiveLengthMeasure? LongitudinalBarNominalDiameter { get; set; }
		public virtual IfcPositiveLengthMeasure? TransverseBarNominalDiameter { get; set; }
		public virtual IfcAreaMeasure? LongitudinalBarCrossSectionArea { get; set; }
		public virtual IfcAreaMeasure? TransverseBarCrossSectionArea { get; set; }
		public virtual IfcPositiveLengthMeasure? LongitudinalBarSpacing { get; set; }
		public virtual IfcPositiveLengthMeasure? TransverseBarSpacing { get; set; }
		public virtual IfcLabel? BendingShapeCode { get; set; }
		public virtual List<IfcBendingParameterSelect>? BendingParameters { get; set; }
		public IfcReinforcingMeshType() : base()
		{
		}
		public IfcReinforcingMeshType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcReinforcingMeshTypeEnum PredefinedType, IfcPositiveLengthMeasure MeshLength, IfcPositiveLengthMeasure MeshWidth, IfcPositiveLengthMeasure LongitudinalBarNominalDiameter, IfcPositiveLengthMeasure TransverseBarNominalDiameter, IfcAreaMeasure LongitudinalBarCrossSectionArea, IfcAreaMeasure TransverseBarCrossSectionArea, IfcPositiveLengthMeasure LongitudinalBarSpacing, IfcPositiveLengthMeasure TransverseBarSpacing, IfcLabel BendingShapeCode, List<IfcBendingParameterSelect> BendingParameters) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.MeshLength = MeshLength;
			this.MeshWidth = MeshWidth;
			this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
			this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
			this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
			this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
			this.LongitudinalBarSpacing = LongitudinalBarSpacing;
			this.TransverseBarSpacing = TransverseBarSpacing;
			this.BendingShapeCode = BendingShapeCode;
			this.BendingParameters = BendingParameters;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAggregates
	/// <para>ENTITY IfcRelAggregates</para>
	/// <para>SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>RelatingObject : IfcObjectDefinition;</para>
	/// <para>RelatedObjects : SET [1:?] OF IfcObjectDefinition;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(Temp <* RelatedObjects | RelatingObject :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAggregates : IfcRelDecomposes
	{
		public virtual IfcObjectDefinition? RelatingObject { get; set; }
		public virtual List<IfcObjectDefinition>? RelatedObjects { get; set; }
		public IfcRelAggregates() : base()
		{
		}
		public IfcRelAggregates(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcObjectDefinition RelatingObject, List<IfcObjectDefinition> RelatedObjects) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingObject = RelatingObject;
			this.RelatedObjects = RelatedObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssigns
	/// <para>ENTITY IfcRelAssigns</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelAssignsToActor</para>
	/// <para>,IfcRelAssignsToControl</para>
	/// <para>,IfcRelAssignsToGroup</para>
	/// <para>,IfcRelAssignsToProcess</para>
	/// <para>,IfcRelAssignsToProduct</para>
	/// <para>,IfcRelAssignsToResource))</para>
	/// <para>SUBTYPE OF (IfcRelationship);</para>
	/// <para>RelatedObjects : SET [1:?] OF IfcObjectDefinition;</para>
	/// <para>RelatedObjectsType : OPTIONAL IfcObjectTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : IfcCorrectObjectAssignment(RelatedObjectsType, RelatedObjects);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelAssigns : IfcRelationship
	{
		public virtual List<IfcObjectDefinition>? RelatedObjects { get; set; }
		public virtual IfcObjectTypeEnum? RelatedObjectsType { get; set; }
		public IfcRelAssigns() : base()
		{
		}
		public IfcRelAssigns(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatedObjectsType = RelatedObjectsType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToActor
	/// <para>ENTITY IfcRelAssignsToActor</para>
	/// <para>SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>RelatingActor : IfcActor;</para>
	/// <para>ActingRole : OPTIONAL IfcActorRole;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingActor :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToActor : IfcRelAssigns
	{
		public virtual IfcActor? RelatingActor { get; set; }
		public virtual IfcActorRole? ActingRole { get; set; }
		public IfcRelAssignsToActor() : base()
		{
		}
		public IfcRelAssignsToActor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcActor RelatingActor, IfcActorRole ActingRole) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingActor = RelatingActor;
			this.ActingRole = ActingRole;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToControl
	/// <para>ENTITY IfcRelAssignsToControl</para>
	/// <para>SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>RelatingControl : IfcControl;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingControl :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToControl : IfcRelAssigns
	{
		public virtual IfcControl? RelatingControl { get; set; }
		public IfcRelAssignsToControl() : base()
		{
		}
		public IfcRelAssignsToControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcControl RelatingControl) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingControl = RelatingControl;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToGroup
	/// <para>ENTITY IfcRelAssignsToGroup</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelAssignsToGroupByFactor))</para>
	/// <para>SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>RelatingGroup : IfcGroup;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingGroup :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToGroup : IfcRelAssigns
	{
		public virtual IfcGroup? RelatingGroup { get; set; }
		public IfcRelAssignsToGroup() : base()
		{
		}
		public IfcRelAssignsToGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcGroup RelatingGroup) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingGroup = RelatingGroup;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToGroupByFactor
	/// <para>ENTITY IfcRelAssignsToGroupByFactor</para>
	/// <para>SUBTYPE OF (IfcRelAssignsToGroup);</para>
	/// <para>Factor : IfcRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToGroupByFactor : IfcRelAssignsToGroup
	{
		public virtual IfcRatioMeasure? Factor { get; set; }
		public IfcRelAssignsToGroupByFactor() : base()
		{
		}
		public IfcRelAssignsToGroupByFactor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcGroup RelatingGroup, IfcRatioMeasure Factor) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup)
		{
			this.Factor = Factor;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToProcess
	/// <para>ENTITY IfcRelAssignsToProcess</para>
	/// <para>SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>RelatingProcess : IfcProcessSelect;</para>
	/// <para>QuantityInProcess : OPTIONAL IfcMeasureWithUnit;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingProcess :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToProcess : IfcRelAssigns
	{
		public virtual IfcProcessSelect? RelatingProcess { get; set; }
		public virtual IfcMeasureWithUnit? QuantityInProcess { get; set; }
		public IfcRelAssignsToProcess() : base()
		{
		}
		public IfcRelAssignsToProcess(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcProcessSelect RelatingProcess, IfcMeasureWithUnit QuantityInProcess) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingProcess = RelatingProcess;
			this.QuantityInProcess = QuantityInProcess;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToProduct
	/// <para>ENTITY IfcRelAssignsToProduct</para>
	/// <para>SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>RelatingProduct : IfcProductSelect;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingProduct :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToProduct : IfcRelAssigns
	{
		public virtual IfcProductSelect? RelatingProduct { get; set; }
		public IfcRelAssignsToProduct() : base()
		{
		}
		public IfcRelAssignsToProduct(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcProductSelect RelatingProduct) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingProduct = RelatingProduct;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssignsToResource
	/// <para>ENTITY IfcRelAssignsToResource</para>
	/// <para>SUBTYPE OF (IfcRelAssigns);</para>
	/// <para>RelatingResource : IfcResourceSelect;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(Temp <* SELF\IfcRelAssigns.RelatedObjects | RelatingResource :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssignsToResource : IfcRelAssigns
	{
		public virtual IfcResourceSelect? RelatingResource { get; set; }
		public IfcRelAssignsToResource() : base()
		{
		}
		public IfcRelAssignsToResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcObjectTypeEnum RelatedObjectsType, IfcResourceSelect RelatingResource) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType)
		{
			this.RelatingResource = RelatingResource;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociates
	/// <para>ENTITY IfcRelAssociates</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelAssociatesApproval</para>
	/// <para>,IfcRelAssociatesClassification</para>
	/// <para>,IfcRelAssociatesConstraint</para>
	/// <para>,IfcRelAssociatesDocument</para>
	/// <para>,IfcRelAssociatesLibrary</para>
	/// <para>,IfcRelAssociatesMaterial))</para>
	/// <para>SUBTYPE OF (IfcRelationship);</para>
	/// <para>RelatedObjects : SET [1:?] OF IfcDefinitionSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelAssociates : IfcRelationship
	{
		public virtual List<IfcDefinitionSelect>? RelatedObjects { get; set; }
		public IfcRelAssociates() : base()
		{
		}
		public IfcRelAssociates(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesApproval
	/// <para>ENTITY IfcRelAssociatesApproval</para>
	/// <para>SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>RelatingApproval : IfcApproval;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesApproval : IfcRelAssociates
	{
		public virtual IfcApproval? RelatingApproval { get; set; }
		public IfcRelAssociatesApproval() : base()
		{
		}
		public IfcRelAssociatesApproval(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcApproval RelatingApproval) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingApproval = RelatingApproval;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesClassification
	/// <para>ENTITY IfcRelAssociatesClassification</para>
	/// <para>SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>RelatingClassification : IfcClassificationSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesClassification : IfcRelAssociates
	{
		public virtual IfcClassificationSelect? RelatingClassification { get; set; }
		public IfcRelAssociatesClassification() : base()
		{
		}
		public IfcRelAssociatesClassification(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcClassificationSelect RelatingClassification) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingClassification = RelatingClassification;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesConstraint
	/// <para>ENTITY IfcRelAssociatesConstraint</para>
	/// <para>SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>Intent : OPTIONAL IfcLabel;</para>
	/// <para>RelatingConstraint : IfcConstraint;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesConstraint : IfcRelAssociates
	{
		public virtual IfcLabel? Intent { get; set; }
		public virtual IfcConstraint? RelatingConstraint { get; set; }
		public IfcRelAssociatesConstraint() : base()
		{
		}
		public IfcRelAssociatesConstraint(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcLabel Intent, IfcConstraint RelatingConstraint) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.Intent = Intent;
			this.RelatingConstraint = RelatingConstraint;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesDocument
	/// <para>ENTITY IfcRelAssociatesDocument</para>
	/// <para>SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>RelatingDocument : IfcDocumentSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesDocument : IfcRelAssociates
	{
		public virtual IfcDocumentSelect? RelatingDocument { get; set; }
		public IfcRelAssociatesDocument() : base()
		{
		}
		public IfcRelAssociatesDocument(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcDocumentSelect RelatingDocument) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingDocument = RelatingDocument;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesLibrary
	/// <para>ENTITY IfcRelAssociatesLibrary</para>
	/// <para>SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>RelatingLibrary : IfcLibrarySelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesLibrary : IfcRelAssociates
	{
		public virtual IfcLibrarySelect? RelatingLibrary { get; set; }
		public IfcRelAssociatesLibrary() : base()
		{
		}
		public IfcRelAssociatesLibrary(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcLibrarySelect RelatingLibrary) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingLibrary = RelatingLibrary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelAssociatesMaterial
	/// <para>ENTITY IfcRelAssociatesMaterial</para>
	/// <para>SUBTYPE OF (IfcRelAssociates);</para>
	/// <para>RelatingMaterial : IfcMaterialSelect;</para>
	/// <para>WHERE</para>
	/// <para>NoVoidElement : SIZEOF(QUERY(temp <* SELF\IfcRelAssociates.RelatedObjects |</para>
	/// <para>('IFC4X1.IFCFEATUREELEMENTSUBTRACTION' IN TYPEOF(temp)) OR</para>
	/// <para>('IFC4X1.IFCVIRTUALELEMENT' IN TYPEOF(temp))</para>
	/// <para>)) = 0;</para>
	/// <para>AllowedElements : SIZEOF(QUERY(temp <* SELF\IfcRelAssociates.RelatedObjects | (</para>
	/// <para>SIZEOF(TYPEOF(temp) * [</para>
	/// <para>'IFC4X1.IFCELEMENT',</para>
	/// <para>'IFC4X1.IFCELEMENTTYPE',</para>
	/// <para>'IFC4X1.IFCWINDOWSTYLE',</para>
	/// <para>'IFC4X1.IFCDOORSTYLE',</para>
	/// <para>'IFC4X1.IFCSTRUCTURALMEMBER',</para>
	/// <para>'IFC4X1.IFCPORT']) = 0)</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelAssociatesMaterial : IfcRelAssociates
	{
		public virtual IfcMaterialSelect? RelatingMaterial { get; set; }
		public IfcRelAssociatesMaterial() : base()
		{
		}
		public IfcRelAssociatesMaterial(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDefinitionSelect> RelatedObjects, IfcMaterialSelect RelatingMaterial) : base (GlobalId, OwnerHistory, Name, Description, RelatedObjects)
		{
			this.RelatingMaterial = RelatingMaterial;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnects
	/// <para>ENTITY IfcRelConnects</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelConnectsElements</para>
	/// <para>,IfcRelConnectsPortToElement</para>
	/// <para>,IfcRelConnectsPorts</para>
	/// <para>,IfcRelConnectsStructuralActivity</para>
	/// <para>,IfcRelConnectsStructuralMember</para>
	/// <para>,IfcRelContainedInSpatialStructure</para>
	/// <para>,IfcRelCoversBldgElements</para>
	/// <para>,IfcRelCoversSpaces</para>
	/// <para>,IfcRelFillsElement</para>
	/// <para>,IfcRelFlowControlElements</para>
	/// <para>,IfcRelInterferesElements</para>
	/// <para>,IfcRelReferencedInSpatialStructure</para>
	/// <para>,IfcRelSequence</para>
	/// <para>,IfcRelServicesBuildings</para>
	/// <para>,IfcRelSpaceBoundary))</para>
	/// <para>SUBTYPE OF (IfcRelationship);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelConnects : IfcRelationship
	{
		public IfcRelConnects() : base()
		{
		}
		public IfcRelConnects(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsElements
	/// <para>ENTITY IfcRelConnectsElements</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelConnectsPathElements</para>
	/// <para>,IfcRelConnectsWithRealizingElements))</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>ConnectionGeometry : OPTIONAL IfcConnectionGeometry;</para>
	/// <para>RelatingElement : IfcElement;</para>
	/// <para>RelatedElement : IfcElement;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : RelatingElement :<>: RelatedElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsElements : IfcRelConnects
	{
		public virtual IfcConnectionGeometry? ConnectionGeometry { get; set; }
		public virtual IfcElement? RelatingElement { get; set; }
		public virtual IfcElement? RelatedElement { get; set; }
		public IfcRelConnectsElements() : base()
		{
		}
		public IfcRelConnectsElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcConnectionGeometry ConnectionGeometry, IfcElement RelatingElement, IfcElement RelatedElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ConnectionGeometry = ConnectionGeometry;
			this.RelatingElement = RelatingElement;
			this.RelatedElement = RelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsPathElements
	/// <para>ENTITY IfcRelConnectsPathElements</para>
	/// <para>SUBTYPE OF (IfcRelConnectsElements);</para>
	/// <para>RelatingPriorities : LIST [0:?] OF IfcInteger;</para>
	/// <para>RelatedPriorities : LIST [0:?] OF IfcInteger;</para>
	/// <para>RelatedConnectionType : IfcConnectionTypeEnum;</para>
	/// <para>RelatingConnectionType : IfcConnectionTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>NormalizedRelatingPriorities : (SIZEOF(RelatingPriorities) = 0)</para>
	/// <para>OR</para>
	/// <para>(SIZEOF (QUERY (temp <* RelatingPriorities</para>
	/// <para>| {0 <= temp <= 100}</para>
	/// <para>)) = SIZEOF(RelatingPriorities));</para>
	/// <para>NormalizedRelatedPriorities : (SIZEOF(RelatedPriorities) = 0)</para>
	/// <para>OR</para>
	/// <para>(SIZEOF (QUERY (temp <* RelatedPriorities</para>
	/// <para>| {0 <= temp <= 100}</para>
	/// <para>)) = SIZEOF(RelatedPriorities));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsPathElements : IfcRelConnectsElements
	{
		public virtual List<IfcInteger>? RelatingPriorities { get; set; }
		public virtual List<IfcInteger>? RelatedPriorities { get; set; }
		public virtual IfcConnectionTypeEnum? RelatedConnectionType { get; set; }
		public virtual IfcConnectionTypeEnum? RelatingConnectionType { get; set; }
		public IfcRelConnectsPathElements() : base()
		{
		}
		public IfcRelConnectsPathElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcConnectionGeometry ConnectionGeometry, IfcElement RelatingElement, IfcElement RelatedElement, List<IfcInteger> RelatingPriorities, List<IfcInteger> RelatedPriorities, IfcConnectionTypeEnum RelatedConnectionType, IfcConnectionTypeEnum RelatingConnectionType) : base (GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement)
		{
			this.RelatingPriorities = RelatingPriorities;
			this.RelatedPriorities = RelatedPriorities;
			this.RelatedConnectionType = RelatedConnectionType;
			this.RelatingConnectionType = RelatingConnectionType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsPortToElement
	/// <para>ENTITY IfcRelConnectsPortToElement</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingPort : IfcPort;</para>
	/// <para>RelatedElement : IfcDistributionElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsPortToElement : IfcRelConnects
	{
		public virtual IfcPort? RelatingPort { get; set; }
		public virtual IfcDistributionElement? RelatedElement { get; set; }
		public IfcRelConnectsPortToElement() : base()
		{
		}
		public IfcRelConnectsPortToElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPort RelatingPort, IfcDistributionElement RelatedElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingPort = RelatingPort;
			this.RelatedElement = RelatedElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsPorts
	/// <para>ENTITY IfcRelConnectsPorts</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingPort : IfcPort;</para>
	/// <para>RelatedPort : IfcPort;</para>
	/// <para>RealizingElement : OPTIONAL IfcElement;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : RelatingPort :<>: RelatedPort;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsPorts : IfcRelConnects
	{
		public virtual IfcPort? RelatingPort { get; set; }
		public virtual IfcPort? RelatedPort { get; set; }
		public virtual IfcElement? RealizingElement { get; set; }
		public IfcRelConnectsPorts() : base()
		{
		}
		public IfcRelConnectsPorts(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPort RelatingPort, IfcPort RelatedPort, IfcElement RealizingElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingPort = RelatingPort;
			this.RelatedPort = RelatedPort;
			this.RealizingElement = RealizingElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsStructuralActivity
	/// <para>ENTITY IfcRelConnectsStructuralActivity</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingElement : IfcStructuralActivityAssignmentSelect;</para>
	/// <para>RelatedStructuralActivity : IfcStructuralActivity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsStructuralActivity : IfcRelConnects
	{
		public virtual IfcStructuralActivityAssignmentSelect? RelatingElement { get; set; }
		public virtual IfcStructuralActivity? RelatedStructuralActivity { get; set; }
		public IfcRelConnectsStructuralActivity() : base()
		{
		}
		public IfcRelConnectsStructuralActivity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcStructuralActivityAssignmentSelect RelatingElement, IfcStructuralActivity RelatedStructuralActivity) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingElement = RelatingElement;
			this.RelatedStructuralActivity = RelatedStructuralActivity;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsStructuralMember
	/// <para>ENTITY IfcRelConnectsStructuralMember</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelConnectsWithEccentricity))</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingStructuralMember : IfcStructuralMember;</para>
	/// <para>RelatedStructuralConnection : IfcStructuralConnection;</para>
	/// <para>AppliedCondition : OPTIONAL IfcBoundaryCondition;</para>
	/// <para>AdditionalConditions : OPTIONAL IfcStructuralConnectionCondition;</para>
	/// <para>SupportedLength : OPTIONAL IfcLengthMeasure;</para>
	/// <para>ConditionCoordinateSystem : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsStructuralMember : IfcRelConnects
	{
		public virtual IfcStructuralMember? RelatingStructuralMember { get; set; }
		public virtual IfcStructuralConnection? RelatedStructuralConnection { get; set; }
		public virtual IfcBoundaryCondition? AppliedCondition { get; set; }
		public virtual IfcStructuralConnectionCondition? AdditionalConditions { get; set; }
		public virtual IfcLengthMeasure? SupportedLength { get; set; }
		public virtual IfcAxis2Placement3D? ConditionCoordinateSystem { get; set; }
		public IfcRelConnectsStructuralMember() : base()
		{
		}
		public IfcRelConnectsStructuralMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcStructuralMember RelatingStructuralMember, IfcStructuralConnection RelatedStructuralConnection, IfcBoundaryCondition AppliedCondition, IfcStructuralConnectionCondition AdditionalConditions, IfcLengthMeasure SupportedLength, IfcAxis2Placement3D ConditionCoordinateSystem) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingStructuralMember = RelatingStructuralMember;
			this.RelatedStructuralConnection = RelatedStructuralConnection;
			this.AppliedCondition = AppliedCondition;
			this.AdditionalConditions = AdditionalConditions;
			this.SupportedLength = SupportedLength;
			this.ConditionCoordinateSystem = ConditionCoordinateSystem;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsWithEccentricity
	/// <para>ENTITY IfcRelConnectsWithEccentricity</para>
	/// <para>SUBTYPE OF (IfcRelConnectsStructuralMember);</para>
	/// <para>ConnectionConstraint : IfcConnectionGeometry;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsWithEccentricity : IfcRelConnectsStructuralMember
	{
		public virtual IfcConnectionGeometry? ConnectionConstraint { get; set; }
		public IfcRelConnectsWithEccentricity() : base()
		{
		}
		public IfcRelConnectsWithEccentricity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcStructuralMember RelatingStructuralMember, IfcStructuralConnection RelatedStructuralConnection, IfcBoundaryCondition AppliedCondition, IfcStructuralConnectionCondition AdditionalConditions, IfcLengthMeasure SupportedLength, IfcAxis2Placement3D ConditionCoordinateSystem, IfcConnectionGeometry ConnectionConstraint) : base (GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem)
		{
			this.ConnectionConstraint = ConnectionConstraint;
		}
	}
	/// <summary>
	/// ENTITY IfcRelConnectsWithRealizingElements
	/// <para>ENTITY IfcRelConnectsWithRealizingElements</para>
	/// <para>SUBTYPE OF (IfcRelConnectsElements);</para>
	/// <para>RealizingElements : SET [1:?] OF IfcElement;</para>
	/// <para>ConnectionType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelConnectsWithRealizingElements : IfcRelConnectsElements
	{
		public virtual List<IfcElement>? RealizingElements { get; set; }
		public virtual IfcLabel? ConnectionType { get; set; }
		public IfcRelConnectsWithRealizingElements() : base()
		{
		}
		public IfcRelConnectsWithRealizingElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcConnectionGeometry ConnectionGeometry, IfcElement RelatingElement, IfcElement RelatedElement, List<IfcElement> RealizingElements, IfcLabel ConnectionType) : base (GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement)
		{
			this.RealizingElements = RealizingElements;
			this.ConnectionType = ConnectionType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelContainedInSpatialStructure
	/// <para>ENTITY IfcRelContainedInSpatialStructure</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatedElements : SET [1:?] OF IfcProduct;</para>
	/// <para>RelatingStructure : IfcSpatialElement;</para>
	/// <para>WHERE</para>
	/// <para>WR31 : SIZEOF(QUERY(temp <* RelatedElements | 'IFC4X1.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelContainedInSpatialStructure : IfcRelConnects
	{
		public virtual List<IfcProduct>? RelatedElements { get; set; }
		public virtual IfcSpatialElement? RelatingStructure { get; set; }
		public IfcRelContainedInSpatialStructure() : base()
		{
		}
		public IfcRelContainedInSpatialStructure(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcProduct> RelatedElements, IfcSpatialElement RelatingStructure) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedElements = RelatedElements;
			this.RelatingStructure = RelatingStructure;
		}
	}
	/// <summary>
	/// ENTITY IfcRelCoversBldgElements
	/// <para>ENTITY IfcRelCoversBldgElements</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingBuildingElement : IfcElement;</para>
	/// <para>RelatedCoverings : SET [1:?] OF IfcCovering;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelCoversBldgElements : IfcRelConnects
	{
		public virtual IfcElement? RelatingBuildingElement { get; set; }
		public virtual List<IfcCovering>? RelatedCoverings { get; set; }
		public IfcRelCoversBldgElements() : base()
		{
		}
		public IfcRelCoversBldgElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingBuildingElement, List<IfcCovering> RelatedCoverings) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingBuildingElement = RelatingBuildingElement;
			this.RelatedCoverings = RelatedCoverings;
		}
	}
	/// <summary>
	/// ENTITY IfcRelCoversSpaces
	/// <para>ENTITY IfcRelCoversSpaces</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingSpace : IfcSpace;</para>
	/// <para>RelatedCoverings : SET [1:?] OF IfcCovering;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelCoversSpaces : IfcRelConnects
	{
		public virtual IfcSpace? RelatingSpace { get; set; }
		public virtual List<IfcCovering>? RelatedCoverings { get; set; }
		public IfcRelCoversSpaces() : base()
		{
		}
		public IfcRelCoversSpaces(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpace RelatingSpace, List<IfcCovering> RelatedCoverings) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingSpace = RelatingSpace;
			this.RelatedCoverings = RelatedCoverings;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDeclares
	/// <para>ENTITY IfcRelDeclares</para>
	/// <para>SUBTYPE OF (IfcRelationship);</para>
	/// <para>RelatingContext : IfcContext;</para>
	/// <para>RelatedDefinitions : SET [1:?] OF IfcDefinitionSelect;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(Temp <* RelatedDefinitions | RelatingContext :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDeclares : IfcRelationship
	{
		public virtual IfcContext? RelatingContext { get; set; }
		public virtual List<IfcDefinitionSelect>? RelatedDefinitions { get; set; }
		public IfcRelDeclares() : base()
		{
		}
		public IfcRelDeclares(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcContext RelatingContext, List<IfcDefinitionSelect> RelatedDefinitions) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingContext = RelatingContext;
			this.RelatedDefinitions = RelatedDefinitions;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDecomposes
	/// <para>ENTITY IfcRelDecomposes</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelAggregates</para>
	/// <para>,IfcRelNests</para>
	/// <para>,IfcRelProjectsElement</para>
	/// <para>,IfcRelVoidsElement))</para>
	/// <para>SUBTYPE OF (IfcRelationship);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelDecomposes : IfcRelationship
	{
		public IfcRelDecomposes() : base()
		{
		}
		public IfcRelDecomposes(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefines
	/// <para>ENTITY IfcRelDefines</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelDefinesByObject</para>
	/// <para>,IfcRelDefinesByProperties</para>
	/// <para>,IfcRelDefinesByTemplate</para>
	/// <para>,IfcRelDefinesByType))</para>
	/// <para>SUBTYPE OF (IfcRelationship);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelDefines : IfcRelationship
	{
		public IfcRelDefines() : base()
		{
		}
		public IfcRelDefines(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByObject
	/// <para>ENTITY IfcRelDefinesByObject</para>
	/// <para>SUBTYPE OF (IfcRelDefines);</para>
	/// <para>RelatedObjects : SET [1:?] OF IfcObject;</para>
	/// <para>RelatingObject : IfcObject;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByObject : IfcRelDefines
	{
		public virtual List<IfcObject>? RelatedObjects { get; set; }
		public virtual IfcObject? RelatingObject { get; set; }
		public IfcRelDefinesByObject() : base()
		{
		}
		public IfcRelDefinesByObject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObject> RelatedObjects, IfcObject RelatingObject) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatingObject = RelatingObject;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByProperties
	/// <para>ENTITY IfcRelDefinesByProperties</para>
	/// <para>SUBTYPE OF (IfcRelDefines);</para>
	/// <para>RelatedObjects : SET [1:?] OF IfcObjectDefinition;</para>
	/// <para>RelatingPropertyDefinition : IfcPropertySetDefinitionSelect;</para>
	/// <para>WHERE</para>
	/// <para>NoRelatedTypeObject : SIZEOF(QUERY(Types <* SELF\IfcRelDefinesByProperties.RelatedObjects |  'IFC4X1.IFCTYPEOBJECT' IN TYPEOF(Types))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByProperties : IfcRelDefines
	{
		public virtual List<IfcObjectDefinition>? RelatedObjects { get; set; }
		public virtual IfcPropertySetDefinitionSelect? RelatingPropertyDefinition { get; set; }
		public IfcRelDefinesByProperties() : base()
		{
		}
		public IfcRelDefinesByProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObjectDefinition> RelatedObjects, IfcPropertySetDefinitionSelect RelatingPropertyDefinition) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatingPropertyDefinition = RelatingPropertyDefinition;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByTemplate
	/// <para>ENTITY IfcRelDefinesByTemplate</para>
	/// <para>SUBTYPE OF (IfcRelDefines);</para>
	/// <para>RelatedPropertySets : SET [1:?] OF IfcPropertySetDefinition;</para>
	/// <para>RelatingTemplate : IfcPropertySetTemplate;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByTemplate : IfcRelDefines
	{
		public virtual List<IfcPropertySetDefinition>? RelatedPropertySets { get; set; }
		public virtual IfcPropertySetTemplate? RelatingTemplate { get; set; }
		public IfcRelDefinesByTemplate() : base()
		{
		}
		public IfcRelDefinesByTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcPropertySetDefinition> RelatedPropertySets, IfcPropertySetTemplate RelatingTemplate) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedPropertySets = RelatedPropertySets;
			this.RelatingTemplate = RelatingTemplate;
		}
	}
	/// <summary>
	/// ENTITY IfcRelDefinesByType
	/// <para>ENTITY IfcRelDefinesByType</para>
	/// <para>SUBTYPE OF (IfcRelDefines);</para>
	/// <para>RelatedObjects : SET [1:?] OF IfcObject;</para>
	/// <para>RelatingType : IfcTypeObject;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelDefinesByType : IfcRelDefines
	{
		public virtual List<IfcObject>? RelatedObjects { get; set; }
		public virtual IfcTypeObject? RelatingType { get; set; }
		public IfcRelDefinesByType() : base()
		{
		}
		public IfcRelDefinesByType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcObject> RelatedObjects, IfcTypeObject RelatingType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedObjects = RelatedObjects;
			this.RelatingType = RelatingType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelFillsElement
	/// <para>ENTITY IfcRelFillsElement</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingOpeningElement : IfcOpeningElement;</para>
	/// <para>RelatedBuildingElement : IfcElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelFillsElement : IfcRelConnects
	{
		public virtual IfcOpeningElement? RelatingOpeningElement { get; set; }
		public virtual IfcElement? RelatedBuildingElement { get; set; }
		public IfcRelFillsElement() : base()
		{
		}
		public IfcRelFillsElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcOpeningElement RelatingOpeningElement, IfcElement RelatedBuildingElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingOpeningElement = RelatingOpeningElement;
			this.RelatedBuildingElement = RelatedBuildingElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelFlowControlElements
	/// <para>ENTITY IfcRelFlowControlElements</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatedControlElements : SET [1:?] OF IfcDistributionControlElement;</para>
	/// <para>RelatingFlowElement : IfcDistributionFlowElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelFlowControlElements : IfcRelConnects
	{
		public virtual List<IfcDistributionControlElement>? RelatedControlElements { get; set; }
		public virtual IfcDistributionFlowElement? RelatingFlowElement { get; set; }
		public IfcRelFlowControlElements() : base()
		{
		}
		public IfcRelFlowControlElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcDistributionControlElement> RelatedControlElements, IfcDistributionFlowElement RelatingFlowElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedControlElements = RelatedControlElements;
			this.RelatingFlowElement = RelatingFlowElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelInterferesElements
	/// <para>ENTITY IfcRelInterferesElements</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingElement : IfcElement;</para>
	/// <para>RelatedElement : IfcElement;</para>
	/// <para>InterferenceGeometry : OPTIONAL IfcConnectionGeometry;</para>
	/// <para>InterferenceType : OPTIONAL IfcIdentifier;</para>
	/// <para>ImpliedOrder : LOGICAL;</para>
	/// <para>WHERE</para>
	/// <para>NotSelfReference : RelatingElement :<>: RelatedElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelInterferesElements : IfcRelConnects
	{
		public virtual IfcElement? RelatingElement { get; set; }
		public virtual IfcElement? RelatedElement { get; set; }
		public virtual IfcConnectionGeometry? InterferenceGeometry { get; set; }
		public virtual IfcIdentifier? InterferenceType { get; set; }
		public virtual LOGICAL? ImpliedOrder { get; set; }
		public IfcRelInterferesElements() : base()
		{
		}
		public IfcRelInterferesElements(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingElement, IfcElement RelatedElement, IfcConnectionGeometry InterferenceGeometry, IfcIdentifier InterferenceType, LOGICAL ImpliedOrder) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingElement = RelatingElement;
			this.RelatedElement = RelatedElement;
			this.InterferenceGeometry = InterferenceGeometry;
			this.InterferenceType = InterferenceType;
			this.ImpliedOrder = ImpliedOrder;
		}
	}
	/// <summary>
	/// ENTITY IfcRelNests
	/// <para>ENTITY IfcRelNests</para>
	/// <para>SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>RelatingObject : IfcObjectDefinition;</para>
	/// <para>RelatedObjects : LIST [1:?] OF IfcObjectDefinition;</para>
	/// <para>WHERE</para>
	/// <para>NoSelfReference : SIZEOF(QUERY(Temp <* RelatedObjects | RelatingObject :=: Temp)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelNests : IfcRelDecomposes
	{
		public virtual IfcObjectDefinition? RelatingObject { get; set; }
		public virtual List<IfcObjectDefinition>? RelatedObjects { get; set; }
		public IfcRelNests() : base()
		{
		}
		public IfcRelNests(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcObjectDefinition RelatingObject, List<IfcObjectDefinition> RelatedObjects) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingObject = RelatingObject;
			this.RelatedObjects = RelatedObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcRelProjectsElement
	/// <para>ENTITY IfcRelProjectsElement</para>
	/// <para>SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>RelatingElement : IfcElement;</para>
	/// <para>RelatedFeatureElement : IfcFeatureElementAddition;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelProjectsElement : IfcRelDecomposes
	{
		public virtual IfcElement? RelatingElement { get; set; }
		public virtual IfcFeatureElementAddition? RelatedFeatureElement { get; set; }
		public IfcRelProjectsElement() : base()
		{
		}
		public IfcRelProjectsElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingElement, IfcFeatureElementAddition RelatedFeatureElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingElement = RelatingElement;
			this.RelatedFeatureElement = RelatedFeatureElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelReferencedInSpatialStructure
	/// <para>ENTITY IfcRelReferencedInSpatialStructure</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatedElements : SET [1:?] OF IfcProduct;</para>
	/// <para>RelatingStructure : IfcSpatialElement;</para>
	/// <para>WHERE</para>
	/// <para>AllowedRelatedElements : SIZEOF(QUERY(temp <* RelatedElements | ('IFC4X1.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF(temp)) AND (NOT ('IFC4X1.IFCSPACE' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelReferencedInSpatialStructure : IfcRelConnects
	{
		public virtual List<IfcProduct>? RelatedElements { get; set; }
		public virtual IfcSpatialElement? RelatingStructure { get; set; }
		public IfcRelReferencedInSpatialStructure() : base()
		{
		}
		public IfcRelReferencedInSpatialStructure(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, List<IfcProduct> RelatedElements, IfcSpatialElement RelatingStructure) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatedElements = RelatedElements;
			this.RelatingStructure = RelatingStructure;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSequence
	/// <para>ENTITY IfcRelSequence</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingProcess : IfcProcess;</para>
	/// <para>RelatedProcess : IfcProcess;</para>
	/// <para>TimeLag : OPTIONAL IfcLagTime;</para>
	/// <para>SequenceType : OPTIONAL IfcSequenceEnum;</para>
	/// <para>UserDefinedSequenceType : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>AvoidInconsistentSequence : RelatingProcess :<>: RelatedProcess;</para>
	/// <para>CorrectSequenceType : (SequenceType <> IfcSequenceEnum.USERDEFINED) OR ((SequenceType = IfcSequenceEnum.USERDEFINED) AND EXISTS(UserDefinedSequenceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSequence : IfcRelConnects
	{
		public virtual IfcProcess? RelatingProcess { get; set; }
		public virtual IfcProcess? RelatedProcess { get; set; }
		public virtual IfcLagTime? TimeLag { get; set; }
		public virtual IfcSequenceEnum? SequenceType { get; set; }
		public virtual IfcLabel? UserDefinedSequenceType { get; set; }
		public IfcRelSequence() : base()
		{
		}
		public IfcRelSequence(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcProcess RelatingProcess, IfcProcess RelatedProcess, IfcLagTime TimeLag, IfcSequenceEnum SequenceType, IfcLabel UserDefinedSequenceType) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingProcess = RelatingProcess;
			this.RelatedProcess = RelatedProcess;
			this.TimeLag = TimeLag;
			this.SequenceType = SequenceType;
			this.UserDefinedSequenceType = UserDefinedSequenceType;
		}
	}
	/// <summary>
	/// ENTITY IfcRelServicesBuildings
	/// <para>ENTITY IfcRelServicesBuildings</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingSystem : IfcSystem;</para>
	/// <para>RelatedBuildings : SET [1:?] OF IfcSpatialElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelServicesBuildings : IfcRelConnects
	{
		public virtual IfcSystem? RelatingSystem { get; set; }
		public virtual List<IfcSpatialElement>? RelatedBuildings { get; set; }
		public IfcRelServicesBuildings() : base()
		{
		}
		public IfcRelServicesBuildings(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSystem RelatingSystem, List<IfcSpatialElement> RelatedBuildings) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingSystem = RelatingSystem;
			this.RelatedBuildings = RelatedBuildings;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSpaceBoundary
	/// <para>ENTITY IfcRelSpaceBoundary</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelSpaceBoundary1stLevel))</para>
	/// <para>SUBTYPE OF (IfcRelConnects);</para>
	/// <para>RelatingSpace : IfcSpaceBoundarySelect;</para>
	/// <para>RelatedBuildingElement : IfcElement;</para>
	/// <para>ConnectionGeometry : OPTIONAL IfcConnectionGeometry;</para>
	/// <para>PhysicalOrVirtualBoundary : IfcPhysicalOrVirtualEnum;</para>
	/// <para>InternalOrExternalBoundary : IfcInternalOrExternalEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPhysOrVirt : ((PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.Physical)</para>
	/// <para>AND (NOT('IFC4X1.IFCVIRTUALELEMENT' IN TYPEOF(RelatedBuildingElement))))</para>
	/// <para>OR</para>
	/// <para>((PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.Virtual)</para>
	/// <para>AND (('IFC4X1.IFCVIRTUALELEMENT' IN TYPEOF(RelatedBuildingElement))</para>
	/// <para>OR   ('IFC4X1.IFCOPENINGELEMENT' IN TYPEOF(RelatedBuildingElement))))</para>
	/// <para>OR</para>
	/// <para>(PhysicalOrVirtualBoundary = IfcPhysicalOrVirtualEnum.NotDefined);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSpaceBoundary : IfcRelConnects
	{
		public virtual IfcSpaceBoundarySelect? RelatingSpace { get; set; }
		public virtual IfcElement? RelatedBuildingElement { get; set; }
		public virtual IfcConnectionGeometry? ConnectionGeometry { get; set; }
		public virtual IfcPhysicalOrVirtualEnum? PhysicalOrVirtualBoundary { get; set; }
		public virtual IfcInternalOrExternalEnum? InternalOrExternalBoundary { get; set; }
		public IfcRelSpaceBoundary() : base()
		{
		}
		public IfcRelSpaceBoundary(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpaceBoundarySelect RelatingSpace, IfcElement RelatedBuildingElement, IfcConnectionGeometry ConnectionGeometry, IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum InternalOrExternalBoundary) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingSpace = RelatingSpace;
			this.RelatedBuildingElement = RelatedBuildingElement;
			this.ConnectionGeometry = ConnectionGeometry;
			this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
			this.InternalOrExternalBoundary = InternalOrExternalBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSpaceBoundary1stLevel
	/// <para>ENTITY IfcRelSpaceBoundary1stLevel</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelSpaceBoundary2ndLevel))</para>
	/// <para>SUBTYPE OF (IfcRelSpaceBoundary);</para>
	/// <para>ParentBoundary : OPTIONAL IfcRelSpaceBoundary1stLevel;</para>
	/// <para>INVERSE</para>
	/// <para>InnerBoundaries : SET [0:?] OF IfcRelSpaceBoundary1stLevel FOR ParentBoundary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSpaceBoundary1stLevel : IfcRelSpaceBoundary
	{
		public virtual IfcRelSpaceBoundary1stLevel? ParentBoundary { get; set; }
		//TODO INVERSE
		public List<IfcRelSpaceBoundary1stLevel>? InnerBoundaries => Model?.GetItems<IfcRelSpaceBoundary1stLevel>().Where(x => x.ParentBoundary != null && x.ParentBoundary == this).ToList();
		public IfcRelSpaceBoundary1stLevel() : base()
		{
		}
		public IfcRelSpaceBoundary1stLevel(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpaceBoundarySelect RelatingSpace, IfcElement RelatedBuildingElement, IfcConnectionGeometry ConnectionGeometry, IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel ParentBoundary) : base (GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary)
		{
			this.ParentBoundary = ParentBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelSpaceBoundary2ndLevel
	/// <para>ENTITY IfcRelSpaceBoundary2ndLevel</para>
	/// <para>SUBTYPE OF (IfcRelSpaceBoundary1stLevel);</para>
	/// <para>CorrespondingBoundary : OPTIONAL IfcRelSpaceBoundary2ndLevel;</para>
	/// <para>INVERSE</para>
	/// <para>Corresponds : SET [0:1] OF IfcRelSpaceBoundary2ndLevel FOR CorrespondingBoundary;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelSpaceBoundary2ndLevel : IfcRelSpaceBoundary1stLevel
	{
		public virtual IfcRelSpaceBoundary2ndLevel? CorrespondingBoundary { get; set; }
		//TODO INVERSE
		public List<IfcRelSpaceBoundary2ndLevel>? Corresponds => Model?.GetItems<IfcRelSpaceBoundary2ndLevel>().Where(x => x.CorrespondingBoundary != null && x.CorrespondingBoundary == this).ToList();
		public IfcRelSpaceBoundary2ndLevel() : base()
		{
		}
		public IfcRelSpaceBoundary2ndLevel(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSpaceBoundarySelect RelatingSpace, IfcElement RelatedBuildingElement, IfcConnectionGeometry ConnectionGeometry, IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel ParentBoundary, IfcRelSpaceBoundary2ndLevel CorrespondingBoundary) : base (GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary)
		{
			this.CorrespondingBoundary = CorrespondingBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcRelVoidsElement
	/// <para>ENTITY IfcRelVoidsElement</para>
	/// <para>SUBTYPE OF (IfcRelDecomposes);</para>
	/// <para>RelatingBuildingElement : IfcElement;</para>
	/// <para>RelatedOpeningElement : IfcFeatureElementSubtraction;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRelVoidsElement : IfcRelDecomposes
	{
		public virtual IfcElement? RelatingBuildingElement { get; set; }
		public virtual IfcFeatureElementSubtraction? RelatedOpeningElement { get; set; }
		public IfcRelVoidsElement() : base()
		{
		}
		public IfcRelVoidsElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcElement RelatingBuildingElement, IfcFeatureElementSubtraction RelatedOpeningElement) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.RelatingBuildingElement = RelatingBuildingElement;
			this.RelatedOpeningElement = RelatedOpeningElement;
		}
	}
	/// <summary>
	/// ENTITY IfcRelationship
	/// <para>ENTITY IfcRelationship</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRelAssigns</para>
	/// <para>,IfcRelAssociates</para>
	/// <para>,IfcRelConnects</para>
	/// <para>,IfcRelDeclares</para>
	/// <para>,IfcRelDecomposes</para>
	/// <para>,IfcRelDefines))</para>
	/// <para>SUBTYPE OF (IfcRoot);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRelationship : IfcRoot
	{
		public IfcRelationship() : base()
		{
		}
		public IfcRelationship(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base (GlobalId, OwnerHistory, Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcReparametrisedCompositeCurveSegment
	/// <para>ENTITY IfcReparametrisedCompositeCurveSegment</para>
	/// <para>SUBTYPE OF (IfcCompositeCurveSegment);</para>
	/// <para>ParamLength : IfcParameterValue;</para>
	/// <para>WHERE</para>
	/// <para>PositiveLengthParameter : ParamLength > 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcReparametrisedCompositeCurveSegment : IfcCompositeCurveSegment
	{
		public virtual IfcParameterValue? ParamLength { get; set; }
		public IfcReparametrisedCompositeCurveSegment() : base()
		{
		}
		public IfcReparametrisedCompositeCurveSegment(IfcTransitionCode Transition, IfcBoolean SameSense, IfcCurve ParentCurve, IfcParameterValue ParamLength) : base (Transition, SameSense, ParentCurve)
		{
			this.ParamLength = ParamLength;
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentation
	/// <para>ENTITY IfcRepresentation</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcShapeModel</para>
	/// <para>,IfcStyleModel));</para>
	/// <para>ContextOfItems : IfcRepresentationContext;</para>
	/// <para>RepresentationIdentifier : OPTIONAL IfcLabel;</para>
	/// <para>RepresentationType : OPTIONAL IfcLabel;</para>
	/// <para>Items : SET [1:?] OF IfcRepresentationItem;</para>
	/// <para>INVERSE</para>
	/// <para>RepresentationMap : SET [0:1] OF IfcRepresentationMap FOR MappedRepresentation;</para>
	/// <para>LayerAssignments : SET [0:?] OF IfcPresentationLayerAssignment FOR AssignedItems;</para>
	/// <para>OfProductRepresentation : SET [0:?] OF IfcProductRepresentation FOR Representations;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRepresentation : Entity, IfcLayeredItem
	{
		public virtual IfcRepresentationContext? ContextOfItems { get; set; }
		public virtual IfcLabel? RepresentationIdentifier { get; set; }
		public virtual IfcLabel? RepresentationType { get; set; }
		public virtual List<IfcRepresentationItem>? Items { get; set; }
		//TODO INVERSE
		public List<IfcRepresentationMap>? RepresentationMap => Model?.GetItems<IfcRepresentationMap>().Where(x => x.MappedRepresentation != null && x.MappedRepresentation == this).ToList();
		//TODO INVERSE
		public List<IfcPresentationLayerAssignment>? LayerAssignments => Model?.GetItems<IfcPresentationLayerAssignment>().Where(x => x.AssignedItems != null && x.AssignedItems.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcProductRepresentation>? OfProductRepresentation => Model?.GetItems<IfcProductRepresentation>().Where(x => x.Representations != null && x.Representations.Contains(this)).ToList();
		public IfcRepresentation() : base()
		{
		}
		public IfcRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base ()
		{
			this.ContextOfItems = ContextOfItems;
			this.RepresentationIdentifier = RepresentationIdentifier;
			this.RepresentationType = RepresentationType;
			this.Items = Items;
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentationContext
	/// <para>ENTITY IfcRepresentationContext</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcGeometricRepresentationContext));</para>
	/// <para>ContextIdentifier : OPTIONAL IfcLabel;</para>
	/// <para>ContextType : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>RepresentationsInContext : SET [0:?] OF IfcRepresentation FOR ContextOfItems;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRepresentationContext : Entity
	{
		public virtual IfcLabel? ContextIdentifier { get; set; }
		public virtual IfcLabel? ContextType { get; set; }
		//TODO INVERSE
		public List<IfcRepresentation>? RepresentationsInContext => Model?.GetItems<IfcRepresentation>().Where(x => x.ContextOfItems != null && x.ContextOfItems == this).ToList();
		public IfcRepresentationContext() : base()
		{
		}
		public IfcRepresentationContext(IfcLabel ContextIdentifier, IfcLabel ContextType) : base ()
		{
			this.ContextIdentifier = ContextIdentifier;
			this.ContextType = ContextType;
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentationItem
	/// <para>ENTITY IfcRepresentationItem</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcGeometricRepresentationItem</para>
	/// <para>,IfcMappedItem</para>
	/// <para>,IfcStyledItem</para>
	/// <para>,IfcTopologicalRepresentationItem));</para>
	/// <para>INVERSE</para>
	/// <para>LayerAssignment : SET [0:1] OF IfcPresentationLayerAssignment FOR AssignedItems;</para>
	/// <para>StyledByItem : SET [0:1] OF IfcStyledItem FOR Item;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRepresentationItem : Entity, IfcLayeredItem
	{
		//TODO INVERSE
		public List<IfcPresentationLayerAssignment>? LayerAssignment => Model?.GetItems<IfcPresentationLayerAssignment>().Where(x => x.AssignedItems != null && x.AssignedItems.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcStyledItem>? StyledByItem => Model?.GetItems<IfcStyledItem>().Where(x => x.Item != null && x.Item == this).ToList();
		public IfcRepresentationItem() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcRepresentationMap;
	/// <para>ENTITY IfcRepresentationMap;</para>
	/// <para>MappingOrigin : IfcAxis2Placement;</para>
	/// <para>MappedRepresentation : IfcRepresentation;</para>
	/// <para>INVERSE</para>
	/// <para>HasShapeAspects : SET [0:?] OF IfcShapeAspect FOR PartOfProductDefinitionShape;</para>
	/// <para>MapUsage : SET [0:?] OF IfcMappedItem FOR MappingSource;</para>
	/// <para>WHERE</para>
	/// <para>ApplicableMappedRepr : 'IFC4X1.IFCSHAPEMODEL' IN TYPEOF(MappedRepresentation);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRepresentationMap : Entity, IfcProductRepresentationSelect
	{
		public virtual IfcAxis2Placement? MappingOrigin { get; set; }
		public virtual IfcRepresentation? MappedRepresentation { get; set; }
		//TODO INVERSE
		public List<IfcShapeAspect>? HasShapeAspects => Model?.GetItems<IfcShapeAspect>().Where(x => x.PartOfProductDefinitionShape != null && x.PartOfProductDefinitionShape == this).ToList();
		//TODO INVERSE
		public List<IfcMappedItem>? MapUsage => Model?.GetItems<IfcMappedItem>().Where(x => x.MappingSource != null && x.MappingSource == this).ToList();
		public IfcRepresentationMap() : base()
		{
		}
		public IfcRepresentationMap(IfcAxis2Placement MappingOrigin, IfcRepresentation MappedRepresentation) : base ()
		{
			this.MappingOrigin = MappingOrigin;
			this.MappedRepresentation = MappedRepresentation;
		}
	}
	/// <summary>
	/// ENTITY IfcResource
	/// <para>ENTITY IfcResource</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcConstructionResource))</para>
	/// <para>SUBTYPE OF (IfcObject);</para>
	/// <para>Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>LongDescription : OPTIONAL IfcText;</para>
	/// <para>INVERSE</para>
	/// <para>ResourceOf : SET [0:?] OF IfcRelAssignsToResource FOR RelatingResource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcResource : IfcObject, IfcResourceSelect
	{
		public virtual IfcIdentifier? Identification { get; set; }
		public virtual IfcText? LongDescription { get; set; }
		public virtual List<IfcAppliedValue>? BaseCosts { get; set;  }
		public virtual IfcPhysicalQuantity? BaseQuantity { get; set;  }
		//TODO INVERSE
		public List<IfcRelAssignsToResource>? ResourceOf => Model?.GetItems<IfcRelAssignsToResource>().Where(x => x.RelatingResource != null && x.RelatingResource == this).ToList();
		public IfcResource() : base()
		{
		}
		public IfcResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceApprovalRelationship
	/// <para>ENTITY IfcResourceApprovalRelationship</para>
	/// <para>SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>RelatedResourceObjects : SET [1:?] OF IfcResourceObjectSelect;</para>
	/// <para>RelatingApproval : IfcApproval;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcResourceApprovalRelationship : IfcResourceLevelRelationship
	{
		public virtual List<IfcResourceObjectSelect>? RelatedResourceObjects { get; set; }
		public virtual IfcApproval? RelatingApproval { get; set; }
		public IfcResourceApprovalRelationship() : base()
		{
		}
		public IfcResourceApprovalRelationship(IfcLabel Name, IfcText Description, List<IfcResourceObjectSelect> RelatedResourceObjects, IfcApproval RelatingApproval) : base (Name, Description)
		{
			this.RelatedResourceObjects = RelatedResourceObjects;
			this.RelatingApproval = RelatingApproval;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceConstraintRelationship
	/// <para>ENTITY IfcResourceConstraintRelationship</para>
	/// <para>SUBTYPE OF (IfcResourceLevelRelationship);</para>
	/// <para>RelatingConstraint : IfcConstraint;</para>
	/// <para>RelatedResourceObjects : SET [1:?] OF IfcResourceObjectSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcResourceConstraintRelationship : IfcResourceLevelRelationship
	{
		public virtual IfcConstraint? RelatingConstraint { get; set; }
		public virtual List<IfcResourceObjectSelect>? RelatedResourceObjects { get; set; }
		public IfcResourceConstraintRelationship() : base()
		{
		}
		public IfcResourceConstraintRelationship(IfcLabel Name, IfcText Description, IfcConstraint RelatingConstraint, List<IfcResourceObjectSelect> RelatedResourceObjects) : base (Name, Description)
		{
			this.RelatingConstraint = RelatingConstraint;
			this.RelatedResourceObjects = RelatedResourceObjects;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceLevelRelationship
	/// <para>ENTITY IfcResourceLevelRelationship</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcApprovalRelationship</para>
	/// <para>,IfcCurrencyRelationship</para>
	/// <para>,IfcDocumentInformationRelationship</para>
	/// <para>,IfcExternalReferenceRelationship</para>
	/// <para>,IfcMaterialRelationship</para>
	/// <para>,IfcOrganizationRelationship</para>
	/// <para>,IfcPropertyDependencyRelationship</para>
	/// <para>,IfcResourceApprovalRelationship</para>
	/// <para>,IfcResourceConstraintRelationship));</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcResourceLevelRelationship : Entity
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public IfcResourceLevelRelationship() : base()
		{
		}
		public IfcResourceLevelRelationship(IfcLabel Name, IfcText Description) : base ()
		{
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcResourceTime
	/// <para>ENTITY IfcResourceTime</para>
	/// <para>SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>ScheduleWork : OPTIONAL IfcDuration;</para>
	/// <para>ScheduleUsage : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>ScheduleStart : OPTIONAL IfcDateTime;</para>
	/// <para>ScheduleFinish : OPTIONAL IfcDateTime;</para>
	/// <para>ScheduleContour : OPTIONAL IfcLabel;</para>
	/// <para>LevelingDelay : OPTIONAL IfcDuration;</para>
	/// <para>IsOverAllocated : OPTIONAL IfcBoolean;</para>
	/// <para>StatusTime : OPTIONAL IfcDateTime;</para>
	/// <para>ActualWork : OPTIONAL IfcDuration;</para>
	/// <para>ActualUsage : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>ActualStart : OPTIONAL IfcDateTime;</para>
	/// <para>ActualFinish : OPTIONAL IfcDateTime;</para>
	/// <para>RemainingWork : OPTIONAL IfcDuration;</para>
	/// <para>RemainingUsage : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>Completion : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcResourceTime : IfcSchedulingTime
	{
		public virtual IfcDuration? ScheduleWork { get; set; }
		public virtual IfcPositiveRatioMeasure? ScheduleUsage { get; set; }
		public virtual IfcDateTime? ScheduleStart { get; set; }
		public virtual IfcDateTime? ScheduleFinish { get; set; }
		public virtual IfcLabel? ScheduleContour { get; set; }
		public virtual IfcDuration? LevelingDelay { get; set; }
		public virtual IfcBoolean? IsOverAllocated { get; set; }
		public virtual IfcDateTime? StatusTime { get; set; }
		public virtual IfcDuration? ActualWork { get; set; }
		public virtual IfcPositiveRatioMeasure? ActualUsage { get; set; }
		public virtual IfcDateTime? ActualStart { get; set; }
		public virtual IfcDateTime? ActualFinish { get; set; }
		public virtual IfcDuration? RemainingWork { get; set; }
		public virtual IfcPositiveRatioMeasure? RemainingUsage { get; set; }
		public virtual IfcPositiveRatioMeasure? Completion { get; set; }
		public IfcResourceTime() : base()
		{
		}
		public IfcResourceTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcDuration ScheduleWork, IfcPositiveRatioMeasure ScheduleUsage, IfcDateTime ScheduleStart, IfcDateTime ScheduleFinish, IfcLabel ScheduleContour, IfcDuration LevelingDelay, IfcBoolean IsOverAllocated, IfcDateTime StatusTime, IfcDuration ActualWork, IfcPositiveRatioMeasure ActualUsage, IfcDateTime ActualStart, IfcDateTime ActualFinish, IfcDuration RemainingWork, IfcPositiveRatioMeasure RemainingUsage, IfcPositiveRatioMeasure Completion) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.ScheduleWork = ScheduleWork;
			this.ScheduleUsage = ScheduleUsage;
			this.ScheduleStart = ScheduleStart;
			this.ScheduleFinish = ScheduleFinish;
			this.ScheduleContour = ScheduleContour;
			this.LevelingDelay = LevelingDelay;
			this.IsOverAllocated = IsOverAllocated;
			this.StatusTime = StatusTime;
			this.ActualWork = ActualWork;
			this.ActualUsage = ActualUsage;
			this.ActualStart = ActualStart;
			this.ActualFinish = ActualFinish;
			this.RemainingWork = RemainingWork;
			this.RemainingUsage = RemainingUsage;
			this.Completion = Completion;
		}
	}
	/// <summary>
	/// ENTITY IfcRevolvedAreaSolid
	/// <para>ENTITY IfcRevolvedAreaSolid</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcRevolvedAreaSolidTapered))</para>
	/// <para>SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>Axis : IfcAxis1Placement;</para>
	/// <para>Angle : IfcPlaneAngleMeasure;</para>
	/// <para>DERIVE</para>
	/// <para>AxisLine : IfcLine := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcCurve() || IfcLine(Axis.Location,</para>
	/// <para>IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector(Axis.Z,1.0));</para>
	/// <para>WHERE</para>
	/// <para>AxisStartInXY : Axis.Location.Coordinates[3] = 0.0;</para>
	/// <para>AxisDirectionInXY : Axis.Z.DirectionRatios[3] = 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRevolvedAreaSolid : IfcSweptAreaSolid
	{
		public virtual IfcAxis1Placement? Axis { get; set; }
		public virtual IfcPlaneAngleMeasure? Angle { get; set; }
		//TODO DERIVE
		public virtual IfcLine? AxisLine {get {return null;}}
		public IfcRevolvedAreaSolid() : base()
		{
		}
		public IfcRevolvedAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcAxis1Placement Axis, IfcPlaneAngleMeasure Angle) : base (SweptArea, Position)
		{
			this.Axis = Axis;
			this.Angle = Angle;
		}
	}
	/// <summary>
	/// ENTITY IfcRevolvedAreaSolidTapered
	/// <para>ENTITY IfcRevolvedAreaSolidTapered</para>
	/// <para>SUBTYPE OF (IfcRevolvedAreaSolid);</para>
	/// <para>EndSweptArea : IfcProfileDef;</para>
	/// <para>WHERE</para>
	/// <para>CorrectProfileAssignment : IfcTaperedSweptAreaProfiles(SELF\IfcSweptAreaSolid.SweptArea, SELF.EndSweptArea);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRevolvedAreaSolidTapered : IfcRevolvedAreaSolid
	{
		public virtual IfcProfileDef? EndSweptArea { get; set; }
		public IfcRevolvedAreaSolidTapered() : base()
		{
		}
		public IfcRevolvedAreaSolidTapered(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcAxis1Placement Axis, IfcPlaneAngleMeasure Angle, IfcProfileDef EndSweptArea) : base (SweptArea, Position, Axis, Angle)
		{
			this.EndSweptArea = EndSweptArea;
		}
	}
	/// <summary>
	/// ENTITY IfcRightCircularCone
	/// <para>ENTITY IfcRightCircularCone</para>
	/// <para>SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>Height : IfcPositiveLengthMeasure;</para>
	/// <para>BottomRadius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRightCircularCone : IfcCsgPrimitive3D
	{
		public virtual IfcPositiveLengthMeasure? Height { get; set; }
		public virtual IfcPositiveLengthMeasure? BottomRadius { get; set; }
		public IfcRightCircularCone() : base()
		{
		}
		public IfcRightCircularCone(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Height, IfcPositiveLengthMeasure BottomRadius) : base (Position)
		{
			this.Height = Height;
			this.BottomRadius = BottomRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcRightCircularCylinder
	/// <para>ENTITY IfcRightCircularCylinder</para>
	/// <para>SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>Height : IfcPositiveLengthMeasure;</para>
	/// <para>Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRightCircularCylinder : IfcCsgPrimitive3D
	{
		public virtual IfcPositiveLengthMeasure? Height { get; set; }
		public virtual IfcPositiveLengthMeasure? Radius { get; set; }
		public IfcRightCircularCylinder() : base()
		{
		}
		public IfcRightCircularCylinder(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Height, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Height = Height;
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcRoof
	/// <para>ENTITY IfcRoof</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcRoofTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcRoofTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRoofTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCROOFTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoof : IfcBuildingElement
	{
		public virtual IfcRoofTypeEnum? PredefinedType { get; set; }
		public IfcRoof() : base()
		{
		}
		public IfcRoof(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcRoofTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRoofType
	/// <para>ENTITY IfcRoofType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcRoofTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcRoofTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcRoofTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoofType : IfcBuildingElementType
	{
		public virtual IfcRoofTypeEnum? PredefinedType { get; set; }
		public IfcRoofType() : base()
		{
		}
		public IfcRoofType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcRoofTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcRoot
	/// <para>ENTITY IfcRoot</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcObjectDefinition</para>
	/// <para>,IfcPropertyDefinition</para>
	/// <para>,IfcRelationship));</para>
	/// <para>GlobalId : IfcGloballyUniqueId;</para>
	/// <para>OwnerHistory : OPTIONAL IfcOwnerHistory;</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>UNIQUE</para>
	/// <para>UR1 : GlobalId;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcRoot : Entity
	{
		public virtual IfcGloballyUniqueId? GlobalId { get; set; }
		public virtual IfcOwnerHistory? OwnerHistory { get; set; }
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public IfcRoot() : base()
		{
		}
		public IfcRoot(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description) : base ()
		{
			this.GlobalId = GlobalId;
			this.OwnerHistory = OwnerHistory;
			this.Name = Name;
			this.Description = Description;
		}
	}
	/// <summary>
	/// ENTITY IfcRoundedRectangleProfileDef
	/// <para>ENTITY IfcRoundedRectangleProfileDef</para>
	/// <para>SUBTYPE OF (IfcRectangleProfileDef);</para>
	/// <para>RoundingRadius : IfcPositiveLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidRadius : ((RoundingRadius <= (SELF\IfcRectangleProfileDef.XDim/2.)) AND</para>
	/// <para>(RoundingRadius <= (SELF\IfcRectangleProfileDef.YDim/2.)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcRoundedRectangleProfileDef : IfcRectangleProfileDef
	{
		public virtual IfcPositiveLengthMeasure? RoundingRadius { get; set; }
		public IfcRoundedRectangleProfileDef() : base()
		{
		}
		public IfcRoundedRectangleProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure XDim, IfcPositiveLengthMeasure YDim, IfcPositiveLengthMeasure RoundingRadius) : base (ProfileType, ProfileName, Position, XDim, YDim)
		{
			this.RoundingRadius = RoundingRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcSIUnit
	/// <para>ENTITY IfcSIUnit</para>
	/// <para>SUBTYPE OF (IfcNamedUnit);</para>
	/// <para>Prefix : OPTIONAL IfcSIPrefix;</para>
	/// <para>Name : IfcSIUnitName;</para>
	/// <para>DERIVE</para>
	/// <para>SELF\IfcNamedUnit.Dimensions : IfcDimensionalExponents := IfcDimensionsForSiUnit (SELF.Name);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSIUnit : IfcNamedUnit
	{
		public virtual IfcSIPrefix? Prefix { get; set; }
		public virtual IfcSIUnitName? Name { get; set; }
		//TODO DERIVE
		public override IfcDimensionalExponents? Dimensions {get {return null;}}
		public IfcSIUnit() : base()
		{
		}
		public IfcSIUnit(IfcDimensionalExponents Dimensions, IfcUnitEnum UnitType, IfcSIPrefix Prefix, IfcSIUnitName Name) : base (Dimensions, UnitType)
		{
			this.Prefix = Prefix;
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcSanitaryTerminal
	/// <para>ENTITY IfcSanitaryTerminal</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcSanitaryTerminalTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcSanitaryTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSanitaryTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSANITARYTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSanitaryTerminal : IfcFlowTerminal
	{
		public virtual IfcSanitaryTerminalTypeEnum? PredefinedType { get; set; }
		public IfcSanitaryTerminal() : base()
		{
		}
		public IfcSanitaryTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSanitaryTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSanitaryTerminalType
	/// <para>ENTITY IfcSanitaryTerminalType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcSanitaryTerminalTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcSanitaryTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSanitaryTerminalTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSanitaryTerminalType : IfcFlowTerminalType
	{
		public virtual IfcSanitaryTerminalTypeEnum? PredefinedType { get; set; }
		public IfcSanitaryTerminalType() : base()
		{
		}
		public IfcSanitaryTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSanitaryTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSchedulingTime
	/// <para>ENTITY IfcSchedulingTime</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcEventTime</para>
	/// <para>,IfcLagTime</para>
	/// <para>,IfcResourceTime</para>
	/// <para>,IfcTaskTime</para>
	/// <para>,IfcWorkTime));</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>DataOrigin : OPTIONAL IfcDataOriginEnum;</para>
	/// <para>UserDefinedDataOrigin : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSchedulingTime : Entity
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcDataOriginEnum? DataOrigin { get; set; }
		public virtual IfcLabel? UserDefinedDataOrigin { get; set; }
		public IfcSchedulingTime() : base()
		{
		}
		public IfcSchedulingTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin) : base ()
		{
			this.Name = Name;
			this.DataOrigin = DataOrigin;
			this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		}
	}
	/// <summary>
	/// ENTITY IfcSeamCurve
	/// <para>ENTITY IfcSeamCurve</para>
	/// <para>SUBTYPE OF (IfcSurfaceCurve);</para>
	/// <para>WHERE</para>
	/// <para>TwoPCurves : SIZEOF(SELF\IfcSurfaceCurve.AssociatedGeometry) = 2;</para>
	/// <para>SameSurface : IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[1]) = IfcAssociatedSurface(SELF\IfcSurfaceCurve.AssociatedGeometry[2]);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSeamCurve : IfcSurfaceCurve
	{
		public IfcSeamCurve() : base()
		{
		}
		public IfcSeamCurve(IfcCurve Curve3D, List<IfcPcurve> AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation MasterRepresentation) : base (Curve3D, AssociatedGeometry, MasterRepresentation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSectionProperties
	/// <para>ENTITY IfcSectionProperties</para>
	/// <para>SUBTYPE OF (IfcPreDefinedProperties);</para>
	/// <para>SectionType : IfcSectionTypeEnum;</para>
	/// <para>StartProfile : IfcProfileDef;</para>
	/// <para>EndProfile : OPTIONAL IfcProfileDef;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionProperties : IfcPreDefinedProperties
	{
		public virtual IfcSectionTypeEnum? SectionType { get; set; }
		public virtual IfcProfileDef? StartProfile { get; set; }
		public virtual IfcProfileDef? EndProfile { get; set; }
		public IfcSectionProperties() : base()
		{
		}
		public IfcSectionProperties(IfcSectionTypeEnum SectionType, IfcProfileDef StartProfile, IfcProfileDef EndProfile) : base ()
		{
			this.SectionType = SectionType;
			this.StartProfile = StartProfile;
			this.EndProfile = EndProfile;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionReinforcementProperties
	/// <para>ENTITY IfcSectionReinforcementProperties</para>
	/// <para>SUBTYPE OF (IfcPreDefinedProperties);</para>
	/// <para>LongitudinalStartPosition : IfcLengthMeasure;</para>
	/// <para>LongitudinalEndPosition : IfcLengthMeasure;</para>
	/// <para>TransversePosition : OPTIONAL IfcLengthMeasure;</para>
	/// <para>ReinforcementRole : IfcReinforcingBarRoleEnum;</para>
	/// <para>SectionDefinition : IfcSectionProperties;</para>
	/// <para>CrossSectionReinforcementDefinitions : SET [1:?] OF IfcReinforcementBarProperties;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionReinforcementProperties : IfcPreDefinedProperties
	{
		public virtual IfcLengthMeasure? LongitudinalStartPosition { get; set; }
		public virtual IfcLengthMeasure? LongitudinalEndPosition { get; set; }
		public virtual IfcLengthMeasure? TransversePosition { get; set; }
		public virtual IfcReinforcingBarRoleEnum? ReinforcementRole { get; set; }
		public virtual IfcSectionProperties? SectionDefinition { get; set; }
		public virtual List<IfcReinforcementBarProperties>? CrossSectionReinforcementDefinitions { get; set; }
		public IfcSectionReinforcementProperties() : base()
		{
		}
		public IfcSectionReinforcementProperties(IfcLengthMeasure LongitudinalStartPosition, IfcLengthMeasure LongitudinalEndPosition, IfcLengthMeasure TransversePosition, IfcReinforcingBarRoleEnum ReinforcementRole, IfcSectionProperties SectionDefinition, List<IfcReinforcementBarProperties> CrossSectionReinforcementDefinitions) : base ()
		{
			this.LongitudinalStartPosition = LongitudinalStartPosition;
			this.LongitudinalEndPosition = LongitudinalEndPosition;
			this.TransversePosition = TransversePosition;
			this.ReinforcementRole = ReinforcementRole;
			this.SectionDefinition = SectionDefinition;
			this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionedSolid
	/// <para>ENTITY IfcSectionedSolid</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcSectionedSolidHorizontal))</para>
	/// <para>SUBTYPE OF (IfcSolidModel);</para>
	/// <para>Directrix : IfcCurve;</para>
	/// <para>CrossSections : LIST [2:?] OF IfcProfileDef;</para>
	/// <para>WHERE</para>
	/// <para>DirectrixIs3D : Directrix.Dim = 3;</para>
	/// <para>ConsistentProfileTypes : SIZEOF(QUERY(temp <* CrossSections | CrossSections[1].ProfileType <> temp.ProfileType)) = 0;</para>
	/// <para>SectionsSameType : SIZEOF(QUERY(temp <* CrossSections | TYPEOF(CrossSections[1]) :<>: TYPEOF(temp))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSectionedSolid : IfcSolidModel
	{
		public virtual IfcCurve? Directrix { get; set; }
		public virtual List<IfcProfileDef>? CrossSections { get; set; }
		public IfcSectionedSolid() : base()
		{
		}
		public IfcSectionedSolid(IfcCurve Directrix, List<IfcProfileDef> CrossSections) : base ()
		{
			this.Directrix = Directrix;
			this.CrossSections = CrossSections;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionedSolidHorizontal
	/// <para>ENTITY IfcSectionedSolidHorizontal</para>
	/// <para>SUBTYPE OF (IfcSectionedSolid);</para>
	/// <para>CrossSectionPositions : LIST [2:?] OF IfcDistanceExpression;</para>
	/// <para>FixedAxisVertical : IfcBoolean;</para>
	/// <para>WHERE</para>
	/// <para>CorrespondingSectionPositions : SIZEOF(CrossSections) = SIZEOF(CrossSectionPositions);</para>
	/// <para>NoLongitudinalOffsets : SIZEOF(QUERY(temp <* CrossSectionPositions | EXISTS(temp.OffsetLongitudinal))) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionedSolidHorizontal : IfcSectionedSolid
	{
		public virtual List<IfcDistanceExpression>? CrossSectionPositions { get; set; }
		public virtual IfcBoolean? FixedAxisVertical { get; set; }
		public IfcSectionedSolidHorizontal() : base()
		{
		}
		public IfcSectionedSolidHorizontal(IfcCurve Directrix, List<IfcProfileDef> CrossSections, List<IfcDistanceExpression> CrossSectionPositions, IfcBoolean FixedAxisVertical) : base (Directrix, CrossSections)
		{
			this.CrossSectionPositions = CrossSectionPositions;
			this.FixedAxisVertical = FixedAxisVertical;
		}
	}
	/// <summary>
	/// ENTITY IfcSectionedSpine
	/// <para>ENTITY IfcSectionedSpine</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>SpineCurve : IfcCompositeCurve;</para>
	/// <para>CrossSections : LIST [2:?] OF IfcProfileDef;</para>
	/// <para>CrossSectionPositions : LIST [2:?] OF IfcAxis2Placement3D;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := 3;</para>
	/// <para>WHERE</para>
	/// <para>CorrespondingSectionPositions : SIZEOF(CrossSections) = SIZEOF(CrossSectionPositions);</para>
	/// <para>ConsistentProfileTypes : SIZEOF(QUERY(temp <* CrossSections | CrossSections[1].ProfileType <> temp.ProfileType)) = 0;</para>
	/// <para>SpineCurveDim : SpineCurve.Dim = 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSectionedSpine : IfcGeometricRepresentationItem
	{
		public virtual IfcCompositeCurve? SpineCurve { get; set; }
		public virtual List<IfcProfileDef>? CrossSections { get; set; }
		public virtual List<IfcAxis2Placement3D>? CrossSectionPositions { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcSectionedSpine() : base()
		{
		}
		public IfcSectionedSpine(IfcCompositeCurve SpineCurve, List<IfcProfileDef> CrossSections, List<IfcAxis2Placement3D> CrossSectionPositions) : base ()
		{
			this.SpineCurve = SpineCurve;
			this.CrossSections = CrossSections;
			this.CrossSectionPositions = CrossSectionPositions;
		}
	}
	/// <summary>
	/// ENTITY IfcSensor
	/// <para>ENTITY IfcSensor</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcSensorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcSensorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSensorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSENSORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSensor : IfcDistributionControlElement
	{
		public virtual IfcSensorTypeEnum? PredefinedType { get; set; }
		public IfcSensor() : base()
		{
		}
		public IfcSensor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSensorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSensorType
	/// <para>ENTITY IfcSensorType</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>PredefinedType : IfcSensorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcSensorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSensorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSensorType : IfcDistributionControlElementType
	{
		public virtual IfcSensorTypeEnum? PredefinedType { get; set; }
		public IfcSensorType() : base()
		{
		}
		public IfcSensorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSensorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcShadingDevice
	/// <para>ENTITY IfcShadingDevice</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcShadingDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcShadingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcShadingDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSHADINGDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShadingDevice : IfcBuildingElement
	{
		public virtual IfcShadingDeviceTypeEnum? PredefinedType { get; set; }
		public IfcShadingDevice() : base()
		{
		}
		public IfcShadingDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcShadingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcShadingDeviceType
	/// <para>ENTITY IfcShadingDeviceType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcShadingDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcShadingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcShadingDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShadingDeviceType : IfcBuildingElementType
	{
		public virtual IfcShadingDeviceTypeEnum? PredefinedType { get; set; }
		public IfcShadingDeviceType() : base()
		{
		}
		public IfcShadingDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcShadingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcShapeAspect;
	/// <para>ENTITY IfcShapeAspect;</para>
	/// <para>ShapeRepresentations : LIST [1:?] OF IfcShapeModel;</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>ProductDefinitional : IfcLogical;</para>
	/// <para>PartOfProductDefinitionShape : OPTIONAL IfcProductRepresentationSelect;</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReferences : SET [0:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShapeAspect : Entity, IfcResourceObjectSelect
	{
		public virtual List<IfcShapeModel>? ShapeRepresentations { get; set; }
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcLogical? ProductDefinitional { get; set; }
		public virtual IfcProductRepresentationSelect? PartOfProductDefinitionShape { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReferences => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		public IfcShapeAspect() : base()
		{
		}
		public IfcShapeAspect(List<IfcShapeModel> ShapeRepresentations, IfcLabel Name, IfcText Description, IfcLogical ProductDefinitional, IfcProductRepresentationSelect PartOfProductDefinitionShape) : base ()
		{
			this.ShapeRepresentations = ShapeRepresentations;
			this.Name = Name;
			this.Description = Description;
			this.ProductDefinitional = ProductDefinitional;
			this.PartOfProductDefinitionShape = PartOfProductDefinitionShape;
		}
	}
	/// <summary>
	/// ENTITY IfcShapeModel
	/// <para>ENTITY IfcShapeModel</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcShapeRepresentation</para>
	/// <para>,IfcTopologyRepresentation))</para>
	/// <para>SUBTYPE OF (IfcRepresentation);</para>
	/// <para>INVERSE</para>
	/// <para>OfShapeAspect : SET [0:1] OF IfcShapeAspect FOR ShapeRepresentations;</para>
	/// <para>WHERE</para>
	/// <para>WR11 : (SIZEOF(SELF\IfcRepresentation.OfProductRepresentation) = 1) XOR</para>
	/// <para>(SIZEOF(SELF\IfcRepresentation.RepresentationMap) = 1) XOR</para>
	/// <para>(SIZEOF(OfShapeAspect) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcShapeModel : IfcRepresentation
	{
		//TODO INVERSE
		public List<IfcShapeAspect>? OfShapeAspect => Model?.GetItems<IfcShapeAspect>().Where(x => x.ShapeRepresentations != null && x.ShapeRepresentations.Contains(this)).ToList();
		public IfcShapeModel() : base()
		{
		}
		public IfcShapeModel(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcShapeRepresentation
	/// <para>ENTITY IfcShapeRepresentation</para>
	/// <para>SUBTYPE OF (IfcShapeModel);</para>
	/// <para>WHERE</para>
	/// <para>CorrectContext : 'IFC4X1.IFCGEOMETRICREPRESENTATIONCONTEXT'</para>
	/// <para>IN TYPEOF(SELF\IfcRepresentation.ContextOfItems);</para>
	/// <para>NoTopologicalItem : SIZEOF(QUERY(temp <* Items |</para>
	/// <para>('IFC4X1.IFCTOPOLOGICALREPRESENTATIONITEM' IN TYPEOF(temp))</para>
	/// <para>AND (NOT(SIZEOF(</para>
	/// <para>['IFC4X1.IFCVERTEXPOINT',</para>
	/// <para>'IFC4X1.IFCEDGECURVE',</para>
	/// <para>'IFC4X1.IFCFACESURFACE'] * TYPEOF(temp)) = 1))</para>
	/// <para>)) = 0;</para>
	/// <para>HasRepresentationType : EXISTS(SELF\IfcRepresentation.RepresentationType);</para>
	/// <para>HasRepresentationIdentifier : EXISTS(SELF\IfcRepresentation.RepresentationIdentifier);</para>
	/// <para>CorrectItemsForType : IfcShapeRepresentationTypes(SELF\IfcRepresentation.RepresentationType, SELF\IfcRepresentation.Items);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShapeRepresentation : IfcShapeModel
	{
		public IfcShapeRepresentation() : base()
		{
		}
		public IfcShapeRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcShellBasedSurfaceModel
	/// <para>ENTITY IfcShellBasedSurfaceModel</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>SbsmBoundary : SET [1:?] OF IfcShell;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcShellBasedSurfaceModel : IfcGeometricRepresentationItem
	{
		public virtual List<IfcShell>? SbsmBoundary { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcShellBasedSurfaceModel() : base()
		{
		}
		public IfcShellBasedSurfaceModel(List<IfcShell> SbsmBoundary) : base ()
		{
			this.SbsmBoundary = SbsmBoundary;
		}
	}
	/// <summary>
	/// ENTITY IfcSimpleProperty
	/// <para>ENTITY IfcSimpleProperty</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPropertyBoundedValue</para>
	/// <para>,IfcPropertyEnumeratedValue</para>
	/// <para>,IfcPropertyListValue</para>
	/// <para>,IfcPropertyReferenceValue</para>
	/// <para>,IfcPropertySingleValue</para>
	/// <para>,IfcPropertyTableValue))</para>
	/// <para>SUBTYPE OF (IfcProperty);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSimpleProperty : IfcProperty
	{
		public IfcSimpleProperty() : base()
		{
		}
		public IfcSimpleProperty(IfcIdentifier Name, IfcText Description) : base (Name, Description)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSimplePropertyTemplate
	/// <para>ENTITY IfcSimplePropertyTemplate</para>
	/// <para>SUBTYPE OF (IfcPropertyTemplate);</para>
	/// <para>TemplateType : OPTIONAL IfcSimplePropertyTemplateTypeEnum;</para>
	/// <para>PrimaryMeasureType : OPTIONAL IfcLabel;</para>
	/// <para>SecondaryMeasureType : OPTIONAL IfcLabel;</para>
	/// <para>Enumerators : OPTIONAL IfcPropertyEnumeration;</para>
	/// <para>PrimaryUnit : OPTIONAL IfcUnit;</para>
	/// <para>SecondaryUnit : OPTIONAL IfcUnit;</para>
	/// <para>Expression : OPTIONAL IfcLabel;</para>
	/// <para>AccessState : OPTIONAL IfcStateEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSimplePropertyTemplate : IfcPropertyTemplate
	{
		public virtual IfcSimplePropertyTemplateTypeEnum? TemplateType { get; set; }
		public virtual IfcLabel? PrimaryMeasureType { get; set; }
		public virtual IfcLabel? SecondaryMeasureType { get; set; }
		public virtual IfcPropertyEnumeration? Enumerators { get; set; }
		public virtual IfcUnit? PrimaryUnit { get; set; }
		public virtual IfcUnit? SecondaryUnit { get; set; }
		public virtual IfcLabel? Expression { get; set; }
		public virtual IfcStateEnum? AccessState { get; set; }
		public IfcSimplePropertyTemplate() : base()
		{
		}
		public IfcSimplePropertyTemplate(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcSimplePropertyTemplateTypeEnum TemplateType, IfcLabel PrimaryMeasureType, IfcLabel SecondaryMeasureType, IfcPropertyEnumeration Enumerators, IfcUnit PrimaryUnit, IfcUnit SecondaryUnit, IfcLabel Expression, IfcStateEnum AccessState) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.TemplateType = TemplateType;
			this.PrimaryMeasureType = PrimaryMeasureType;
			this.SecondaryMeasureType = SecondaryMeasureType;
			this.Enumerators = Enumerators;
			this.PrimaryUnit = PrimaryUnit;
			this.SecondaryUnit = SecondaryUnit;
			this.Expression = Expression;
			this.AccessState = AccessState;
		}
	}
	/// <summary>
	/// ENTITY IfcSite
	/// <para>ENTITY IfcSite</para>
	/// <para>SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>RefLatitude : OPTIONAL IfcCompoundPlaneAngleMeasure;</para>
	/// <para>RefLongitude : OPTIONAL IfcCompoundPlaneAngleMeasure;</para>
	/// <para>RefElevation : OPTIONAL IfcLengthMeasure;</para>
	/// <para>LandTitleNumber : OPTIONAL IfcLabel;</para>
	/// <para>SiteAddress : OPTIONAL IfcPostalAddress;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSite : IfcSpatialStructureElement
	{
		public virtual IfcCompoundPlaneAngleMeasure? RefLatitude { get; set; }
		public virtual IfcCompoundPlaneAngleMeasure? RefLongitude { get; set; }
		public virtual IfcLengthMeasure? RefElevation { get; set; }
		public virtual IfcLabel? LandTitleNumber { get; set; }
		public virtual IfcPostalAddress? SiteAddress { get; set; }
		public IfcSite() : base()
		{
		}
		public IfcSite(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcCompoundPlaneAngleMeasure RefLatitude, IfcCompoundPlaneAngleMeasure RefLongitude, IfcLengthMeasure RefElevation, IfcLabel LandTitleNumber, IfcPostalAddress SiteAddress) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.RefLatitude = RefLatitude;
			this.RefLongitude = RefLongitude;
			this.RefElevation = RefElevation;
			this.LandTitleNumber = LandTitleNumber;
			this.SiteAddress = SiteAddress;
		}
	}
	/// <summary>
	/// ENTITY IfcSlab
	/// <para>ENTITY IfcSlab</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcSlabElementedCase</para>
	/// <para>,IfcSlabStandardCase))</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcSlabTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcSlabTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSlabTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSLABTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlab : IfcBuildingElement
	{
		public virtual IfcSlabTypeEnum? PredefinedType { get; set; }
		public IfcSlab() : base()
		{
		}
		public IfcSlab(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSlabTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSlabElementedCase
	/// <para>ENTITY IfcSlabElementedCase</para>
	/// <para>SUBTYPE OF (IfcSlab);</para>
	/// <para>WHERE</para>
	/// <para>HasDecomposition : HIINDEX(SELF\IfcObjectDefinition.IsDecomposedBy) > 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlabElementedCase : IfcSlab
	{
		public IfcSlabElementedCase() : base()
		{
		}
		public IfcSlabElementedCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSlabTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSlabStandardCase
	/// <para>ENTITY IfcSlabStandardCase</para>
	/// <para>SUBTYPE OF (IfcSlab);</para>
	/// <para>WHERE</para>
	/// <para>HasMaterialLayerSetusage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4X1.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>('IFC4X1.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>('IFC4X1.IFCMATERIALLAYERSETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlabStandardCase : IfcSlab
	{
		public IfcSlabStandardCase() : base()
		{
		}
		public IfcSlabStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSlabTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSlabType
	/// <para>ENTITY IfcSlabType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcSlabTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcSlabTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSlabTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlabType : IfcBuildingElementType
	{
		public virtual IfcSlabTypeEnum? PredefinedType { get; set; }
		public IfcSlabType() : base()
		{
		}
		public IfcSlabType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSlabTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSlippageConnectionCondition
	/// <para>ENTITY IfcSlippageConnectionCondition</para>
	/// <para>SUBTYPE OF (IfcStructuralConnectionCondition);</para>
	/// <para>SlippageX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>SlippageY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>SlippageZ : OPTIONAL IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSlippageConnectionCondition : IfcStructuralConnectionCondition
	{
		public virtual IfcLengthMeasure? SlippageX { get; set; }
		public virtual IfcLengthMeasure? SlippageY { get; set; }
		public virtual IfcLengthMeasure? SlippageZ { get; set; }
		public IfcSlippageConnectionCondition() : base()
		{
		}
		public IfcSlippageConnectionCondition(IfcLabel Name, IfcLengthMeasure SlippageX, IfcLengthMeasure SlippageY, IfcLengthMeasure SlippageZ) : base (Name)
		{
			this.SlippageX = SlippageX;
			this.SlippageY = SlippageY;
			this.SlippageZ = SlippageZ;
		}
	}
	/// <summary>
	/// ENTITY IfcSolarDevice
	/// <para>ENTITY IfcSolarDevice</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcSolarDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcSolarDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSolarDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSOLARDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSolarDevice : IfcEnergyConversionDevice
	{
		public virtual IfcSolarDeviceTypeEnum? PredefinedType { get; set; }
		public IfcSolarDevice() : base()
		{
		}
		public IfcSolarDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSolarDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSolarDeviceType
	/// <para>ENTITY IfcSolarDeviceType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcSolarDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcSolarDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSolarDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSolarDeviceType : IfcEnergyConversionDeviceType
	{
		public virtual IfcSolarDeviceTypeEnum? PredefinedType { get; set; }
		public IfcSolarDeviceType() : base()
		{
		}
		public IfcSolarDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSolarDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSolidModel
	/// <para>ENTITY IfcSolidModel</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcCsgSolid</para>
	/// <para>,IfcManifoldSolidBrep</para>
	/// <para>,IfcSectionedSolid</para>
	/// <para>,IfcSweptAreaSolid</para>
	/// <para>,IfcSweptDiskSolid))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSolidModel : IfcGeometricRepresentationItem, IfcBooleanOperand, IfcSolidOrShell
	{
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcSolidModel() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSpace
	/// <para>ENTITY IfcSpace</para>
	/// <para>SUBTYPE OF (IfcSpatialStructureElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcSpaceTypeEnum;</para>
	/// <para>ElevationWithFlooring : OPTIONAL IfcLengthMeasure;</para>
	/// <para>INVERSE</para>
	/// <para>HasCoverings : SET [0:?] OF IfcRelCoversSpaces FOR RelatingSpace;</para>
	/// <para>BoundedBy : SET [0:?] OF IfcRelSpaceBoundary FOR RelatingSpace;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcSpaceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSpaceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSPACETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpace : IfcSpatialStructureElement, IfcSpaceBoundarySelect
	{
		public virtual IfcSpaceTypeEnum? PredefinedType { get; set; }
		public virtual IfcLengthMeasure? ElevationWithFlooring { get; set; }
		//TODO INVERSE
		public List<IfcRelCoversSpaces>? HasCoverings => Model?.GetItems<IfcRelCoversSpaces>().Where(x => x.RelatingSpace != null && x.RelatingSpace == this).ToList();
		//TODO INVERSE
		public List<IfcRelSpaceBoundary>? BoundedBy => Model?.GetItems<IfcRelSpaceBoundary>().Where(x => x.RelatingSpace != null && x.RelatingSpace == this).ToList();
		public IfcSpace() : base()
		{
		}
		public IfcSpace(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType, IfcSpaceTypeEnum PredefinedType, IfcLengthMeasure ElevationWithFlooring) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType)
		{
			this.PredefinedType = PredefinedType;
			this.ElevationWithFlooring = ElevationWithFlooring;
		}
	}
	/// <summary>
	/// ENTITY IfcSpaceHeater
	/// <para>ENTITY IfcSpaceHeater</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcSpaceHeaterTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcSpaceHeaterTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSpaceHeaterTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSPACEHEATERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpaceHeater : IfcFlowTerminal
	{
		public virtual IfcSpaceHeaterTypeEnum? PredefinedType { get; set; }
		public IfcSpaceHeater() : base()
		{
		}
		public IfcSpaceHeater(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSpaceHeaterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpaceHeaterType
	/// <para>ENTITY IfcSpaceHeaterType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcSpaceHeaterTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcSpaceHeaterTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSpaceHeaterTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpaceHeaterType : IfcFlowTerminalType
	{
		public virtual IfcSpaceHeaterTypeEnum? PredefinedType { get; set; }
		public IfcSpaceHeaterType() : base()
		{
		}
		public IfcSpaceHeaterType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSpaceHeaterTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpaceType
	/// <para>ENTITY IfcSpaceType</para>
	/// <para>SUBTYPE OF (IfcSpatialStructureElementType);</para>
	/// <para>PredefinedType : IfcSpaceTypeEnum;</para>
	/// <para>LongName : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcSpaceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSpaceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcSpatialElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpaceType : IfcSpatialStructureElementType
	{
		public virtual IfcSpaceTypeEnum? PredefinedType { get; set; }
		public virtual IfcLabel? LongName { get; set; }
		public IfcSpaceType() : base()
		{
		}
		public IfcSpaceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSpaceTypeEnum PredefinedType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialElement
	/// <para>ENTITY IfcSpatialElement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcExternalSpatialStructureElement</para>
	/// <para>,IfcSpatialStructureElement</para>
	/// <para>,IfcSpatialZone))</para>
	/// <para>SUBTYPE OF (IfcProduct);</para>
	/// <para>LongName : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>ContainsElements : SET [0:?] OF IfcRelContainedInSpatialStructure FOR RelatingStructure;</para>
	/// <para>ServicedBySystems : SET [0:?] OF IfcRelServicesBuildings FOR RelatedBuildings;</para>
	/// <para>ReferencesElements : SET [0:?] OF IfcRelReferencedInSpatialStructure FOR RelatingStructure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialElement : IfcProduct
	{
		public virtual IfcLabel? LongName { get; set; }
		//TODO INVERSE
		public List<IfcRelContainedInSpatialStructure>? ContainsElements => Model?.GetItems<IfcRelContainedInSpatialStructure>().Where(x => x.RelatingStructure != null && x.RelatingStructure == this).ToList();
		//TODO INVERSE
		public List<IfcRelServicesBuildings>? ServicedBySystems => Model?.GetItems<IfcRelServicesBuildings>().Where(x => x.RelatedBuildings != null && x.RelatedBuildings.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcRelReferencedInSpatialStructure>? ReferencesElements => Model?.GetItems<IfcRelReferencedInSpatialStructure>().Where(x => x.RelatingStructure != null && x.RelatingStructure == this).ToList();
		public IfcSpatialElement() : base()
		{
		}
		public IfcSpatialElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialElementType
	/// <para>ENTITY IfcSpatialElementType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcSpatialStructureElementType</para>
	/// <para>,IfcSpatialZoneType))</para>
	/// <para>SUBTYPE OF (IfcTypeProduct);</para>
	/// <para>ElementType : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialElementType : IfcTypeProduct
	{
		public virtual IfcLabel? ElementType { get; set; }
		public IfcSpatialElementType() : base()
		{
		}
		public IfcSpatialElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.ElementType = ElementType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialStructureElement
	/// <para>ENTITY IfcSpatialStructureElement</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBuilding</para>
	/// <para>,IfcBuildingStorey</para>
	/// <para>,IfcSite</para>
	/// <para>,IfcSpace))</para>
	/// <para>SUBTYPE OF (IfcSpatialElement);</para>
	/// <para>CompositionType : OPTIONAL IfcElementCompositionEnum;</para>
	/// <para>WHERE</para>
	/// <para>WR41 : (HIINDEX(SELF\IfcObjectDefinition.Decomposes) = 1)</para>
	/// <para>AND</para>
	/// <para>('IFC4X1.IFCRELAGGREGATES' IN TYPEOF(SELF\IfcObjectDefinition.Decomposes[1]))</para>
	/// <para>AND</para>
	/// <para>(('IFC4X1.IFCPROJECT' IN TYPEOF (SELF\IfcObjectDefinition.Decomposes[1].RelatingObject)) OR</para>
	/// <para>('IFC4X1.IFCSPATIALSTRUCTUREELEMENT' IN TYPEOF (SELF\IfcObjectDefinition.Decomposes[1].RelatingObject))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialStructureElement : IfcSpatialElement
	{
		public virtual IfcElementCompositionEnum? CompositionType { get; set; }
		public IfcSpatialStructureElement() : base()
		{
		}
		public IfcSpatialStructureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcElementCompositionEnum CompositionType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
			this.CompositionType = CompositionType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialStructureElementType
	/// <para>ENTITY IfcSpatialStructureElementType</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcSpaceType))</para>
	/// <para>SUBTYPE OF (IfcSpatialElementType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSpatialStructureElementType : IfcSpatialElementType
	{
		public IfcSpatialStructureElementType() : base()
		{
		}
		public IfcSpatialStructureElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialZone
	/// <para>ENTITY IfcSpatialZone</para>
	/// <para>SUBTYPE OF (IfcSpatialElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcSpatialZoneTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcSpatialZoneTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSpatialZoneTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSPATIALZONETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpatialZone : IfcSpatialElement
	{
		public virtual IfcSpatialZoneTypeEnum? PredefinedType { get; set; }
		public IfcSpatialZone() : base()
		{
		}
		public IfcSpatialZone(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcLabel LongName, IfcSpatialZoneTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSpatialZoneType
	/// <para>ENTITY IfcSpatialZoneType</para>
	/// <para>SUBTYPE OF (IfcSpatialElementType);</para>
	/// <para>PredefinedType : IfcSpatialZoneTypeEnum;</para>
	/// <para>LongName : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcSpatialZoneTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSpatialZoneTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcSpatialElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSpatialZoneType : IfcSpatialElementType
	{
		public virtual IfcSpatialZoneTypeEnum? PredefinedType { get; set; }
		public virtual IfcLabel? LongName { get; set; }
		public IfcSpatialZoneType() : base()
		{
		}
		public IfcSpatialZoneType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSpatialZoneTypeEnum PredefinedType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.LongName = LongName;
		}
	}
	/// <summary>
	/// ENTITY IfcSphere
	/// <para>ENTITY IfcSphere</para>
	/// <para>SUBTYPE OF (IfcCsgPrimitive3D);</para>
	/// <para>Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSphere : IfcCsgPrimitive3D
	{
		public virtual IfcPositiveLengthMeasure? Radius { get; set; }
		public IfcSphere() : base()
		{
		}
		public IfcSphere(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcSphericalSurface
	/// <para>ENTITY IfcSphericalSurface</para>
	/// <para>SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>Radius : IfcPositiveLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSphericalSurface : IfcElementarySurface
	{
		public virtual IfcPositiveLengthMeasure? Radius { get; set; }
		public IfcSphericalSurface() : base()
		{
		}
		public IfcSphericalSurface(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure Radius) : base (Position)
		{
			this.Radius = Radius;
		}
	}
	/// <summary>
	/// ENTITY IfcStackTerminal
	/// <para>ENTITY IfcStackTerminal</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcStackTerminalTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcStackTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcStackTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSTACKTERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStackTerminal : IfcFlowTerminal
	{
		public virtual IfcStackTerminalTypeEnum? PredefinedType { get; set; }
		public IfcStackTerminal() : base()
		{
		}
		public IfcStackTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcStackTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStackTerminalType
	/// <para>ENTITY IfcStackTerminalType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcStackTerminalTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcStackTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcStackTerminalTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStackTerminalType : IfcFlowTerminalType
	{
		public virtual IfcStackTerminalTypeEnum? PredefinedType { get; set; }
		public IfcStackTerminalType() : base()
		{
		}
		public IfcStackTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcStackTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStair
	/// <para>ENTITY IfcStair</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcStairTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcStairTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcStairTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSTAIRTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStair : IfcBuildingElement
	{
		public virtual IfcStairTypeEnum? PredefinedType { get; set; }
		public IfcStair() : base()
		{
		}
		public IfcStair(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcStairTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStairFlight
	/// <para>ENTITY IfcStairFlight</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>NumberOfRisers : OPTIONAL IfcInteger;</para>
	/// <para>NumberOfTreads : OPTIONAL IfcInteger;</para>
	/// <para>RiserHeight : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>TreadLength : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>PredefinedType : OPTIONAL IfcStairFlightTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcStairFlightTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcStairFlightTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSTAIRFLIGHTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStairFlight : IfcBuildingElement
	{
		public virtual IfcInteger? NumberOfRisers { get; set; }
		public virtual IfcInteger? NumberOfTreads { get; set; }
		public virtual IfcPositiveLengthMeasure? RiserHeight { get; set; }
		public virtual IfcPositiveLengthMeasure? TreadLength { get; set; }
		public virtual IfcStairFlightTypeEnum? PredefinedType { get; set; }
		public IfcStairFlight() : base()
		{
		}
		public IfcStairFlight(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcInteger NumberOfRisers, IfcInteger NumberOfTreads, IfcPositiveLengthMeasure RiserHeight, IfcPositiveLengthMeasure TreadLength, IfcStairFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.NumberOfRisers = NumberOfRisers;
			this.NumberOfTreads = NumberOfTreads;
			this.RiserHeight = RiserHeight;
			this.TreadLength = TreadLength;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStairFlightType
	/// <para>ENTITY IfcStairFlightType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcStairFlightTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcStairFlightTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcStairFlightTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStairFlightType : IfcBuildingElementType
	{
		public virtual IfcStairFlightTypeEnum? PredefinedType { get; set; }
		public IfcStairFlightType() : base()
		{
		}
		public IfcStairFlightType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcStairFlightTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStairType
	/// <para>ENTITY IfcStairType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcStairTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcStairTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcStairTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStairType : IfcBuildingElementType
	{
		public virtual IfcStairTypeEnum? PredefinedType { get; set; }
		public IfcStairType() : base()
		{
		}
		public IfcStairType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcStairTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralAction
	/// <para>ENTITY IfcStructuralAction</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralCurveAction</para>
	/// <para>,IfcStructuralPointAction</para>
	/// <para>,IfcStructuralSurfaceAction))</para>
	/// <para>SUBTYPE OF (IfcStructuralActivity);</para>
	/// <para>DestabilizingLoad : OPTIONAL IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralAction : IfcStructuralActivity
	{
		public virtual IfcBoolean? DestabilizingLoad { get; set; }
		public IfcStructuralAction() : base()
		{
		}
		public IfcStructuralAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
			this.DestabilizingLoad = DestabilizingLoad;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralActivity
	/// <para>ENTITY IfcStructuralActivity</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralAction</para>
	/// <para>,IfcStructuralReaction))</para>
	/// <para>SUBTYPE OF (IfcProduct);</para>
	/// <para>AppliedLoad : IfcStructuralLoad;</para>
	/// <para>GlobalOrLocal : IfcGlobalOrLocalEnum;</para>
	/// <para>INVERSE</para>
	/// <para>AssignedToStructuralItem : SET [0:1] OF IfcRelConnectsStructuralActivity FOR RelatedStructuralActivity;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralActivity : IfcProduct
	{
		public virtual IfcStructuralLoad? AppliedLoad { get; set; }
		public virtual IfcGlobalOrLocalEnum? GlobalOrLocal { get; set; }
		//TODO INVERSE
		public List<IfcRelConnectsStructuralActivity>? AssignedToStructuralItem => Model?.GetItems<IfcRelConnectsStructuralActivity>().Where(x => x.RelatedStructuralActivity != null && x.RelatedStructuralActivity == this).ToList();
		public IfcStructuralActivity() : base()
		{
		}
		public IfcStructuralActivity(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.AppliedLoad = AppliedLoad;
			this.GlobalOrLocal = GlobalOrLocal;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralAnalysisModel
	/// <para>ENTITY IfcStructuralAnalysisModel</para>
	/// <para>SUBTYPE OF (IfcSystem);</para>
	/// <para>PredefinedType : IfcAnalysisModelTypeEnum;</para>
	/// <para>OrientationOf2DPlane : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>LoadedBy : OPTIONAL SET [1:?] OF IfcStructuralLoadGroup;</para>
	/// <para>HasResults : OPTIONAL SET [1:?] OF IfcStructuralResultGroup;</para>
	/// <para>SharedPlacement : OPTIONAL IfcObjectPlacement;</para>
	/// <para>WHERE</para>
	/// <para>HasObjectType : (PredefinedType <> IfcAnalysisModelTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralAnalysisModel : IfcSystem
	{
		public virtual IfcAnalysisModelTypeEnum? PredefinedType { get; set; }
		public virtual IfcAxis2Placement3D? OrientationOf2DPlane { get; set; }
		public virtual List<IfcStructuralLoadGroup>? LoadedBy { get; set; }
		public virtual List<IfcStructuralResultGroup>? HasResults { get; set; }
		public virtual IfcObjectPlacement? SharedPlacement { get; set; }
		public IfcStructuralAnalysisModel() : base()
		{
		}
		public IfcStructuralAnalysisModel(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcAnalysisModelTypeEnum PredefinedType, IfcAxis2Placement3D OrientationOf2DPlane, List<IfcStructuralLoadGroup> LoadedBy, List<IfcStructuralResultGroup> HasResults, IfcObjectPlacement SharedPlacement) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.OrientationOf2DPlane = OrientationOf2DPlane;
			this.LoadedBy = LoadedBy;
			this.HasResults = HasResults;
			this.SharedPlacement = SharedPlacement;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralConnection
	/// <para>ENTITY IfcStructuralConnection</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralCurveConnection</para>
	/// <para>,IfcStructuralPointConnection</para>
	/// <para>,IfcStructuralSurfaceConnection))</para>
	/// <para>SUBTYPE OF (IfcStructuralItem);</para>
	/// <para>AppliedCondition : OPTIONAL IfcBoundaryCondition;</para>
	/// <para>INVERSE</para>
	/// <para>ConnectsStructuralMembers : SET [1:?] OF IfcRelConnectsStructuralMember FOR RelatedStructuralConnection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralConnection : IfcStructuralItem
	{
		public virtual IfcBoundaryCondition? AppliedCondition { get; set; }
		//TODO INVERSE
		public List<IfcRelConnectsStructuralMember>? ConnectsStructuralMembers => Model?.GetItems<IfcRelConnectsStructuralMember>().Where(x => x.RelatedStructuralConnection != null && x.RelatedStructuralConnection == this).ToList();
		public IfcStructuralConnection() : base()
		{
		}
		public IfcStructuralConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.AppliedCondition = AppliedCondition;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralConnectionCondition
	/// <para>ENTITY IfcStructuralConnectionCondition</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcFailureConnectionCondition</para>
	/// <para>,IfcSlippageConnectionCondition));</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralConnectionCondition : Entity
	{
		public virtual IfcLabel? Name { get; set; }
		public IfcStructuralConnectionCondition() : base()
		{
		}
		public IfcStructuralConnectionCondition(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveAction
	/// <para>ENTITY IfcStructuralCurveAction</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralLinearAction))</para>
	/// <para>SUBTYPE OF (IfcStructuralAction);</para>
	/// <para>ProjectedOrTrue : OPTIONAL IfcProjectedOrTrueLengthEnum;</para>
	/// <para>PredefinedType : IfcStructuralCurveActivityTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>ProjectedIsGlobal : (NOT EXISTS(ProjectedOrTrue)) OR</para>
	/// <para>((ProjectedOrTrue <> PROJECTED_LENGTH) OR</para>
	/// <para>(SELF\IfcStructuralActivity.GlobalOrLocal = GLOBAL_COORDS));</para>
	/// <para>HasObjectType : (PredefinedType <> IfcStructuralCurveActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>SuitablePredefinedType : PredefinedType <> IfcStructuralCurveActivityTypeEnum.EQUIDISTANT;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveAction : IfcStructuralAction
	{
		public virtual IfcProjectedOrTrueLengthEnum? ProjectedOrTrue { get; set; }
		public virtual IfcStructuralCurveActivityTypeEnum? PredefinedType { get; set; }
		public IfcStructuralCurveAction() : base()
		{
		}
		public IfcStructuralCurveAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
		{
			this.ProjectedOrTrue = ProjectedOrTrue;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveConnection
	/// <para>ENTITY IfcStructuralCurveConnection</para>
	/// <para>SUBTYPE OF (IfcStructuralConnection);</para>
	/// <para>Axis : IfcDirection;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveConnection : IfcStructuralConnection
	{
		public virtual IfcDirection? Axis { get; set; }
		public IfcStructuralCurveConnection() : base()
		{
		}
		public IfcStructuralCurveConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition, IfcDirection Axis) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
		{
			this.Axis = Axis;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveMember
	/// <para>ENTITY IfcStructuralCurveMember</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralCurveMemberVarying))</para>
	/// <para>SUBTYPE OF (IfcStructuralMember);</para>
	/// <para>PredefinedType : IfcStructuralCurveMemberTypeEnum;</para>
	/// <para>Axis : IfcDirection;</para>
	/// <para>WHERE</para>
	/// <para>HasObjectType : (PredefinedType <> IfcStructuralCurveMemberTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveMember : IfcStructuralMember
	{
		public virtual IfcStructuralCurveMemberTypeEnum? PredefinedType { get; set; }
		public virtual IfcDirection? Axis { get; set; }
		public IfcStructuralCurveMember() : base()
		{
		}
		public IfcStructuralCurveMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralCurveMemberTypeEnum PredefinedType, IfcDirection Axis) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.PredefinedType = PredefinedType;
			this.Axis = Axis;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveMemberVarying
	/// <para>ENTITY IfcStructuralCurveMemberVarying</para>
	/// <para>SUBTYPE OF (IfcStructuralCurveMember);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveMemberVarying : IfcStructuralCurveMember
	{
		public IfcStructuralCurveMemberVarying() : base()
		{
		}
		public IfcStructuralCurveMemberVarying(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralCurveMemberTypeEnum PredefinedType, IfcDirection Axis) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralCurveReaction
	/// <para>ENTITY IfcStructuralCurveReaction</para>
	/// <para>SUBTYPE OF (IfcStructuralReaction);</para>
	/// <para>PredefinedType : IfcStructuralCurveActivityTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>HasObjectType : (PredefinedType <> IfcStructuralCurveActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>SuitablePredefinedType : (PredefinedType <> IfcStructuralCurveActivityTypeEnum.SINUS) AND (PredefinedType <> IfcStructuralCurveActivityTypeEnum.PARABOLA);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralCurveReaction : IfcStructuralReaction
	{
		public virtual IfcStructuralCurveActivityTypeEnum? PredefinedType { get; set; }
		public IfcStructuralCurveReaction() : base()
		{
		}
		public IfcStructuralCurveReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcStructuralCurveActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralItem
	/// <para>ENTITY IfcStructuralItem</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralConnection</para>
	/// <para>,IfcStructuralMember))</para>
	/// <para>SUBTYPE OF (IfcProduct);</para>
	/// <para>INVERSE</para>
	/// <para>AssignedStructuralActivity : SET [0:?] OF IfcRelConnectsStructuralActivity FOR RelatingElement;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralItem : IfcProduct, IfcStructuralActivityAssignmentSelect
	{
		//TODO INVERSE
		public List<IfcRelConnectsStructuralActivity>? AssignedStructuralActivity => Model?.GetItems<IfcRelConnectsStructuralActivity>().Where(x => x.RelatingElement != null && x.RelatingElement == this).ToList();
		public IfcStructuralItem() : base()
		{
		}
		public IfcStructuralItem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLinearAction
	/// <para>ENTITY IfcStructuralLinearAction</para>
	/// <para>SUBTYPE OF (IfcStructuralCurveAction);</para>
	/// <para>WHERE</para>
	/// <para>SuitableLoadType : SIZEOF(['IFC4X1.IFCSTRUCTURALLOADLINEARFORCE', 'IFC4X1.IFCSTRUCTURALLOADTEMPERATURE'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>ConstPredefinedType : SELF\IfcStructuralCurveAction.PredefinedType = IfcStructuralCurveActivityTypeEnum.CONST;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLinearAction : IfcStructuralCurveAction
	{
		public IfcStructuralLinearAction() : base()
		{
		}
		public IfcStructuralLinearAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoad
	/// <para>ENTITY IfcStructuralLoad</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralLoadConfiguration</para>
	/// <para>,IfcStructuralLoadOrResult));</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralLoad : Entity
	{
		public virtual IfcLabel? Name { get; set; }
		public IfcStructuralLoad() : base()
		{
		}
		public IfcStructuralLoad(IfcLabel Name) : base ()
		{
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadCase
	/// <para>ENTITY IfcStructuralLoadCase</para>
	/// <para>SUBTYPE OF (IfcStructuralLoadGroup);</para>
	/// <para>SelfWeightCoefficients : OPTIONAL LIST [3:3] OF IfcRatioMeasure;</para>
	/// <para>WHERE</para>
	/// <para>IsLoadCasePredefinedType : SELF\IfcStructuralLoadGroup.PredefinedType = IfcLoadGroupTypeEnum.LOAD_CASE;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadCase : IfcStructuralLoadGroup
	{
		public virtual List<IfcRatioMeasure>? SelfWeightCoefficients { get; set; }
		public IfcStructuralLoadCase() : base()
		{
		}
		public IfcStructuralLoadCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLoadGroupTypeEnum PredefinedType, IfcActionTypeEnum ActionType, IfcActionSourceTypeEnum ActionSource, IfcRatioMeasure Coefficient, IfcLabel Purpose, List<IfcRatioMeasure> SelfWeightCoefficients) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose)
		{
			this.SelfWeightCoefficients = SelfWeightCoefficients;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadConfiguration
	/// <para>ENTITY IfcStructuralLoadConfiguration</para>
	/// <para>SUBTYPE OF (IfcStructuralLoad);</para>
	/// <para>Values : LIST [1:?] OF IfcStructuralLoadOrResult;</para>
	/// <para>Locations : OPTIONAL LIST [1:?] OF UNIQUE LIST [1:2] OF IfcLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidListSize : NOT EXISTS(Locations) OR (SIZEOF(Locations) = SIZEOF(Values));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadConfiguration : IfcStructuralLoad
	{
		public virtual List<IfcStructuralLoadOrResult>? Values { get; set; }
		public IfcStructuralLoadConfiguration() : base()
		{
		}
		public IfcStructuralLoadConfiguration(IfcLabel Name, List<IfcStructuralLoadOrResult> Values) : base (Name)
		{
			this.Values = Values;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadGroup
	/// <para>ENTITY IfcStructuralLoadGroup</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralLoadCase))</para>
	/// <para>SUBTYPE OF (IfcGroup);</para>
	/// <para>PredefinedType : IfcLoadGroupTypeEnum;</para>
	/// <para>ActionType : IfcActionTypeEnum;</para>
	/// <para>ActionSource : IfcActionSourceTypeEnum;</para>
	/// <para>Coefficient : OPTIONAL IfcRatioMeasure;</para>
	/// <para>Purpose : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>SourceOfResultGroup : SET [0:1] OF IfcStructuralResultGroup FOR ResultForLoadGroup;</para>
	/// <para>LoadGroupFor : SET [0:?] OF IfcStructuralAnalysisModel FOR LoadedBy;</para>
	/// <para>WHERE</para>
	/// <para>HasObjectType : (</para>
	/// <para>(PredefinedType <> IfcLoadGroupTypeEnum.USERDEFINED) AND</para>
	/// <para>(ActionType <> IfcActionTypeEnum.USERDEFINED) AND</para>
	/// <para>(ActionSource <> IfcActionSourceTypeEnum.USERDEFINED)</para>
	/// <para>) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadGroup : IfcGroup
	{
		public virtual IfcLoadGroupTypeEnum? PredefinedType { get; set; }
		public virtual IfcActionTypeEnum? ActionType { get; set; }
		public virtual IfcActionSourceTypeEnum? ActionSource { get; set; }
		public virtual IfcRatioMeasure? Coefficient { get; set; }
		public virtual IfcLabel? Purpose { get; set; }
		//TODO INVERSE
		public List<IfcStructuralResultGroup>? SourceOfResultGroup => Model?.GetItems<IfcStructuralResultGroup>().Where(x => x.ResultForLoadGroup != null && x.ResultForLoadGroup == this).ToList();
		//TODO INVERSE
		public List<IfcStructuralAnalysisModel>? LoadGroupFor => Model?.GetItems<IfcStructuralAnalysisModel>().Where(x => x.LoadedBy != null && x.LoadedBy.Contains(this)).ToList();
		public IfcStructuralLoadGroup() : base()
		{
		}
		public IfcStructuralLoadGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLoadGroupTypeEnum PredefinedType, IfcActionTypeEnum ActionType, IfcActionSourceTypeEnum ActionSource, IfcRatioMeasure Coefficient, IfcLabel Purpose) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.PredefinedType = PredefinedType;
			this.ActionType = ActionType;
			this.ActionSource = ActionSource;
			this.Coefficient = Coefficient;
			this.Purpose = Purpose;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadLinearForce
	/// <para>ENTITY IfcStructuralLoadLinearForce</para>
	/// <para>SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>LinearForceX : OPTIONAL IfcLinearForceMeasure;</para>
	/// <para>LinearForceY : OPTIONAL IfcLinearForceMeasure;</para>
	/// <para>LinearForceZ : OPTIONAL IfcLinearForceMeasure;</para>
	/// <para>LinearMomentX : OPTIONAL IfcLinearMomentMeasure;</para>
	/// <para>LinearMomentY : OPTIONAL IfcLinearMomentMeasure;</para>
	/// <para>LinearMomentZ : OPTIONAL IfcLinearMomentMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadLinearForce : IfcStructuralLoadStatic
	{
		public virtual IfcLinearForceMeasure? LinearForceX { get; set; }
		public virtual IfcLinearForceMeasure? LinearForceY { get; set; }
		public virtual IfcLinearForceMeasure? LinearForceZ { get; set; }
		public virtual IfcLinearMomentMeasure? LinearMomentX { get; set; }
		public virtual IfcLinearMomentMeasure? LinearMomentY { get; set; }
		public virtual IfcLinearMomentMeasure? LinearMomentZ { get; set; }
		public IfcStructuralLoadLinearForce() : base()
		{
		}
		public IfcStructuralLoadLinearForce(IfcLabel Name, IfcLinearForceMeasure LinearForceX, IfcLinearForceMeasure LinearForceY, IfcLinearForceMeasure LinearForceZ, IfcLinearMomentMeasure LinearMomentX, IfcLinearMomentMeasure LinearMomentY, IfcLinearMomentMeasure LinearMomentZ) : base (Name)
		{
			this.LinearForceX = LinearForceX;
			this.LinearForceY = LinearForceY;
			this.LinearForceZ = LinearForceZ;
			this.LinearMomentX = LinearMomentX;
			this.LinearMomentY = LinearMomentY;
			this.LinearMomentZ = LinearMomentZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadOrResult
	/// <para>ENTITY IfcStructuralLoadOrResult</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralLoadStatic</para>
	/// <para>,IfcSurfaceReinforcementArea))</para>
	/// <para>SUBTYPE OF (IfcStructuralLoad);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralLoadOrResult : IfcStructuralLoad
	{
		public IfcStructuralLoadOrResult() : base()
		{
		}
		public IfcStructuralLoadOrResult(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadPlanarForce
	/// <para>ENTITY IfcStructuralLoadPlanarForce</para>
	/// <para>SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>PlanarForceX : OPTIONAL IfcPlanarForceMeasure;</para>
	/// <para>PlanarForceY : OPTIONAL IfcPlanarForceMeasure;</para>
	/// <para>PlanarForceZ : OPTIONAL IfcPlanarForceMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadPlanarForce : IfcStructuralLoadStatic
	{
		public virtual IfcPlanarForceMeasure? PlanarForceX { get; set; }
		public virtual IfcPlanarForceMeasure? PlanarForceY { get; set; }
		public virtual IfcPlanarForceMeasure? PlanarForceZ { get; set; }
		public IfcStructuralLoadPlanarForce() : base()
		{
		}
		public IfcStructuralLoadPlanarForce(IfcLabel Name, IfcPlanarForceMeasure PlanarForceX, IfcPlanarForceMeasure PlanarForceY, IfcPlanarForceMeasure PlanarForceZ) : base (Name)
		{
			this.PlanarForceX = PlanarForceX;
			this.PlanarForceY = PlanarForceY;
			this.PlanarForceZ = PlanarForceZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleDisplacement
	/// <para>ENTITY IfcStructuralLoadSingleDisplacement</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralLoadSingleDisplacementDistortion))</para>
	/// <para>SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>DisplacementX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>DisplacementY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>DisplacementZ : OPTIONAL IfcLengthMeasure;</para>
	/// <para>RotationalDisplacementRX : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>RotationalDisplacementRY : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>RotationalDisplacementRZ : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleDisplacement : IfcStructuralLoadStatic
	{
		public virtual IfcLengthMeasure? DisplacementX { get; set; }
		public virtual IfcLengthMeasure? DisplacementY { get; set; }
		public virtual IfcLengthMeasure? DisplacementZ { get; set; }
		public virtual IfcPlaneAngleMeasure? RotationalDisplacementRX { get; set; }
		public virtual IfcPlaneAngleMeasure? RotationalDisplacementRY { get; set; }
		public virtual IfcPlaneAngleMeasure? RotationalDisplacementRZ { get; set; }
		public IfcStructuralLoadSingleDisplacement() : base()
		{
		}
		public IfcStructuralLoadSingleDisplacement(IfcLabel Name, IfcLengthMeasure DisplacementX, IfcLengthMeasure DisplacementY, IfcLengthMeasure DisplacementZ, IfcPlaneAngleMeasure RotationalDisplacementRX, IfcPlaneAngleMeasure RotationalDisplacementRY, IfcPlaneAngleMeasure RotationalDisplacementRZ) : base (Name)
		{
			this.DisplacementX = DisplacementX;
			this.DisplacementY = DisplacementY;
			this.DisplacementZ = DisplacementZ;
			this.RotationalDisplacementRX = RotationalDisplacementRX;
			this.RotationalDisplacementRY = RotationalDisplacementRY;
			this.RotationalDisplacementRZ = RotationalDisplacementRZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleDisplacementDistortion
	/// <para>ENTITY IfcStructuralLoadSingleDisplacementDistortion</para>
	/// <para>SUBTYPE OF (IfcStructuralLoadSingleDisplacement);</para>
	/// <para>Distortion : OPTIONAL IfcCurvatureMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleDisplacementDistortion : IfcStructuralLoadSingleDisplacement
	{
		public virtual IfcCurvatureMeasure? Distortion { get; set; }
		public IfcStructuralLoadSingleDisplacementDistortion() : base()
		{
		}
		public IfcStructuralLoadSingleDisplacementDistortion(IfcLabel Name, IfcLengthMeasure DisplacementX, IfcLengthMeasure DisplacementY, IfcLengthMeasure DisplacementZ, IfcPlaneAngleMeasure RotationalDisplacementRX, IfcPlaneAngleMeasure RotationalDisplacementRY, IfcPlaneAngleMeasure RotationalDisplacementRZ, IfcCurvatureMeasure Distortion) : base (Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ)
		{
			this.Distortion = Distortion;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleForce
	/// <para>ENTITY IfcStructuralLoadSingleForce</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralLoadSingleForceWarping))</para>
	/// <para>SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>ForceX : OPTIONAL IfcForceMeasure;</para>
	/// <para>ForceY : OPTIONAL IfcForceMeasure;</para>
	/// <para>ForceZ : OPTIONAL IfcForceMeasure;</para>
	/// <para>MomentX : OPTIONAL IfcTorqueMeasure;</para>
	/// <para>MomentY : OPTIONAL IfcTorqueMeasure;</para>
	/// <para>MomentZ : OPTIONAL IfcTorqueMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleForce : IfcStructuralLoadStatic
	{
		public virtual IfcForceMeasure? ForceX { get; set; }
		public virtual IfcForceMeasure? ForceY { get; set; }
		public virtual IfcForceMeasure? ForceZ { get; set; }
		public virtual IfcTorqueMeasure? MomentX { get; set; }
		public virtual IfcTorqueMeasure? MomentY { get; set; }
		public virtual IfcTorqueMeasure? MomentZ { get; set; }
		public IfcStructuralLoadSingleForce() : base()
		{
		}
		public IfcStructuralLoadSingleForce(IfcLabel Name, IfcForceMeasure ForceX, IfcForceMeasure ForceY, IfcForceMeasure ForceZ, IfcTorqueMeasure MomentX, IfcTorqueMeasure MomentY, IfcTorqueMeasure MomentZ) : base (Name)
		{
			this.ForceX = ForceX;
			this.ForceY = ForceY;
			this.ForceZ = ForceZ;
			this.MomentX = MomentX;
			this.MomentY = MomentY;
			this.MomentZ = MomentZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadSingleForceWarping
	/// <para>ENTITY IfcStructuralLoadSingleForceWarping</para>
	/// <para>SUBTYPE OF (IfcStructuralLoadSingleForce);</para>
	/// <para>WarpingMoment : OPTIONAL IfcWarpingMomentMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadSingleForceWarping : IfcStructuralLoadSingleForce
	{
		public virtual IfcWarpingMomentMeasure? WarpingMoment { get; set; }
		public IfcStructuralLoadSingleForceWarping() : base()
		{
		}
		public IfcStructuralLoadSingleForceWarping(IfcLabel Name, IfcForceMeasure ForceX, IfcForceMeasure ForceY, IfcForceMeasure ForceZ, IfcTorqueMeasure MomentX, IfcTorqueMeasure MomentY, IfcTorqueMeasure MomentZ, IfcWarpingMomentMeasure WarpingMoment) : base (Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ)
		{
			this.WarpingMoment = WarpingMoment;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadStatic
	/// <para>ENTITY IfcStructuralLoadStatic</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralLoadLinearForce</para>
	/// <para>,IfcStructuralLoadPlanarForce</para>
	/// <para>,IfcStructuralLoadSingleDisplacement</para>
	/// <para>,IfcStructuralLoadSingleForce</para>
	/// <para>,IfcStructuralLoadTemperature))</para>
	/// <para>SUBTYPE OF (IfcStructuralLoadOrResult);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralLoadStatic : IfcStructuralLoadOrResult
	{
		public IfcStructuralLoadStatic() : base()
		{
		}
		public IfcStructuralLoadStatic(IfcLabel Name) : base (Name)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralLoadTemperature
	/// <para>ENTITY IfcStructuralLoadTemperature</para>
	/// <para>SUBTYPE OF (IfcStructuralLoadStatic);</para>
	/// <para>DeltaTConstant : OPTIONAL IfcThermodynamicTemperatureMeasure;</para>
	/// <para>DeltaTY : OPTIONAL IfcThermodynamicTemperatureMeasure;</para>
	/// <para>DeltaTZ : OPTIONAL IfcThermodynamicTemperatureMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralLoadTemperature : IfcStructuralLoadStatic
	{
		public virtual IfcThermodynamicTemperatureMeasure? DeltaTConstant { get; set; }
		public virtual IfcThermodynamicTemperatureMeasure? DeltaTY { get; set; }
		public virtual IfcThermodynamicTemperatureMeasure? DeltaTZ { get; set; }
		public IfcStructuralLoadTemperature() : base()
		{
		}
		public IfcStructuralLoadTemperature(IfcLabel Name, IfcThermodynamicTemperatureMeasure DeltaTConstant, IfcThermodynamicTemperatureMeasure DeltaTY, IfcThermodynamicTemperatureMeasure DeltaTZ) : base (Name)
		{
			this.DeltaTConstant = DeltaTConstant;
			this.DeltaTY = DeltaTY;
			this.DeltaTZ = DeltaTZ;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralMember
	/// <para>ENTITY IfcStructuralMember</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralCurveMember</para>
	/// <para>,IfcStructuralSurfaceMember))</para>
	/// <para>SUBTYPE OF (IfcStructuralItem);</para>
	/// <para>INVERSE</para>
	/// <para>ConnectedBy : SET [0:?] OF IfcRelConnectsStructuralMember FOR RelatingStructuralMember;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralMember : IfcStructuralItem
	{
		//TODO INVERSE
		public List<IfcRelConnectsStructuralMember>? ConnectedBy => Model?.GetItems<IfcRelConnectsStructuralMember>().Where(x => x.RelatingStructuralMember != null && x.RelatingStructuralMember == this).ToList();
		public IfcStructuralMember() : base()
		{
		}
		public IfcStructuralMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPlanarAction
	/// <para>ENTITY IfcStructuralPlanarAction</para>
	/// <para>SUBTYPE OF (IfcStructuralSurfaceAction);</para>
	/// <para>WHERE</para>
	/// <para>SuitableLoadType : SIZEOF(['IFC4X1.IFCSTRUCTURALLOADPLANARFORCE', 'IFC4X1.IFCSTRUCTURALLOADTEMPERATURE'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>ConstPredefinedType : SELF\IfcStructuralSurfaceAction.PredefinedType = IfcStructuralSurfaceActivityTypeEnum.CONST;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPlanarAction : IfcStructuralSurfaceAction
	{
		public IfcStructuralPlanarAction() : base()
		{
		}
		public IfcStructuralPlanarAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPointAction
	/// <para>ENTITY IfcStructuralPointAction</para>
	/// <para>SUBTYPE OF (IfcStructuralAction);</para>
	/// <para>WHERE</para>
	/// <para>SuitableLoadType : SIZEOF(['IFC4X1.IFCSTRUCTURALLOADSINGLEFORCE', 'IFC4X1.IFCSTRUCTURALLOADSINGLEDISPLACEMENT'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPointAction : IfcStructuralAction
	{
		public IfcStructuralPointAction() : base()
		{
		}
		public IfcStructuralPointAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPointConnection
	/// <para>ENTITY IfcStructuralPointConnection</para>
	/// <para>SUBTYPE OF (IfcStructuralConnection);</para>
	/// <para>ConditionCoordinateSystem : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPointConnection : IfcStructuralConnection
	{
		public virtual IfcAxis2Placement3D? ConditionCoordinateSystem { get; set; }
		public IfcStructuralPointConnection() : base()
		{
		}
		public IfcStructuralPointConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition, IfcAxis2Placement3D ConditionCoordinateSystem) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
		{
			this.ConditionCoordinateSystem = ConditionCoordinateSystem;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralPointReaction
	/// <para>ENTITY IfcStructuralPointReaction</para>
	/// <para>SUBTYPE OF (IfcStructuralReaction);</para>
	/// <para>WHERE</para>
	/// <para>SuitableLoadType : SIZEOF(['IFC4X1.IFCSTRUCTURALLOADSINGLEFORCE', 'IFC4X1.IFCSTRUCTURALLOADSINGLEDISPLACEMENT'] * TYPEOF(SELF\IfcStructuralActivity.AppliedLoad)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralPointReaction : IfcStructuralReaction
	{
		public IfcStructuralPointReaction() : base()
		{
		}
		public IfcStructuralPointReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralReaction
	/// <para>ENTITY IfcStructuralReaction</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralCurveReaction</para>
	/// <para>,IfcStructuralPointReaction</para>
	/// <para>,IfcStructuralSurfaceReaction))</para>
	/// <para>SUBTYPE OF (IfcStructuralActivity);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStructuralReaction : IfcStructuralActivity
	{
		public IfcStructuralReaction() : base()
		{
		}
		public IfcStructuralReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralResultGroup
	/// <para>ENTITY IfcStructuralResultGroup</para>
	/// <para>SUBTYPE OF (IfcGroup);</para>
	/// <para>TheoryType : IfcAnalysisTheoryTypeEnum;</para>
	/// <para>ResultForLoadGroup : OPTIONAL IfcStructuralLoadGroup;</para>
	/// <para>IsLinear : IfcBoolean;</para>
	/// <para>INVERSE</para>
	/// <para>ResultGroupFor : SET [0:1] OF IfcStructuralAnalysisModel FOR HasResults;</para>
	/// <para>WHERE</para>
	/// <para>HasObjectType : (TheoryType <> IfcAnalysisTheoryTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralResultGroup : IfcGroup
	{
		public virtual IfcAnalysisTheoryTypeEnum? TheoryType { get; set; }
		public virtual IfcStructuralLoadGroup? ResultForLoadGroup { get; set; }
		public virtual IfcBoolean? IsLinear { get; set; }
		//TODO INVERSE
		public List<IfcStructuralAnalysisModel>? ResultGroupFor => Model?.GetItems<IfcStructuralAnalysisModel>().Where(x => x.HasResults != null && x.HasResults.Contains(this)).ToList();
		public IfcStructuralResultGroup() : base()
		{
		}
		public IfcStructuralResultGroup(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcAnalysisTheoryTypeEnum TheoryType, IfcStructuralLoadGroup ResultForLoadGroup, IfcBoolean IsLinear) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.TheoryType = TheoryType;
			this.ResultForLoadGroup = ResultForLoadGroup;
			this.IsLinear = IsLinear;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceAction
	/// <para>ENTITY IfcStructuralSurfaceAction</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralPlanarAction))</para>
	/// <para>SUBTYPE OF (IfcStructuralAction);</para>
	/// <para>ProjectedOrTrue : OPTIONAL IfcProjectedOrTrueLengthEnum;</para>
	/// <para>PredefinedType : IfcStructuralSurfaceActivityTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>ProjectedIsGlobal : (NOT EXISTS(ProjectedOrTrue)) OR</para>
	/// <para>((ProjectedOrTrue <> PROJECTED_LENGTH) OR</para>
	/// <para>(SELF\IfcStructuralActivity.GlobalOrLocal = GLOBAL_COORDS));</para>
	/// <para>HasObjectType : (PredefinedType <> IfcStructuralSurfaceActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceAction : IfcStructuralAction
	{
		public virtual IfcProjectedOrTrueLengthEnum? ProjectedOrTrue { get; set; }
		public virtual IfcStructuralSurfaceActivityTypeEnum? PredefinedType { get; set; }
		public IfcStructuralSurfaceAction() : base()
		{
		}
		public IfcStructuralSurfaceAction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcBoolean DestabilizingLoad, IfcProjectedOrTrueLengthEnum ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad)
		{
			this.ProjectedOrTrue = ProjectedOrTrue;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceConnection
	/// <para>ENTITY IfcStructuralSurfaceConnection</para>
	/// <para>SUBTYPE OF (IfcStructuralConnection);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceConnection : IfcStructuralConnection
	{
		public IfcStructuralSurfaceConnection() : base()
		{
		}
		public IfcStructuralSurfaceConnection(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcBoundaryCondition AppliedCondition) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceMember
	/// <para>ENTITY IfcStructuralSurfaceMember</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStructuralSurfaceMemberVarying))</para>
	/// <para>SUBTYPE OF (IfcStructuralMember);</para>
	/// <para>PredefinedType : IfcStructuralSurfaceMemberTypeEnum;</para>
	/// <para>Thickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>HasObjectType : (PredefinedType <> IfcStructuralSurfaceMemberTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceMember : IfcStructuralMember
	{
		public virtual IfcStructuralSurfaceMemberTypeEnum? PredefinedType { get; set; }
		public virtual IfcPositiveLengthMeasure? Thickness { get; set; }
		public IfcStructuralSurfaceMember() : base()
		{
		}
		public IfcStructuralSurfaceMember(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralSurfaceMemberTypeEnum PredefinedType, IfcPositiveLengthMeasure Thickness) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation)
		{
			this.PredefinedType = PredefinedType;
			this.Thickness = Thickness;
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceMemberVarying
	/// <para>ENTITY IfcStructuralSurfaceMemberVarying</para>
	/// <para>SUBTYPE OF (IfcStructuralSurfaceMember);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceMemberVarying : IfcStructuralSurfaceMember
	{
		public IfcStructuralSurfaceMemberVarying() : base()
		{
		}
		public IfcStructuralSurfaceMemberVarying(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralSurfaceMemberTypeEnum PredefinedType, IfcPositiveLengthMeasure Thickness) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStructuralSurfaceReaction
	/// <para>ENTITY IfcStructuralSurfaceReaction</para>
	/// <para>SUBTYPE OF (IfcStructuralReaction);</para>
	/// <para>PredefinedType : IfcStructuralSurfaceActivityTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>HasPredefinedType : (PredefinedType <> IfcStructuralSurfaceActivityTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStructuralSurfaceReaction : IfcStructuralReaction
	{
		public virtual IfcStructuralSurfaceActivityTypeEnum? PredefinedType { get; set; }
		public IfcStructuralSurfaceReaction() : base()
		{
		}
		public IfcStructuralSurfaceReaction(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcStructuralLoad AppliedLoad, IfcGlobalOrLocalEnum GlobalOrLocal, IfcStructuralSurfaceActivityTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcStyleModel
	/// <para>ENTITY IfcStyleModel</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcStyledRepresentation))</para>
	/// <para>SUBTYPE OF (IfcRepresentation);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcStyleModel : IfcRepresentation
	{
		public IfcStyleModel() : base()
		{
		}
		public IfcStyleModel(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcStyledItem
	/// <para>ENTITY IfcStyledItem</para>
	/// <para>SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>Item : OPTIONAL IfcRepresentationItem;</para>
	/// <para>Styles : SET [1:?] OF IfcStyleAssignmentSelect;</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>ApplicableItem : NOT('IFC4X1.IFCSTYLEDITEM' IN TYPEOF(Item));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStyledItem : IfcRepresentationItem
	{
		public virtual IfcRepresentationItem? Item { get; set; }
		public virtual List<IfcStyleAssignmentSelect>? Styles { get; set; }
		public virtual IfcLabel? Name { get; set; }
		public IfcStyledItem() : base()
		{
		}
		public IfcStyledItem(IfcRepresentationItem Item, List<IfcStyleAssignmentSelect> Styles, IfcLabel Name) : base ()
		{
			this.Item = Item;
			this.Styles = Styles;
			this.Name = Name;
		}
	}
	/// <summary>
	/// ENTITY IfcStyledRepresentation
	/// <para>ENTITY IfcStyledRepresentation</para>
	/// <para>SUBTYPE OF (IfcStyleModel);</para>
	/// <para>WHERE</para>
	/// <para>OnlyStyledItems : SIZEOF(QUERY(temp <* SELF\IfcRepresentation.Items |</para>
	/// <para>(NOT('IFC4X1.IFCSTYLEDITEM' IN TYPEOF(temp)))</para>
	/// <para>)) = 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcStyledRepresentation : IfcStyleModel
	{
		public IfcStyledRepresentation() : base()
		{
		}
		public IfcStyledRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSubContractResource
	/// <para>ENTITY IfcSubContractResource</para>
	/// <para>SUBTYPE OF (IfcConstructionResource);</para>
	/// <para>PredefinedType : OPTIONAL IfcSubContractResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcSubContractResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSubContractResourceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSubContractResource : IfcConstructionResource
	{
		public virtual IfcSubContractResourceTypeEnum? PredefinedType { get; set; }
		public IfcSubContractResource() : base()
		{
		}
		public IfcSubContractResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcResourceTime Usage, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcSubContractResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSubContractResourceType
	/// <para>ENTITY IfcSubContractResourceType</para>
	/// <para>SUBTYPE OF (IfcConstructionResourceType);</para>
	/// <para>PredefinedType : IfcSubContractResourceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcSubContractResourceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSubContractResourceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeResource.ResourceType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSubContractResourceType : IfcConstructionResourceType
	{
		public virtual IfcSubContractResourceTypeEnum? PredefinedType { get; set; }
		public IfcSubContractResourceType() : base()
		{
		}
		public IfcSubContractResourceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType, List<IfcAppliedValue> BaseCosts, IfcPhysicalQuantity BaseQuantity, IfcSubContractResourceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSubedge
	/// <para>ENTITY IfcSubedge</para>
	/// <para>SUBTYPE OF (IfcEdge);</para>
	/// <para>ParentEdge : IfcEdge;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSubedge : IfcEdge
	{
		public virtual IfcEdge? ParentEdge { get; set; }
		public IfcSubedge() : base()
		{
		}
		public IfcSubedge(IfcVertex EdgeStart, IfcVertex EdgeEnd, IfcEdge ParentEdge) : base (EdgeStart, EdgeEnd)
		{
			this.ParentEdge = ParentEdge;
		}
	}
	/// <summary>
	/// ENTITY IfcSurface
	/// <para>ENTITY IfcSurface</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBoundedSurface</para>
	/// <para>,IfcElementarySurface</para>
	/// <para>,IfcSweptSurface))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := 3;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSurface : IfcGeometricRepresentationItem, IfcGeometricSetSelect, IfcSurfaceOrFaceSurface
	{
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcSurface() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceCurve
	/// <para>ENTITY IfcSurfaceCurve</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcIntersectionCurve</para>
	/// <para>,IfcSeamCurve))</para>
	/// <para>SUBTYPE OF (IfcCurve);</para>
	/// <para>Curve3D : IfcCurve;</para>
	/// <para>AssociatedGeometry : LIST [1:2] OF IfcPcurve;</para>
	/// <para>MasterRepresentation : IfcPreferredSurfaceCurveRepresentation;</para>
	/// <para>DERIVE</para>
	/// <para>BasisSurface : SET [1:2] OF IfcSurface := IfcGetBasisSurface(SELF);</para>
	/// <para>WHERE</para>
	/// <para>CurveIs3D : Curve3D.Dim = 3;</para>
	/// <para>CurveIsNotPcurve : NOT ('IFC4X1.IFCPCURVE' IN TYPEOF(Curve3D));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceCurve : IfcCurve, IfcCurveOnSurface
	{
		public virtual IfcCurve? Curve3D { get; set; }
		public virtual List<IfcPcurve>? AssociatedGeometry { get; set; }
		public virtual IfcPreferredSurfaceCurveRepresentation? MasterRepresentation { get; set; }
		//TODO DERIVE
		public virtual List<IfcSurface>? BasisSurface {get {return null;}}
		public IfcSurfaceCurve() : base()
		{
		}
		public IfcSurfaceCurve(IfcCurve Curve3D, List<IfcPcurve> AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation MasterRepresentation) : base ()
		{
			this.Curve3D = Curve3D;
			this.AssociatedGeometry = AssociatedGeometry;
			this.MasterRepresentation = MasterRepresentation;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceCurveSweptAreaSolid
	/// <para>ENTITY IfcSurfaceCurveSweptAreaSolid</para>
	/// <para>SUBTYPE OF (IfcSweptAreaSolid);</para>
	/// <para>Directrix : IfcCurve;</para>
	/// <para>StartParam : OPTIONAL IfcParameterValue;</para>
	/// <para>EndParam : OPTIONAL IfcParameterValue;</para>
	/// <para>ReferenceSurface : IfcSurface;</para>
	/// <para>WHERE</para>
	/// <para>DirectrixBounded : (EXISTS(StartParam) AND EXISTS(EndParam)) OR</para>
	/// <para>(SIZEOF(['IFC4X1.IFCCONIC', 'IFC4X1.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceCurveSweptAreaSolid : IfcSweptAreaSolid
	{
		public virtual IfcCurve? Directrix { get; set; }
		public virtual IfcParameterValue? StartParam { get; set; }
		public virtual IfcParameterValue? EndParam { get; set; }
		public virtual IfcSurface? ReferenceSurface { get; set; }
		public IfcSurfaceCurveSweptAreaSolid() : base()
		{
		}
		public IfcSurfaceCurveSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position, IfcCurve Directrix, IfcParameterValue StartParam, IfcParameterValue EndParam, IfcSurface ReferenceSurface) : base (SweptArea, Position)
		{
			this.Directrix = Directrix;
			this.StartParam = StartParam;
			this.EndParam = EndParam;
			this.ReferenceSurface = ReferenceSurface;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceFeature
	/// <para>ENTITY IfcSurfaceFeature</para>
	/// <para>SUBTYPE OF (IfcFeatureElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcSurfaceFeatureTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>HasObjectType : NOT EXISTS(PredefinedType) OR (PredefinedType <> IfcSurfaceFeatureTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceFeature : IfcFeatureElement
	{
		public virtual IfcSurfaceFeatureTypeEnum? PredefinedType { get; set; }
		public IfcSurfaceFeature() : base()
		{
		}
		public IfcSurfaceFeature(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSurfaceFeatureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceOfLinearExtrusion
	/// <para>ENTITY IfcSurfaceOfLinearExtrusion</para>
	/// <para>SUBTYPE OF (IfcSweptSurface);</para>
	/// <para>ExtrudedDirection : IfcDirection;</para>
	/// <para>Depth : IfcLengthMeasure;</para>
	/// <para>DERIVE</para>
	/// <para>ExtrusionAxis : IfcVector := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector (ExtrudedDirection, Depth);</para>
	/// <para>WHERE</para>
	/// <para>DepthGreaterZero : Depth > 0.;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceOfLinearExtrusion : IfcSweptSurface
	{
		public virtual IfcDirection? ExtrudedDirection { get; set; }
		public virtual IfcLengthMeasure? Depth { get; set; }
		//TODO DERIVE
		public virtual IfcVector? ExtrusionAxis {get {return null;}}
		public IfcSurfaceOfLinearExtrusion() : base()
		{
		}
		public IfcSurfaceOfLinearExtrusion(IfcProfileDef SweptCurve, IfcAxis2Placement3D Position, IfcDirection ExtrudedDirection, IfcLengthMeasure Depth) : base (SweptCurve, Position)
		{
			this.ExtrudedDirection = ExtrudedDirection;
			this.Depth = Depth;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceOfRevolution
	/// <para>ENTITY IfcSurfaceOfRevolution</para>
	/// <para>SUBTYPE OF (IfcSweptSurface);</para>
	/// <para>AxisPosition : IfcAxis1Placement;</para>
	/// <para>DERIVE</para>
	/// <para>AxisLine : IfcLine := IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcCurve() || IfcLine(AxisPosition.Location,</para>
	/// <para>IfcRepresentationItem() || IfcGeometricRepresentationItem () || IfcVector(AxisPosition.Z,1.0));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceOfRevolution : IfcSweptSurface
	{
		public virtual IfcAxis1Placement? AxisPosition { get; set; }
		//TODO DERIVE
		public virtual IfcLine? AxisLine {get {return null;}}
		public IfcSurfaceOfRevolution() : base()
		{
		}
		public IfcSurfaceOfRevolution(IfcProfileDef SweptCurve, IfcAxis2Placement3D Position, IfcAxis1Placement AxisPosition) : base (SweptCurve, Position)
		{
			this.AxisPosition = AxisPosition;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceReinforcementArea
	/// <para>ENTITY IfcSurfaceReinforcementArea</para>
	/// <para>SUBTYPE OF (IfcStructuralLoadOrResult);</para>
	/// <para>SurfaceReinforcement1 : OPTIONAL LIST [2:3] OF IfcLengthMeasure;</para>
	/// <para>SurfaceReinforcement2 : OPTIONAL LIST [2:3] OF IfcLengthMeasure;</para>
	/// <para>ShearReinforcement : OPTIONAL IfcRatioMeasure;</para>
	/// <para>WHERE</para>
	/// <para>SurfaceAndOrShearAreaSpecified : EXISTS(SurfaceReinforcement1) OR EXISTS(SurfaceReinforcement2) OR EXISTS(ShearReinforcement);</para>
	/// <para>NonnegativeArea1 : (NOT EXISTS(SurfaceReinforcement1)) OR (</para>
	/// <para>(SurfaceReinforcement1[1] >= 0.) AND</para>
	/// <para>(SurfaceReinforcement1[2] >= 0.) AND</para>
	/// <para>((SIZEOF(SurfaceReinforcement1) = 1) OR (SurfaceReinforcement1[1] >= 0.))</para>
	/// <para>);</para>
	/// <para>NonnegativeArea2 : (NOT EXISTS(SurfaceReinforcement2)) OR (</para>
	/// <para>(SurfaceReinforcement2[1] >= 0.) AND</para>
	/// <para>(SurfaceReinforcement2[2] >= 0.) AND</para>
	/// <para>((SIZEOF(SurfaceReinforcement2) = 1) OR (SurfaceReinforcement2[1] >= 0.))</para>
	/// <para>);</para>
	/// <para>NonnegativeArea3 : (NOT EXISTS(ShearReinforcement)) OR (ShearReinforcement >= 0.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceReinforcementArea : IfcStructuralLoadOrResult
	{
		public virtual List<IfcLengthMeasure>? SurfaceReinforcement1 { get; set; }
		public virtual List<IfcLengthMeasure>? SurfaceReinforcement2 { get; set; }
		public virtual IfcRatioMeasure? ShearReinforcement { get; set; }
		public IfcSurfaceReinforcementArea() : base()
		{
		}
		public IfcSurfaceReinforcementArea(IfcLabel Name, List<IfcLengthMeasure> SurfaceReinforcement1, List<IfcLengthMeasure> SurfaceReinforcement2, IfcRatioMeasure ShearReinforcement) : base (Name)
		{
			this.SurfaceReinforcement1 = SurfaceReinforcement1;
			this.SurfaceReinforcement2 = SurfaceReinforcement2;
			this.ShearReinforcement = ShearReinforcement;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyle
	/// <para>ENTITY IfcSurfaceStyle</para>
	/// <para>SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>Side : IfcSurfaceSide;</para>
	/// <para>Styles : SET [1:5] OF IfcSurfaceStyleElementSelect;</para>
	/// <para>WHERE</para>
	/// <para>MaxOneShading : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>'IFC4X1.IFCSURFACESTYLESHADING' IN</para>
	/// <para>TYPEOF(Style)</para>
	/// <para>)) <= 1;</para>
	/// <para>MaxOneLighting : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>'IFC4X1.IFCSURFACESTYLELIGHTING' IN</para>
	/// <para>TYPEOF(Style)</para>
	/// <para>)) <= 1;</para>
	/// <para>MaxOneRefraction : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>'IFC4X1.IFCSURFACESTYLEREFRACTION' IN</para>
	/// <para>TYPEOF(Style)</para>
	/// <para>)) <= 1;</para>
	/// <para>MaxOneTextures : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>'IFC4X1.IFCSURFACESTYLEWITHTEXTURES' IN</para>
	/// <para>TYPEOF(Style)</para>
	/// <para>)) <= 1;</para>
	/// <para>MaxOneExtDefined : SIZEOF(QUERY(Style <* SELF.Styles |</para>
	/// <para>'IFC4X1.IFCEXTERNALLYDEFINEDSURFACESTYLE' IN</para>
	/// <para>TYPEOF(Style)</para>
	/// <para>)) <= 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyle : IfcPresentationStyle, IfcPresentationStyleSelect
	{
		public virtual IfcSurfaceSide? Side { get; set; }
		public virtual List<IfcSurfaceStyleElementSelect>? Styles { get; set; }
		public IfcSurfaceStyle() : base()
		{
		}
		public IfcSurfaceStyle(IfcLabel Name, IfcSurfaceSide Side, List<IfcSurfaceStyleElementSelect> Styles) : base (Name)
		{
			this.Side = Side;
			this.Styles = Styles;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleLighting
	/// <para>ENTITY IfcSurfaceStyleLighting</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>DiffuseTransmissionColour : IfcColourRgb;</para>
	/// <para>DiffuseReflectionColour : IfcColourRgb;</para>
	/// <para>TransmissionColour : IfcColourRgb;</para>
	/// <para>ReflectanceColour : IfcColourRgb;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleLighting : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public virtual IfcColourRgb? DiffuseTransmissionColour { get; set; }
		public virtual IfcColourRgb? DiffuseReflectionColour { get; set; }
		public virtual IfcColourRgb? TransmissionColour { get; set; }
		public virtual IfcColourRgb? ReflectanceColour { get; set; }
		public IfcSurfaceStyleLighting() : base()
		{
		}
		public IfcSurfaceStyleLighting(IfcColourRgb DiffuseTransmissionColour, IfcColourRgb DiffuseReflectionColour, IfcColourRgb TransmissionColour, IfcColourRgb ReflectanceColour) : base ()
		{
			this.DiffuseTransmissionColour = DiffuseTransmissionColour;
			this.DiffuseReflectionColour = DiffuseReflectionColour;
			this.TransmissionColour = TransmissionColour;
			this.ReflectanceColour = ReflectanceColour;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleRefraction
	/// <para>ENTITY IfcSurfaceStyleRefraction</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>RefractionIndex : OPTIONAL IfcReal;</para>
	/// <para>DispersionFactor : OPTIONAL IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleRefraction : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public virtual IfcReal? RefractionIndex { get; set; }
		public virtual IfcReal? DispersionFactor { get; set; }
		public IfcSurfaceStyleRefraction() : base()
		{
		}
		public IfcSurfaceStyleRefraction(IfcReal RefractionIndex, IfcReal DispersionFactor) : base ()
		{
			this.RefractionIndex = RefractionIndex;
			this.DispersionFactor = DispersionFactor;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleRendering
	/// <para>ENTITY IfcSurfaceStyleRendering</para>
	/// <para>SUBTYPE OF (IfcSurfaceStyleShading);</para>
	/// <para>DiffuseColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>TransmissionColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>DiffuseTransmissionColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>ReflectionColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>SpecularColour : OPTIONAL IfcColourOrFactor;</para>
	/// <para>SpecularHighlight : OPTIONAL IfcSpecularHighlightSelect;</para>
	/// <para>ReflectanceMethod : IfcReflectanceMethodEnum;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleRendering : IfcSurfaceStyleShading
	{
		public virtual IfcColourOrFactor? DiffuseColour { get; set; }
		public virtual IfcColourOrFactor? TransmissionColour { get; set; }
		public virtual IfcColourOrFactor? DiffuseTransmissionColour { get; set; }
		public virtual IfcColourOrFactor? ReflectionColour { get; set; }
		public virtual IfcColourOrFactor? SpecularColour { get; set; }
		public virtual IfcSpecularHighlightSelect? SpecularHighlight { get; set; }
		public virtual IfcReflectanceMethodEnum? ReflectanceMethod { get; set; }
		public IfcSurfaceStyleRendering() : base()
		{
		}
		public IfcSurfaceStyleRendering(IfcColourRgb SurfaceColour, IfcNormalisedRatioMeasure Transparency, IfcColourOrFactor DiffuseColour, IfcColourOrFactor TransmissionColour, IfcColourOrFactor DiffuseTransmissionColour, IfcColourOrFactor ReflectionColour, IfcColourOrFactor SpecularColour, IfcSpecularHighlightSelect SpecularHighlight, IfcReflectanceMethodEnum ReflectanceMethod) : base (SurfaceColour, Transparency)
		{
			this.DiffuseColour = DiffuseColour;
			this.TransmissionColour = TransmissionColour;
			this.DiffuseTransmissionColour = DiffuseTransmissionColour;
			this.ReflectionColour = ReflectionColour;
			this.SpecularColour = SpecularColour;
			this.SpecularHighlight = SpecularHighlight;
			this.ReflectanceMethod = ReflectanceMethod;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleShading
	/// <para>ENTITY IfcSurfaceStyleShading</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcSurfaceStyleRendering))</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>SurfaceColour : IfcColourRgb;</para>
	/// <para>Transparency : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleShading : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public virtual IfcColourRgb? SurfaceColour { get; set; }
		public virtual IfcNormalisedRatioMeasure? Transparency { get; set; }
		public IfcSurfaceStyleShading() : base()
		{
		}
		public IfcSurfaceStyleShading(IfcColourRgb SurfaceColour, IfcNormalisedRatioMeasure Transparency) : base ()
		{
			this.SurfaceColour = SurfaceColour;
			this.Transparency = Transparency;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceStyleWithTextures
	/// <para>ENTITY IfcSurfaceStyleWithTextures</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>Textures : LIST [1:?] OF IfcSurfaceTexture;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSurfaceStyleWithTextures : IfcPresentationItem, IfcSurfaceStyleElementSelect
	{
		public virtual List<IfcSurfaceTexture>? Textures { get; set; }
		public IfcSurfaceStyleWithTextures() : base()
		{
		}
		public IfcSurfaceStyleWithTextures(List<IfcSurfaceTexture> Textures) : base ()
		{
			this.Textures = Textures;
		}
	}
	/// <summary>
	/// ENTITY IfcSurfaceTexture
	/// <para>ENTITY IfcSurfaceTexture</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBlobTexture</para>
	/// <para>,IfcImageTexture</para>
	/// <para>,IfcPixelTexture))</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>RepeatS : IfcBoolean;</para>
	/// <para>RepeatT : IfcBoolean;</para>
	/// <para>Mode : OPTIONAL IfcIdentifier;</para>
	/// <para>TextureTransform : OPTIONAL IfcCartesianTransformationOperator2D;</para>
	/// <para>Parameter : OPTIONAL LIST [1:?] OF IfcIdentifier;</para>
	/// <para>INVERSE</para>
	/// <para>IsMappedBy : SET [0:?] OF IfcTextureCoordinate FOR Maps;</para>
	/// <para>UsedInStyles : SET [0:?] OF IfcSurfaceStyleWithTextures FOR Textures;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSurfaceTexture : IfcPresentationItem
	{
		public virtual IfcBoolean? RepeatS { get; set; }
		public virtual IfcBoolean? RepeatT { get; set; }
		public virtual IfcIdentifier? Mode { get; set; }
		public virtual IfcCartesianTransformationOperator2D? TextureTransform { get; set; }
		public virtual List<IfcIdentifier>? Parameter { get; set; }
		//TODO INVERSE
		public List<IfcTextureCoordinate>? IsMappedBy => Model?.GetItems<IfcTextureCoordinate>().Where(x => x.Maps != null && x.Maps.Contains(this)).ToList();
		//TODO INVERSE
		public List<IfcSurfaceStyleWithTextures>? UsedInStyles => Model?.GetItems<IfcSurfaceStyleWithTextures>().Where(x => x.Textures != null && x.Textures.Contains(this)).ToList();
		public IfcSurfaceTexture() : base()
		{
		}
		public IfcSurfaceTexture(IfcBoolean RepeatS, IfcBoolean RepeatT, IfcIdentifier Mode, IfcCartesianTransformationOperator2D TextureTransform, List<IfcIdentifier> Parameter) : base ()
		{
			this.RepeatS = RepeatS;
			this.RepeatT = RepeatT;
			this.Mode = Mode;
			this.TextureTransform = TextureTransform;
			this.Parameter = Parameter;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptAreaSolid
	/// <para>ENTITY IfcSweptAreaSolid</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcExtrudedAreaSolid</para>
	/// <para>,IfcFixedReferenceSweptAreaSolid</para>
	/// <para>,IfcRevolvedAreaSolid</para>
	/// <para>,IfcSurfaceCurveSweptAreaSolid))</para>
	/// <para>SUBTYPE OF (IfcSolidModel);</para>
	/// <para>SweptArea : IfcProfileDef;</para>
	/// <para>Position : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>WHERE</para>
	/// <para>SweptAreaType : SweptArea.ProfileType = IfcProfileTypeEnum.Area;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSweptAreaSolid : IfcSolidModel
	{
		public virtual IfcProfileDef? SweptArea { get; set; }
		public virtual IfcAxis2Placement3D? Position { get; set; }
		public IfcSweptAreaSolid() : base()
		{
		}
		public IfcSweptAreaSolid(IfcProfileDef SweptArea, IfcAxis2Placement3D Position) : base ()
		{
			this.SweptArea = SweptArea;
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptDiskSolid
	/// <para>ENTITY IfcSweptDiskSolid</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcSweptDiskSolidPolygonal))</para>
	/// <para>SUBTYPE OF (IfcSolidModel);</para>
	/// <para>Directrix : IfcCurve;</para>
	/// <para>Radius : IfcPositiveLengthMeasure;</para>
	/// <para>InnerRadius : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>StartParam : OPTIONAL IfcParameterValue;</para>
	/// <para>EndParam : OPTIONAL IfcParameterValue;</para>
	/// <para>WHERE</para>
	/// <para>DirectrixDim : Directrix.Dim = 3;</para>
	/// <para>InnerRadiusSize : (NOT EXISTS(InnerRadius)) OR (Radius > InnerRadius);</para>
	/// <para>DirectrixBounded : (EXISTS(StartParam) AND EXISTS(EndParam)) OR</para>
	/// <para>(SIZEOF(['IFC4X1.IFCCONIC', 'IFC4X1.IFCBOUNDEDCURVE'] * TYPEOF(Directrix)) = 1);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSweptDiskSolid : IfcSolidModel
	{
		public virtual IfcCurve? Directrix { get; set; }
		public virtual IfcPositiveLengthMeasure? Radius { get; set; }
		public virtual IfcPositiveLengthMeasure? InnerRadius { get; set; }
		public virtual IfcParameterValue? StartParam { get; set; }
		public virtual IfcParameterValue? EndParam { get; set; }
		public IfcSweptDiskSolid() : base()
		{
		}
		public IfcSweptDiskSolid(IfcCurve Directrix, IfcPositiveLengthMeasure Radius, IfcPositiveLengthMeasure InnerRadius, IfcParameterValue StartParam, IfcParameterValue EndParam) : base ()
		{
			this.Directrix = Directrix;
			this.Radius = Radius;
			this.InnerRadius = InnerRadius;
			this.StartParam = StartParam;
			this.EndParam = EndParam;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptDiskSolidPolygonal
	/// <para>ENTITY IfcSweptDiskSolidPolygonal</para>
	/// <para>SUBTYPE OF (IfcSweptDiskSolid);</para>
	/// <para>FilletRadius : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>CorrectRadii : NOT(EXISTS(FilletRadius)) OR (FilletRadius >= SELF\IfcSweptDiskSolid.Radius);</para>
	/// <para>DirectrixIsPolyline : ('IFC4X1.IFCPOLYLINE' IN TYPEOF(SELF\IfcSweptDiskSolid.Directrix)) OR</para>
	/// <para>(('IFC4X1.IFCINDEXEDPOLYCURVE' IN TYPEOF(SELF\IfcSweptDiskSolid.Directrix)) AND NOT(EXISTS(SELF\IfcSweptDiskSolid.Directrix.Segments)));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSweptDiskSolidPolygonal : IfcSweptDiskSolid
	{
		public virtual IfcPositiveLengthMeasure? FilletRadius { get; set; }
		public IfcSweptDiskSolidPolygonal() : base()
		{
		}
		public IfcSweptDiskSolidPolygonal(IfcCurve Directrix, IfcPositiveLengthMeasure Radius, IfcPositiveLengthMeasure InnerRadius, IfcParameterValue StartParam, IfcParameterValue EndParam, IfcPositiveLengthMeasure FilletRadius) : base (Directrix, Radius, InnerRadius, StartParam, EndParam)
		{
			this.FilletRadius = FilletRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcSweptSurface
	/// <para>ENTITY IfcSweptSurface</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcSurfaceOfLinearExtrusion</para>
	/// <para>,IfcSurfaceOfRevolution))</para>
	/// <para>SUBTYPE OF (IfcSurface);</para>
	/// <para>SweptCurve : IfcProfileDef;</para>
	/// <para>Position : OPTIONAL IfcAxis2Placement3D;</para>
	/// <para>WHERE</para>
	/// <para>SweptCurveType : SweptCurve.ProfileType = IfcProfileTypeEnum.Curve;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcSweptSurface : IfcSurface
	{
		public virtual IfcProfileDef? SweptCurve { get; set; }
		public virtual IfcAxis2Placement3D? Position { get; set; }
		public IfcSweptSurface() : base()
		{
		}
		public IfcSweptSurface(IfcProfileDef SweptCurve, IfcAxis2Placement3D Position) : base ()
		{
			this.SweptCurve = SweptCurve;
			this.Position = Position;
		}
	}
	/// <summary>
	/// ENTITY IfcSwitchingDevice
	/// <para>ENTITY IfcSwitchingDevice</para>
	/// <para>SUBTYPE OF (IfcFlowController);</para>
	/// <para>PredefinedType : OPTIONAL IfcSwitchingDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcSwitchingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSwitchingDeviceTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSWITCHINGDEVICETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSwitchingDevice : IfcFlowController
	{
		public virtual IfcSwitchingDeviceTypeEnum? PredefinedType { get; set; }
		public IfcSwitchingDevice() : base()
		{
		}
		public IfcSwitchingDevice(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSwitchingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSwitchingDeviceType
	/// <para>ENTITY IfcSwitchingDeviceType</para>
	/// <para>SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>PredefinedType : IfcSwitchingDeviceTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcSwitchingDeviceTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSwitchingDeviceTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSwitchingDeviceType : IfcFlowControllerType
	{
		public virtual IfcSwitchingDeviceTypeEnum? PredefinedType { get; set; }
		public IfcSwitchingDeviceType() : base()
		{
		}
		public IfcSwitchingDeviceType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSwitchingDeviceTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSystem
	/// <para>ENTITY IfcSystem</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcBuildingSystem</para>
	/// <para>,IfcDistributionSystem</para>
	/// <para>,IfcStructuralAnalysisModel</para>
	/// <para>,IfcZone))</para>
	/// <para>SUBTYPE OF (IfcGroup);</para>
	/// <para>INVERSE</para>
	/// <para>ServicesBuildings : SET [0:1] OF IfcRelServicesBuildings FOR RelatingSystem;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSystem : IfcGroup
	{
		//TODO INVERSE
		public List<IfcRelServicesBuildings>? ServicesBuildings => Model?.GetItems<IfcRelServicesBuildings>().Where(x => x.RelatingSystem != null && x.RelatingSystem == this).ToList();
		public IfcSystem() : base()
		{
		}
		public IfcSystem(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcSystemFurnitureElement
	/// <para>ENTITY IfcSystemFurnitureElement</para>
	/// <para>SUBTYPE OF (IfcFurnishingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcSystemFurnitureElementTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcSystemFurnitureElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSystemFurnitureElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCSYSTEMFURNITUREELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSystemFurnitureElement : IfcFurnishingElement
	{
		public virtual IfcSystemFurnitureElementTypeEnum? PredefinedType { get; set; }
		public IfcSystemFurnitureElement() : base()
		{
		}
		public IfcSystemFurnitureElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcSystemFurnitureElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcSystemFurnitureElementType
	/// <para>ENTITY IfcSystemFurnitureElementType</para>
	/// <para>SUBTYPE OF (IfcFurnishingElementType);</para>
	/// <para>PredefinedType : OPTIONAL IfcSystemFurnitureElementTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcSystemFurnitureElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcSystemFurnitureElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcSystemFurnitureElementType : IfcFurnishingElementType
	{
		public virtual IfcSystemFurnitureElementTypeEnum? PredefinedType { get; set; }
		public IfcSystemFurnitureElementType() : base()
		{
		}
		public IfcSystemFurnitureElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcSystemFurnitureElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTShapeProfileDef
	/// <para>ENTITY IfcTShapeProfileDef</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>Depth : IfcPositiveLengthMeasure;</para>
	/// <para>FlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>FlangeEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>WebEdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>WebSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>FlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidFlangeThickness : FlangeThickness < Depth;</para>
	/// <para>ValidWebThickness : WebThickness < FlangeWidth;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTShapeProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? Depth { get; set; }
		public virtual IfcPositiveLengthMeasure? FlangeWidth { get; set; }
		public virtual IfcPositiveLengthMeasure? WebThickness { get; set; }
		public virtual IfcPositiveLengthMeasure? FlangeThickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public virtual IfcNonNegativeLengthMeasure? FlangeEdgeRadius { get; set; }
		public virtual IfcNonNegativeLengthMeasure? WebEdgeRadius { get; set; }
		public virtual IfcPlaneAngleMeasure? WebSlope { get; set; }
		public virtual IfcPlaneAngleMeasure? FlangeSlope { get; set; }
		public IfcTShapeProfileDef() : base()
		{
		}
		public IfcTShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure FlangeWidth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure FlangeEdgeRadius, IfcNonNegativeLengthMeasure WebEdgeRadius, IfcPlaneAngleMeasure WebSlope, IfcPlaneAngleMeasure FlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.FlangeWidth = FlangeWidth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.FlangeEdgeRadius = FlangeEdgeRadius;
			this.WebEdgeRadius = WebEdgeRadius;
			this.WebSlope = WebSlope;
			this.FlangeSlope = FlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcTable;
	/// <para>ENTITY IfcTable;</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Rows : OPTIONAL LIST [1:?] OF IfcTableRow;</para>
	/// <para>Columns : OPTIONAL LIST [1:?] OF IfcTableColumn;</para>
	/// <para>DERIVE</para>
	/// <para>NumberOfCellsInRow : IfcInteger := HIINDEX(Rows[1].RowCells);</para>
	/// <para>NumberOfHeadings : IfcInteger := SIZEOF(QUERY( Temp <* Rows | Temp.IsHeading));</para>
	/// <para>NumberOfDataRows : IfcInteger := SIZEOF(QUERY( Temp <* Rows | NOT(Temp.IsHeading)));</para>
	/// <para>WHERE</para>
	/// <para>WR1 : SIZEOF(QUERY( Temp <* Rows | HIINDEX(Temp.RowCells) <> HIINDEX(Rows[1].RowCells))) = 0;</para>
	/// <para>WR2 : { 0 <= NumberOfHeadings <= 1 };</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTable : Entity, IfcMetricValueSelect, IfcObjectReferenceSelect
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual List<IfcTableRow>? Rows { get; set; }
		public virtual List<IfcTableColumn>? Columns { get; set; }
		//TODO DERIVE
		public virtual IfcInteger? NumberOfCellsInRow {get {return null;}}
		//TODO DERIVE
		public virtual IfcInteger? NumberOfHeadings {get {return null;}}
		//TODO DERIVE
		public virtual IfcInteger? NumberOfDataRows {get {return null;}}
		public IfcTable() : base()
		{
		}
		public IfcTable(IfcLabel Name, List<IfcTableRow> Rows, List<IfcTableColumn> Columns) : base ()
		{
			this.Name = Name;
			this.Rows = Rows;
			this.Columns = Columns;
		}
	}
	/// <summary>
	/// ENTITY IfcTableColumn;
	/// <para>ENTITY IfcTableColumn;</para>
	/// <para>Identifier : OPTIONAL IfcIdentifier;</para>
	/// <para>Name : OPTIONAL IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>Unit : OPTIONAL IfcUnit;</para>
	/// <para>ReferencePath : OPTIONAL IfcReference;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTableColumn : Entity
	{
		public virtual IfcIdentifier? Identifier { get; set; }
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcUnit? Unit { get; set; }
		public virtual IfcReference? ReferencePath { get; set; }
		public IfcTableColumn() : base()
		{
		}
		public IfcTableColumn(IfcIdentifier Identifier, IfcLabel Name, IfcText Description, IfcUnit Unit, IfcReference ReferencePath) : base ()
		{
			this.Identifier = Identifier;
			this.Name = Name;
			this.Description = Description;
			this.Unit = Unit;
			this.ReferencePath = ReferencePath;
		}
	}
	/// <summary>
	/// ENTITY IfcTableRow;
	/// <para>ENTITY IfcTableRow;</para>
	/// <para>RowCells : OPTIONAL LIST [1:?] OF IfcValue;</para>
	/// <para>IsHeading : OPTIONAL IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTableRow : Entity
	{
		public virtual List<IfcValue>? RowCells { get; set; }
		public virtual IfcBoolean? IsHeading { get; set; }
		public IfcTableRow() : base()
		{
		}
		public IfcTableRow(List<IfcValue> RowCells, IfcBoolean IsHeading) : base ()
		{
			this.RowCells = RowCells;
			this.IsHeading = IsHeading;
		}
	}
	/// <summary>
	/// ENTITY IfcTank
	/// <para>ENTITY IfcTank</para>
	/// <para>SUBTYPE OF (IfcFlowStorageDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcTankTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcTankTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTankTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCTANKTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTank : IfcFlowStorageDevice
	{
		public virtual IfcTankTypeEnum? PredefinedType { get; set; }
		public IfcTank() : base()
		{
		}
		public IfcTank(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTankTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTankType
	/// <para>ENTITY IfcTankType</para>
	/// <para>SUBTYPE OF (IfcFlowStorageDeviceType);</para>
	/// <para>PredefinedType : IfcTankTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcTankTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTankTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTankType : IfcFlowStorageDeviceType
	{
		public virtual IfcTankTypeEnum? PredefinedType { get; set; }
		public IfcTankType() : base()
		{
		}
		public IfcTankType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTankTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTask
	/// <para>ENTITY IfcTask</para>
	/// <para>SUBTYPE OF (IfcProcess);</para>
	/// <para>Status : OPTIONAL IfcLabel;</para>
	/// <para>WorkMethod : OPTIONAL IfcLabel;</para>
	/// <para>IsMilestone : IfcBoolean;</para>
	/// <para>Priority : OPTIONAL IfcInteger;</para>
	/// <para>TaskTime : OPTIONAL IfcTaskTime;</para>
	/// <para>PredefinedType : OPTIONAL IfcTaskTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>HasName : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcTaskTypeEnum.USERDEFINED) OR ((PredefinedType = IfcTaskTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTask : IfcProcess
	{
		public virtual IfcLabel? Status { get; set; }
		public virtual IfcLabel? WorkMethod { get; set; }
		public virtual IfcBoolean? IsMilestone { get; set; }
		public virtual IfcInteger? Priority { get; set; }
		public virtual IfcTaskTime? TaskTime { get; set; }
		public virtual IfcTaskTypeEnum? PredefinedType { get; set; }
		public IfcTask() : base()
		{
		}
		public IfcTask(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcText LongDescription, IfcLabel Status, IfcLabel WorkMethod, IfcBoolean IsMilestone, IfcInteger Priority, IfcTaskTime TaskTime, IfcTaskTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription)
		{
			this.Status = Status;
			this.WorkMethod = WorkMethod;
			this.IsMilestone = IsMilestone;
			this.Priority = Priority;
			this.TaskTime = TaskTime;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTaskTime
	/// <para>ENTITY IfcTaskTime</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcTaskTimeRecurring))</para>
	/// <para>SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>DurationType : OPTIONAL IfcTaskDurationEnum;</para>
	/// <para>ScheduleDuration : OPTIONAL IfcDuration;</para>
	/// <para>ScheduleStart : OPTIONAL IfcDateTime;</para>
	/// <para>ScheduleFinish : OPTIONAL IfcDateTime;</para>
	/// <para>EarlyStart : OPTIONAL IfcDateTime;</para>
	/// <para>EarlyFinish : OPTIONAL IfcDateTime;</para>
	/// <para>LateStart : OPTIONAL IfcDateTime;</para>
	/// <para>LateFinish : OPTIONAL IfcDateTime;</para>
	/// <para>FreeFloat : OPTIONAL IfcDuration;</para>
	/// <para>TotalFloat : OPTIONAL IfcDuration;</para>
	/// <para>IsCritical : OPTIONAL IfcBoolean;</para>
	/// <para>StatusTime : OPTIONAL IfcDateTime;</para>
	/// <para>ActualDuration : OPTIONAL IfcDuration;</para>
	/// <para>ActualStart : OPTIONAL IfcDateTime;</para>
	/// <para>ActualFinish : OPTIONAL IfcDateTime;</para>
	/// <para>RemainingTime : OPTIONAL IfcDuration;</para>
	/// <para>Completion : OPTIONAL IfcPositiveRatioMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTaskTime : IfcSchedulingTime
	{
		public virtual IfcTaskDurationEnum? DurationType { get; set; }
		public virtual IfcDuration? ScheduleDuration { get; set; }
		public virtual IfcDateTime? ScheduleStart { get; set; }
		public virtual IfcDateTime? ScheduleFinish { get; set; }
		public virtual IfcDateTime? EarlyStart { get; set; }
		public virtual IfcDateTime? EarlyFinish { get; set; }
		public virtual IfcDateTime? LateStart { get; set; }
		public virtual IfcDateTime? LateFinish { get; set; }
		public virtual IfcDuration? FreeFloat { get; set; }
		public virtual IfcDuration? TotalFloat { get; set; }
		public virtual IfcBoolean? IsCritical { get; set; }
		public virtual IfcDateTime? StatusTime { get; set; }
		public virtual IfcDuration? ActualDuration { get; set; }
		public virtual IfcDateTime? ActualStart { get; set; }
		public virtual IfcDateTime? ActualFinish { get; set; }
		public virtual IfcDuration? RemainingTime { get; set; }
		public virtual IfcPositiveRatioMeasure? Completion { get; set; }
		public IfcTaskTime() : base()
		{
		}
		public IfcTaskTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcTaskDurationEnum DurationType, IfcDuration ScheduleDuration, IfcDateTime ScheduleStart, IfcDateTime ScheduleFinish, IfcDateTime EarlyStart, IfcDateTime EarlyFinish, IfcDateTime LateStart, IfcDateTime LateFinish, IfcDuration FreeFloat, IfcDuration TotalFloat, IfcBoolean IsCritical, IfcDateTime StatusTime, IfcDuration ActualDuration, IfcDateTime ActualStart, IfcDateTime ActualFinish, IfcDuration RemainingTime, IfcPositiveRatioMeasure Completion) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.DurationType = DurationType;
			this.ScheduleDuration = ScheduleDuration;
			this.ScheduleStart = ScheduleStart;
			this.ScheduleFinish = ScheduleFinish;
			this.EarlyStart = EarlyStart;
			this.EarlyFinish = EarlyFinish;
			this.LateStart = LateStart;
			this.LateFinish = LateFinish;
			this.FreeFloat = FreeFloat;
			this.TotalFloat = TotalFloat;
			this.IsCritical = IsCritical;
			this.StatusTime = StatusTime;
			this.ActualDuration = ActualDuration;
			this.ActualStart = ActualStart;
			this.ActualFinish = ActualFinish;
			this.RemainingTime = RemainingTime;
			this.Completion = Completion;
		}
	}
	/// <summary>
	/// ENTITY IfcTaskTimeRecurring
	/// <para>ENTITY IfcTaskTimeRecurring</para>
	/// <para>SUBTYPE OF (IfcTaskTime);</para>
	/// <para>Recurrence : IfcRecurrencePattern;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTaskTimeRecurring : IfcTaskTime
	{
		public virtual IfcRecurrencePattern? Recurrence { get; set; }
		public IfcTaskTimeRecurring() : base()
		{
		}
		public IfcTaskTimeRecurring(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcTaskDurationEnum DurationType, IfcDuration ScheduleDuration, IfcDateTime ScheduleStart, IfcDateTime ScheduleFinish, IfcDateTime EarlyStart, IfcDateTime EarlyFinish, IfcDateTime LateStart, IfcDateTime LateFinish, IfcDuration FreeFloat, IfcDuration TotalFloat, IfcBoolean IsCritical, IfcDateTime StatusTime, IfcDuration ActualDuration, IfcDateTime ActualStart, IfcDateTime ActualFinish, IfcDuration RemainingTime, IfcPositiveRatioMeasure Completion, IfcRecurrencePattern Recurrence) : base (Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion)
		{
			this.Recurrence = Recurrence;
		}
	}
	/// <summary>
	/// ENTITY IfcTaskType
	/// <para>ENTITY IfcTaskType</para>
	/// <para>SUBTYPE OF (IfcTypeProcess);</para>
	/// <para>PredefinedType : IfcTaskTypeEnum;</para>
	/// <para>WorkMethod : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcTaskTypeEnum.USERDEFINED) OR ((PredefinedType = IfcTaskTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcTypeProcess.ProcessType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTaskType : IfcTypeProcess
	{
		public virtual IfcTaskTypeEnum? PredefinedType { get; set; }
		public virtual IfcLabel? WorkMethod { get; set; }
		public IfcTaskType() : base()
		{
		}
		public IfcTaskType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType, IfcTaskTypeEnum PredefinedType, IfcLabel WorkMethod) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType)
		{
			this.PredefinedType = PredefinedType;
			this.WorkMethod = WorkMethod;
		}
	}
	/// <summary>
	/// ENTITY IfcTelecomAddress
	/// <para>ENTITY IfcTelecomAddress</para>
	/// <para>SUBTYPE OF (IfcAddress);</para>
	/// <para>TelephoneNumbers : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>FacsimileNumbers : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>PagerNumber : OPTIONAL IfcLabel;</para>
	/// <para>ElectronicMailAddresses : OPTIONAL LIST [1:?] OF IfcLabel;</para>
	/// <para>WWWHomePageURL : OPTIONAL IfcURIReference;</para>
	/// <para>MessagingIDs : OPTIONAL LIST [1:?] OF IfcURIReference;</para>
	/// <para>WHERE</para>
	/// <para>MinimumDataProvided : EXISTS (TelephoneNumbers) OR</para>
	/// <para>EXISTS (FacsimileNumbers) OR</para>
	/// <para>EXISTS (PagerNumber) OR</para>
	/// <para>EXISTS (ElectronicMailAddresses) OR</para>
	/// <para>EXISTS (WWWHomePageURL) OR</para>
	/// <para>EXISTS (MessagingIDs);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTelecomAddress : IfcAddress
	{
		public virtual List<IfcLabel>? TelephoneNumbers { get; set; }
		public virtual List<IfcLabel>? FacsimileNumbers { get; set; }
		public virtual IfcLabel? PagerNumber { get; set; }
		public virtual List<IfcLabel>? ElectronicMailAddresses { get; set; }
		public virtual IfcURIReference? WWWHomePageURL { get; set; }
		public virtual List<IfcURIReference>? MessagingIDs { get; set; }
		public IfcTelecomAddress() : base()
		{
		}
		public IfcTelecomAddress(IfcAddressTypeEnum Purpose, IfcText Description, IfcLabel UserDefinedPurpose, List<IfcLabel> TelephoneNumbers, List<IfcLabel> FacsimileNumbers, IfcLabel PagerNumber, List<IfcLabel> ElectronicMailAddresses, IfcURIReference WWWHomePageURL, List<IfcURIReference> MessagingIDs) : base (Purpose, Description, UserDefinedPurpose)
		{
			this.TelephoneNumbers = TelephoneNumbers;
			this.FacsimileNumbers = FacsimileNumbers;
			this.PagerNumber = PagerNumber;
			this.ElectronicMailAddresses = ElectronicMailAddresses;
			this.WWWHomePageURL = WWWHomePageURL;
			this.MessagingIDs = MessagingIDs;
		}
	}
	/// <summary>
	/// ENTITY IfcTendon
	/// <para>ENTITY IfcTendon</para>
	/// <para>SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcTendonTypeEnum;</para>
	/// <para>NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>TensionForce : OPTIONAL IfcForceMeasure;</para>
	/// <para>PreStress : OPTIONAL IfcPressureMeasure;</para>
	/// <para>FrictionCoefficient : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>AnchorageSlip : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>MinCurvatureRadius : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcTendonTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTendonTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCTENDONTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendon : IfcReinforcingElement
	{
		public virtual IfcTendonTypeEnum? PredefinedType { get; set; }
		public virtual IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public virtual IfcAreaMeasure? CrossSectionArea { get; set; }
		public virtual IfcForceMeasure? TensionForce { get; set; }
		public virtual IfcPressureMeasure? PreStress { get; set; }
		public virtual IfcNormalisedRatioMeasure? FrictionCoefficient { get; set; }
		public virtual IfcPositiveLengthMeasure? AnchorageSlip { get; set; }
		public virtual IfcPositiveLengthMeasure? MinCurvatureRadius { get; set; }
		public IfcTendon() : base()
		{
		}
		public IfcTendon(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcTendonTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcForceMeasure TensionForce, IfcPressureMeasure PreStress, IfcNormalisedRatioMeasure FrictionCoefficient, IfcPositiveLengthMeasure AnchorageSlip, IfcPositiveLengthMeasure MinCurvatureRadius) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.TensionForce = TensionForce;
			this.PreStress = PreStress;
			this.FrictionCoefficient = FrictionCoefficient;
			this.AnchorageSlip = AnchorageSlip;
			this.MinCurvatureRadius = MinCurvatureRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonAnchor
	/// <para>ENTITY IfcTendonAnchor</para>
	/// <para>SUBTYPE OF (IfcReinforcingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcTendonAnchorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcTendonAnchorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTendonAnchorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCTENDONANCHORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonAnchor : IfcReinforcingElement
	{
		public virtual IfcTendonAnchorTypeEnum? PredefinedType { get; set; }
		public IfcTendonAnchor() : base()
		{
		}
		public IfcTendonAnchor(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcLabel SteelGrade, IfcTendonAnchorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonAnchorType
	/// <para>ENTITY IfcTendonAnchorType</para>
	/// <para>SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>PredefinedType : IfcTendonAnchorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcTendonAnchorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTendonAnchorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonAnchorType : IfcReinforcingElementType
	{
		public virtual IfcTendonAnchorTypeEnum? PredefinedType { get; set; }
		public IfcTendonAnchorType() : base()
		{
		}
		public IfcTendonAnchorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTendonAnchorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTendonType
	/// <para>ENTITY IfcTendonType</para>
	/// <para>SUBTYPE OF (IfcReinforcingElementType);</para>
	/// <para>PredefinedType : IfcTendonTypeEnum;</para>
	/// <para>NominalDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>CrossSectionArea : OPTIONAL IfcAreaMeasure;</para>
	/// <para>SheathDiameter : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcTendonTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTendonTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTendonType : IfcReinforcingElementType
	{
		public virtual IfcTendonTypeEnum? PredefinedType { get; set; }
		public virtual IfcPositiveLengthMeasure? NominalDiameter { get; set; }
		public virtual IfcAreaMeasure? CrossSectionArea { get; set; }
		public virtual IfcPositiveLengthMeasure? SheathDiameter { get; set; }
		public IfcTendonType() : base()
		{
		}
		public IfcTendonType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTendonTypeEnum PredefinedType, IfcPositiveLengthMeasure NominalDiameter, IfcAreaMeasure CrossSectionArea, IfcPositiveLengthMeasure SheathDiameter) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.NominalDiameter = NominalDiameter;
			this.CrossSectionArea = CrossSectionArea;
			this.SheathDiameter = SheathDiameter;
		}
	}
	/// <summary>
	/// ENTITY IfcTessellatedFaceSet
	/// <para>ENTITY IfcTessellatedFaceSet</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcPolygonalFaceSet</para>
	/// <para>,IfcTriangulatedFaceSet))</para>
	/// <para>SUBTYPE OF (IfcTessellatedItem);</para>
	/// <para>Coordinates : IfcCartesianPointList3D;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := 3;</para>
	/// <para>INVERSE</para>
	/// <para>HasColours : SET [0:1] OF IfcIndexedColourMap FOR MappedTo;</para>
	/// <para>HasTextures : SET [0:?] OF IfcIndexedTextureMap FOR MappedTo;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTessellatedFaceSet : IfcTessellatedItem, IfcBooleanOperand
	{
		public virtual IfcCartesianPointList3D? Coordinates { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		//TODO INVERSE
		public List<IfcIndexedColourMap>? HasColours => Model?.GetItems<IfcIndexedColourMap>().Where(x => x.MappedTo != null && x.MappedTo == this).ToList();
		//TODO INVERSE
		public List<IfcIndexedTextureMap>? HasTextures => Model?.GetItems<IfcIndexedTextureMap>().Where(x => x.MappedTo != null && x.MappedTo == this).ToList();
		public IfcTessellatedFaceSet() : base()
		{
		}
		public IfcTessellatedFaceSet(IfcCartesianPointList3D Coordinates) : base ()
		{
			this.Coordinates = Coordinates;
		}
	}
	/// <summary>
	/// ENTITY IfcTessellatedItem
	/// <para>ENTITY IfcTessellatedItem</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcIndexedPolygonalFace</para>
	/// <para>,IfcTessellatedFaceSet))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTessellatedItem : IfcGeometricRepresentationItem
	{
		public IfcTessellatedItem() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTextLiteral
	/// <para>ENTITY IfcTextLiteral</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcTextLiteralWithExtent))</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Literal : IfcPresentableText;</para>
	/// <para>Placement : IfcAxis2Placement;</para>
	/// <para>Path : IfcTextPath;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextLiteral : IfcGeometricRepresentationItem
	{
		public virtual IfcPresentableText? Literal { get; set; }
		public virtual IfcAxis2Placement? Placement { get; set; }
		public virtual IfcTextPath? Path { get; set; }
		public IfcTextLiteral() : base()
		{
		}
		public IfcTextLiteral(IfcPresentableText Literal, IfcAxis2Placement Placement, IfcTextPath Path) : base ()
		{
			this.Literal = Literal;
			this.Placement = Placement;
			this.Path = Path;
		}
	}
	/// <summary>
	/// ENTITY IfcTextLiteralWithExtent
	/// <para>ENTITY IfcTextLiteralWithExtent</para>
	/// <para>SUBTYPE OF (IfcTextLiteral);</para>
	/// <para>Extent : IfcPlanarExtent;</para>
	/// <para>BoxAlignment : IfcBoxAlignment;</para>
	/// <para>WHERE</para>
	/// <para>WR31 : NOT('IFC4X1.IFCPLANARBOX' IN TYPEOF(Extent));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextLiteralWithExtent : IfcTextLiteral
	{
		public virtual IfcPlanarExtent? Extent { get; set; }
		public virtual IfcBoxAlignment? BoxAlignment { get; set; }
		public IfcTextLiteralWithExtent() : base()
		{
		}
		public IfcTextLiteralWithExtent(IfcPresentableText Literal, IfcAxis2Placement Placement, IfcTextPath Path, IfcPlanarExtent Extent, IfcBoxAlignment BoxAlignment) : base (Literal, Placement, Path)
		{
			this.Extent = Extent;
			this.BoxAlignment = BoxAlignment;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyle
	/// <para>ENTITY IfcTextStyle</para>
	/// <para>SUBTYPE OF (IfcPresentationStyle);</para>
	/// <para>TextCharacterAppearance : OPTIONAL IfcTextStyleForDefinedFont;</para>
	/// <para>TextStyle : OPTIONAL IfcTextStyleTextModel;</para>
	/// <para>TextFontStyle : IfcTextFontSelect;</para>
	/// <para>ModelOrDraughting : OPTIONAL IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyle : IfcPresentationStyle, IfcPresentationStyleSelect
	{
		public virtual IfcTextStyleForDefinedFont? TextCharacterAppearance { get; set; }
		public virtual IfcTextStyleTextModel? TextStyle { get; set; }
		public virtual IfcTextFontSelect? TextFontStyle { get; set; }
		public virtual IfcBoolean? ModelOrDraughting { get; set; }
		public IfcTextStyle() : base()
		{
		}
		public IfcTextStyle(IfcLabel Name, IfcTextStyleForDefinedFont TextCharacterAppearance, IfcTextStyleTextModel TextStyle, IfcTextFontSelect TextFontStyle, IfcBoolean ModelOrDraughting) : base (Name)
		{
			this.TextCharacterAppearance = TextCharacterAppearance;
			this.TextStyle = TextStyle;
			this.TextFontStyle = TextFontStyle;
			this.ModelOrDraughting = ModelOrDraughting;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyleFontModel
	/// <para>ENTITY IfcTextStyleFontModel</para>
	/// <para>SUBTYPE OF (IfcPreDefinedTextFont);</para>
	/// <para>FontFamily : LIST [1:?] OF IfcTextFontName;</para>
	/// <para>FontStyle : OPTIONAL IfcFontStyle;</para>
	/// <para>FontVariant : OPTIONAL IfcFontVariant;</para>
	/// <para>FontWeight : OPTIONAL IfcFontWeight;</para>
	/// <para>FontSize : IfcSizeSelect;</para>
	/// <para>WHERE</para>
	/// <para>MeasureOfFontSize : ('IFC4X1.IFCLENGTHMEASURE' IN TYPEOF(SELF.FontSize)) AND</para>
	/// <para>(SELF.FontSize > 0.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyleFontModel : IfcPreDefinedTextFont
	{
		public virtual List<IfcTextFontName>? FontFamily { get; set; }
		public virtual IfcFontStyle? FontStyle { get; set; }
		public virtual IfcFontVariant? FontVariant { get; set; }
		public virtual IfcFontWeight? FontWeight { get; set; }
		public virtual IfcSizeSelect? FontSize { get; set; }
		public IfcTextStyleFontModel() : base()
		{
		}
		public IfcTextStyleFontModel(IfcLabel Name, List<IfcTextFontName> FontFamily, IfcFontStyle FontStyle, IfcFontVariant FontVariant, IfcFontWeight FontWeight, IfcSizeSelect FontSize) : base (Name)
		{
			this.FontFamily = FontFamily;
			this.FontStyle = FontStyle;
			this.FontVariant = FontVariant;
			this.FontWeight = FontWeight;
			this.FontSize = FontSize;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyleForDefinedFont
	/// <para>ENTITY IfcTextStyleForDefinedFont</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>Colour : IfcColour;</para>
	/// <para>BackgroundColour : OPTIONAL IfcColour;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyleForDefinedFont : IfcPresentationItem
	{
		public virtual IfcColour? Colour { get; set; }
		public virtual IfcColour? BackgroundColour { get; set; }
		public IfcTextStyleForDefinedFont() : base()
		{
		}
		public IfcTextStyleForDefinedFont(IfcColour Colour, IfcColour BackgroundColour) : base ()
		{
			this.Colour = Colour;
			this.BackgroundColour = BackgroundColour;
		}
	}
	/// <summary>
	/// ENTITY IfcTextStyleTextModel
	/// <para>ENTITY IfcTextStyleTextModel</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>TextIndent : OPTIONAL IfcSizeSelect;</para>
	/// <para>TextAlign : OPTIONAL IfcTextAlignment;</para>
	/// <para>TextDecoration : OPTIONAL IfcTextDecoration;</para>
	/// <para>LetterSpacing : OPTIONAL IfcSizeSelect;</para>
	/// <para>WordSpacing : OPTIONAL IfcSizeSelect;</para>
	/// <para>TextTransform : OPTIONAL IfcTextTransformation;</para>
	/// <para>LineHeight : OPTIONAL IfcSizeSelect;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextStyleTextModel : IfcPresentationItem
	{
		public virtual IfcSizeSelect? TextIndent { get; set; }
		public virtual IfcTextAlignment? TextAlign { get; set; }
		public virtual IfcTextDecoration? TextDecoration { get; set; }
		public virtual IfcSizeSelect? LetterSpacing { get; set; }
		public virtual IfcSizeSelect? WordSpacing { get; set; }
		public virtual IfcTextTransformation? TextTransform { get; set; }
		public virtual IfcSizeSelect? LineHeight { get; set; }
		public IfcTextStyleTextModel() : base()
		{
		}
		public IfcTextStyleTextModel(IfcSizeSelect TextIndent, IfcTextAlignment TextAlign, IfcTextDecoration TextDecoration, IfcSizeSelect LetterSpacing, IfcSizeSelect WordSpacing, IfcTextTransformation TextTransform, IfcSizeSelect LineHeight) : base ()
		{
			this.TextIndent = TextIndent;
			this.TextAlign = TextAlign;
			this.TextDecoration = TextDecoration;
			this.LetterSpacing = LetterSpacing;
			this.WordSpacing = WordSpacing;
			this.TextTransform = TextTransform;
			this.LineHeight = LineHeight;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureCoordinate
	/// <para>ENTITY IfcTextureCoordinate</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcIndexedTextureMap</para>
	/// <para>,IfcTextureCoordinateGenerator</para>
	/// <para>,IfcTextureMap))</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>Maps : LIST [1:?] OF IfcSurfaceTexture;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTextureCoordinate : IfcPresentationItem
	{
		public virtual List<IfcSurfaceTexture>? Maps { get; set; }
		public IfcTextureCoordinate() : base()
		{
		}
		public IfcTextureCoordinate(List<IfcSurfaceTexture> Maps) : base ()
		{
			this.Maps = Maps;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureCoordinateGenerator
	/// <para>ENTITY IfcTextureCoordinateGenerator</para>
	/// <para>SUBTYPE OF (IfcTextureCoordinate);</para>
	/// <para>Mode : IfcLabel;</para>
	/// <para>Parameter : OPTIONAL LIST [1:?] OF IfcReal;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureCoordinateGenerator : IfcTextureCoordinate
	{
		public virtual IfcLabel? Mode { get; set; }
		public virtual List<IfcReal>? Parameter { get; set; }
		public IfcTextureCoordinateGenerator() : base()
		{
		}
		public IfcTextureCoordinateGenerator(List<IfcSurfaceTexture> Maps, IfcLabel Mode, List<IfcReal> Parameter) : base (Maps)
		{
			this.Mode = Mode;
			this.Parameter = Parameter;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureMap
	/// <para>ENTITY IfcTextureMap</para>
	/// <para>SUBTYPE OF (IfcTextureCoordinate);</para>
	/// <para>Vertices : LIST [3:?] OF IfcTextureVertex;</para>
	/// <para>MappedTo : IfcFace;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureMap : IfcTextureCoordinate
	{
		public virtual List<IfcTextureVertex>? Vertices { get; set; }
		public virtual IfcFace? MappedTo { get; set; }
		public IfcTextureMap() : base()
		{
		}
		public IfcTextureMap(List<IfcSurfaceTexture> Maps, List<IfcTextureVertex> Vertices, IfcFace MappedTo) : base (Maps)
		{
			this.Vertices = Vertices;
			this.MappedTo = MappedTo;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureVertex
	/// <para>ENTITY IfcTextureVertex</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>Coordinates : LIST [2:2] OF IfcParameterValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureVertex : IfcPresentationItem
	{
		public virtual List<IfcParameterValue>? Coordinates { get; set; }
		public IfcTextureVertex() : base()
		{
		}
		public IfcTextureVertex(List<IfcParameterValue> Coordinates) : base ()
		{
			this.Coordinates = Coordinates;
		}
	}
	/// <summary>
	/// ENTITY IfcTextureVertexList
	/// <para>ENTITY IfcTextureVertexList</para>
	/// <para>SUBTYPE OF (IfcPresentationItem);</para>
	/// <para>TexCoordsList : LIST [1:?] OF LIST [2:2] OF IfcParameterValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTextureVertexList : IfcPresentationItem
	{
		public virtual List<List<IfcParameterValue >>? TexCoordsList { get; set; }
		public IfcTextureVertexList() : base()
		{
		}
		public IfcTextureVertexList(List<List<IfcParameterValue >> TexCoordsList) : base ()
		{
			this.TexCoordsList = TexCoordsList;
		}
	}
	/// <summary>
	/// ENTITY IfcTimePeriod;
	/// <para>ENTITY IfcTimePeriod;</para>
	/// <para>StartTime : IfcTime;</para>
	/// <para>EndTime : IfcTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTimePeriod : Entity
	{
		public virtual IfcTime? StartTime { get; set; }
		public virtual IfcTime? EndTime { get; set; }
		public IfcTimePeriod() : base()
		{
		}
		public IfcTimePeriod(IfcTime StartTime, IfcTime EndTime) : base ()
		{
			this.StartTime = StartTime;
			this.EndTime = EndTime;
		}
	}
	/// <summary>
	/// ENTITY IfcTimeSeries
	/// <para>ENTITY IfcTimeSeries</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcIrregularTimeSeries</para>
	/// <para>,IfcRegularTimeSeries));</para>
	/// <para>Name : IfcLabel;</para>
	/// <para>Description : OPTIONAL IfcText;</para>
	/// <para>StartTime : IfcDateTime;</para>
	/// <para>EndTime : IfcDateTime;</para>
	/// <para>TimeSeriesDataType : IfcTimeSeriesDataTypeEnum;</para>
	/// <para>DataOrigin : IfcDataOriginEnum;</para>
	/// <para>UserDefinedDataOrigin : OPTIONAL IfcLabel;</para>
	/// <para>Unit : OPTIONAL IfcUnit;</para>
	/// <para>INVERSE</para>
	/// <para>HasExternalReference : SET [1:?] OF IfcExternalReferenceRelationship FOR RelatedResourceObjects;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTimeSeries : Entity, IfcMetricValueSelect, IfcObjectReferenceSelect, IfcResourceObjectSelect
	{
		public virtual IfcLabel? Name { get; set; }
		public virtual IfcText? Description { get; set; }
		public virtual IfcDateTime? StartTime { get; set; }
		public virtual IfcDateTime? EndTime { get; set; }
		public virtual IfcTimeSeriesDataTypeEnum? TimeSeriesDataType { get; set; }
		public virtual IfcDataOriginEnum? DataOrigin { get; set; }
		public virtual IfcLabel? UserDefinedDataOrigin { get; set; }
		public virtual IfcUnit? Unit { get; set; }
		//TODO INVERSE
		public List<IfcExternalReferenceRelationship>? HasExternalReference => Model?.GetItems<IfcExternalReferenceRelationship>().Where(x => x.RelatedResourceObjects != null && x.RelatedResourceObjects.Contains(this)).ToList();
		public IfcTimeSeries() : base()
		{
		}
		public IfcTimeSeries(IfcLabel Name, IfcText Description, IfcDateTime StartTime, IfcDateTime EndTime, IfcTimeSeriesDataTypeEnum TimeSeriesDataType, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcUnit Unit) : base ()
		{
			this.Name = Name;
			this.Description = Description;
			this.StartTime = StartTime;
			this.EndTime = EndTime;
			this.TimeSeriesDataType = TimeSeriesDataType;
			this.DataOrigin = DataOrigin;
			this.UserDefinedDataOrigin = UserDefinedDataOrigin;
			this.Unit = Unit;
		}
	}
	/// <summary>
	/// ENTITY IfcTimeSeriesValue;
	/// <para>ENTITY IfcTimeSeriesValue;</para>
	/// <para>ListValues : LIST [1:?] OF IfcValue;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTimeSeriesValue : Entity
	{
		public virtual List<IfcValue>? ListValues { get; set; }
		public IfcTimeSeriesValue() : base()
		{
		}
		public IfcTimeSeriesValue(List<IfcValue> ListValues) : base ()
		{
			this.ListValues = ListValues;
		}
	}
	/// <summary>
	/// ENTITY IfcTopologicalRepresentationItem
	/// <para>ENTITY IfcTopologicalRepresentationItem</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcConnectedFaceSet</para>
	/// <para>,IfcEdge</para>
	/// <para>,IfcFace</para>
	/// <para>,IfcFaceBound</para>
	/// <para>,IfcLoop</para>
	/// <para>,IfcPath</para>
	/// <para>,IfcVertex))</para>
	/// <para>SUBTYPE OF (IfcRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTopologicalRepresentationItem : IfcRepresentationItem
	{
		public IfcTopologicalRepresentationItem() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTopologyRepresentation
	/// <para>ENTITY IfcTopologyRepresentation</para>
	/// <para>SUBTYPE OF (IfcShapeModel);</para>
	/// <para>WHERE</para>
	/// <para>WR21 : SIZEOF(QUERY(temp <* SELF\IfcRepresentation.Items |</para>
	/// <para>NOT('IFC4X1.IFCTOPOLOGICALREPRESENTATIONITEM' IN TYPEOF(temp))</para>
	/// <para>)) = 0;</para>
	/// <para>WR22 : EXISTS(SELF\IfcRepresentation.RepresentationType);</para>
	/// <para>WR23 : IfcTopologyRepresentationTypes(SELF\IfcRepresentation.RepresentationType, SELF\IfcRepresentation.Items);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTopologyRepresentation : IfcShapeModel
	{
		public IfcTopologyRepresentation() : base()
		{
		}
		public IfcTopologyRepresentation(IfcRepresentationContext ContextOfItems, IfcLabel RepresentationIdentifier, IfcLabel RepresentationType, List<IfcRepresentationItem> Items) : base (ContextOfItems, RepresentationIdentifier, RepresentationType, Items)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcToroidalSurface
	/// <para>ENTITY IfcToroidalSurface</para>
	/// <para>SUBTYPE OF (IfcElementarySurface);</para>
	/// <para>MajorRadius : IfcPositiveLengthMeasure;</para>
	/// <para>MinorRadius : IfcPositiveLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>MajorLargerMinor : MinorRadius < MajorRadius;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcToroidalSurface : IfcElementarySurface
	{
		public virtual IfcPositiveLengthMeasure? MajorRadius { get; set; }
		public virtual IfcPositiveLengthMeasure? MinorRadius { get; set; }
		public IfcToroidalSurface() : base()
		{
		}
		public IfcToroidalSurface(IfcAxis2Placement3D Position, IfcPositiveLengthMeasure MajorRadius, IfcPositiveLengthMeasure MinorRadius) : base (Position)
		{
			this.MajorRadius = MajorRadius;
			this.MinorRadius = MinorRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcTransformer
	/// <para>ENTITY IfcTransformer</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcTransformerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcTransformerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTransformerTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCTRANFORMERTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransformer : IfcEnergyConversionDevice
	{
		public virtual IfcTransformerTypeEnum? PredefinedType { get; set; }
		public IfcTransformer() : base()
		{
		}
		public IfcTransformer(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTransformerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransformerType
	/// <para>ENTITY IfcTransformerType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcTransformerTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcTransformerTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTransformerTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransformerType : IfcEnergyConversionDeviceType
	{
		public virtual IfcTransformerTypeEnum? PredefinedType { get; set; }
		public IfcTransformerType() : base()
		{
		}
		public IfcTransformerType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTransformerTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransitionCurveSegment2D
	/// <para>ENTITY IfcTransitionCurveSegment2D</para>
	/// <para>SUBTYPE OF (IfcCurveSegment2D);</para>
	/// <para>StartRadius : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>EndRadius : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>IsStartRadiusCCW : IfcBoolean;</para>
	/// <para>IsEndRadiusCCW : IfcBoolean;</para>
	/// <para>TransitionCurveType : IfcTransitionCurveType;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransitionCurveSegment2D : IfcCurveSegment2D
	{
		public virtual IfcPositiveLengthMeasure? StartRadius { get; set; }
		public virtual IfcPositiveLengthMeasure? EndRadius { get; set; }
		public virtual IfcBoolean? IsStartRadiusCCW { get; set; }
		public virtual IfcBoolean? IsEndRadiusCCW { get; set; }
		public virtual IfcTransitionCurveType? TransitionCurveType { get; set; }
		public IfcTransitionCurveSegment2D() : base()
		{
		}
		public IfcTransitionCurveSegment2D(IfcCartesianPoint StartPoint, IfcPlaneAngleMeasure StartDirection, IfcPositiveLengthMeasure SegmentLength, IfcPositiveLengthMeasure StartRadius, IfcPositiveLengthMeasure EndRadius, IfcBoolean IsStartRadiusCCW, IfcBoolean IsEndRadiusCCW, IfcTransitionCurveType TransitionCurveType) : base (StartPoint, StartDirection, SegmentLength)
		{
			this.StartRadius = StartRadius;
			this.EndRadius = EndRadius;
			this.IsStartRadiusCCW = IsStartRadiusCCW;
			this.IsEndRadiusCCW = IsEndRadiusCCW;
			this.TransitionCurveType = TransitionCurveType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransportElement
	/// <para>ENTITY IfcTransportElement</para>
	/// <para>SUBTYPE OF (IfcElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcTransportElementTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcTransportElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTransportElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCTRANSPORTELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransportElement : IfcElement
	{
		public virtual IfcTransportElementTypeEnum? PredefinedType { get; set; }
		public IfcTransportElement() : base()
		{
		}
		public IfcTransportElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTransportElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTransportElementType
	/// <para>ENTITY IfcTransportElementType</para>
	/// <para>SUBTYPE OF (IfcElementType);</para>
	/// <para>PredefinedType : IfcTransportElementTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcTransportElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTransportElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTransportElementType : IfcElementType
	{
		public virtual IfcTransportElementTypeEnum? PredefinedType { get; set; }
		public IfcTransportElementType() : base()
		{
		}
		public IfcTransportElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTransportElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTrapeziumProfileDef
	/// <para>ENTITY IfcTrapeziumProfileDef</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>BottomXDim : IfcPositiveLengthMeasure;</para>
	/// <para>TopXDim : IfcPositiveLengthMeasure;</para>
	/// <para>YDim : IfcPositiveLengthMeasure;</para>
	/// <para>TopXOffset : IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTrapeziumProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? BottomXDim { get; set; }
		public virtual IfcPositiveLengthMeasure? TopXDim { get; set; }
		public virtual IfcPositiveLengthMeasure? YDim { get; set; }
		public virtual IfcLengthMeasure? TopXOffset { get; set; }
		public IfcTrapeziumProfileDef() : base()
		{
		}
		public IfcTrapeziumProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure BottomXDim, IfcPositiveLengthMeasure TopXDim, IfcPositiveLengthMeasure YDim, IfcLengthMeasure TopXOffset) : base (ProfileType, ProfileName, Position)
		{
			this.BottomXDim = BottomXDim;
			this.TopXDim = TopXDim;
			this.YDim = YDim;
			this.TopXOffset = TopXOffset;
		}
	}
	/// <summary>
	/// ENTITY IfcTriangulatedFaceSet
	/// <para>ENTITY IfcTriangulatedFaceSet</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcTriangulatedIrregularNetwork))</para>
	/// <para>SUBTYPE OF (IfcTessellatedFaceSet);</para>
	/// <para>Normals : OPTIONAL LIST [1:?] OF LIST [3:3] OF IfcParameterValue;</para>
	/// <para>Closed : OPTIONAL IfcBoolean;</para>
	/// <para>CoordIndex : LIST [1:?] OF LIST [3:3] OF IfcPositiveInteger;</para>
	/// <para>PnIndex : OPTIONAL LIST [1:?] OF IfcPositiveInteger;</para>
	/// <para>DERIVE</para>
	/// <para>NumberOfTriangles : IfcInteger := SIZEOF(CoordIndex);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTriangulatedFaceSet : IfcTessellatedFaceSet
	{
		public virtual List<List<IfcParameterValue >>? Normals { get; set; }
		public virtual IfcBoolean? Closed { get; set; }
		public virtual List<List<IfcPositiveInteger >>? CoordIndex { get; set; }
		public virtual List<IfcPositiveInteger>? PnIndex { get; set; }
		//TODO DERIVE
		public virtual IfcInteger? NumberOfTriangles {get {return null;}}
		public IfcTriangulatedFaceSet() : base()
		{
		}
		public IfcTriangulatedFaceSet(IfcCartesianPointList3D Coordinates, List<List<IfcParameterValue >> Normals, IfcBoolean Closed, List<List<IfcPositiveInteger >> CoordIndex, List<IfcPositiveInteger> PnIndex) : base (Coordinates)
		{
			this.Normals = Normals;
			this.Closed = Closed;
			this.CoordIndex = CoordIndex;
			this.PnIndex = PnIndex;
		}
	}
	/// <summary>
	/// ENTITY IfcTriangulatedIrregularNetwork
	/// <para>ENTITY IfcTriangulatedIrregularNetwork</para>
	/// <para>SUBTYPE OF (IfcTriangulatedFaceSet);</para>
	/// <para>Flags : LIST [1:?] OF IfcInteger;</para>
	/// <para>WHERE</para>
	/// <para>NotClosed : SELF\IfcTriangulatedFaceSet.Closed = FALSE;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTriangulatedIrregularNetwork : IfcTriangulatedFaceSet
	{
		public virtual List<IfcInteger>? Flags { get; set; }
		public IfcTriangulatedIrregularNetwork() : base()
		{
		}
		public IfcTriangulatedIrregularNetwork(IfcCartesianPointList3D Coordinates, List<List<IfcParameterValue >> Normals, IfcBoolean Closed, List<List<IfcPositiveInteger >> CoordIndex, List<IfcPositiveInteger> PnIndex, List<IfcInteger> Flags) : base (Coordinates, Normals, Closed, CoordIndex, PnIndex)
		{
			this.Flags = Flags;
		}
	}
	/// <summary>
	/// ENTITY IfcTrimmedCurve
	/// <para>ENTITY IfcTrimmedCurve</para>
	/// <para>SUBTYPE OF (IfcBoundedCurve);</para>
	/// <para>BasisCurve : IfcCurve;</para>
	/// <para>Trim1 : SET [1:2] OF IfcTrimmingSelect;</para>
	/// <para>Trim2 : SET [1:2] OF IfcTrimmingSelect;</para>
	/// <para>SenseAgreement : IfcBoolean;</para>
	/// <para>MasterRepresentation : IfcTrimmingPreference;</para>
	/// <para>WHERE</para>
	/// <para>Trim1ValuesConsistent : (HIINDEX(Trim1) = 1) OR (TYPEOF(Trim1[1]) <> TYPEOF(Trim1[2]));</para>
	/// <para>Trim2ValuesConsistent : (HIINDEX(Trim2) = 1) OR (TYPEOF(Trim2[1]) <> TYPEOF(Trim2[2]));</para>
	/// <para>NoTrimOfBoundedCurves : NOT('IFC4X1.IFCBOUNDEDCURVE' IN TYPEOF(BasisCurve));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTrimmedCurve : IfcBoundedCurve
	{
		public virtual IfcCurve? BasisCurve { get; set; }
		public virtual List<IfcTrimmingSelect>? Trim1 { get; set; }
		public virtual List<IfcTrimmingSelect>? Trim2 { get; set; }
		public virtual IfcBoolean? SenseAgreement { get; set; }
		public virtual IfcTrimmingPreference? MasterRepresentation { get; set; }
		public IfcTrimmedCurve() : base()
		{
		}
		public IfcTrimmedCurve(IfcCurve BasisCurve, List<IfcTrimmingSelect> Trim1, List<IfcTrimmingSelect> Trim2, IfcBoolean SenseAgreement, IfcTrimmingPreference MasterRepresentation) : base ()
		{
			this.BasisCurve = BasisCurve;
			this.Trim1 = Trim1;
			this.Trim2 = Trim2;
			this.SenseAgreement = SenseAgreement;
			this.MasterRepresentation = MasterRepresentation;
		}
	}
	/// <summary>
	/// ENTITY IfcTubeBundle
	/// <para>ENTITY IfcTubeBundle</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcTubeBundleTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcTubeBundleTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTubeBundleTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCTUBEBUNDLETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTubeBundle : IfcEnergyConversionDevice
	{
		public virtual IfcTubeBundleTypeEnum? PredefinedType { get; set; }
		public IfcTubeBundle() : base()
		{
		}
		public IfcTubeBundle(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcTubeBundleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTubeBundleType
	/// <para>ENTITY IfcTubeBundleType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcTubeBundleTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcTubeBundleTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcTubeBundleTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTubeBundleType : IfcEnergyConversionDeviceType
	{
		public virtual IfcTubeBundleTypeEnum? PredefinedType { get; set; }
		public IfcTubeBundleType() : base()
		{
		}
		public IfcTubeBundleType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcTubeBundleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcTypeObject
	/// <para>ENTITY IfcTypeObject</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcTypeProcess</para>
	/// <para>,IfcTypeProduct</para>
	/// <para>,IfcTypeResource))</para>
	/// <para>SUBTYPE OF (IfcObjectDefinition);</para>
	/// <para>ApplicableOccurrence : OPTIONAL IfcIdentifier;</para>
	/// <para>HasPropertySets : OPTIONAL SET [1:?] OF IfcPropertySetDefinition;</para>
	/// <para>INVERSE</para>
	/// <para>Types : SET [0:1] OF IfcRelDefinesByType FOR RelatingType;</para>
	/// <para>WHERE</para>
	/// <para>NameRequired : EXISTS(SELF\IfcRoot.Name);</para>
	/// <para>UniquePropertySetNames : (NOT(EXISTS(HasPropertySets))) OR IfcUniquePropertySetNames(HasPropertySets);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTypeObject : IfcObjectDefinition
	{
		public virtual IfcIdentifier? ApplicableOccurrence { get; set; }
		public virtual List<IfcPropertySetDefinition>? HasPropertySets { get; set; }
		//TODO INVERSE
		public List<IfcRelDefinesByType>? Types => Model?.GetItems<IfcRelDefinesByType>().Where(x => x.RelatingType != null && x.RelatingType == this).ToList();
		public IfcTypeObject() : base()
		{
		}
		public IfcTypeObject(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.ApplicableOccurrence = ApplicableOccurrence;
			this.HasPropertySets = HasPropertySets;
		}
	}
	/// <summary>
	/// ENTITY IfcTypeProcess
	/// <para>ENTITY IfcTypeProcess</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcEventType</para>
	/// <para>,IfcProcedureType</para>
	/// <para>,IfcTaskType))</para>
	/// <para>SUBTYPE OF (IfcTypeObject);</para>
	/// <para>Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>LongDescription : OPTIONAL IfcText;</para>
	/// <para>ProcessType : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>OperatesOn : SET [0:?] OF IfcRelAssignsToProcess FOR RelatingProcess;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTypeProcess : IfcTypeObject, IfcProcessSelect
	{
		public virtual IfcIdentifier? Identification { get; set; }
		public virtual IfcText? LongDescription { get; set; }
		public virtual IfcLabel? ProcessType { get; set; }
		//TODO INVERSE
		public List<IfcRelAssignsToProcess>? OperatesOn => Model?.GetItems<IfcRelAssignsToProcess>().Where(x => x.RelatingProcess != null && x.RelatingProcess == this).ToList();
		public IfcTypeProcess() : base()
		{
		}
		public IfcTypeProcess(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ProcessType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
			this.ProcessType = ProcessType;
		}
	}
	/// <summary>
	/// ENTITY IfcTypeProduct
	/// <para>ENTITY IfcTypeProduct</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcDoorStyle</para>
	/// <para>,IfcElementType</para>
	/// <para>,IfcSpatialElementType</para>
	/// <para>,IfcWindowStyle))</para>
	/// <para>SUBTYPE OF (IfcTypeObject);</para>
	/// <para>RepresentationMaps : OPTIONAL LIST [1:?] OF UNIQUE IfcRepresentationMap;</para>
	/// <para>Tag : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>ReferencedBy : SET [0:?] OF IfcRelAssignsToProduct FOR RelatingProduct;</para>
	/// <para>WHERE</para>
	/// <para>ApplicableOccurrence : NOT(EXISTS(SELF\IfcTypeObject.Types[1])) OR</para>
	/// <para>(SIZEOF(QUERY(temp <* SELF\IfcTypeObject.Types[1].RelatedObjects |</para>
	/// <para>NOT('IFC4X1.IFCPRODUCT' IN TYPEOF(temp)))</para>
	/// <para>) = 0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcTypeProduct : IfcTypeObject, IfcProductSelect
	{
		//TODO INVERSE
		public List<IfcRelAssignsToProduct>? ReferencedBy => Model?.GetItems<IfcRelAssignsToProduct>().Where(x => x.RelatingProduct != null && x.RelatingProduct == this).ToList();
		public IfcTypeProduct() : base()
		{
		}
		public IfcTypeProduct(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcTypeResource
	/// <para>ENTITY IfcTypeResource</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcConstructionResourceType))</para>
	/// <para>SUBTYPE OF (IfcTypeObject);</para>
	/// <para>Identification : OPTIONAL IfcIdentifier;</para>
	/// <para>LongDescription : OPTIONAL IfcText;</para>
	/// <para>ResourceType : OPTIONAL IfcLabel;</para>
	/// <para>INVERSE</para>
	/// <para>ResourceOf : SET [0:?] OF IfcRelAssignsToResource FOR RelatingResource;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcTypeResource : IfcTypeObject, IfcResourceSelect
	{
		public virtual IfcIdentifier? Identification { get; set; }
		public virtual IfcText? LongDescription { get; set; }
		public virtual IfcLabel? ResourceType { get; set; }
		public virtual List<IfcAppliedValue>? BaseCosts { get; set;  }
		public virtual IfcPhysicalQuantity? BaseQuantity { get; set;  }
		//TODO INVERSE
		public List<IfcRelAssignsToResource>? ResourceOf => Model?.GetItems<IfcRelAssignsToResource>().Where(x => x.RelatingResource != null && x.RelatingResource == this).ToList();
		public IfcTypeResource() : base()
		{
		}
		public IfcTypeResource(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcIdentifier Identification, IfcText LongDescription, IfcLabel ResourceType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.Identification = Identification;
			this.LongDescription = LongDescription;
			this.ResourceType = ResourceType;
		}
	}
	/// <summary>
	/// ENTITY IfcUShapeProfileDef
	/// <para>ENTITY IfcUShapeProfileDef</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>Depth : IfcPositiveLengthMeasure;</para>
	/// <para>FlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>EdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>FlangeSlope : OPTIONAL IfcPlaneAngleMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidFlangeThickness : FlangeThickness < (Depth / 2.);</para>
	/// <para>ValidWebThickness : WebThickness < FlangeWidth;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUShapeProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? Depth { get; set; }
		public virtual IfcPositiveLengthMeasure? FlangeWidth { get; set; }
		public virtual IfcPositiveLengthMeasure? WebThickness { get; set; }
		public virtual IfcPositiveLengthMeasure? FlangeThickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public virtual IfcNonNegativeLengthMeasure? EdgeRadius { get; set; }
		public virtual IfcPlaneAngleMeasure? FlangeSlope { get; set; }
		public IfcUShapeProfileDef() : base()
		{
		}
		public IfcUShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure FlangeWidth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure EdgeRadius, IfcPlaneAngleMeasure FlangeSlope) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.FlangeWidth = FlangeWidth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.EdgeRadius = EdgeRadius;
			this.FlangeSlope = FlangeSlope;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitAssignment;
	/// <para>ENTITY IfcUnitAssignment;</para>
	/// <para>Units : SET [1:?] OF IfcUnit;</para>
	/// <para>WHERE</para>
	/// <para>WR01 : IfcCorrectUnitAssignment(Units);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitAssignment : Entity
	{
		public virtual List<IfcUnit>? Units { get; set; }
		public IfcUnitAssignment() : base()
		{
		}
		public IfcUnitAssignment(List<IfcUnit> Units) : base ()
		{
			this.Units = Units;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryControlElement
	/// <para>ENTITY IfcUnitaryControlElement</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcUnitaryControlElementTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcUnitaryControlElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcUnitaryControlElementTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCUNITARYCONTROLELEMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryControlElement : IfcDistributionControlElement
	{
		public virtual IfcUnitaryControlElementTypeEnum? PredefinedType { get; set; }
		public IfcUnitaryControlElement() : base()
		{
		}
		public IfcUnitaryControlElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcUnitaryControlElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryControlElementType
	/// <para>ENTITY IfcUnitaryControlElementType</para>
	/// <para>SUBTYPE OF (IfcDistributionControlElementType);</para>
	/// <para>PredefinedType : IfcUnitaryControlElementTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcUnitaryControlElementTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcUnitaryControlElementTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryControlElementType : IfcDistributionControlElementType
	{
		public virtual IfcUnitaryControlElementTypeEnum? PredefinedType { get; set; }
		public IfcUnitaryControlElementType() : base()
		{
		}
		public IfcUnitaryControlElementType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcUnitaryControlElementTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryEquipment
	/// <para>ENTITY IfcUnitaryEquipment</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDevice);</para>
	/// <para>PredefinedType : OPTIONAL IfcUnitaryEquipmentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcUnitaryEquipmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcUnitaryEquipmentTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCUNITARYEQUIPMENTTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryEquipment : IfcEnergyConversionDevice
	{
		public virtual IfcUnitaryEquipmentTypeEnum? PredefinedType { get; set; }
		public IfcUnitaryEquipment() : base()
		{
		}
		public IfcUnitaryEquipment(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcUnitaryEquipmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcUnitaryEquipmentType
	/// <para>ENTITY IfcUnitaryEquipmentType</para>
	/// <para>SUBTYPE OF (IfcEnergyConversionDeviceType);</para>
	/// <para>PredefinedType : IfcUnitaryEquipmentTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcUnitaryEquipmentTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcUnitaryEquipmentTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcUnitaryEquipmentType : IfcEnergyConversionDeviceType
	{
		public virtual IfcUnitaryEquipmentTypeEnum? PredefinedType { get; set; }
		public IfcUnitaryEquipmentType() : base()
		{
		}
		public IfcUnitaryEquipmentType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcUnitaryEquipmentTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcValve
	/// <para>ENTITY IfcValve</para>
	/// <para>SUBTYPE OF (IfcFlowController);</para>
	/// <para>PredefinedType : OPTIONAL IfcValveTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcValveTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcValveTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCVALVETYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcValve : IfcFlowController
	{
		public virtual IfcValveTypeEnum? PredefinedType { get; set; }
		public IfcValve() : base()
		{
		}
		public IfcValve(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcValveTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcValveType
	/// <para>ENTITY IfcValveType</para>
	/// <para>SUBTYPE OF (IfcFlowControllerType);</para>
	/// <para>PredefinedType : IfcValveTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcValveTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcValveTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcValveType : IfcFlowControllerType
	{
		public virtual IfcValveTypeEnum? PredefinedType { get; set; }
		public IfcValveType() : base()
		{
		}
		public IfcValveType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcValveTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVector
	/// <para>ENTITY IfcVector</para>
	/// <para>SUBTYPE OF (IfcGeometricRepresentationItem);</para>
	/// <para>Orientation : IfcDirection;</para>
	/// <para>Magnitude : IfcLengthMeasure;</para>
	/// <para>DERIVE</para>
	/// <para>Dim : IfcDimensionCount := Orientation.Dim;</para>
	/// <para>WHERE</para>
	/// <para>MagGreaterOrEqualZero : Magnitude >= 0.0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVector : IfcGeometricRepresentationItem, IfcHatchLineDistanceSelect, IfcVectorOrDirection
	{
		public virtual IfcDirection? Orientation { get; set; }
		public virtual IfcLengthMeasure? Magnitude { get; set; }
		//TODO DERIVE
		public virtual IfcDimensionCount? Dim {get {return null;}}
		public IfcVector() : base()
		{
		}
		public IfcVector(IfcDirection Orientation, IfcLengthMeasure Magnitude) : base ()
		{
			this.Orientation = Orientation;
			this.Magnitude = Magnitude;
		}
	}
	/// <summary>
	/// ENTITY IfcVertex
	/// <para>ENTITY IfcVertex</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcVertexPoint))</para>
	/// <para>SUBTYPE OF (IfcTopologicalRepresentationItem);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVertex : IfcTopologicalRepresentationItem
	{
		public IfcVertex() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcVertexLoop
	/// <para>ENTITY IfcVertexLoop</para>
	/// <para>SUBTYPE OF (IfcLoop);</para>
	/// <para>LoopVertex : IfcVertex;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVertexLoop : IfcLoop
	{
		public virtual IfcVertex? LoopVertex { get; set; }
		public IfcVertexLoop() : base()
		{
		}
		public IfcVertexLoop(IfcVertex LoopVertex) : base ()
		{
			this.LoopVertex = LoopVertex;
		}
	}
	/// <summary>
	/// ENTITY IfcVertexPoint
	/// <para>ENTITY IfcVertexPoint</para>
	/// <para>SUBTYPE OF (IfcVertex);</para>
	/// <para>VertexGeometry : IfcPoint;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVertexPoint : IfcVertex, IfcPointOrVertexPoint
	{
		public virtual IfcPoint? VertexGeometry { get; set; }
		public IfcVertexPoint() : base()
		{
		}
		public IfcVertexPoint(IfcPoint VertexGeometry) : base ()
		{
			this.VertexGeometry = VertexGeometry;
		}
	}
	/// <summary>
	/// ENTITY IfcVibrationIsolator
	/// <para>ENTITY IfcVibrationIsolator</para>
	/// <para>SUBTYPE OF (IfcElementComponent);</para>
	/// <para>PredefinedType : OPTIONAL IfcVibrationIsolatorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcVibrationIsolatorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcVibrationIsolatorTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCVIBRATIONISOLATORTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVibrationIsolator : IfcElementComponent
	{
		public virtual IfcVibrationIsolatorTypeEnum? PredefinedType { get; set; }
		public IfcVibrationIsolator() : base()
		{
		}
		public IfcVibrationIsolator(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcVibrationIsolatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVibrationIsolatorType
	/// <para>ENTITY IfcVibrationIsolatorType</para>
	/// <para>SUBTYPE OF (IfcElementComponentType);</para>
	/// <para>PredefinedType : IfcVibrationIsolatorTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcVibrationIsolatorTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcVibrationIsolatorTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVibrationIsolatorType : IfcElementComponentType
	{
		public virtual IfcVibrationIsolatorTypeEnum? PredefinedType { get; set; }
		public IfcVibrationIsolatorType() : base()
		{
		}
		public IfcVibrationIsolatorType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcVibrationIsolatorTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcVirtualElement
	/// <para>ENTITY IfcVirtualElement</para>
	/// <para>SUBTYPE OF (IfcElement);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVirtualElement : IfcElement
	{
		public IfcVirtualElement() : base()
		{
		}
		public IfcVirtualElement(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcVirtualGridIntersection;
	/// <para>ENTITY IfcVirtualGridIntersection;</para>
	/// <para>IntersectingAxes : LIST [2:2] OF UNIQUE IfcGridAxis;</para>
	/// <para>OffsetDistances : LIST [2:3] OF IfcLengthMeasure;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVirtualGridIntersection : Entity, IfcGridPlacementDirectionSelect
	{
		public IfcVirtualGridIntersection() : base()
		{
		}
	}
	/// <summary>
	/// ENTITY IfcVoidingFeature
	/// <para>ENTITY IfcVoidingFeature</para>
	/// <para>SUBTYPE OF (IfcFeatureElementSubtraction);</para>
	/// <para>PredefinedType : OPTIONAL IfcVoidingFeatureTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>HasObjectType : NOT EXISTS(PredefinedType) OR (PredefinedType <> IfcVoidingFeatureTypeEnum.USERDEFINED) OR EXISTS(SELF\IfcObject.ObjectType);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcVoidingFeature : IfcFeatureElementSubtraction
	{
		public virtual IfcVoidingFeatureTypeEnum? PredefinedType { get; set; }
		public IfcVoidingFeature() : base()
		{
		}
		public IfcVoidingFeature(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcVoidingFeatureTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWall
	/// <para>ENTITY IfcWall</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcWallElementedCase</para>
	/// <para>,IfcWallStandardCase))</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>PredefinedType : OPTIONAL IfcWallTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcWallTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWallTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCWALLTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWall : IfcBuildingElement
	{
		public virtual IfcWallTypeEnum? PredefinedType { get; set; }
		public IfcWall() : base()
		{
		}
		public IfcWall(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWallElementedCase
	/// <para>ENTITY IfcWallElementedCase</para>
	/// <para>SUBTYPE OF (IfcWall);</para>
	/// <para>WHERE</para>
	/// <para>HasDecomposition : HIINDEX(SELF\IfcObjectDefinition.IsDecomposedBy) > 0;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWallElementedCase : IfcWall
	{
		public IfcWallElementedCase() : base()
		{
		}
		public IfcWallElementedCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcWallStandardCase
	/// <para>ENTITY IfcWallStandardCase</para>
	/// <para>SUBTYPE OF (IfcWall);</para>
	/// <para>WHERE</para>
	/// <para>HasMaterialLayerSetUsage : SIZEOF (QUERY(temp <* USEDIN(SELF, 'IFC4X1.IFCRELASSOCIATES.RELATEDOBJECTS') |</para>
	/// <para>('IFC4X1.IFCRELASSOCIATESMATERIAL' IN TYPEOF(temp)) AND</para>
	/// <para>('IFC4X1.IFCMATERIALLAYERSETUSAGE' IN TYPEOF(temp.RelatingMaterial))</para>
	/// <para>)) = 1;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWallStandardCase : IfcWall
	{
		public IfcWallStandardCase() : base()
		{
		}
		public IfcWallStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcWallType
	/// <para>ENTITY IfcWallType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcWallTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcWallTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWallTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWallType : IfcBuildingElementType
	{
		public virtual IfcWallTypeEnum? PredefinedType { get; set; }
		public IfcWallType() : base()
		{
		}
		public IfcWallType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcWallTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWasteTerminal
	/// <para>ENTITY IfcWasteTerminal</para>
	/// <para>SUBTYPE OF (IfcFlowTerminal);</para>
	/// <para>PredefinedType : OPTIONAL IfcWasteTerminalTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR</para>
	/// <para>(PredefinedType <> IfcWasteTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWasteTerminalTypeEnum.USERDEFINED) AND EXISTS (SELF\IfcObject.ObjectType));</para>
	/// <para>CorrectTypeAssigned : (SIZEOF(IsTypedBy) = 0) OR</para>
	/// <para>('IFC4X1.IFCWASTETERMINALTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWasteTerminal : IfcFlowTerminal
	{
		public virtual IfcWasteTerminalTypeEnum? PredefinedType { get; set; }
		public IfcWasteTerminal() : base()
		{
		}
		public IfcWasteTerminal(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcWasteTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWasteTerminalType
	/// <para>ENTITY IfcWasteTerminalType</para>
	/// <para>SUBTYPE OF (IfcFlowTerminalType);</para>
	/// <para>PredefinedType : IfcWasteTerminalTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcWasteTerminalTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWasteTerminalTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWasteTerminalType : IfcFlowTerminalType
	{
		public virtual IfcWasteTerminalTypeEnum? PredefinedType { get; set; }
		public IfcWasteTerminalType() : base()
		{
		}
		public IfcWasteTerminalType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcWasteTerminalTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWindow
	/// <para>ENTITY IfcWindow</para>
	/// <para>SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcWindowStandardCase))</para>
	/// <para>SUBTYPE OF (IfcBuildingElement);</para>
	/// <para>OverallHeight : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>OverallWidth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>PredefinedType : OPTIONAL IfcWindowTypeEnum;</para>
	/// <para>PartitioningType : OPTIONAL IfcWindowTypePartitioningEnum;</para>
	/// <para>UserDefinedPartitioningType : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>CorrectStyleAssigned : (SIZEOF(IsTypedBy) = 0)</para>
	/// <para>OR ('IFC4X1.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcObject.IsTypedBy[1].RelatingType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindow : IfcBuildingElement
	{
		public virtual IfcPositiveLengthMeasure? OverallHeight { get; set; }
		public virtual IfcPositiveLengthMeasure? OverallWidth { get; set; }
		public virtual IfcWindowTypeEnum? PredefinedType { get; set; }
		public virtual IfcWindowTypePartitioningEnum? PartitioningType { get; set; }
		public virtual IfcLabel? UserDefinedPartitioningType { get; set; }
		public IfcWindow() : base()
		{
		}
		public IfcWindow(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure OverallHeight, IfcPositiveLengthMeasure OverallWidth, IfcWindowTypeEnum PredefinedType, IfcWindowTypePartitioningEnum PartitioningType, IfcLabel UserDefinedPartitioningType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag)
		{
			this.OverallHeight = OverallHeight;
			this.OverallWidth = OverallWidth;
			this.PredefinedType = PredefinedType;
			this.PartitioningType = PartitioningType;
			this.UserDefinedPartitioningType = UserDefinedPartitioningType;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowLiningProperties
	/// <para>ENTITY IfcWindowLiningProperties</para>
	/// <para>SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>LiningDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>LiningThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>TransomThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>MullionThickness : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>FirstTransomOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>SecondTransomOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>FirstMullionOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>SecondMullionOffset : OPTIONAL IfcNormalisedRatioMeasure;</para>
	/// <para>ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>LiningOffset : OPTIONAL IfcLengthMeasure;</para>
	/// <para>LiningToPanelOffsetX : OPTIONAL IfcLengthMeasure;</para>
	/// <para>LiningToPanelOffsetY : OPTIONAL IfcLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>WR31 : NOT(EXISTS(LiningDepth) AND NOT(EXISTS(LiningThickness)));</para>
	/// <para>WR32 : NOT(NOT(EXISTS(FirstTransomOffset)) AND EXISTS(SecondTransomOffset));</para>
	/// <para>WR33 : NOT(NOT(EXISTS(FirstMullionOffset)) AND EXISTS(SecondMullionOffset));</para>
	/// <para>WR34 : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>AND</para>
	/// <para>(</para>
	/// <para>('IFC4X1.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>OR</para>
	/// <para>('IFC4X1.IFCWINDOWSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowLiningProperties : IfcPreDefinedPropertySet
	{
		public virtual IfcPositiveLengthMeasure? LiningDepth { get; set; }
		public virtual IfcNonNegativeLengthMeasure? LiningThickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? TransomThickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? MullionThickness { get; set; }
		public virtual IfcNormalisedRatioMeasure? FirstTransomOffset { get; set; }
		public virtual IfcNormalisedRatioMeasure? SecondTransomOffset { get; set; }
		public virtual IfcNormalisedRatioMeasure? FirstMullionOffset { get; set; }
		public virtual IfcNormalisedRatioMeasure? SecondMullionOffset { get; set; }
		public virtual IfcShapeAspect? ShapeAspectStyle { get; set; }
		public virtual IfcLengthMeasure? LiningOffset { get; set; }
		public virtual IfcLengthMeasure? LiningToPanelOffsetX { get; set; }
		public virtual IfcLengthMeasure? LiningToPanelOffsetY { get; set; }
		public IfcWindowLiningProperties() : base()
		{
		}
		public IfcWindowLiningProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcPositiveLengthMeasure LiningDepth, IfcNonNegativeLengthMeasure LiningThickness, IfcNonNegativeLengthMeasure TransomThickness, IfcNonNegativeLengthMeasure MullionThickness, IfcNormalisedRatioMeasure FirstTransomOffset, IfcNormalisedRatioMeasure SecondTransomOffset, IfcNormalisedRatioMeasure FirstMullionOffset, IfcNormalisedRatioMeasure SecondMullionOffset, IfcShapeAspect ShapeAspectStyle, IfcLengthMeasure LiningOffset, IfcLengthMeasure LiningToPanelOffsetX, IfcLengthMeasure LiningToPanelOffsetY) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.LiningDepth = LiningDepth;
			this.LiningThickness = LiningThickness;
			this.TransomThickness = TransomThickness;
			this.MullionThickness = MullionThickness;
			this.FirstTransomOffset = FirstTransomOffset;
			this.SecondTransomOffset = SecondTransomOffset;
			this.FirstMullionOffset = FirstMullionOffset;
			this.SecondMullionOffset = SecondMullionOffset;
			this.ShapeAspectStyle = ShapeAspectStyle;
			this.LiningOffset = LiningOffset;
			this.LiningToPanelOffsetX = LiningToPanelOffsetX;
			this.LiningToPanelOffsetY = LiningToPanelOffsetY;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowPanelProperties
	/// <para>ENTITY IfcWindowPanelProperties</para>
	/// <para>SUBTYPE OF (IfcPreDefinedPropertySet);</para>
	/// <para>OperationType : IfcWindowPanelOperationEnum;</para>
	/// <para>PanelPosition : IfcWindowPanelPositionEnum;</para>
	/// <para>FrameDepth : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>FrameThickness : OPTIONAL IfcPositiveLengthMeasure;</para>
	/// <para>ShapeAspectStyle : OPTIONAL IfcShapeAspect;</para>
	/// <para>WHERE</para>
	/// <para>ApplicableToType : (EXISTS(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>AND</para>
	/// <para>(</para>
	/// <para>('IFC4X1.IFCWINDOWTYPE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>OR</para>
	/// <para>('IFC4X1.IFCWINDOWSTYLE' IN TYPEOF(SELF\IfcPropertySetDefinition.DefinesType[1]))</para>
	/// <para>);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowPanelProperties : IfcPreDefinedPropertySet
	{
		public virtual IfcWindowPanelOperationEnum? OperationType { get; set; }
		public virtual IfcWindowPanelPositionEnum? PanelPosition { get; set; }
		public virtual IfcPositiveLengthMeasure? FrameDepth { get; set; }
		public virtual IfcPositiveLengthMeasure? FrameThickness { get; set; }
		public virtual IfcShapeAspect? ShapeAspectStyle { get; set; }
		public IfcWindowPanelProperties() : base()
		{
		}
		public IfcWindowPanelProperties(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcWindowPanelOperationEnum OperationType, IfcWindowPanelPositionEnum PanelPosition, IfcPositiveLengthMeasure FrameDepth, IfcPositiveLengthMeasure FrameThickness, IfcShapeAspect ShapeAspectStyle) : base (GlobalId, OwnerHistory, Name, Description)
		{
			this.OperationType = OperationType;
			this.PanelPosition = PanelPosition;
			this.FrameDepth = FrameDepth;
			this.FrameThickness = FrameThickness;
			this.ShapeAspectStyle = ShapeAspectStyle;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowStandardCase
	/// <para>ENTITY IfcWindowStandardCase</para>
	/// <para>SUBTYPE OF (IfcWindow);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowStandardCase : IfcWindow
	{
		public IfcWindowStandardCase() : base()
		{
		}
		public IfcWindowStandardCase(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcObjectPlacement ObjectPlacement, IfcProductRepresentation Representation, IfcIdentifier Tag, IfcPositiveLengthMeasure OverallHeight, IfcPositiveLengthMeasure OverallWidth, IfcWindowTypeEnum PredefinedType, IfcWindowTypePartitioningEnum PartitioningType, IfcLabel UserDefinedPartitioningType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType)
		{
		}
	}
	/// <summary>
	/// ENTITY IfcWindowStyle
	/// <para>ENTITY IfcWindowStyle</para>
	/// <para>SUBTYPE OF (IfcTypeProduct);</para>
	/// <para>ConstructionType : IfcWindowStyleConstructionEnum;</para>
	/// <para>OperationType : IfcWindowStyleOperationEnum;</para>
	/// <para>ParameterTakesPrecedence : IfcBoolean;</para>
	/// <para>Sizeable : IfcBoolean;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowStyle : IfcTypeProduct
	{
		public virtual IfcWindowStyleConstructionEnum? ConstructionType { get; set; }
		public virtual IfcWindowStyleOperationEnum? OperationType { get; set; }
		public virtual IfcBoolean? ParameterTakesPrecedence { get; set; }
		public virtual IfcBoolean? Sizeable { get; set; }
		public IfcWindowStyle() : base()
		{
		}
		public IfcWindowStyle(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcWindowStyleConstructionEnum ConstructionType, IfcWindowStyleOperationEnum OperationType, IfcBoolean ParameterTakesPrecedence, IfcBoolean Sizeable) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets)
		{
			this.ConstructionType = ConstructionType;
			this.OperationType = OperationType;
			this.ParameterTakesPrecedence = ParameterTakesPrecedence;
			this.Sizeable = Sizeable;
		}
	}
	/// <summary>
	/// ENTITY IfcWindowType
	/// <para>ENTITY IfcWindowType</para>
	/// <para>SUBTYPE OF (IfcBuildingElementType);</para>
	/// <para>PredefinedType : IfcWindowTypeEnum;</para>
	/// <para>PartitioningType : IfcWindowTypePartitioningEnum;</para>
	/// <para>ParameterTakesPrecedence : OPTIONAL IfcBoolean;</para>
	/// <para>UserDefinedPartitioningType : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : (PredefinedType <> IfcWindowTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWindowTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcElementType.ElementType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWindowType : IfcBuildingElementType
	{
		public virtual IfcWindowTypeEnum? PredefinedType { get; set; }
		public virtual IfcWindowTypePartitioningEnum? PartitioningType { get; set; }
		public virtual IfcBoolean? ParameterTakesPrecedence { get; set; }
		public virtual IfcLabel? UserDefinedPartitioningType { get; set; }
		public IfcWindowType() : base()
		{
		}
		public IfcWindowType(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcIdentifier ApplicableOccurrence, List<IfcPropertySetDefinition> HasPropertySets, IfcLabel ElementType, IfcWindowTypeEnum PredefinedType, IfcWindowTypePartitioningEnum PartitioningType, IfcBoolean ParameterTakesPrecedence, IfcLabel UserDefinedPartitioningType) : base (GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, ElementType)
		{
			this.PredefinedType = PredefinedType;
			this.PartitioningType = PartitioningType;
			this.ParameterTakesPrecedence = ParameterTakesPrecedence;
			this.UserDefinedPartitioningType = UserDefinedPartitioningType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkCalendar
	/// <para>ENTITY IfcWorkCalendar</para>
	/// <para>SUBTYPE OF (IfcControl);</para>
	/// <para>WorkingTimes : OPTIONAL SET [1:?] OF IfcWorkTime;</para>
	/// <para>ExceptionTimes : OPTIONAL SET [1:?] OF IfcWorkTime;</para>
	/// <para>PredefinedType : OPTIONAL IfcWorkCalendarTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcWorkCalendarTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWorkCalendarTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkCalendar : IfcControl
	{
		public virtual List<IfcWorkTime>? WorkingTimes { get; set; }
		public virtual List<IfcWorkTime>? ExceptionTimes { get; set; }
		public virtual IfcWorkCalendarTypeEnum? PredefinedType { get; set; }
		public IfcWorkCalendar() : base()
		{
		}
		public IfcWorkCalendar(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, List<IfcWorkTime> WorkingTimes, List<IfcWorkTime> ExceptionTimes, IfcWorkCalendarTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.WorkingTimes = WorkingTimes;
			this.ExceptionTimes = ExceptionTimes;
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkControl
	/// <para>ENTITY IfcWorkControl</para>
	/// <para>ABSTRACT SUPERTYPE OF (ONEOF</para>
	/// <para>(IfcWorkPlan</para>
	/// <para>,IfcWorkSchedule))</para>
	/// <para>SUBTYPE OF (IfcControl);</para>
	/// <para>CreationDate : IfcDateTime;</para>
	/// <para>Creators : OPTIONAL SET [1:?] OF IfcPerson;</para>
	/// <para>Purpose : OPTIONAL IfcLabel;</para>
	/// <para>Duration : OPTIONAL IfcDuration;</para>
	/// <para>TotalFloat : OPTIONAL IfcDuration;</para>
	/// <para>StartTime : IfcDateTime;</para>
	/// <para>FinishTime : OPTIONAL IfcDateTime;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public abstract class IfcWorkControl : IfcControl
	{
		public virtual IfcDateTime? CreationDate { get; set; }
		public virtual List<IfcPerson>? Creators { get; set; }
		public virtual IfcLabel? Purpose { get; set; }
		public virtual IfcDuration? Duration { get; set; }
		public virtual IfcDuration? TotalFloat { get; set; }
		public virtual IfcDateTime? StartTime { get; set; }
		public virtual IfcDateTime? FinishTime { get; set; }
		public IfcWorkControl() : base()
		{
		}
		public IfcWorkControl(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcDateTime CreationDate, List<IfcPerson> Creators, IfcLabel Purpose, IfcDuration Duration, IfcDuration TotalFloat, IfcDateTime StartTime, IfcDateTime FinishTime) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification)
		{
			this.CreationDate = CreationDate;
			this.Creators = Creators;
			this.Purpose = Purpose;
			this.Duration = Duration;
			this.TotalFloat = TotalFloat;
			this.StartTime = StartTime;
			this.FinishTime = FinishTime;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkPlan
	/// <para>ENTITY IfcWorkPlan</para>
	/// <para>SUBTYPE OF (IfcWorkControl);</para>
	/// <para>PredefinedType : OPTIONAL IfcWorkPlanTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcWorkPlanTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWorkPlanTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkPlan : IfcWorkControl
	{
		public virtual IfcWorkPlanTypeEnum? PredefinedType { get; set; }
		public IfcWorkPlan() : base()
		{
		}
		public IfcWorkPlan(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcDateTime CreationDate, List<IfcPerson> Creators, IfcLabel Purpose, IfcDuration Duration, IfcDuration TotalFloat, IfcDateTime StartTime, IfcDateTime FinishTime, IfcWorkPlanTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkSchedule
	/// <para>ENTITY IfcWorkSchedule</para>
	/// <para>SUBTYPE OF (IfcWorkControl);</para>
	/// <para>PredefinedType : OPTIONAL IfcWorkScheduleTypeEnum;</para>
	/// <para>WHERE</para>
	/// <para>CorrectPredefinedType : NOT(EXISTS(PredefinedType)) OR (PredefinedType <> IfcWorkScheduleTypeEnum.USERDEFINED) OR</para>
	/// <para>((PredefinedType = IfcWorkScheduleTypeEnum.USERDEFINED) AND EXISTS(SELF\IfcObject.ObjectType));</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkSchedule : IfcWorkControl
	{
		public virtual IfcWorkScheduleTypeEnum? PredefinedType { get; set; }
		public IfcWorkSchedule() : base()
		{
		}
		public IfcWorkSchedule(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcIdentifier Identification, IfcDateTime CreationDate, List<IfcPerson> Creators, IfcLabel Purpose, IfcDuration Duration, IfcDuration TotalFloat, IfcDateTime StartTime, IfcDateTime FinishTime, IfcWorkScheduleTypeEnum PredefinedType) : base (GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime)
		{
			this.PredefinedType = PredefinedType;
		}
	}
	/// <summary>
	/// ENTITY IfcWorkTime
	/// <para>ENTITY IfcWorkTime</para>
	/// <para>SUBTYPE OF (IfcSchedulingTime);</para>
	/// <para>RecurrencePattern : OPTIONAL IfcRecurrencePattern;</para>
	/// <para>Start : OPTIONAL IfcDate;</para>
	/// <para>Finish : OPTIONAL IfcDate;</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcWorkTime : IfcSchedulingTime
	{
		public virtual IfcRecurrencePattern? RecurrencePattern { get; set; }
		public virtual IfcDate? Start { get; set; }
		public virtual IfcDate? Finish { get; set; }
		public IfcWorkTime() : base()
		{
		}
		public IfcWorkTime(IfcLabel Name, IfcDataOriginEnum DataOrigin, IfcLabel UserDefinedDataOrigin, IfcRecurrencePattern RecurrencePattern, IfcDate Start, IfcDate Finish) : base (Name, DataOrigin, UserDefinedDataOrigin)
		{
			this.RecurrencePattern = RecurrencePattern;
			this.Start = Start;
			this.Finish = Finish;
		}
	}
	/// <summary>
	/// ENTITY IfcZShapeProfileDef
	/// <para>ENTITY IfcZShapeProfileDef</para>
	/// <para>SUBTYPE OF (IfcParameterizedProfileDef);</para>
	/// <para>Depth : IfcPositiveLengthMeasure;</para>
	/// <para>FlangeWidth : IfcPositiveLengthMeasure;</para>
	/// <para>WebThickness : IfcPositiveLengthMeasure;</para>
	/// <para>FlangeThickness : IfcPositiveLengthMeasure;</para>
	/// <para>FilletRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>EdgeRadius : OPTIONAL IfcNonNegativeLengthMeasure;</para>
	/// <para>WHERE</para>
	/// <para>ValidFlangeThickness : FlangeThickness < (Depth / 2.);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcZShapeProfileDef : IfcParameterizedProfileDef
	{
		public virtual IfcPositiveLengthMeasure? Depth { get; set; }
		public virtual IfcPositiveLengthMeasure? FlangeWidth { get; set; }
		public virtual IfcPositiveLengthMeasure? WebThickness { get; set; }
		public virtual IfcPositiveLengthMeasure? FlangeThickness { get; set; }
		public virtual IfcNonNegativeLengthMeasure? FilletRadius { get; set; }
		public virtual IfcNonNegativeLengthMeasure? EdgeRadius { get; set; }
		public IfcZShapeProfileDef() : base()
		{
		}
		public IfcZShapeProfileDef(IfcProfileTypeEnum ProfileType, IfcLabel ProfileName, IfcAxis2Placement2D Position, IfcPositiveLengthMeasure Depth, IfcPositiveLengthMeasure FlangeWidth, IfcPositiveLengthMeasure WebThickness, IfcPositiveLengthMeasure FlangeThickness, IfcNonNegativeLengthMeasure FilletRadius, IfcNonNegativeLengthMeasure EdgeRadius) : base (ProfileType, ProfileName, Position)
		{
			this.Depth = Depth;
			this.FlangeWidth = FlangeWidth;
			this.WebThickness = WebThickness;
			this.FlangeThickness = FlangeThickness;
			this.FilletRadius = FilletRadius;
			this.EdgeRadius = EdgeRadius;
		}
	}
	/// <summary>
	/// ENTITY IfcZone
	/// <para>ENTITY IfcZone</para>
	/// <para>SUBTYPE OF (IfcSystem);</para>
	/// <para>LongName : OPTIONAL IfcLabel;</para>
	/// <para>WHERE</para>
	/// <para>WR1 : (SIZEOF(SELF\IfcGroup.IsGroupedBy) = 0) OR</para>
	/// <para>(SIZEOF (QUERY (temp <* SELF\IfcGroup.IsGroupedBy[1].RelatedObjects |</para>
	/// <para>NOT(('IFC4X1.IFCZONE' IN TYPEOF(temp)) OR</para>
	/// <para>('IFC4X1.IFCSPACE' IN TYPEOF(temp)) OR</para>
	/// <para>('IFC4X1.IFCSPATIALZONE' IN TYPEOF(temp))</para>
	/// <para>))) = 0);</para>
	/// <para>END_ENTITY;</para>
	/// <summary>
	public class IfcZone : IfcSystem
	{
		public virtual IfcLabel? LongName { get; set; }
		public IfcZone() : base()
		{
		}
		public IfcZone(IfcGloballyUniqueId GlobalId, IfcOwnerHistory OwnerHistory, IfcLabel Name, IfcText Description, IfcLabel ObjectType, IfcLabel LongName) : base (GlobalId, OwnerHistory, Name, Description, ObjectType)
		{
			this.LongName = LongName;
		}
	}
}
